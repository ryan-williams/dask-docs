








<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API &mdash; Dask 2.13.0+4.gf26bb993.dirty documentation</title>
  

  
  
  
  

  
  <link rel="stylesheet" href="_static/css/style.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  <link rel="stylesheet" href="_static/style.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/explore.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/nbsphinx.css" type="text/css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="_static/js/custom.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Create and Store Dask DataFrames" href="dataframe-create.html" />
    <link rel="prev" title="DataFrame" href="dataframe.html" />
    <link rel="shortcut icon" href="_static/images/favicon.ico"/>
  
</head>

<body class="wy-body-for-nav">

  
    <nav id="explore-links">
        <a href="https://docs.dask.org/">
        <img class="caption" src="_static/images/dask-horizontal-white.svg"/>
        </a>

        <ul>
        <li>
            <a>Get Started</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/install.html"> Install </a></li>
            <li><a href="https://examples.dask.org"> Examples </a></li>
            <li><a href="https://github.com/dask/dask-tutorial"> Tutorial </a></li>
            <li><a href="https://docs.dask.org/en/latest/why.html"> Why Dask? </a></li>
            <li><a href="https://stories.dask.org/en/latest"> Use Cases </a></li>
            <li><a href="https://www.youtube.com/watch?v=RA_2qdipVng&list=PLRtz5iA93T4PQvWuoMnIyEIz1fXiJ5Pri"> Talks </a></li>
            <li><a href="https://mybinder.org/v2/gh/dask/dask-examples/master?urlpath=lab"> Try Online </a></li>
            <li><a href="https://dask.org/slides"> Slides </a></li>
            </ul>
        </li>

        <li>
            <a href="">Algorithms</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/array.html">Arrays</a></li>
            <li><a href="https://docs.dask.org/en/latest/dataframe.html">Dataframes</a></li>
            <li><a href="https://docs.dask.org/en/latest/bag.html">Bags</a></li>
            <li><a href="https://docs.dask.org/en/latest/delayed.html">Delayed (custom)</a></li>
            <li><a href="https://docs.dask.org/en/latest/futures.html">Futures (real-time)</a></li>
            <li><a href="http://ml.dask.org">Machine Learning</a></li>
            <li><a href="https://xarray.pydata.org/en/latest/">XArray</a></li>
            </ul>
        </li>

        <li>
            <a href="https://docs.dask.org/en/latest/setup.html">Setup</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/setup/single-machine.html"> Local </a></li>
            <li><a href="https://docs.dask.org/en/latest/setup/cloud.html"> Cloud </a></li>
            <li><a href="https://docs.dask.org/en/latest/setup/hpc.html"> HPC </a></li>
            <li><a href="https://kubernetes.dask.org/en/latest/"> Kubernetes </a></li>
            <li><a href="https://yarn.dask.org/en/latest/"> Hadoop / Yarn </a></li>
            </ul>
        </li>

        <li>
            <a>Community</a>
            <ul>
            <li><a href="http://docs.dask.org/en/latest/support.html">Ask for Help</a></li>
            <li><a href="https://github.com/dask">Github</a></li>
            <li><a href="https://stackoverflow.com/questions/tagged/dask">Stack Overflow</a></li>
            <li><a href="https://twitter.com/dask_dev">Twitter</a></li>
            <li><a href="https://blog.dask.org/"> Developer Blog </a></li>
            </ul>
        </li>
        </ul>

    </nav>
  
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Dask
          

          
          </a>

          
            
            
              <div class="version">
                2.13.0+4.gf26bb993.dirty
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Install Dask</a></li>
<li class="toctree-l1"><a class="reference internal" href="setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference external" href="https://stories.dask.org">Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="support.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="why.html">Why Dask?</a></li>
<li class="toctree-l1"><a class="reference internal" href="institutional-faq.html">Institutional FAQ</a></li>
</ul>
<p class="caption"><span class="caption-text">User Interface</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="user-interfaces.html">User Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="array.html">Array</a></li>
<li class="toctree-l1"><a class="reference internal" href="bag.html">Bag</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="dataframe.html">DataFrame</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dataframe">Dataframe</a></li>
<li class="toctree-l3"><a class="reference internal" href="#series">Series</a></li>
<li class="toctree-l3"><a class="reference internal" href="#groupby-operations">Groupby Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rolling-operations">Rolling Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#create-dataframes">Create DataFrames</a></li>
<li class="toctree-l3"><a class="reference internal" href="#store-dataframes">Store DataFrames</a></li>
<li class="toctree-l3"><a class="reference internal" href="#convert-dataframes">Convert DataFrames</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reshape-dataframes">Reshape DataFrames</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dataframe-methods">DataFrame Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#series-methods">Series Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dataframegroupby">DataFrameGroupBy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#seriesgroupby">SeriesGroupBy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#custom-aggregation">Custom Aggregation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#storage-and-conversion">Storage and Conversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rolling">Rolling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#resampling">Resampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dask-metadata">Dask Metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-functions">Other functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="dataframe-create.html">Create and Store Dask DataFrames</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe-best-practices.html">Best Practices</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe-design.html">Internal Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe-groupby.html">Shuffling for GroupBy and Join</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe-groupby.html#aggregate">Aggregate</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe-joins.html">Joins</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe-indexing.html">Indexing into Dask DataFrames</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe-categoricals.html">Categoricals</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe-extend.html">Extending DataFrames</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe.html#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe.html#design">Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe.html#dask-dataframe-copies-the-pandas-api">Dask DataFrame copies the Pandas API</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe.html#common-uses-and-anti-uses">Common Uses and Anti-Uses</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe.html#scope">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataframe.html#execution">Execution</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="delayed.html">Delayed</a></li>
<li class="toctree-l1"><a class="reference internal" href="futures.html">Futures</a></li>
<li class="toctree-l1"><a class="reference external" href="https://ml.dask.org">Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="best-practices.html">Best Practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
</ul>
<p class="caption"><span class="caption-text">Scheduling</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="scheduling.html">Scheduling</a></li>
<li class="toctree-l1"><a class="reference external" href="https://distributed.dask.org/">Distributed Scheduling</a></li>
</ul>
<p class="caption"><span class="caption-text">Diagnostics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="understanding-performance.html">Understanding Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphviz.html">Visualize task graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics-local.html">Diagnostics (local)</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics-distributed.html">Diagnostics (distributed)</a></li>
<li class="toctree-l1"><a class="reference internal" href="debugging.html">Debugging</a></li>
</ul>
<p class="caption"><span class="caption-text">Help &amp; reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="develop.html">Development Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="educational-resources.html">Educational Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="presentations.html">Presentations On Dask</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheatsheet.html">Dask Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="spark.html">Comparison to Spark</a></li>
<li class="toctree-l1"><a class="reference internal" href="caching.html">Opportunistic Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphs.html">Task Graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="remote-data-services.html">Remote Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpu.html">GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="cite.html">Citations</a></li>
<li class="toctree-l1"><a class="reference internal" href="funding.html">Funding</a></li>
<li class="toctree-l1"><a class="reference internal" href="logos.html">Images and Logos</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Dask</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="dataframe.html">DataFrame</a> &raquo;</li>
        
      <li>API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/dataframe-api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api">
<h1>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="dataframe">
<h2>Dataframe<a class="headerlink" href="#dataframe" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame" title="dask.dataframe.DataFrame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame</span></code></a>(dsk, name, meta, divisions)</p></td>
<td><p>Parallel Pandas DataFrame</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a>(other[, axis, level, fill_value])</p></td>
<td><p>Get Addition of dataframe and other, element-wise (binary operator <cite>add</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.append" title="dask.dataframe.DataFrame.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.append</span></code></a>(other[, interleave_partitions])</p></td>
<td><p>Append rows of <cite>other</cite> to the end of caller, returning a new object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.apply" title="dask.dataframe.DataFrame.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.apply</span></code></a>(func[, axis, broadcast, …])</p></td>
<td><p>Parallel version of pandas.DataFrame.apply</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.assign" title="dask.dataframe.DataFrame.assign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.assign</span></code></a>(**kwargs)</p></td>
<td><p>Assign new columns to a DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.astype" title="dask.dataframe.DataFrame.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.astype</span></code></a>(dtype)</p></td>
<td><p>Cast a pandas object to a specified dtype <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.categorize" title="dask.dataframe.DataFrame.categorize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.categorize</span></code></a>([columns, index, …])</p></td>
<td><p>Convert columns of the DataFrame to category dtype.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.columns</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.compute" title="dask.dataframe.DataFrame.compute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.compute</span></code></a>(**kwargs)</p></td>
<td><p>Compute this dask collection</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.corr" title="dask.dataframe.DataFrame.corr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.corr</span></code></a>([method, min_periods, …])</p></td>
<td><p>Compute pairwise correlation of columns, excluding NA/null values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.count" title="dask.dataframe.DataFrame.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.count</span></code></a>([axis, split_every])</p></td>
<td><p>Count non-NA cells for each column or row.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.cov" title="dask.dataframe.DataFrame.cov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cov</span></code></a>([min_periods, split_every])</p></td>
<td><p>Compute pairwise covariance of columns, excluding NA/null values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.cummax" title="dask.dataframe.DataFrame.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummax</span></code></a>([axis, skipna, out])</p></td>
<td><p>Return cumulative maximum over a DataFrame or Series axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.cummin" title="dask.dataframe.DataFrame.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummin</span></code></a>([axis, skipna, out])</p></td>
<td><p>Return cumulative minimum over a DataFrame or Series axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.cumprod" title="dask.dataframe.DataFrame.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumprod</span></code></a>([axis, skipna, dtype, out])</p></td>
<td><p>Return cumulative product over a DataFrame or Series axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.cumsum" title="dask.dataframe.DataFrame.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumsum</span></code></a>([axis, skipna, dtype, out])</p></td>
<td><p>Return cumulative sum over a DataFrame or Series axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.describe" title="dask.dataframe.DataFrame.describe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.describe</span></code></a>([split_every, …])</p></td>
<td><p>Generate descriptive statistics.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a>(other[, axis, level, fill_value])</p></td>
<td><p>Get Floating division of dataframe and other, element-wise (binary operator <cite>truediv</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.drop" title="dask.dataframe.DataFrame.drop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.drop</span></code></a>([labels, axis, columns, errors])</p></td>
<td><p>Drop specified labels from rows or columns.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.drop_duplicates" title="dask.dataframe.DataFrame.drop_duplicates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.drop_duplicates</span></code></a>([subset, …])</p></td>
<td><p>Return DataFrame with duplicate rows removed.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.dropna" title="dask.dataframe.DataFrame.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.dropna</span></code></a>([how, subset, thresh])</p></td>
<td><p>Remove missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.dtypes" title="dask.dataframe.DataFrame.dtypes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.dtypes</span></code></a></p></td>
<td><p>Return data types</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.explode" title="dask.dataframe.DataFrame.explode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.explode</span></code></a>(column)</p></td>
<td><p>Transform each element of a list-like to a row, replicating index values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.fillna" title="dask.dataframe.DataFrame.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.fillna</span></code></a>([value, method, limit, axis])</p></td>
<td><p>Fill NA/NaN values using the specified method.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a>(other[, axis, level, …])</p></td>
<td><p>Get Integer division of dataframe and other, element-wise (binary operator <cite>floordiv</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.get_partition" title="dask.dataframe.DataFrame.get_partition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.get_partition</span></code></a>(n)</p></td>
<td><p>Get a dask DataFrame/Series representing the <cite>nth</cite> partition.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.groupby" title="dask.dataframe.DataFrame.groupby"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></a>([by])</p></td>
<td><p>Group DataFrame using a mapper or by a Series of columns.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.head" title="dask.dataframe.DataFrame.head"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.head</span></code></a>([n, npartitions, compute])</p></td>
<td><p>First n rows of the dataset</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.iloc" title="dask.dataframe.DataFrame.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.iloc</span></code></a></p></td>
<td><p>Purely integer-location based indexing for selection by position.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.index" title="dask.dataframe.DataFrame.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.index</span></code></a></p></td>
<td><p>Return dask Index instance</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.isna" title="dask.dataframe.DataFrame.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.isna</span></code></a>()</p></td>
<td><p>Detect missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.isnull" title="dask.dataframe.DataFrame.isnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.isnull</span></code></a>()</p></td>
<td><p>Detect missing values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.iterrows" title="dask.dataframe.DataFrame.iterrows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.iterrows</span></code></a>()</p></td>
<td><p>Iterate over DataFrame rows as (index, Series) pairs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.itertuples" title="dask.dataframe.DataFrame.itertuples"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.itertuples</span></code></a>([index, name])</p></td>
<td><p>Iterate over DataFrame rows as namedtuples.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.join" title="dask.dataframe.DataFrame.join"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.join</span></code></a>(other[, on, how, lsuffix, …])</p></td>
<td><p>Join columns of another DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.known_divisions" title="dask.dataframe.DataFrame.known_divisions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.known_divisions</span></code></a></p></td>
<td><p>Whether divisions are already known</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.loc" title="dask.dataframe.DataFrame.loc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.loc</span></code></a></p></td>
<td><p>Purely label-location based indexer for selection by label.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.map_partitions" title="dask.dataframe.DataFrame.map_partitions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.map_partitions</span></code></a>(func, *args, **kwargs)</p></td>
<td><p>Apply Python function on each DataFrame partition.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.mask" title="dask.dataframe.DataFrame.mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mask</span></code></a>(cond[, other])</p></td>
<td><p>Replace values where the condition is True.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.max" title="dask.dataframe.DataFrame.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.max</span></code></a>([axis, skipna, split_every, out])</p></td>
<td><p>Return the maximum of the values for the requested axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.mean" title="dask.dataframe.DataFrame.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mean</span></code></a>([axis, skipna, split_every, …])</p></td>
<td><p>Return the mean of the values for the requested axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.memory_usage" title="dask.dataframe.DataFrame.memory_usage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.memory_usage</span></code></a>([index, deep])</p></td>
<td><p>Return the memory usage of each column in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.memory_usage_per_partition" title="dask.dataframe.DataFrame.memory_usage_per_partition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.memory_usage_per_partition</span></code></a>([…])</p></td>
<td><p>Return the memory usage of each partition</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.merge" title="dask.dataframe.DataFrame.merge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.merge</span></code></a>(right[, how, on, left_on, …])</p></td>
<td><p>Merge the DataFrame with another DataFrame</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.min" title="dask.dataframe.DataFrame.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.min</span></code></a>([axis, skipna, split_every, out])</p></td>
<td><p>Return the minimum of the values for the requested axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a>(other[, axis, level, fill_value])</p></td>
<td><p>Get Modulo of dataframe and other, element-wise (binary operator <cite>mod</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a>(other[, axis, level, fill_value])</p></td>
<td><p>Get Multiplication of dataframe and other, element-wise (binary operator <cite>mul</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.ndim" title="dask.dataframe.DataFrame.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.ndim</span></code></a></p></td>
<td><p>Return dimensionality</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.nlargest" title="dask.dataframe.DataFrame.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.nlargest</span></code></a>([n, columns, split_every])</p></td>
<td><p>Return the first <cite>n</cite> rows ordered by <cite>columns</cite> in descending order.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.npartitions" title="dask.dataframe.DataFrame.npartitions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.npartitions</span></code></a></p></td>
<td><p>Return number of partitions</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.partitions" title="dask.dataframe.DataFrame.partitions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.partitions</span></code></a></p></td>
<td><p>Slice dataframe by partitions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.pop" title="dask.dataframe.DataFrame.pop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pop</span></code></a>(item)</p></td>
<td><p>Return item and drop from frame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a>(other[, axis, level, fill_value])</p></td>
<td><p>Get Exponential power of dataframe and other, element-wise (binary operator <cite>pow</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.prod" title="dask.dataframe.DataFrame.prod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.prod</span></code></a>([axis, skipna, split_every, …])</p></td>
<td><p>Return the product of the values for the requested axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.quantile" title="dask.dataframe.DataFrame.quantile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.quantile</span></code></a>([q, axis, method])</p></td>
<td><p>Approximate row-wise and precise column-wise quantiles of DataFrame</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.query" title="dask.dataframe.DataFrame.query"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.query</span></code></a>(expr, **kwargs)</p></td>
<td><p>Filter dataframe with complex expression</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.radd" title="dask.dataframe.DataFrame.radd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.radd</span></code></a>(other[, axis, level, fill_value])</p></td>
<td><p>Get Addition of dataframe and other, element-wise (binary operator <cite>radd</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.random_split" title="dask.dataframe.DataFrame.random_split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.random_split</span></code></a>(frac[, random_state, …])</p></td>
<td><p>Pseudorandomly split dataframe into different pieces row-wise</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.rdiv" title="dask.dataframe.DataFrame.rdiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.rdiv</span></code></a>(other[, axis, level, fill_value])</p></td>
<td><p>Get Floating division of dataframe and other, element-wise (binary operator <cite>rtruediv</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.rename" title="dask.dataframe.DataFrame.rename"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.rename</span></code></a>([index, columns])</p></td>
<td><p>Alter axes labels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.repartition" title="dask.dataframe.DataFrame.repartition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.repartition</span></code></a>([divisions, …])</p></td>
<td><p>Repartition dataframe along new divisions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.replace" title="dask.dataframe.DataFrame.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.replace</span></code></a>([to_replace, value, regex])</p></td>
<td><p>Replace values given in <cite>to_replace</cite> with <cite>value</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.reset_index" title="dask.dataframe.DataFrame.reset_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.reset_index</span></code></a>([drop])</p></td>
<td><p>Reset the index to the default index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.rfloordiv" title="dask.dataframe.DataFrame.rfloordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.rfloordiv</span></code></a>(other[, axis, level, …])</p></td>
<td><p>Get Integer division of dataframe and other, element-wise (binary operator <cite>rfloordiv</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.rmod" title="dask.dataframe.DataFrame.rmod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.rmod</span></code></a>(other[, axis, level, fill_value])</p></td>
<td><p>Get Modulo of dataframe and other, element-wise (binary operator <cite>rmod</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.rmul" title="dask.dataframe.DataFrame.rmul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.rmul</span></code></a>(other[, axis, level, fill_value])</p></td>
<td><p>Get Multiplication of dataframe and other, element-wise (binary operator <cite>rmul</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.rpow" title="dask.dataframe.DataFrame.rpow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.rpow</span></code></a>(other[, axis, level, fill_value])</p></td>
<td><p>Get Exponential power of dataframe and other, element-wise (binary operator <cite>rpow</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.rsub" title="dask.dataframe.DataFrame.rsub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.rsub</span></code></a>(other[, axis, level, fill_value])</p></td>
<td><p>Get Subtraction of dataframe and other, element-wise (binary operator <cite>rsub</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.rtruediv" title="dask.dataframe.DataFrame.rtruediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.rtruediv</span></code></a>(other[, axis, level, …])</p></td>
<td><p>Get Floating division of dataframe and other, element-wise (binary operator <cite>rtruediv</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.sample" title="dask.dataframe.DataFrame.sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sample</span></code></a>([n, frac, replace, …])</p></td>
<td><p>Random sample of items</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.set_index" title="dask.dataframe.DataFrame.set_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.set_index</span></code></a>(other[, drop, sorted, …])</p></td>
<td><p>Set the DataFrame index (row labels) using an existing column.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.shape" title="dask.dataframe.DataFrame.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.shape</span></code></a></p></td>
<td><p>Return a tuple representing the dimensionality of the DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.std" title="dask.dataframe.DataFrame.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.std</span></code></a>([axis, skipna, ddof, …])</p></td>
<td><p>Return sample standard deviation over requested axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a>(other[, axis, level, fill_value])</p></td>
<td><p>Get Subtraction of dataframe and other, element-wise (binary operator <cite>sub</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.sum" title="dask.dataframe.DataFrame.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sum</span></code></a>([axis, skipna, split_every, …])</p></td>
<td><p>Return the sum of the values for the requested axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.tail" title="dask.dataframe.DataFrame.tail"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.tail</span></code></a>([n, compute])</p></td>
<td><p>Last n rows of the dataset</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.to_bag" title="dask.dataframe.DataFrame.to_bag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.to_bag</span></code></a>([index])</p></td>
<td><p>Create Dask Bag from a Dask DataFrame</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.to_csv" title="dask.dataframe.DataFrame.to_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.to_csv</span></code></a>(filename, **kwargs)</p></td>
<td><p>Store Dask DataFrame to CSV files</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.to_dask_array" title="dask.dataframe.DataFrame.to_dask_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.to_dask_array</span></code></a>([lengths])</p></td>
<td><p>Convert a dask DataFrame to a dask array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.to_delayed" title="dask.dataframe.DataFrame.to_delayed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.to_delayed</span></code></a>([optimize_graph])</p></td>
<td><p>Convert into a list of <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> objects, one per partition.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.to_hdf" title="dask.dataframe.DataFrame.to_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.to_hdf</span></code></a>(path_or_buf, key[, mode, …])</p></td>
<td><p>Store Dask Dataframe to Hierarchical Data Format (HDF) files</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.to_json" title="dask.dataframe.DataFrame.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.to_json</span></code></a>(filename, *args, **kwargs)</p></td>
<td><p>See dd.to_json docstring for more information</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.to_parquet" title="dask.dataframe.DataFrame.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.to_parquet</span></code></a>(path, *args, **kwargs)</p></td>
<td><p>Store Dask.dataframe to Parquet files</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.to_records" title="dask.dataframe.DataFrame.to_records"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.to_records</span></code></a>([index, lengths])</p></td>
<td><p>Create Dask Array from a Dask Dataframe</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.to_sql" title="dask.dataframe.DataFrame.to_sql"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.to_sql</span></code></a>(name, con[, schema, …])</p></td>
<td><p>See dd.to_sql docstring for more information</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a>(other[, axis, level, …])</p></td>
<td><p>Get Floating division of dataframe and other, element-wise (binary operator <cite>truediv</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.values" title="dask.dataframe.DataFrame.values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.values</span></code></a></p></td>
<td><p>Return a dask.array of the values of this dataframe</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.var" title="dask.dataframe.DataFrame.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.var</span></code></a>([axis, skipna, ddof, …])</p></td>
<td><p>Return unbiased variance over requested axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.visualize" title="dask.dataframe.DataFrame.visualize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.visualize</span></code></a>([filename, format, …])</p></td>
<td><p>Render the computation of this object’s task graph using graphviz.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.where" title="dask.dataframe.DataFrame.where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.where</span></code></a>(cond[, other])</p></td>
<td><p>Replace values where the condition is False.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="series">
<h2>Series<a class="headerlink" href="#series" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series" title="dask.dataframe.Series"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series</span></code></a>(dsk, name, meta, divisions)</p></td>
<td><p>Parallel Pandas Series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.add" title="dask.dataframe.Series.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.add</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Addition of series and other, element-wise (binary operator <cite>add</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.align" title="dask.dataframe.Series.align"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.align</span></code></a>(other[, join, axis, fill_value])</p></td>
<td><p>Align two objects on their axes with the specified join method.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.all" title="dask.dataframe.Series.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.all</span></code></a>([axis, skipna, split_every, out])</p></td>
<td><p>Return whether all elements are True, potentially over an axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.any" title="dask.dataframe.Series.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.any</span></code></a>([axis, skipna, split_every, out])</p></td>
<td><p>Return whether any element is True, potentially over an axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.append" title="dask.dataframe.Series.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.append</span></code></a>(other[, interleave_partitions])</p></td>
<td><p>Concatenate two or more Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.apply" title="dask.dataframe.Series.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.apply</span></code></a>(func[, convert_dtype, meta, args])</p></td>
<td><p>Parallel version of pandas.Series.apply</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.astype" title="dask.dataframe.Series.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.astype</span></code></a>(dtype)</p></td>
<td><p>Cast a pandas object to a specified dtype <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.autocorr" title="dask.dataframe.Series.autocorr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.autocorr</span></code></a>([lag, split_every])</p></td>
<td><p>Compute the lag-N autocorrelation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.between" title="dask.dataframe.Series.between"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.between</span></code></a>(left, right[, inclusive])</p></td>
<td><p>Return boolean Series equivalent to left &lt;= series &lt;= right.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.bfill" title="dask.dataframe.Series.bfill"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.bfill</span></code></a>([axis, limit])</p></td>
<td><p>Synonym for <a class="reference internal" href="#dask.dataframe.DataFrame.fillna" title="dask.dataframe.DataFrame.fillna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.fillna()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">method='bfill'</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.cat</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.clear_divisions" title="dask.dataframe.Series.clear_divisions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.clear_divisions</span></code></a>()</p></td>
<td><p>Forget division information</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.clip" title="dask.dataframe.Series.clip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.clip</span></code></a>([lower, upper, out])</p></td>
<td><p>Trim values at input threshold(s).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.clip_lower</span></code>(threshold)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.clip_upper</span></code>(threshold)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.compute" title="dask.dataframe.Series.compute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.compute</span></code></a>(**kwargs)</p></td>
<td><p>Compute this dask collection</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.copy" title="dask.dataframe.Series.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.copy</span></code></a>()</p></td>
<td><p>Make a copy of the dataframe</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.corr" title="dask.dataframe.Series.corr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.corr</span></code></a>(other[, method, min_periods, …])</p></td>
<td><p>Compute correlation with <cite>other</cite> Series, excluding missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.count" title="dask.dataframe.Series.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.count</span></code></a>([split_every])</p></td>
<td><p>Return number of non-NA/null observations in the Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.cov" title="dask.dataframe.Series.cov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.cov</span></code></a>(other[, min_periods, split_every])</p></td>
<td><p>Compute covariance with Series, excluding missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.cummax" title="dask.dataframe.Series.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.cummax</span></code></a>([axis, skipna, out])</p></td>
<td><p>Return cumulative maximum over a DataFrame or Series axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.cummin" title="dask.dataframe.Series.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.cummin</span></code></a>([axis, skipna, out])</p></td>
<td><p>Return cumulative minimum over a DataFrame or Series axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.cumprod" title="dask.dataframe.Series.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.cumprod</span></code></a>([axis, skipna, dtype, out])</p></td>
<td><p>Return cumulative product over a DataFrame or Series axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.cumsum" title="dask.dataframe.Series.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.cumsum</span></code></a>([axis, skipna, dtype, out])</p></td>
<td><p>Return cumulative sum over a DataFrame or Series axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.describe" title="dask.dataframe.Series.describe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.describe</span></code></a>([split_every, percentiles, …])</p></td>
<td><p>Generate descriptive statistics.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.diff" title="dask.dataframe.Series.diff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.diff</span></code></a>([periods, axis])</p></td>
<td><p>First discrete difference of element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.div" title="dask.dataframe.Series.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.div</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Floating division of series and other, element-wise (binary operator <cite>truediv</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.drop_duplicates" title="dask.dataframe.Series.drop_duplicates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.drop_duplicates</span></code></a>([subset, …])</p></td>
<td><p>Return DataFrame with duplicate rows removed.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.dropna" title="dask.dataframe.Series.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.dropna</span></code></a>()</p></td>
<td><p>Return a new Series with missing values removed.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.dt" title="dask.dataframe.Series.dt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.dt</span></code></a></p></td>
<td><p>Namespace of datetime methods</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.dtype" title="dask.dataframe.Series.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.dtype</span></code></a></p></td>
<td><p>Return data type</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.eq" title="dask.dataframe.Series.eq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.eq</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Equal to of series and other, element-wise (binary operator <cite>eq</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.explode" title="dask.dataframe.Series.explode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.explode</span></code></a>()</p></td>
<td><p>Transform each element of a list-like to a row, replicating the index values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.ffill" title="dask.dataframe.Series.ffill"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.ffill</span></code></a>([axis, limit])</p></td>
<td><p>Synonym for <a class="reference internal" href="#dask.dataframe.DataFrame.fillna" title="dask.dataframe.DataFrame.fillna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.fillna()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">method='ffill'</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.fillna" title="dask.dataframe.Series.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.fillna</span></code></a>([value, method, limit, axis])</p></td>
<td><p>Fill NA/NaN values using the specified method.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.first" title="dask.dataframe.Series.first"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.first</span></code></a>(offset)</p></td>
<td><p>Method to subset initial periods of time series data based on a date offset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.floordiv" title="dask.dataframe.Series.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.floordiv</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Integer division of series and other, element-wise (binary operator <cite>floordiv</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.ge" title="dask.dataframe.Series.ge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.ge</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Greater than or equal to of series and other, element-wise (binary operator <cite>ge</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.get_partition" title="dask.dataframe.Series.get_partition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.get_partition</span></code></a>(n)</p></td>
<td><p>Get a dask DataFrame/Series representing the <cite>nth</cite> partition.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.groupby" title="dask.dataframe.Series.groupby"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code></a>([by])</p></td>
<td><p>Group Series using a mapper or by a Series of columns.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.gt" title="dask.dataframe.Series.gt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.gt</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Greater than of series and other, element-wise (binary operator <cite>gt</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.head" title="dask.dataframe.Series.head"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.head</span></code></a>([n, npartitions, compute])</p></td>
<td><p>First n rows of the dataset</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.idxmax" title="dask.dataframe.Series.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmax</span></code></a>([axis, skipna, split_every])</p></td>
<td><p>Return index of first occurrence of maximum over requested axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.idxmin" title="dask.dataframe.Series.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmin</span></code></a>([axis, skipna, split_every])</p></td>
<td><p>Return index of first occurrence of minimum over requested axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.isin" title="dask.dataframe.Series.isin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.isin</span></code></a>(values)</p></td>
<td><p>Check whether <cite>values</cite> are contained in Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.isna" title="dask.dataframe.Series.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.isna</span></code></a>()</p></td>
<td><p>Detect missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.isnull" title="dask.dataframe.Series.isnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.isnull</span></code></a>()</p></td>
<td><p>Detect missing values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.iteritems" title="dask.dataframe.Series.iteritems"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.iteritems</span></code></a>()</p></td>
<td><p>Lazily iterate over (index, value) tuples.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.known_divisions" title="dask.dataframe.Series.known_divisions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.known_divisions</span></code></a></p></td>
<td><p>Whether divisions are already known</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.last" title="dask.dataframe.Series.last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.last</span></code></a>(offset)</p></td>
<td><p>Method to subset final periods of time series data based on a date offset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.le" title="dask.dataframe.Series.le"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.le</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Less than or equal to of series and other, element-wise (binary operator <cite>le</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.loc" title="dask.dataframe.Series.loc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.loc</span></code></a></p></td>
<td><p>Purely label-location based indexer for selection by label.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.lt" title="dask.dataframe.Series.lt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.lt</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Less than of series and other, element-wise (binary operator <cite>lt</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.map" title="dask.dataframe.Series.map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.map</span></code></a>(arg[, na_action, meta])</p></td>
<td><p>Map values of Series according to input correspondence.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.map_overlap" title="dask.dataframe.Series.map_overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.map_overlap</span></code></a>(func, before, after, …)</p></td>
<td><p>Apply a function to each partition, sharing rows with adjacent partitions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.map_partitions" title="dask.dataframe.Series.map_partitions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.map_partitions</span></code></a>(func, *args, **kwargs)</p></td>
<td><p>Apply Python function on each DataFrame partition.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.mask" title="dask.dataframe.Series.mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.mask</span></code></a>(cond[, other])</p></td>
<td><p>Replace values where the condition is True.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.max" title="dask.dataframe.Series.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.max</span></code></a>([axis, skipna, split_every, out])</p></td>
<td><p>Return the maximum of the values for the requested axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.mean" title="dask.dataframe.Series.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.mean</span></code></a>([axis, skipna, split_every, …])</p></td>
<td><p>Return the mean of the values for the requested axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.memory_usage" title="dask.dataframe.Series.memory_usage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.memory_usage</span></code></a>([index, deep])</p></td>
<td><p>Return the memory usage of the Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.memory_usage_per_partition" title="dask.dataframe.Series.memory_usage_per_partition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.memory_usage_per_partition</span></code></a>([index, deep])</p></td>
<td><p>Return the memory usage of each partition</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.min" title="dask.dataframe.Series.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.min</span></code></a>([axis, skipna, split_every, out])</p></td>
<td><p>Return the minimum of the values for the requested axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.mod" title="dask.dataframe.Series.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.mod</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Modulo of series and other, element-wise (binary operator <cite>mod</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.mul" title="dask.dataframe.Series.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.mul</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Multiplication of series and other, element-wise (binary operator <cite>mul</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.nbytes" title="dask.dataframe.Series.nbytes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.nbytes</span></code></a></p></td>
<td><p>Number of bytes</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.ndim" title="dask.dataframe.Series.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.ndim</span></code></a></p></td>
<td><p>Return dimensionality</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.ne" title="dask.dataframe.Series.ne"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.ne</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Not equal to of series and other, element-wise (binary operator <cite>ne</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.nlargest" title="dask.dataframe.Series.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.nlargest</span></code></a>([n, split_every])</p></td>
<td><p>Return the largest <cite>n</cite> elements.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.notnull" title="dask.dataframe.Series.notnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.notnull</span></code></a>()</p></td>
<td><p>Detect existing (non-missing) values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.nsmallest" title="dask.dataframe.Series.nsmallest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.nsmallest</span></code></a>([n, split_every])</p></td>
<td><p>Return the smallest <cite>n</cite> elements.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.nunique" title="dask.dataframe.Series.nunique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.nunique</span></code></a>([split_every])</p></td>
<td><p>Return number of unique elements in the object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.nunique_approx" title="dask.dataframe.Series.nunique_approx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.nunique_approx</span></code></a>([split_every])</p></td>
<td><p>Approximate number of unique rows.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.persist" title="dask.dataframe.Series.persist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.persist</span></code></a>(**kwargs)</p></td>
<td><p>Persist this dask collection into memory</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.pipe" title="dask.dataframe.Series.pipe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.pipe</span></code></a>(func, *args, **kwargs)</p></td>
<td><p>Apply func(self, *args, **kwargs).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.pow" title="dask.dataframe.Series.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.pow</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Exponential power of series and other, element-wise (binary operator <cite>pow</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.prod" title="dask.dataframe.Series.prod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.prod</span></code></a>([axis, skipna, split_every, …])</p></td>
<td><p>Return the product of the values for the requested axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.quantile" title="dask.dataframe.Series.quantile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.quantile</span></code></a>([q, method])</p></td>
<td><p>Approximate quantiles of Series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.radd" title="dask.dataframe.Series.radd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.radd</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Addition of series and other, element-wise (binary operator <cite>radd</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.random_split" title="dask.dataframe.Series.random_split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.random_split</span></code></a>(frac[, random_state, …])</p></td>
<td><p>Pseudorandomly split dataframe into different pieces row-wise</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.rdiv" title="dask.dataframe.Series.rdiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.rdiv</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Floating division of series and other, element-wise (binary operator <cite>rtruediv</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.reduction" title="dask.dataframe.Series.reduction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.reduction</span></code></a>(chunk[, aggregate, …])</p></td>
<td><p>Generic row-wise reductions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.repartition" title="dask.dataframe.Series.repartition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.repartition</span></code></a>([divisions, npartitions, …])</p></td>
<td><p>Repartition dataframe along new divisions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.replace" title="dask.dataframe.Series.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.replace</span></code></a>([to_replace, value, regex])</p></td>
<td><p>Replace values given in <cite>to_replace</cite> with <cite>value</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.rename" title="dask.dataframe.Series.rename"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.rename</span></code></a>([index, inplace, sorted_index])</p></td>
<td><p>Alter Series index labels or name</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.resample" title="dask.dataframe.Series.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.resample</span></code></a>(rule[, closed, label])</p></td>
<td><p>Resample time-series data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.reset_index" title="dask.dataframe.Series.reset_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.reset_index</span></code></a>([drop])</p></td>
<td><p>Reset the index to the default index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.rolling" title="dask.dataframe.Series.rolling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.rolling</span></code></a>(window[, min_periods, …])</p></td>
<td><p>Provides rolling transformations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.round" title="dask.dataframe.Series.round"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.round</span></code></a>([decimals])</p></td>
<td><p>Round each value in a Series to the given number of decimals.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.sample" title="dask.dataframe.Series.sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.sample</span></code></a>([n, frac, replace, random_state])</p></td>
<td><p>Random sample of items</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.sem" title="dask.dataframe.Series.sem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.sem</span></code></a>([axis, skipna, ddof, split_every])</p></td>
<td><p>Return unbiased standard error of the mean over requested axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.shape" title="dask.dataframe.Series.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.shape</span></code></a></p></td>
<td><p>Return a tuple representing the dimensionality of a Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.shift" title="dask.dataframe.Series.shift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.shift</span></code></a>([periods, freq, axis])</p></td>
<td><p>Shift index by desired number of periods with an optional time <cite>freq</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.size" title="dask.dataframe.Series.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.size</span></code></a></p></td>
<td><p>Size of the Series or DataFrame as a Delayed object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.std" title="dask.dataframe.Series.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.std</span></code></a>([axis, skipna, ddof, …])</p></td>
<td><p>Return sample standard deviation over requested axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.str" title="dask.dataframe.Series.str"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.str</span></code></a></p></td>
<td><p>Namespace for string methods</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.sub" title="dask.dataframe.Series.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.sub</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Subtraction of series and other, element-wise (binary operator <cite>sub</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.sum" title="dask.dataframe.Series.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.sum</span></code></a>([axis, skipna, split_every, …])</p></td>
<td><p>Return the sum of the values for the requested axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.to_bag" title="dask.dataframe.Series.to_bag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.to_bag</span></code></a>([index])</p></td>
<td><p>Create a Dask Bag from a Series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.to_csv" title="dask.dataframe.Series.to_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.to_csv</span></code></a>(filename, **kwargs)</p></td>
<td><p>Store Dask DataFrame to CSV files</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.to_dask_array" title="dask.dataframe.Series.to_dask_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.to_dask_array</span></code></a>([lengths])</p></td>
<td><p>Convert a dask DataFrame to a dask array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.to_delayed" title="dask.dataframe.Series.to_delayed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.to_delayed</span></code></a>([optimize_graph])</p></td>
<td><p>Convert into a list of <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> objects, one per partition.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.to_frame" title="dask.dataframe.Series.to_frame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.to_frame</span></code></a>([name])</p></td>
<td><p>Convert Series to DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.to_hdf" title="dask.dataframe.Series.to_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.to_hdf</span></code></a>(path_or_buf, key[, mode, append])</p></td>
<td><p>Store Dask Dataframe to Hierarchical Data Format (HDF) files</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.to_string" title="dask.dataframe.Series.to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.to_string</span></code></a>([max_rows])</p></td>
<td><p>Render a string representation of the Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.to_timestamp" title="dask.dataframe.Series.to_timestamp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.to_timestamp</span></code></a>([freq, how, axis])</p></td>
<td><p>Cast to DatetimeIndex of timestamps, at <em>beginning</em> of period.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.truediv" title="dask.dataframe.Series.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.truediv</span></code></a>(other[, level, fill_value, axis])</p></td>
<td><p>Return Floating division of series and other, element-wise (binary operator <cite>truediv</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.unique" title="dask.dataframe.Series.unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.unique</span></code></a>([split_every, split_out])</p></td>
<td><p>Return Series of unique values in the object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.value_counts" title="dask.dataframe.Series.value_counts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.value_counts</span></code></a>([split_every, split_out])</p></td>
<td><p>Return a Series containing counts of unique values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.values" title="dask.dataframe.Series.values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.values</span></code></a></p></td>
<td><p>Return a dask.array of the values of this dataframe</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.var" title="dask.dataframe.Series.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.var</span></code></a>([axis, skipna, ddof, …])</p></td>
<td><p>Return unbiased variance over requested axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.visualize" title="dask.dataframe.Series.visualize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.visualize</span></code></a>([filename, format, …])</p></td>
<td><p>Render the computation of this object’s task graph using graphviz.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.Series.where" title="dask.dataframe.Series.where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.where</span></code></a>(cond[, other])</p></td>
<td><p>Replace values where the condition is False.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="groupby-operations">
<h2>Groupby Operations<a class="headerlink" href="#groupby-operations" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.aggregate" title="dask.dataframe.groupby.DataFrameGroupBy.aggregate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.aggregate</span></code></a>(arg[, …])</p></td>
<td><p>Aggregate using one or more operations over the specified axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.apply" title="dask.dataframe.groupby.DataFrameGroupBy.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.apply</span></code></a>(func, *args, **kwargs)</p></td>
<td><p>Parallel version of pandas GroupBy.apply</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.count" title="dask.dataframe.groupby.DataFrameGroupBy.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.count</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute count of group, excluding missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.cumcount" title="dask.dataframe.groupby.DataFrameGroupBy.cumcount"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.cumcount</span></code></a>([axis])</p></td>
<td><p>Number each item in each group from 0 to the length of that group - 1.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.cumprod" title="dask.dataframe.groupby.DataFrameGroupBy.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.cumprod</span></code></a>([axis])</p></td>
<td><p>Cumulative product for each group.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.cumsum" title="dask.dataframe.groupby.DataFrameGroupBy.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.cumsum</span></code></a>([axis])</p></td>
<td><p>Cumulative sum for each group.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.get_group" title="dask.dataframe.groupby.DataFrameGroupBy.get_group"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.get_group</span></code></a>(key)</p></td>
<td><p>Construct DataFrame from group with provided name.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.max" title="dask.dataframe.groupby.DataFrameGroupBy.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.max</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute max of group values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.mean" title="dask.dataframe.groupby.DataFrameGroupBy.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.mean</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute mean of groups, excluding missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.min" title="dask.dataframe.groupby.DataFrameGroupBy.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.min</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute min of group values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.size" title="dask.dataframe.groupby.DataFrameGroupBy.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.size</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute group sizes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.std" title="dask.dataframe.groupby.DataFrameGroupBy.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.std</span></code></a>([ddof, split_every, …])</p></td>
<td><p>Compute standard deviation of groups, excluding missing values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.sum" title="dask.dataframe.groupby.DataFrameGroupBy.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.sum</span></code></a>([split_every, …])</p></td>
<td><p>Compute sum of group values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.var" title="dask.dataframe.groupby.DataFrameGroupBy.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.var</span></code></a>([ddof, split_every, …])</p></td>
<td><p>Compute variance of groups, excluding missing values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.cov" title="dask.dataframe.groupby.DataFrameGroupBy.cov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.cov</span></code></a>([ddof, split_every, …])</p></td>
<td><p>Compute pairwise covariance of columns, excluding NA/null values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.corr" title="dask.dataframe.groupby.DataFrameGroupBy.corr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.corr</span></code></a>([ddof, split_every, …])</p></td>
<td><p>Compute pairwise correlation of columns, excluding NA/null values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.first" title="dask.dataframe.groupby.DataFrameGroupBy.first"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.first</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute first of group values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.last" title="dask.dataframe.groupby.DataFrameGroupBy.last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.last</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute last of group values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.idxmin" title="dask.dataframe.groupby.DataFrameGroupBy.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.idxmin</span></code></a>([split_every, …])</p></td>
<td><p>Return index of first occurrence of minimum over requested axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.DataFrameGroupBy.idxmax" title="dask.dataframe.groupby.DataFrameGroupBy.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.idxmax</span></code></a>([split_every, …])</p></td>
<td><p>Return index of first occurrence of maximum over requested axis.</p></td>
</tr>
</tbody>
</table>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.aggregate" title="dask.dataframe.groupby.SeriesGroupBy.aggregate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.aggregate</span></code></a>(arg[, split_every, …])</p></td>
<td><p>Aggregate using one or more operations over the specified axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.apply" title="dask.dataframe.groupby.SeriesGroupBy.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.apply</span></code></a>(func, *args, **kwargs)</p></td>
<td><p>Parallel version of pandas GroupBy.apply</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.count" title="dask.dataframe.groupby.SeriesGroupBy.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.count</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute count of group, excluding missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.cumcount" title="dask.dataframe.groupby.SeriesGroupBy.cumcount"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.cumcount</span></code></a>([axis])</p></td>
<td><p>Number each item in each group from 0 to the length of that group - 1.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.cumprod" title="dask.dataframe.groupby.SeriesGroupBy.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.cumprod</span></code></a>([axis])</p></td>
<td><p>Cumulative product for each group.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.cumsum" title="dask.dataframe.groupby.SeriesGroupBy.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.cumsum</span></code></a>([axis])</p></td>
<td><p>Cumulative sum for each group.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.get_group" title="dask.dataframe.groupby.SeriesGroupBy.get_group"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.get_group</span></code></a>(key)</p></td>
<td><p>Construct DataFrame from group with provided name.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.max" title="dask.dataframe.groupby.SeriesGroupBy.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.max</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute max of group values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.mean" title="dask.dataframe.groupby.SeriesGroupBy.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.mean</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute mean of groups, excluding missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.min" title="dask.dataframe.groupby.SeriesGroupBy.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.min</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute min of group values.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.nunique</span></code>([split_every, split_out])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.size" title="dask.dataframe.groupby.SeriesGroupBy.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.size</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute group sizes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.std" title="dask.dataframe.groupby.SeriesGroupBy.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.std</span></code></a>([ddof, split_every, split_out])</p></td>
<td><p>Compute standard deviation of groups, excluding missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.sum" title="dask.dataframe.groupby.SeriesGroupBy.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.sum</span></code></a>([split_every, split_out, …])</p></td>
<td><p>Compute sum of group values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.var" title="dask.dataframe.groupby.SeriesGroupBy.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.var</span></code></a>([ddof, split_every, split_out])</p></td>
<td><p>Compute variance of groups, excluding missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.first" title="dask.dataframe.groupby.SeriesGroupBy.first"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.first</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute first of group values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.last" title="dask.dataframe.groupby.SeriesGroupBy.last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.last</span></code></a>([split_every, split_out])</p></td>
<td><p>Compute last of group values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.idxmin" title="dask.dataframe.groupby.SeriesGroupBy.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.idxmin</span></code></a>([split_every, …])</p></td>
<td><p>Return index of first occurrence of minimum over requested axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.idxmax" title="dask.dataframe.groupby.SeriesGroupBy.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeriesGroupBy.idxmax</span></code></a>([split_every, …])</p></td>
<td><p>Return index of first occurrence of maximum over requested axis.</p></td>
</tr>
</tbody>
</table>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.groupby.Aggregation" title="dask.dataframe.groupby.Aggregation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Aggregation</span></code></a>(name, chunk, agg[, finalize])</p></td>
<td><p>User defined groupby-aggregation.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="rolling-operations">
<h2>Rolling Operations<a class="headerlink" href="#rolling-operations" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.rolling.map_overlap" title="dask.dataframe.rolling.map_overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rolling.map_overlap</span></code></a>(func, df, before, after, …)</p></td>
<td><p>Apply a function to each partition, sharing rows with adjacent partitions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.Series.rolling" title="dask.dataframe.Series.rolling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.rolling</span></code></a>(window[, min_periods, …])</p></td>
<td><p>Provides rolling transformations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.rolling" title="dask.dataframe.DataFrame.rolling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.rolling</span></code></a>(window[, min_periods, …])</p></td>
<td><p>Provides rolling transformations.</p></td>
</tr>
</tbody>
</table>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rolling.apply</span></code>(func[, raw, engine, …])</p></td>
<td><p>The rolling function’s apply function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rolling.count</span></code>()</p></td>
<td><p>The rolling count of any non-NaN observations inside the window.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rolling.kurt</span></code>()</p></td>
<td><p>Calculate unbiased rolling kurtosis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rolling.max</span></code>()</p></td>
<td><p>Calculate the rolling maximum.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rolling.mean</span></code>()</p></td>
<td><p>Calculate the rolling mean of the values.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rolling.median</span></code>()</p></td>
<td><p>Calculate the rolling median.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rolling.min</span></code>()</p></td>
<td><p>Calculate the rolling minimum.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rolling.quantile</span></code>(quantile)</p></td>
<td><p>Calculate the rolling quantile.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rolling.skew</span></code>()</p></td>
<td><p>Unbiased rolling skewness.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rolling.std</span></code>([ddof])</p></td>
<td><p>Calculate rolling standard deviation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rolling.sum</span></code>()</p></td>
<td><p>Calculate rolling sum of given DataFrame or Series.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rolling.var</span></code>([ddof])</p></td>
<td><p>Calculate unbiased rolling variance.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="create-dataframes">
<h2>Create DataFrames<a class="headerlink" href="#create-dataframes" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.read_csv" title="dask.dataframe.read_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_csv</span></code></a>(urlpath[, blocksize, collection, …])</p></td>
<td><p>Read CSV files into a Dask.DataFrame</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.read_table" title="dask.dataframe.read_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_table</span></code></a>(urlpath[, blocksize, collection, …])</p></td>
<td><p>Read delimited files into a Dask.DataFrame</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.read_fwf" title="dask.dataframe.read_fwf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_fwf</span></code></a>(urlpath[, blocksize, collection, …])</p></td>
<td><p>Read fixed-width files into a Dask.DataFrame</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.read_parquet" title="dask.dataframe.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_parquet</span></code></a>(path[, columns, filters, …])</p></td>
<td><p>Read a Parquet file into a Dask DataFrame</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.read_hdf" title="dask.dataframe.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_hdf</span></code></a>(pattern, key[, start, stop, …])</p></td>
<td><p>Read HDF files into a Dask DataFrame</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.read_json" title="dask.dataframe.read_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_json</span></code></a>(url_path[, orient, lines, …])</p></td>
<td><p>Create a dataframe from a set of JSON files</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.read_orc" title="dask.dataframe.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_orc</span></code></a>(path[, columns, storage_options])</p></td>
<td><p>Read dataframe from ORC file(s)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.read_sql_table" title="dask.dataframe.read_sql_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_sql_table</span></code></a>(table, uri, index_col[, …])</p></td>
<td><p>Create dataframe from an SQL table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.from_array" title="dask.dataframe.from_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_array</span></code></a>(x[, chunksize, columns])</p></td>
<td><p>Read any slicable array into a Dask Dataframe</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.from_bcolz" title="dask.dataframe.from_bcolz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_bcolz</span></code></a>(x[, chunksize, categorize, …])</p></td>
<td><p>Read BColz CTable into a Dask Dataframe</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.from_dask_array" title="dask.dataframe.from_dask_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_dask_array</span></code></a>(x[, columns, index])</p></td>
<td><p>Create a Dask DataFrame from a Dask Array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.from_delayed" title="dask.dataframe.from_delayed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_delayed</span></code></a>(dfs[, meta, divisions, prefix, …])</p></td>
<td><p>Create Dask DataFrame from many Dask Delayed objects</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.from_pandas" title="dask.dataframe.from_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_pandas</span></code></a>(data[, npartitions, chunksize, …])</p></td>
<td><p>Construct a Dask DataFrame from a Pandas DataFrame</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="bag-creation.html#dask.bag.core.Bag.to_dataframe" title="dask.bag.core.Bag.to_dataframe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.bag.core.Bag.to_dataframe</span></code></a>([meta, columns])</p></td>
<td><p>Create Dask Dataframe from a Dask Bag.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="store-dataframes">
<h2>Store DataFrames<a class="headerlink" href="#store-dataframes" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.to_csv" title="dask.dataframe.to_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_csv</span></code></a>(df, filename[, single_file, …])</p></td>
<td><p>Store Dask DataFrame to CSV files</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.to_parquet" title="dask.dataframe.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_parquet</span></code></a>(df, path[, engine, compression, …])</p></td>
<td><p>Store Dask.dataframe to Parquet files</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.to_hdf" title="dask.dataframe.to_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_hdf</span></code></a>(df, path, key[, mode, append, …])</p></td>
<td><p>Store Dask Dataframe to Hierarchical Data Format (HDF) files</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.to_records" title="dask.dataframe.to_records"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_records</span></code></a>(df)</p></td>
<td><p>Create Dask Array from a Dask Dataframe</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.to_sql" title="dask.dataframe.to_sql"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_sql</span></code></a>(df, name, con[, schema, if_exists, …])</p></td>
<td><p>Store Dask Dataframe to a SQL table</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.to_bag" title="dask.dataframe.to_bag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_bag</span></code></a>(df[, index])</p></td>
<td><p>Create Dask Bag from a Dask DataFrame</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.to_json" title="dask.dataframe.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_json</span></code></a>(df, url_path[, orient, lines, …])</p></td>
<td><p>Write dataframe into JSON text files</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="convert-dataframes">
<h2>Convert DataFrames<a class="headerlink" href="#convert-dataframes" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.to_dask_array" title="dask.dataframe.DataFrame.to_dask_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.to_dask_array</span></code></a>([lengths])</p></td>
<td><p>Convert a dask DataFrame to a dask array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.DataFrame.to_delayed" title="dask.dataframe.DataFrame.to_delayed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.to_delayed</span></code></a>([optimize_graph])</p></td>
<td><p>Convert into a list of <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> objects, one per partition.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="reshape-dataframes">
<h2>Reshape DataFrames<a class="headerlink" href="#reshape-dataframes" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.reshape.get_dummies" title="dask.dataframe.reshape.get_dummies"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dummies</span></code></a>(data[, prefix, prefix_sep, …])</p></td>
<td><p>Convert categorical variable into dummy/indicator variables.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.dataframe.reshape.pivot_table" title="dask.dataframe.reshape.pivot_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pivot_table</span></code></a>(df[, index, columns, values, …])</p></td>
<td><p>Create a spreadsheet-style pivot table as a DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.dataframe.reshape.melt" title="dask.dataframe.reshape.melt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">melt</span></code></a>(frame[, id_vars, value_vars, var_name, …])</p></td>
<td><p>Unpivots a DataFrame from wide format to long format, optionally leaving identifier variables set.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dataframe-methods">
<h2>DataFrame Methods<a class="headerlink" href="#dataframe-methods" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dask.dataframe.DataFrame">
<em class="property">class </em><code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">DataFrame</code><span class="sig-paren">(</span><em class="sig-param">dsk</em>, <em class="sig-param">name</em>, <em class="sig-param">meta</em>, <em class="sig-param">divisions</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel Pandas DataFrame</p>
<p>Do not use this class directly.  Instead use functions like
<code class="docutils literal notranslate"><span class="pre">dd.read_csv</span></code>, <code class="docutils literal notranslate"><span class="pre">dd.read_parquet</span></code>, or <code class="docutils literal notranslate"><span class="pre">dd.from_pandas</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dsk: dict</strong></dt><dd><p>The dask graph to compute this DataFrame</p>
</dd>
<dt><strong>name: str</strong></dt><dd><p>The key prefix that specifies which keys in the dask comprise this
particular DataFrame</p>
</dd>
<dt><strong>meta: pandas.DataFrame</strong></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code> with names, dtypes, and index matching
the expected output.</p>
</dd>
<dt><strong>divisions: tuple of index values</strong></dt><dd><p>Values along which we partition our blocks on the index</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="dask.dataframe.DataFrame.abs">
<code class="sig-name descname">abs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Series/DataFrame with absolute numeric value of each element.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.abs.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This function only applies to elements that are all numeric.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>abs</strong></dt><dd><p>Series/DataFrame containing the absolute value of each element.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.absolute.html#numpy.absolute" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.absolute</span></code></a></dt><dd><p>Calculate the absolute value element-wise.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For <code class="docutils literal notranslate"><span class="pre">complex</span></code> inputs, <code class="docutils literal notranslate"><span class="pre">1.2</span> <span class="pre">+</span> <span class="pre">1j</span></code>, the absolute value is
<span class="math notranslate nohighlight">\(\sqrt{ a^2 + b^2 }\)</span>.</p>
<p class="rubric">Examples</p>
<p>Absolute numeric values in a Series.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="o">-</span><span class="mf">1.10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.33</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>  
<span class="go">0    1.10</span>
<span class="go">1    2.00</span>
<span class="go">2    3.33</span>
<span class="go">3    4.00</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Absolute numeric values in a Series with complex numbers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">1.2</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>  
<span class="go">0    1.56205</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Absolute numeric values in a Series with a Timedelta element.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="s1">&#39;1 days&#39;</span><span class="p">)])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>  
<span class="go">0   1 days</span>
<span class="go">dtype: timedelta64[ns]</span>
</pre></div>
</div>
<p>Select rows with data closest to certain value using argsort (from
<a class="reference external" href="https://stackoverflow.com/a/17758115">StackOverflow</a>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>  
<span class="gp">... </span>    <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>    <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span>
<span class="gp">... </span>    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">]</span>
<span class="gp">... </span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     a    b    c</span>
<span class="go">0    4   10  100</span>
<span class="go">1    5   20   50</span>
<span class="go">2    6   30  -30</span>
<span class="go">3    7   40  -50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">df</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span> <span class="mi">43</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>  
<span class="go">     a    b    c</span>
<span class="go">1    5   20   50</span>
<span class="go">0    4   10  100</span>
<span class="go">2    6   30  -30</span>
<span class="go">3    7   40  -50</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Addition of dataframe and other, element-wise (binary operator <cite>add</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.add.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">+</span> <span class="pre">other</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>radd</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.align">
<code class="sig-name descname">align</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">join='outer'</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align two objects on their axes with the specified join method.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.align.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Join method is specified for each axis Index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">DataFrame or Series</span></dt><dd></dd>
<dt><strong>join</strong><span class="classifier">{‘outer’, ‘inner’, ‘left’, ‘right’}, default ‘outer’</span></dt><dd></dd>
<dt><strong>axis</strong><span class="classifier">allowed axis of the other object, default None</span></dt><dd><p>Align on index (0), columns (1), or both (None).</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>Always returns new objects. If copy=False and no reindexing is
required then original objects are returned.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">scalar, default np.NaN</span></dt><dd><p>Value to use for missing values. Defaults to NaN, but can be any
“compatible” value.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘backfill’, ‘bfill’, ‘pad’, ‘ffill’, None}, default None  (Not supported in Dask)</span></dt><dd><p>Method to use for filling holes in reindexed Series:</p>
<ul class="simple">
<li><p>pad / ffill: propagate last valid observation forward to next valid.</p></li>
<li><p>backfill / bfill: use NEXT valid observation to fill gap.</p></li>
</ul>
</dd>
<dt><strong>limit</strong><span class="classifier">int, default None  (Not supported in Dask)</span></dt><dd><p>If method is specified, this is the maximum number of consecutive
NaN values to forward/backward fill. In other words, if there is
a gap with more than this number of consecutive NaNs, it will only
be partially filled. If method is not specified, this is the
maximum number of entries along the entire axis where NaNs will be
filled. Must be greater than 0 if not None.</p>
</dd>
<dt><strong>fill_axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0  (Not supported in Dask)</span></dt><dd><p>Filling axis, method and limit.</p>
</dd>
<dt><strong>broadcast_axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default None  (Not supported in Dask)</span></dt><dd><p>Broadcast values along this axis, if aligning two objects of
different dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>(left, right)</strong><span class="classifier">(DataFrame, type of other)</span></dt><dd><p>Aligned objects.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.all">
<code class="sig-name descname">all</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether all elements are True, potentially over an axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.all.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns True unless there at least one element within a series or
along a Dataframe axis that is False or equivalent (e.g. zero or
empty).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’, None}, default 0</span></dt><dd><p>Indicate which axis or axes should be reduced.</p>
<ul class="simple">
<li><p>0 / ‘index’ : reduce the index, return a Series whose index is the
original column labels.</p></li>
<li><p>1 / ‘columns’ : reduce the columns, return a Series whose index is the
original index.</p></li>
<li><p>None : reduce all axes, return a scalar.</p></li>
</ul>
</dd>
<dt><strong>bool_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only boolean columns. If None, will attempt to use everything,
then use only boolean data. Not implemented for Series.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If the entire row/column is NA and skipna is
True, then the result will be True, as for an empty row/column.
If skipna is False, then NA are treated as True, because these are not
equal to zero.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">any, default None</span></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with NumPy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>If level is specified, then, DataFrame is returned; otherwise, Series
is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.all" title="dask.dataframe.Series.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.all</span></code></a></dt><dd><p>Return True if all elements are True.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.any" title="dask.dataframe.DataFrame.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.any</span></code></a></dt><dd><p>Return True if one (or more) elements are True.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p><strong>Series</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">True</span>
</pre></div>
</div>
<p><strong>DataFrames</strong></p>
<p>Create a dataframe from a dictionary.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;col1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="s1">&#39;col2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   col1   col2</span>
<span class="go">0  True   True</span>
<span class="go">1  True  False</span>
</pre></div>
</div>
<p>Default behaviour checks if column-wise values all return True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  
<span class="go">col1     True</span>
<span class="go">col2    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>Specify <code class="docutils literal notranslate"><span class="pre">axis='columns'</span></code> to check if row-wise values all return True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">0     True</span>
<span class="go">1    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>Or <code class="docutils literal notranslate"><span class="pre">axis=None</span></code> for whether every value is True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.any">
<code class="sig-name descname">any</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether any element is True, potentially over an axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.any.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns False unless there at least one element within a series or
along a Dataframe axis that is True or equivalent (e.g. non-zero or
non-empty).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’, None}, default 0</span></dt><dd><p>Indicate which axis or axes should be reduced.</p>
<ul class="simple">
<li><p>0 / ‘index’ : reduce the index, return a Series whose index is the
original column labels.</p></li>
<li><p>1 / ‘columns’ : reduce the columns, return a Series whose index is the
original index.</p></li>
<li><p>None : reduce all axes, return a scalar.</p></li>
</ul>
</dd>
<dt><strong>bool_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only boolean columns. If None, will attempt to use everything,
then use only boolean data. Not implemented for Series.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If the entire row/column is NA and skipna is
True, then the result will be False, as for an empty row/column.
If skipna is False, then NA are treated as True, because these are not
equal to zero.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">any, default None</span></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with NumPy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>If level is specified, then, DataFrame is returned; otherwise, Series
is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.any.html#numpy.any" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.any</span></code></a></dt><dd><p>Numpy version of this method.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.any" title="dask.dataframe.Series.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.any</span></code></a></dt><dd><p>Return whether any element is True.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.all" title="dask.dataframe.Series.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.all</span></code></a></dt><dd><p>Return whether all elements are True.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.any" title="dask.dataframe.DataFrame.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.any</span></code></a></dt><dd><p>Return whether any element is True over requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.all" title="dask.dataframe.DataFrame.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.all</span></code></a></dt><dd><p>Return whether all elements are True over requested axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p><strong>Series</strong></p>
<p>For Series input, the output is a scalar indicating whether any element
is True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">True</span>
</pre></div>
</div>
<p><strong>DataFrame</strong></p>
<p>Whether each column contains at least one True element (the default).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A  B  C</span>
<span class="go">0  1  0  0</span>
<span class="go">1  2  2  0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>  
<span class="go">A     True</span>
<span class="go">B     True</span>
<span class="go">C    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>Aggregating over the columns.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">       A  B</span>
<span class="go">0   True  1</span>
<span class="go">1  False  2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">0    True</span>
<span class="go">1    True</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">       A  B</span>
<span class="go">0   True  1</span>
<span class="go">1  False  0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">0    True</span>
<span class="go">1    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>Aggregating over the entire DataFrame with <code class="docutils literal notranslate"><span class="pre">axis=None</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  
<span class="go">True</span>
</pre></div>
</div>
<p><cite>any</cite> for an empty DataFrame is an empty Series.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>  
<span class="go">Series([], dtype: bool)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">interleave_partitions=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append rows of <cite>other</cite> to the end of caller, returning a new object.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.append.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Columns in <cite>other</cite> that are not in the caller are added as new columns.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier">DataFrame or Series/dict-like object, or list of these</span></dt><dd><p>The data to append.</p>
</dd>
<dt><strong>ignore_index</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True, do not use the index labels.</p>
</dd>
<dt><strong>verify_integrity</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True, raise ValueError on creating index with duplicates.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Sort columns if the columns of <cite>self</cite> and <cite>other</cite> are not aligned.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.23.0.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.0.0: </span>Changed to not sort by default.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">concat</span></code></dt><dd><p>General function to concatenate DataFrame or Series objects.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If a list of dict/series is passed and the keys are all contained in
the DataFrame’s index, the order of the columns in the resulting
DataFrame will be unchanged.</p>
<p>Iteratively appending rows to a DataFrame can be more computationally
intensive than a single concatenate. A better solution is to append
those rows to a list and then concatenate the list with the original
DataFrame all at once.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A  B</span>
<span class="go">0  1  2</span>
<span class="go">1  3  4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]],</span> <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df2</span><span class="p">)</span>  
<span class="go">   A  B</span>
<span class="go">0  1  2</span>
<span class="go">1  3  4</span>
<span class="go">0  5  6</span>
<span class="go">1  7  8</span>
</pre></div>
</div>
<p>With <cite>ignore_index</cite> set to True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">   A  B</span>
<span class="go">0  1  2</span>
<span class="go">1  3  4</span>
<span class="go">2  5  6</span>
<span class="go">3  7  8</span>
</pre></div>
</div>
<p>The following, while not recommended methods for generating DataFrames,
show two ways to generate a DataFrame from multiple data sources.</p>
<p>Less efficient:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">},</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A</span>
<span class="go">0  0</span>
<span class="go">1  1</span>
<span class="go">2  2</span>
<span class="go">3  3</span>
<span class="go">4  4</span>
</pre></div>
</div>
<p>More efficient:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">i</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)],</span>  
<span class="gp">... </span>          <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">   A</span>
<span class="go">0  0</span>
<span class="go">1  1</span>
<span class="go">2  2</span>
<span class="go">3  3</span>
<span class="go">4  4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">broadcast=None</em>, <em class="sig-param">raw=False</em>, <em class="sig-param">reduce=None</em>, <em class="sig-param">args=()</em>, <em class="sig-param">meta='__no_default__'</em>, <em class="sig-param">**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel version of pandas.DataFrame.apply</p>
<p>This mimics the pandas version except for the following:</p>
<ol class="arabic simple">
<li><p>Only <code class="docutils literal notranslate"><span class="pre">axis=1</span></code> is supported (and must be specified explicitly).</p></li>
<li><p>The user should provide output metadata via the <cite>meta</cite> keyword.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function to apply to each column/row</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><ul class="simple">
<li><p>0 or ‘index’: apply function to each column (NOT SUPPORTED)</p></li>
<li><p>1 or ‘columns’: apply function to each row</p></li>
</ul>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes
and column names of the output. This metadata is necessary for
many algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code>
can be provided (note that the order of the names should match the
order of the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span>
<span class="pre">dtype)</span></code> can be used. If not provided, dask will try to infer the
metadata. This may lead to unexpected results, so providing
<code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For more information, see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
<dt><strong>args</strong><span class="classifier">tuple</span></dt><dd><p>Positional arguments to pass to function in addition to the array/series</p>
</dd>
<dt><strong>Additional keyword arguments will be passed as keywords to the function</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>applied</strong><span class="classifier">Series or DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.DataFrame.map_partitions</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply a function to row-wise passing in extra arguments in <code class="docutils literal notranslate"><span class="pre">args</span></code> and
<code class="docutils literal notranslate"><span class="pre">kwargs</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">myadd</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">row</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">myadd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>  
</pre></div>
</div>
<p>By default, dask tries to infer the output metadata by running your
provided function on some fake data. This works well in many cases, but
can sometimes be expensive, or even fail. To avoid this, you can
manually specify the output metadata with the <code class="docutils literal notranslate"><span class="pre">meta</span></code> keyword. This
can be specified in many forms, for more information see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
<p>Here we specify the output is a Series with name <code class="docutils literal notranslate"><span class="pre">'x'</span></code>, and dtype
<code class="docutils literal notranslate"><span class="pre">float64</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">myadd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;f8&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>In the case where the metadata doesn’t change, you can also pass in
the object itself directly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">ddf</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.applymap">
<code class="sig-name descname">applymap</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">meta='__no_default__'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.applymap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to a Dataframe elementwise.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.applymap.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This method applies a function that accepts and returns a scalar
to every element of a DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>Python function, returns a single value from a single value.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Transformed DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.apply" title="dask.dataframe.DataFrame.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.apply</span></code></a></dt><dd><p>Apply a function along input axis of DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>In the current implementation applymap calls <cite>func</cite> twice on the
first column/row to decide whether it can take a fast or slow
code path. This can lead to unexpected behavior if <cite>func</cite> has
side-effects, as they will take effect twice for the first
column/row.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.12</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.356</span><span class="p">,</span> <span class="mf">4.567</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">       0      1</span>
<span class="go">0  1.000  2.120</span>
<span class="go">1  3.356  4.567</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>  
<span class="go">   0  1</span>
<span class="go">0  3  4</span>
<span class="go">1  5  5</span>
</pre></div>
</div>
<p>Note that a vectorized version of <cite>func</cite> often exists, which will
be much faster. You could square each number elementwise.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">           0          1</span>
<span class="go">0   1.000000   4.494400</span>
<span class="go">1  11.262736  20.857489</span>
</pre></div>
</div>
<p>But it’s better to avoid applymap in that case.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">**</span> <span class="mi">2</span>  
<span class="go">           0          1</span>
<span class="go">0   1.000000   4.494400</span>
<span class="go">1  11.262736  20.857489</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.assign">
<code class="sig-name descname">assign</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign new columns to a DataFrame.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.assign.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns a new object with all original columns in addition to new ones.
Existing columns that are re-assigned will be overwritten.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>**kwargs</strong><span class="classifier">dict of {str: callable or Series}</span></dt><dd><p>The column names are keywords. If the values are
callable, they are computed on the DataFrame and
assigned to the new columns. The callable must not
change input DataFrame (though pandas doesn’t check it).
If the values are not callable, (e.g. a Series, scalar, or array),
they are simply assigned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>A new DataFrame with the new columns in addition to
all the existing columns.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Assigning multiple columns within the same <code class="docutils literal notranslate"><span class="pre">assign</span></code> is possible.
Later items in ‘**kwargs’ may refer to newly created or modified
columns in ‘df’; items are computed and assigned into ‘df’ in order.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.23.0: </span>Keyword argument order is maintained.</p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;temp_c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">17.0</span><span class="p">,</span> <span class="mf">25.0</span><span class="p">]},</span>  
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Portland&#39;</span><span class="p">,</span> <span class="s1">&#39;Berkeley&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">          temp_c</span>
<span class="go">Portland    17.0</span>
<span class="go">Berkeley    25.0</span>
</pre></div>
</div>
<p>Where the value is a callable, evaluated on <cite>df</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">temp_f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">temp_c</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">/</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span>  
<span class="go">          temp_c  temp_f</span>
<span class="go">Portland    17.0    62.6</span>
<span class="go">Berkeley    25.0    77.0</span>
</pre></div>
</div>
<p>Alternatively, the same behavior can be achieved by directly
referencing an existing Series or sequence:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">temp_f</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;temp_c&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">/</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span>  
<span class="go">          temp_c  temp_f</span>
<span class="go">Portland    17.0    62.6</span>
<span class="go">Berkeley    25.0    77.0</span>
</pre></div>
</div>
<p>You can create multiple columns within the same assign where one
of the columns depends on another one defined within the same assign:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">temp_f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;temp_c&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">/</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">32</span><span class="p">,</span>  
<span class="gp">... </span>          <span class="n">temp_k</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;temp_f&#39;</span><span class="p">]</span> <span class="o">+</span>  <span class="mf">459.67</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span><span class="p">)</span>
<span class="go">          temp_c  temp_f  temp_k</span>
<span class="go">Portland    17.0    62.6  290.15</span>
<span class="go">Berkeley    25.0    77.0  298.15</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.astype">
<code class="sig-name descname">astype</code><span class="sig-paren">(</span><em class="sig-param">dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast a pandas object to a specified dtype <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.astype.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data type, or dict of column name -&gt; data type</span></dt><dd><p>Use a numpy.dtype or Python type to cast entire pandas object to
the same type. Alternatively, use {col: dtype, …}, where col is a
column label and dtype is a numpy.dtype or Python type to cast one
or more of the DataFrame’s columns to column-specific types.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>Return a copy when <code class="docutils literal notranslate"><span class="pre">copy=True</span></code> (be very careful setting
<code class="docutils literal notranslate"><span class="pre">copy=False</span></code> as changes to values then may propagate to other
pandas objects).</p>
</dd>
<dt><strong>errors</strong><span class="classifier">{‘raise’, ‘ignore’}, default ‘raise’  (Not supported in Dask)</span></dt><dd><p>Control raising of exceptions on invalid data for provided dtype.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">raise</span></code> : allow exceptions to be raised</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ignore</span></code> : suppress exceptions. On error return original object.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>casted</strong><span class="classifier">same type as caller</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.to_datetime" title="dask.dataframe.to_datetime"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_datetime</span></code></a></dt><dd><p>Convert argument to datetime.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_timedelta</span></code></dt><dd><p>Convert argument to timedelta.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.to_numeric" title="dask.dataframe.to_numeric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_numeric</span></code></a></dt><dd><p>Convert argument to a numeric type.</p>
</dd>
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray.astype</span></code></a></dt><dd><p>Cast a numpy array to a specified type.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Create a DataFrame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;col1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;col2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]}</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span>  
<span class="go">col1    int64</span>
<span class="go">col2    int64</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Cast all columns to int32:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dtypes</span>  
<span class="go">col1    int32</span>
<span class="go">col2    int32</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Cast col1 to int32 using a dictionary:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s1">&#39;col1&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">dtypes</span>  
<span class="go">col1    int32</span>
<span class="go">col2    int64</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Create a series:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Convert to categorical type:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: category</span>
<span class="go">Categories (2, int64): [1, 2]</span>
</pre></div>
</div>
<p>Convert to ordered categorical type with custom ordering:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cat_dtype</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">CategoricalDtype</span><span class="p">(</span>  
<span class="gp">... </span>    <span class="n">categories</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cat_dtype</span><span class="p">)</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: category</span>
<span class="go">Categories (2, int64): [2 &lt; 1]</span>
</pre></div>
</div>
<p>Note that using <code class="docutils literal notranslate"><span class="pre">copy=False</span></code> and changing data on a new
pandas object may propagate changes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span>  <span class="c1"># note that s1[0] has changed too  </span>
<span class="go">0    10</span>
<span class="go">1     2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.bfill">
<code class="sig-name descname">bfill</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.bfill" title="Permalink to this definition">¶</a></dt>
<dd><p>Synonym for <a class="reference internal" href="#dask.dataframe.DataFrame.fillna" title="dask.dataframe.DataFrame.fillna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.fillna()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">method='bfill'</span></code>.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.bfill.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>%(klass)s or None</strong></dt><dd><p>Object with missing values filled or None if <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.categorize">
<code class="sig-name descname">categorize</code><span class="sig-paren">(</span><em class="sig-param">columns=None</em>, <em class="sig-param">index=None</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.categorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert columns of the DataFrame to category dtype.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>columns</strong><span class="classifier">list, optional</span></dt><dd><p>A list of column names to convert to categoricals. By default any
column with an object dtype is converted to a categorical, and any
unknown categoricals are made known.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to categorize the index. By default, object indices are
converted to categorical, and unknown categorical indices are made
known. Set True to always categorize the index, False to never.</p>
</dd>
<dt><strong>split_every</strong><span class="classifier">int, optional</span></dt><dd><p>Group partitions into groups of this size while performing a
tree-reduction. If set to False, no tree-reduction will be used.
Default is 16.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Keyword arguments are passed on to compute.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.clear_divisions">
<code class="sig-name descname">clear_divisions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.clear_divisions" title="Permalink to this definition">¶</a></dt>
<dd><p>Forget division information</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.clip">
<code class="sig-name descname">clip</code><span class="sig-paren">(</span><em class="sig-param">lower=None</em>, <em class="sig-param">upper=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Trim values at input threshold(s).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.clip.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Assigns values outside boundary to boundary values. Thresholds
can be singular values or array like, and in the latter case
the clipping is performed element-wise in the specified axis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>lower</strong><span class="classifier">float or array_like, default None</span></dt><dd><p>Minimum threshold value. All values below this
threshold will be set to it.</p>
</dd>
<dt><strong>upper</strong><span class="classifier">float or array_like, default None</span></dt><dd><p>Maximum threshold value. All values above this
threshold will be set to it.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or str axis name, optional  (Not supported in Dask)</span></dt><dd><p>Align object with lower and upper along the given axis.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Whether to perform the operation in place on the data.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.21.0.</span></p>
</div>
</dd>
<dt><strong>*args, **kwargs</strong></dt><dd><p>Additional keywords have no effect but might be accepted
for compatibility with numpy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Same type as calling object with the values outside the
clip boundaries replaced.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;col_0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="s1">&#39;col_1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]}</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   col_0  col_1</span>
<span class="go">0      9     -2</span>
<span class="go">1     -3     -7</span>
<span class="go">2      0      6</span>
<span class="go">3     -1      8</span>
<span class="go">4      5     -5</span>
</pre></div>
</div>
<p>Clips per column using lower and upper thresholds:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>  
<span class="go">   col_0  col_1</span>
<span class="go">0      6     -2</span>
<span class="go">1     -3     -4</span>
<span class="go">2      0      6</span>
<span class="go">3     -1      6</span>
<span class="go">4      5     -4</span>
</pre></div>
</div>
<p>Clips using specific lower and upper thresholds per column element:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span>  
<span class="go">0    2</span>
<span class="go">1   -4</span>
<span class="go">2   -1</span>
<span class="go">3    6</span>
<span class="go">4    3</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">   col_0  col_1</span>
<span class="go">0      6      2</span>
<span class="go">1     -3     -4</span>
<span class="go">2      0      3</span>
<span class="go">3      6      8</span>
<span class="go">4      5      3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.combine">
<code class="sig-name descname">combine</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">func</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">overwrite=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform column-wise combine with another DataFrame.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.combine.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Combines a DataFrame with <cite>other</cite> DataFrame using <cite>func</cite>
to element-wise combine columns. The row and column indexes of the
resulting DataFrame will be the union of the two.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">DataFrame</span></dt><dd><p>The DataFrame to merge column-wise.</p>
</dd>
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function that takes two series as inputs and return a Series or a
scalar. Used to merge the two dataframes column by columns.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">scalar value, default None</span></dt><dd><p>The value to fill NaNs with prior to passing any column to the
merge func.</p>
</dd>
<dt><strong>overwrite</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, columns in <cite>self</cite> that do not exist in <cite>other</cite> will be
overwritten with NaNs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Combination of the provided DataFrames.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.combine_first" title="dask.dataframe.DataFrame.combine_first"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.combine_first</span></code></a></dt><dd><p>Combine two DataFrame objects and default to non-null values in frame calling the method.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Combine using a simple function that chooses the smaller column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">take_smaller</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">s1</span> <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="k">else</span> <span class="n">s2</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">take_smaller</span><span class="p">)</span>  
<span class="go">   A  B</span>
<span class="go">0  0  3</span>
<span class="go">1  0  3</span>
</pre></div>
</div>
<p>Example using a true element-wise combine function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">)</span>  
<span class="go">   A  B</span>
<span class="go">0  1  2</span>
<span class="go">1  0  3</span>
</pre></div>
</div>
<p>Using <cite>fill_value</cite> fills Nones prior to passing the column to the
merge function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">take_smaller</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">5</span><span class="p">)</span>  
<span class="go">   A    B</span>
<span class="go">0  0 -5.0</span>
<span class="go">1  0  4.0</span>
</pre></div>
</div>
<p>However, if the same element in both dataframes is None, that None
is preserved</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">take_smaller</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">5</span><span class="p">)</span>  
<span class="go">    A    B</span>
<span class="go">0  0 -5.0</span>
<span class="go">1  0  3.0</span>
</pre></div>
</div>
<p>Example that demonstrates the use of <cite>overwrite</cite> and behavior when
the axis differ between the dataframes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">},</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">take_smaller</span><span class="p">)</span>  
<span class="go">     A    B     C</span>
<span class="go">0  NaN  NaN   NaN</span>
<span class="go">1  NaN  3.0 -10.0</span>
<span class="go">2  NaN  3.0   1.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">take_smaller</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">     A    B     C</span>
<span class="go">0  0.0  NaN   NaN</span>
<span class="go">1  0.0  3.0 -10.0</span>
<span class="go">2  NaN  3.0   1.0</span>
</pre></div>
</div>
<p>Demonstrating the preference of the passed in dataframe.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">},</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">df1</span><span class="p">,</span> <span class="n">take_smaller</span><span class="p">)</span>  
<span class="go">   A    B   C</span>
<span class="go">0  0.0  NaN NaN</span>
<span class="go">1  0.0  3.0 NaN</span>
<span class="go">2  NaN  3.0 NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">df1</span><span class="p">,</span> <span class="n">take_smaller</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">     A    B   C</span>
<span class="go">0  0.0  NaN NaN</span>
<span class="go">1  0.0  3.0 1.0</span>
<span class="go">2  NaN  3.0 1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.combine_first">
<code class="sig-name descname">combine_first</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.combine_first" title="Permalink to this definition">¶</a></dt>
<dd><p>Update null elements with value in the same location in <cite>other</cite>.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.combine_first.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Combine two DataFrame objects by filling null values in one DataFrame
with non-null values from other DataFrame. The row and column indexes
of the resulting DataFrame will be the union of the two.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">DataFrame</span></dt><dd><p>Provided DataFrame to use to fill null values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.combine" title="dask.dataframe.DataFrame.combine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.combine</span></code></a></dt><dd><p>Perform series-wise operation on two DataFrames using a given function.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span><span class="o">.</span><span class="n">combine_first</span><span class="p">(</span><span class="n">df2</span><span class="p">)</span>  
<span class="go">     A    B</span>
<span class="go">0  1.0  3.0</span>
<span class="go">1  0.0  4.0</span>
</pre></div>
</div>
<p>Null values still persist if the location of that null value
does not exist in <cite>other</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="kc">None</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]},</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span><span class="o">.</span><span class="n">combine_first</span><span class="p">(</span><span class="n">df2</span><span class="p">)</span>  
<span class="go">     A    B    C</span>
<span class="go">0  NaN  4.0  NaN</span>
<span class="go">1  0.0  3.0  1.0</span>
<span class="go">2  NaN  3.0  1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.compute">
<code class="sig-name descname">compute</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute this dask collection</p>
<p>This turns a lazy Dask collection into its in-memory equivalent.
For example a Dask.array turns into a  <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html#numpy.array" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.array()</span></code></a> and a Dask.dataframe
turns into a Pandas dataframe.  The entire dataset must fit into memory
before calling this operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scheduler</strong><span class="classifier">string, optional</span></dt><dd><p>Which scheduler to use like “threads”, “synchronous” or “processes”.
If not provided, the default is to check the global settings first,
and then fall back to the collection defaults.</p>
</dd>
<dt><strong>optimize_graph</strong><span class="classifier">bool, optional</span></dt><dd><p>If True [default], the graph is optimized before computation.
Otherwise the graph is run as is. This can be useful for debugging.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Extra keywords to forward to the scheduler function.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.base.compute</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of the dataframe</p>
<p>This is strictly a shallow copy of the underlying computational graph.
It does not affect the underlying data</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.corr">
<code class="sig-name descname">corr</code><span class="sig-paren">(</span><em class="sig-param">method='pearson'</em>, <em class="sig-param">min_periods=None</em>, <em class="sig-param">split_every=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute pairwise correlation of columns, excluding NA/null values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.corr.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>method</strong><span class="classifier">{‘pearson’, ‘kendall’, ‘spearman’} or callable</span></dt><dd><p>Method of correlation:</p>
<ul>
<li><p>pearson : standard correlation coefficient</p></li>
<li><p>kendall : Kendall Tau correlation coefficient</p></li>
<li><p>spearman : Spearman rank correlation</p></li>
<li><dl>
<dt>callable: callable with input two 1d ndarrays</dt><dd><p>and returning a float. Note that the returned matrix from corr
will have 1 along the diagonals and will be symmetric
regardless of the callable’s behavior.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0.</span></p>
</div>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>min_periods</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum number of observations required per pair of columns
to have a valid result. Currently only available for Pearson
and Spearman correlation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Correlation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.corrwith</span></code>, <a class="reference internal" href="#dask.dataframe.Series.corr" title="dask.dataframe.Series.corr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.corr</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">histogram_intersection</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">v</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([(</span><span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="o">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="o">.</span><span class="mi">6</span><span class="p">,</span> <span class="o">.</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">)],</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dogs&#39;</span><span class="p">,</span> <span class="s1">&#39;cats&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">histogram_intersection</span><span class="p">)</span>  
<span class="go">      dogs  cats</span>
<span class="go">dogs   1.0   0.3</span>
<span class="go">cats   0.3   1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">split_every=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count non-NA cells for each column or row.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.count.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The values <cite>None</cite>, <cite>NaN</cite>, <cite>NaT</cite>, and optionally <cite>numpy.inf</cite> (depending
on <cite>pandas.options.mode.use_inf_as_na</cite>) are considered NA.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>If 0 or ‘index’ counts are generated for each column.
If 1 or ‘columns’ counts are generated for each <strong>row</strong>.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or str, optional  (Not supported in Dask)</span></dt><dd><p>If the axis is a <cite>MultiIndex</cite> (hierarchical), count along a
particular <cite>level</cite>, collapsing into a <cite>DataFrame</cite>.
A <cite>str</cite> specifies the level name.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Include only <cite>float</cite>, <cite>int</cite> or <cite>boolean</cite> data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>For each column/row the number of non-NA/null entries.
If <cite>level</cite> is specified returns a <cite>DataFrame</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.count" title="dask.dataframe.Series.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.count</span></code></a></dt><dd><p>Number of non-NA elements in a Series.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.shape" title="dask.dataframe.DataFrame.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.shape</span></code></a></dt><dd><p>Number of DataFrame rows and columns (including NA elements).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.isna" title="dask.dataframe.DataFrame.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.isna</span></code></a></dt><dd><p>Boolean same-sized DataFrame showing places of NA elements.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Constructing DataFrame from a dictionary:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;Person&quot;</span><span class="p">:</span>  
<span class="gp">... </span>                   <span class="p">[</span><span class="s2">&quot;John&quot;</span><span class="p">,</span> <span class="s2">&quot;Myla&quot;</span><span class="p">,</span> <span class="s2">&quot;Lewis&quot;</span><span class="p">,</span> <span class="s2">&quot;John&quot;</span><span class="p">,</span> <span class="s2">&quot;Myla&quot;</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s2">&quot;Age&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">24.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">21.</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">26</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s2">&quot;Single&quot;</span><span class="p">:</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   Person   Age  Single</span>
<span class="go">0    John  24.0   False</span>
<span class="go">1    Myla   NaN    True</span>
<span class="go">2   Lewis  21.0    True</span>
<span class="go">3    John  33.0    True</span>
<span class="go">4    Myla  26.0   False</span>
</pre></div>
</div>
<p>Notice the uncounted NA values:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>  
<span class="go">Person    5</span>
<span class="go">Age       4</span>
<span class="go">Single    5</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Counts for each <strong>row</strong>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">0    3</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">3    3</span>
<span class="go">4    3</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Counts for one level of a <cite>MultiIndex</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;Person&quot;</span><span class="p">,</span> <span class="s2">&quot;Single&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s2">&quot;Person&quot;</span><span class="p">)</span>  
<span class="go">        Age</span>
<span class="go">Person</span>
<span class="go">John      2</span>
<span class="go">Lewis     1</span>
<span class="go">Myla      1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.cov">
<code class="sig-name descname">cov</code><span class="sig-paren">(</span><em class="sig-param">min_periods=None</em>, <em class="sig-param">split_every=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute pairwise covariance of columns, excluding NA/null values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.cov.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute the pairwise covariance among the series of a DataFrame.
The returned data frame is the <a class="reference external" href="https://en.wikipedia.org/wiki/Covariance_matrix">covariance matrix</a> of the columns
of the DataFrame.</p>
<p>Both NA and null values are automatically excluded from the
calculation. (See the note below about bias from missing values.)
A threshold can be set for the minimum number of
observations for each value created. Comparisons with observations
below this threshold will be returned as <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
<p>This method is generally used for the analysis of time series data to
understand the relationship between different measures
across time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_periods</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum number of observations required per pair of columns
to have a valid result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>The covariance matrix of the series of the DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.cov" title="dask.dataframe.Series.cov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.cov</span></code></a></dt><dd><p>Compute covariance with another Series.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.EWM.cov</span></code></dt><dd><p>Exponential weighted sample covariance.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Expanding.cov</span></code></dt><dd><p>Expanding sample covariance.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Rolling.cov</span></code></dt><dd><p>Rolling sample covariance.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Returns the covariance matrix of the DataFrame’s time series.
The covariance is normalized by N-1.</p>
<p>For DataFrames that have Series that are missing data (assuming that
data is <a class="reference external" href="https://en.wikipedia.org/wiki/Missing_data#Missing_at_random">missing at random</a>)
the returned covariance matrix will be an unbiased estimate
of the variance and covariance between the member Series.</p>
<p>However, for many applications this estimate may not be acceptable
because the estimate covariance matrix is not guaranteed to be positive
semi-definite. This could lead to estimate correlations having
absolute values which are greater than one, and/or a non-invertible
covariance matrix. See <a class="reference external" href="http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices">Estimation of covariance matrices</a> for more details.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dogs&#39;</span><span class="p">,</span> <span class="s1">&#39;cats&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span>  
<span class="go">          dogs      cats</span>
<span class="go">dogs  0.666667 -1.000000</span>
<span class="go">cats -1.000000  1.666667</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span>  
<span class="go">          a         b         c         d         e</span>
<span class="go">a  0.998438 -0.020161  0.059277 -0.008943  0.014144</span>
<span class="go">b -0.020161  1.059352 -0.008543 -0.024738  0.009826</span>
<span class="go">c  0.059277 -0.008543  1.010670 -0.001486 -0.000271</span>
<span class="go">d -0.008943 -0.024738 -0.001486  0.921297 -0.013692</span>
<span class="go">e  0.014144  0.009826 -0.000271 -0.013692  0.977795</span>
</pre></div>
</div>
<p><strong>Minimum number of periods</strong></p>
<p>This method also supports an optional <code class="docutils literal notranslate"><span class="pre">min_periods</span></code> keyword
that specifies the required minimum number of non-NA observations for
each column pair in order to have a valid result:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="mi">5</span><span class="p">],</span> <span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">min_periods</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>  
<span class="go">          a         b         c</span>
<span class="go">a  0.316741       NaN -0.150812</span>
<span class="go">b       NaN  1.248003  0.191417</span>
<span class="go">c -0.150812  0.191417  0.895202</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.cummax">
<code class="sig-name descname">cummax</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.cummax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative maximum over a DataFrame or Series axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.cummax.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns a DataFrame or Series of the same size containing the cumulative
maximum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The index or the name of the axis. 0 is equivalent to None or ‘index’.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>*args, **kwargs :</strong></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with NumPy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Expanding.max</span></code></dt><dd><p>Similar functionality but ignores <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.max" title="dask.dataframe.DataFrame.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.max</span></code></a></dt><dd><p>Return the maximum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummax" title="dask.dataframe.DataFrame.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummax</span></code></a></dt><dd><p>Return cumulative maximum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummin" title="dask.dataframe.DataFrame.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummin</span></code></a></dt><dd><p>Return cumulative minimum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumsum" title="dask.dataframe.DataFrame.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumsum</span></code></a></dt><dd><p>Return cumulative sum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumprod" title="dask.dataframe.DataFrame.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumprod</span></code></a></dt><dd><p>Return cumulative product over DataFrame axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p><strong>Series</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    5.0</span>
<span class="go">3   -1.0</span>
<span class="go">4    0.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>By default, NA values are ignored.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cummax</span><span class="p">()</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    5.0</span>
<span class="go">3    5.0</span>
<span class="go">4    5.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>To include NA values in the operation, use <code class="docutils literal notranslate"><span class="pre">skipna=False</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cummax</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    NaN</span>
<span class="go">3    NaN</span>
<span class="go">4    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p><strong>DataFrame</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]],</span>
<span class="gp">... </span>                   <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
<p>By default, iterates over rows and finds the maximum
in each column. This is equivalent to <code class="docutils literal notranslate"><span class="pre">axis=None</span></code> or <code class="docutils literal notranslate"><span class="pre">axis='index'</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cummax</span><span class="p">()</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  3.0  1.0</span>
</pre></div>
</div>
<p>To iterate over columns and find the maximum in each row,
use <code class="docutils literal notranslate"><span class="pre">axis=1</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cummax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  2.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.cummin">
<code class="sig-name descname">cummin</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.cummin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative minimum over a DataFrame or Series axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.cummin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns a DataFrame or Series of the same size containing the cumulative
minimum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The index or the name of the axis. 0 is equivalent to None or ‘index’.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>*args, **kwargs :</strong></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with NumPy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Expanding.min</span></code></dt><dd><p>Similar functionality but ignores <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.min" title="dask.dataframe.DataFrame.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.min</span></code></a></dt><dd><p>Return the minimum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummax" title="dask.dataframe.DataFrame.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummax</span></code></a></dt><dd><p>Return cumulative maximum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummin" title="dask.dataframe.DataFrame.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummin</span></code></a></dt><dd><p>Return cumulative minimum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumsum" title="dask.dataframe.DataFrame.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumsum</span></code></a></dt><dd><p>Return cumulative sum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumprod" title="dask.dataframe.DataFrame.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumprod</span></code></a></dt><dd><p>Return cumulative product over DataFrame axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p><strong>Series</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    5.0</span>
<span class="go">3   -1.0</span>
<span class="go">4    0.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>By default, NA values are ignored.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cummin</span><span class="p">()</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    2.0</span>
<span class="go">3   -1.0</span>
<span class="go">4   -1.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>To include NA values in the operation, use <code class="docutils literal notranslate"><span class="pre">skipna=False</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cummin</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    NaN</span>
<span class="go">3    NaN</span>
<span class="go">4    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p><strong>DataFrame</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]],</span>
<span class="gp">... </span>                   <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
<p>By default, iterates over rows and finds the minimum
in each column. This is equivalent to <code class="docutils literal notranslate"><span class="pre">axis=None</span></code> or <code class="docutils literal notranslate"><span class="pre">axis='index'</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cummin</span><span class="p">()</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  2.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
<p>To iterate over columns and find the minimum in each row,
use <code class="docutils literal notranslate"><span class="pre">axis=1</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cummin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.cumprod">
<code class="sig-name descname">cumprod</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative product over a DataFrame or Series axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.cumprod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns a DataFrame or Series of the same size containing the cumulative
product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The index or the name of the axis. 0 is equivalent to None or ‘index’.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>*args, **kwargs :</strong></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with NumPy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Expanding.prod</span></code></dt><dd><p>Similar functionality but ignores <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.prod" title="dask.dataframe.DataFrame.prod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.prod</span></code></a></dt><dd><p>Return the product over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummax" title="dask.dataframe.DataFrame.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummax</span></code></a></dt><dd><p>Return cumulative maximum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummin" title="dask.dataframe.DataFrame.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummin</span></code></a></dt><dd><p>Return cumulative minimum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumsum" title="dask.dataframe.DataFrame.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumsum</span></code></a></dt><dd><p>Return cumulative sum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumprod" title="dask.dataframe.DataFrame.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumprod</span></code></a></dt><dd><p>Return cumulative product over DataFrame axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p><strong>Series</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    5.0</span>
<span class="go">3   -1.0</span>
<span class="go">4    0.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>By default, NA values are ignored.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cumprod</span><span class="p">()</span>  
<span class="go">0     2.0</span>
<span class="go">1     NaN</span>
<span class="go">2    10.0</span>
<span class="go">3   -10.0</span>
<span class="go">4    -0.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>To include NA values in the operation, use <code class="docutils literal notranslate"><span class="pre">skipna=False</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    NaN</span>
<span class="go">3    NaN</span>
<span class="go">4    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p><strong>DataFrame</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]],</span>
<span class="gp">... </span>                   <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
<p>By default, iterates over rows and finds the product
in each column. This is equivalent to <code class="docutils literal notranslate"><span class="pre">axis=None</span></code> or <code class="docutils literal notranslate"><span class="pre">axis='index'</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cumprod</span><span class="p">()</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  6.0  NaN</span>
<span class="go">2  6.0  0.0</span>
</pre></div>
</div>
<p>To iterate over columns and find the product in each row,
use <code class="docutils literal notranslate"><span class="pre">axis=1</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  2.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.cumsum">
<code class="sig-name descname">cumsum</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative sum over a DataFrame or Series axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.cumsum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns a DataFrame or Series of the same size containing the cumulative
sum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The index or the name of the axis. 0 is equivalent to None or ‘index’.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>*args, **kwargs :</strong></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with NumPy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Expanding.sum</span></code></dt><dd><p>Similar functionality but ignores <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sum" title="dask.dataframe.DataFrame.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sum</span></code></a></dt><dd><p>Return the sum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummax" title="dask.dataframe.DataFrame.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummax</span></code></a></dt><dd><p>Return cumulative maximum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummin" title="dask.dataframe.DataFrame.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummin</span></code></a></dt><dd><p>Return cumulative minimum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumsum" title="dask.dataframe.DataFrame.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumsum</span></code></a></dt><dd><p>Return cumulative sum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumprod" title="dask.dataframe.DataFrame.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumprod</span></code></a></dt><dd><p>Return cumulative product over DataFrame axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p><strong>Series</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    5.0</span>
<span class="go">3   -1.0</span>
<span class="go">4    0.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>By default, NA values are ignored.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    7.0</span>
<span class="go">3    6.0</span>
<span class="go">4    6.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>To include NA values in the operation, use <code class="docutils literal notranslate"><span class="pre">skipna=False</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    NaN</span>
<span class="go">3    NaN</span>
<span class="go">4    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p><strong>DataFrame</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]],</span>
<span class="gp">... </span>                   <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
<p>By default, iterates over rows and finds the sum
in each column. This is equivalent to <code class="docutils literal notranslate"><span class="pre">axis=None</span></code> or <code class="docutils literal notranslate"><span class="pre">axis='index'</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  5.0  NaN</span>
<span class="go">2  6.0  1.0</span>
</pre></div>
</div>
<p>To iterate over columns and find the sum in each row,
use <code class="docutils literal notranslate"><span class="pre">axis=1</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  3.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.describe">
<code class="sig-name descname">describe</code><span class="sig-paren">(</span><em class="sig-param">split_every=False</em>, <em class="sig-param">percentiles=None</em>, <em class="sig-param">percentiles_method='default'</em>, <em class="sig-param">include=None</em>, <em class="sig-param">exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate descriptive statistics.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.describe.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Descriptive statistics include those that summarize the central
tendency, dispersion and shape of a
dataset’s distribution, excluding <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values.</p>
<p>Analyzes both numeric and object series, as well
as <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> column sets of mixed data types. The output
will vary depending on what is provided. Refer to the notes
below for more detail.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>percentiles</strong><span class="classifier">list-like of numbers, optional</span></dt><dd><p>The percentiles to include in the output. All should
fall between 0 and 1. The default is
<code class="docutils literal notranslate"><span class="pre">[.25,</span> <span class="pre">.5,</span> <span class="pre">.75]</span></code>, which returns the 25th, 50th, and
75th percentiles.</p>
</dd>
<dt><strong>include</strong><span class="classifier">‘all’, list-like of dtypes or None (default), optional</span></dt><dd><p>A white list of data types to include in the result. Ignored
for <code class="docutils literal notranslate"><span class="pre">Series</span></code>. Here are the options:</p>
<ul class="simple">
<li><p>‘all’ : All columns of the input will be included in the output.</p></li>
<li><p>A list-like of dtypes : Limits the results to the
provided data types.
To limit the result to numeric types submit
<code class="docutils literal notranslate"><span class="pre">numpy.number</span></code>. To limit it instead to object columns submit
the <code class="docutils literal notranslate"><span class="pre">numpy.object</span></code> data type. Strings
can also be used in the style of
<code class="docutils literal notranslate"><span class="pre">select_dtypes</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">df.describe(include=['O'])</span></code>). To
select pandas categorical columns, use <code class="docutils literal notranslate"><span class="pre">'category'</span></code></p></li>
<li><p>None (default) : The result will include all numeric columns.</p></li>
</ul>
</dd>
<dt><strong>exclude</strong><span class="classifier">list-like of dtypes or None (default), optional,</span></dt><dd><p>A black list of data types to omit from the result. Ignored
for <code class="docutils literal notranslate"><span class="pre">Series</span></code>. Here are the options:</p>
<ul class="simple">
<li><p>A list-like of dtypes : Excludes the provided data types
from the result. To exclude numeric types submit
<code class="docutils literal notranslate"><span class="pre">numpy.number</span></code>. To exclude object columns submit the data
type <code class="docutils literal notranslate"><span class="pre">numpy.object</span></code>. Strings can also be used in the style of
<code class="docutils literal notranslate"><span class="pre">select_dtypes</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">df.describe(include=['O'])</span></code>). To
exclude pandas categorical columns, use <code class="docutils literal notranslate"><span class="pre">'category'</span></code></p></li>
<li><p>None (default) : The result will exclude nothing.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Summary statistics of the Series or Dataframe provided.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.count" title="dask.dataframe.DataFrame.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.count</span></code></a></dt><dd><p>Count number of non-NA/null observations.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.max" title="dask.dataframe.DataFrame.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.max</span></code></a></dt><dd><p>Maximum of the values in the object.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.min" title="dask.dataframe.DataFrame.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.min</span></code></a></dt><dd><p>Minimum of the values in the object.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mean" title="dask.dataframe.DataFrame.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mean</span></code></a></dt><dd><p>Mean of the values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.std" title="dask.dataframe.DataFrame.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.std</span></code></a></dt><dd><p>Standard deviation of the observations.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.select_dtypes" title="dask.dataframe.DataFrame.select_dtypes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.select_dtypes</span></code></a></dt><dd><p>Subset of a DataFrame including/excluding columns based on their dtype.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For numeric data, the result’s index will include <code class="docutils literal notranslate"><span class="pre">count</span></code>,
<code class="docutils literal notranslate"><span class="pre">mean</span></code>, <code class="docutils literal notranslate"><span class="pre">std</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code> as well as lower, <code class="docutils literal notranslate"><span class="pre">50</span></code> and
upper percentiles. By default the lower percentile is <code class="docutils literal notranslate"><span class="pre">25</span></code> and the
upper percentile is <code class="docutils literal notranslate"><span class="pre">75</span></code>. The <code class="docutils literal notranslate"><span class="pre">50</span></code> percentile is the
same as the median.</p>
<p>For object data (e.g. strings or timestamps), the result’s index
will include <code class="docutils literal notranslate"><span class="pre">count</span></code>, <code class="docutils literal notranslate"><span class="pre">unique</span></code>, <code class="docutils literal notranslate"><span class="pre">top</span></code>, and <code class="docutils literal notranslate"><span class="pre">freq</span></code>. The <code class="docutils literal notranslate"><span class="pre">top</span></code>
is the most common value. The <code class="docutils literal notranslate"><span class="pre">freq</span></code> is the most common value’s
frequency. Timestamps also include the <code class="docutils literal notranslate"><span class="pre">first</span></code> and <code class="docutils literal notranslate"><span class="pre">last</span></code> items.</p>
<p>If multiple object values have the highest count, then the
<code class="docutils literal notranslate"><span class="pre">count</span></code> and <code class="docutils literal notranslate"><span class="pre">top</span></code> results will be arbitrarily chosen from
among those with the highest count.</p>
<p>For mixed data types provided via a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, the default is to
return only an analysis of numeric columns. If the dataframe consists
only of object and categorical data without any numeric columns, the
default is to return an analysis of both the object and categorical
columns. If <code class="docutils literal notranslate"><span class="pre">include='all'</span></code> is provided as an option, the result
will include a union of attributes of each type.</p>
<p>The <cite>include</cite> and <cite>exclude</cite> parameters can be used to limit
which columns in a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> are analyzed for the output.
The parameters are ignored when analyzing a <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p>
<p class="rubric">Examples</p>
<p>Describing a numeric <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>  
<span class="go">count    3.0</span>
<span class="go">mean     2.0</span>
<span class="go">std      1.0</span>
<span class="go">min      1.0</span>
<span class="go">25%      1.5</span>
<span class="go">50%      2.0</span>
<span class="go">75%      2.5</span>
<span class="go">max      3.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Describing a categorical <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>  
<span class="go">count     4</span>
<span class="go">unique    3</span>
<span class="go">top       a</span>
<span class="go">freq      2</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Describing a timestamp <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span>  
<span class="gp">... </span>  <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;2000-01-01&quot;</span><span class="p">),</span>
<span class="gp">... </span>  <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;2010-01-01&quot;</span><span class="p">),</span>
<span class="gp">... </span>  <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;2010-01-01&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>  
<span class="go">count                       3</span>
<span class="go">unique                      2</span>
<span class="go">top       2010-01-01 00:00:00</span>
<span class="go">freq                        2</span>
<span class="go">first     2000-01-01 00:00:00</span>
<span class="go">last      2010-01-01 00:00:00</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Describing a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. By default only numeric fields
are returned.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;categorical&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">([</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>                   <span class="s1">&#39;numeric&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;object&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>
<span class="gp">... </span>                  <span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>  
<span class="go">       numeric</span>
<span class="go">count      3.0</span>
<span class="go">mean       2.0</span>
<span class="go">std        1.0</span>
<span class="go">min        1.0</span>
<span class="go">25%        1.5</span>
<span class="go">50%        2.0</span>
<span class="go">75%        2.5</span>
<span class="go">max        3.0</span>
</pre></div>
</div>
<p>Describing all columns of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> regardless of data type.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>  
<span class="go">        categorical  numeric object</span>
<span class="go">count            3      3.0      3</span>
<span class="go">unique           3      NaN      3</span>
<span class="go">top              f      NaN      c</span>
<span class="go">freq             1      NaN      1</span>
<span class="go">mean           NaN      2.0    NaN</span>
<span class="go">std            NaN      1.0    NaN</span>
<span class="go">min            NaN      1.0    NaN</span>
<span class="go">25%            NaN      1.5    NaN</span>
<span class="go">50%            NaN      2.0    NaN</span>
<span class="go">75%            NaN      2.5    NaN</span>
<span class="go">max            NaN      3.0    NaN</span>
</pre></div>
</div>
<p>Describing a column from a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> by accessing it as
an attribute.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">numeric</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>  
<span class="go">count    3.0</span>
<span class="go">mean     2.0</span>
<span class="go">std      1.0</span>
<span class="go">min      1.0</span>
<span class="go">25%      1.5</span>
<span class="go">50%      2.0</span>
<span class="go">75%      2.5</span>
<span class="go">max      3.0</span>
<span class="go">Name: numeric, dtype: float64</span>
</pre></div>
</div>
<p>Including only numeric columns in a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> description.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>  
<span class="go">       numeric</span>
<span class="go">count      3.0</span>
<span class="go">mean       2.0</span>
<span class="go">std        1.0</span>
<span class="go">min        1.0</span>
<span class="go">25%        1.5</span>
<span class="go">50%        2.0</span>
<span class="go">75%        2.5</span>
<span class="go">max        3.0</span>
</pre></div>
</div>
<p>Including only string columns in a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> description.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">])</span>  
<span class="go">       object</span>
<span class="go">count       3</span>
<span class="go">unique      3</span>
<span class="go">top         c</span>
<span class="go">freq        1</span>
</pre></div>
</div>
<p>Including only categorical columns from a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> description.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;category&#39;</span><span class="p">])</span>  
<span class="go">       categorical</span>
<span class="go">count            3</span>
<span class="go">unique           3</span>
<span class="go">top              f</span>
<span class="go">freq             1</span>
</pre></div>
</div>
<p>Excluding numeric columns from a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> description.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>  
<span class="go">       categorical object</span>
<span class="go">count            3      3</span>
<span class="go">unique           3      3</span>
<span class="go">top              f      c</span>
<span class="go">freq             1      1</span>
</pre></div>
</div>
<p>Excluding object columns from a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> description.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">])</span>  
<span class="go">       categorical  numeric</span>
<span class="go">count            3      3.0</span>
<span class="go">unique           3      NaN</span>
<span class="go">top              f      NaN</span>
<span class="go">freq             1      NaN</span>
<span class="go">mean           NaN      2.0</span>
<span class="go">std            NaN      1.0</span>
<span class="go">min            NaN      1.0</span>
<span class="go">25%            NaN      1.5</span>
<span class="go">50%            NaN      2.0</span>
<span class="go">75%            NaN      2.5</span>
<span class="go">max            NaN      3.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.diff">
<code class="sig-name descname">diff</code><span class="sig-paren">(</span><em class="sig-param">periods=1</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>First discrete difference of element.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.diff.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Pandas currently uses an <code class="docutils literal notranslate"><span class="pre">object</span></code>-dtype column to represent
boolean data with missing values. This can cause issues for
boolean-specific operations, like <code class="docutils literal notranslate"><span class="pre">|</span></code>. To enable boolean-
specific operations, at the cost of metadata that doesn’t match
pandas, use <code class="docutils literal notranslate"><span class="pre">.astype(bool)</span></code> after the <code class="docutils literal notranslate"><span class="pre">shift</span></code>.</p>
</div>
<p>Calculates the difference of a DataFrame element compared with another
element in the DataFrame (default is the element in the same column
of the previous row).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>periods</strong><span class="classifier">int, default 1</span></dt><dd><p>Periods to shift for calculating difference, accepts negative
values.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>Take difference over rows (0) or columns (1).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.diff" title="dask.dataframe.Series.diff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.diff</span></code></a></dt><dd><p>First discrete difference for a Series.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pct_change</span></code></dt><dd><p>Percent change over given number of periods.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.shift" title="dask.dataframe.DataFrame.shift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.shift</span></code></a></dt><dd><p>Shift index by desired number of periods with an optional time freq.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For boolean dtypes, this uses <code class="xref py py-meth docutils literal notranslate"><span class="pre">operator.xor()</span></code> rather than
<code class="xref py py-meth docutils literal notranslate"><span class="pre">operator.sub()</span></code>.</p>
<p class="rubric">Examples</p>
<p>Difference with previous row</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   a  b   c</span>
<span class="go">0  1  1   1</span>
<span class="go">1  2  1   4</span>
<span class="go">2  3  2   9</span>
<span class="go">3  4  3  16</span>
<span class="go">4  5  5  25</span>
<span class="go">5  6  8  36</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>  
<span class="go">     a    b     c</span>
<span class="go">0  NaN  NaN   NaN</span>
<span class="go">1  1.0  0.0   3.0</span>
<span class="go">2  1.0  1.0   5.0</span>
<span class="go">3  1.0  1.0   7.0</span>
<span class="go">4  1.0  2.0   9.0</span>
<span class="go">5  1.0  3.0  11.0</span>
</pre></div>
</div>
<p>Difference with previous column</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">    a    b     c</span>
<span class="go">0 NaN  0.0   0.0</span>
<span class="go">1 NaN -1.0   3.0</span>
<span class="go">2 NaN -1.0   7.0</span>
<span class="go">3 NaN -1.0  13.0</span>
<span class="go">4 NaN  0.0  20.0</span>
<span class="go">5 NaN  2.0  28.0</span>
</pre></div>
</div>
<p>Difference with 3rd previous row</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  
<span class="go">     a    b     c</span>
<span class="go">0  NaN  NaN   NaN</span>
<span class="go">1  NaN  NaN   NaN</span>
<span class="go">2  NaN  NaN   NaN</span>
<span class="go">3  3.0  2.0  15.0</span>
<span class="go">4  3.0  4.0  21.0</span>
<span class="go">5  3.0  6.0  27.0</span>
</pre></div>
</div>
<p>Difference with following row</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">periods</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">     a    b     c</span>
<span class="go">0 -1.0  0.0  -3.0</span>
<span class="go">1 -1.0 -1.0  -5.0</span>
<span class="go">2 -1.0 -1.0  -7.0</span>
<span class="go">3 -1.0 -2.0  -9.0</span>
<span class="go">4 -1.0 -3.0 -11.0</span>
<span class="go">5  NaN  NaN   NaN</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.div">
<code class="sig-name descname">div</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.div" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Floating division of dataframe and other, element-wise (binary operator <cite>truediv</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.div.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">/</span> <span class="pre">other</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>rtruediv</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.divide">
<code class="sig-name descname">divide</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.divide" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Floating division of dataframe and other, element-wise (binary operator <cite>truediv</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.divide.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">/</span> <span class="pre">other</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>rtruediv</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.drop">
<code class="sig-name descname">drop</code><span class="sig-paren">(</span><em class="sig-param">labels=None</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">errors='raise'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.drop" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop specified labels from rows or columns.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.drop.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Remove rows or columns by specifying label names and corresponding
axis, or by specifying directly index or column names. When using a
multi-index, labels on different levels can be removed by specifying
the level.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>labels</strong><span class="classifier">single label or list-like</span></dt><dd><p>Index or column labels to drop.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>Whether to drop labels from the index (0 or ‘index’) or
columns (1 or ‘columns’).</p>
</dd>
<dt><strong>index</strong><span class="classifier">single label or list-like  (Not supported in Dask)</span></dt><dd><p>Alternative to specifying axis (<code class="docutils literal notranslate"><span class="pre">labels,</span> <span class="pre">axis=0</span></code>
is equivalent to <code class="docutils literal notranslate"><span class="pre">index=labels</span></code>).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.21.0.</span></p>
</div>
</dd>
<dt><strong>columns</strong><span class="classifier">single label or list-like</span></dt><dd><p>Alternative to specifying axis (<code class="docutils literal notranslate"><span class="pre">labels,</span> <span class="pre">axis=1</span></code>
is equivalent to <code class="docutils literal notranslate"><span class="pre">columns=labels</span></code>).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.21.0.</span></p>
</div>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, optional  (Not supported in Dask)</span></dt><dd><p>For MultiIndex, level from which the labels will be removed.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True, do operation inplace and return None.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">{‘ignore’, ‘raise’}, default ‘raise’</span></dt><dd><p>If ‘ignore’, suppress error and only existing labels are
dropped.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>DataFrame without the removed index or column labels.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>KeyError</strong></dt><dd><p>If any of the labels is not found in the selected axis.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.loc" title="dask.dataframe.DataFrame.loc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.loc</span></code></a></dt><dd><p>Label-location based indexer for selection by label.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.dropna" title="dask.dataframe.DataFrame.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.dropna</span></code></a></dt><dd><p>Return DataFrame with labels on given axis omitted where (all or any) data are missing.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.drop_duplicates" title="dask.dataframe.DataFrame.drop_duplicates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.drop_duplicates</span></code></a></dt><dd><p>Return DataFrame with duplicate rows removed, optionally only considering certain columns.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.drop</span></code></dt><dd><p>Return Series with specified index labels removed.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A  B   C   D</span>
<span class="go">0  0  1   2   3</span>
<span class="go">1  4  5   6   7</span>
<span class="go">2  8  9  10  11</span>
</pre></div>
</div>
<p>Drop columns</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">   A   D</span>
<span class="go">0  0   3</span>
<span class="go">1  4   7</span>
<span class="go">2  8  11</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>  
<span class="go">   A   D</span>
<span class="go">0  0   3</span>
<span class="go">1  4   7</span>
<span class="go">2  8  11</span>
</pre></div>
</div>
<p>Drop a row by index</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  
<span class="go">   A  B   C   D</span>
<span class="go">2  8  9  10  11</span>
</pre></div>
</div>
<p>Drop columns and/or rows of MultiIndex DataFrame</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">midx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">(</span><span class="n">levels</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;lama&#39;</span><span class="p">,</span> <span class="s1">&#39;cow&#39;</span><span class="p">,</span> <span class="s1">&#39;falcon&#39;</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="p">[</span><span class="s1">&#39;speed&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="s1">&#39;length&#39;</span><span class="p">]],</span>
<span class="gp">... </span>                     <span class="n">codes</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">midx</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="s1">&#39;small&#39;</span><span class="p">],</span>  
<span class="gp">... </span>                  <span class="n">data</span><span class="o">=</span><span class="p">[[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">150</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">320</span><span class="p">,</span> <span class="mi">250</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">                big     small</span>
<span class="go">lama    speed   45.0    30.0</span>
<span class="go">        weight  200.0   100.0</span>
<span class="go">        length  1.5     1.0</span>
<span class="go">cow     speed   30.0    20.0</span>
<span class="go">        weight  250.0   150.0</span>
<span class="go">        length  1.5     0.8</span>
<span class="go">falcon  speed   320.0   250.0</span>
<span class="go">        weight  1.0     0.8</span>
<span class="go">        length  0.3     0.2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;cow&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;small&#39;</span><span class="p">)</span>  
<span class="go">                big</span>
<span class="go">lama    speed   45.0</span>
<span class="go">        weight  200.0</span>
<span class="go">        length  1.5</span>
<span class="go">falcon  speed   320.0</span>
<span class="go">        weight  1.0</span>
<span class="go">        length  0.3</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">                big     small</span>
<span class="go">lama    speed   45.0    30.0</span>
<span class="go">        weight  200.0   100.0</span>
<span class="go">cow     speed   30.0    20.0</span>
<span class="go">        weight  250.0   150.0</span>
<span class="go">falcon  speed   320.0   250.0</span>
<span class="go">        weight  1.0     0.8</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.drop_duplicates">
<code class="sig-name descname">drop_duplicates</code><span class="sig-paren">(</span><em class="sig-param">subset=None</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.drop_duplicates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return DataFrame with duplicate rows removed.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.drop_duplicates.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Considering certain columns is optional. Indexes, including time indexes
are ignored.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>subset</strong><span class="classifier">column label or sequence of labels, optional</span></dt><dd><p>Only consider certain columns for identifying duplicates, by
default use all of the columns.</p>
</dd>
<dt><strong>keep</strong><span class="classifier">{‘first’, ‘last’, False}, default ‘first’  (Not supported in Dask)</span></dt><dd><p>Determines which duplicates (if any) to keep.
- <code class="docutils literal notranslate"><span class="pre">first</span></code> : Drop duplicates except for the first occurrence.
- <code class="docutils literal notranslate"><span class="pre">last</span></code> : Drop duplicates except for the last occurrence.
- False : Drop all duplicates.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Whether to drop duplicates in place or to return a copy.</p>
</dd>
<dt><strong>ignore_index</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True, the resulting axis will be labeled 0, 1, …, n - 1.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.0.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>DataFrame with duplicates removed or None if <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.dropna">
<code class="sig-name descname">dropna</code><span class="sig-paren">(</span><em class="sig-param">how='any'</em>, <em class="sig-param">subset=None</em>, <em class="sig-param">thresh=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.dropna" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove missing values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.dropna.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>See the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html#missing-data" title="(in pandas v1.0.3)"><span class="xref std std-ref">User Guide</span></a> for more on which values are
considered missing, and how to work with missing data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0  (Not supported in Dask)</span></dt><dd><p>Determine if rows or columns which contain missing values are
removed.</p>
<ul class="simple">
<li><p>0, or ‘index’ : Drop rows which contain missing values.</p></li>
<li><p>1, or ‘columns’ : Drop columns which contain missing value.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.0.0: </span>Pass tuple or list to drop on multiple axes.
Only a single axis is allowed.</p>
</div>
</dd>
<dt><strong>how</strong><span class="classifier">{‘any’, ‘all’}, default ‘any’</span></dt><dd><p>Determine if row or column is removed from DataFrame, when we have
at least one NA or all NA.</p>
<ul class="simple">
<li><p>‘any’ : If any NA values are present, drop that row or column.</p></li>
<li><p>‘all’ : If all values are NA, drop that row or column.</p></li>
</ul>
</dd>
<dt><strong>thresh</strong><span class="classifier">int, optional</span></dt><dd><p>Require that many non-NA values.</p>
</dd>
<dt><strong>subset</strong><span class="classifier">array-like, optional</span></dt><dd><p>Labels along other axis to consider, e.g. if you are dropping rows
these would be a list of columns to include.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True, do operation inplace and return None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>DataFrame with NA entries dropped from it.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.isna" title="dask.dataframe.DataFrame.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.isna</span></code></a></dt><dd><p>Indicate missing values.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.notna</span></code></dt><dd><p>Indicate existing (non-missing) values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.fillna" title="dask.dataframe.DataFrame.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.fillna</span></code></a></dt><dd><p>Replace missing values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.dropna" title="dask.dataframe.Series.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.dropna</span></code></a></dt><dd><p>Drop missing values.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Index.dropna</span></code></dt><dd><p>Drop missing indices.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Alfred&#39;</span><span class="p">,</span> <span class="s1">&#39;Batman&#39;</span><span class="p">,</span> <span class="s1">&#39;Catwoman&#39;</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s2">&quot;toy&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;Batmobile&#39;</span><span class="p">,</span> <span class="s1">&#39;Bullwhip&#39;</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s2">&quot;born&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s2">&quot;1940-04-25&quot;</span><span class="p">),</span>
<span class="gp">... </span>                            <span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">       name        toy       born</span>
<span class="go">0    Alfred        NaN        NaT</span>
<span class="go">1    Batman  Batmobile 1940-04-25</span>
<span class="go">2  Catwoman   Bullwhip        NaT</span>
</pre></div>
</div>
<p>Drop the rows where at least one element is missing.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>  
<span class="go">     name        toy       born</span>
<span class="go">1  Batman  Batmobile 1940-04-25</span>
</pre></div>
</div>
<p>Drop the columns where at least one element is missing.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">       name</span>
<span class="go">0    Alfred</span>
<span class="go">1    Batman</span>
<span class="go">2  Catwoman</span>
</pre></div>
</div>
<p>Drop the rows where all elements are missing.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>  
<span class="go">       name        toy       born</span>
<span class="go">0    Alfred        NaN        NaT</span>
<span class="go">1    Batman  Batmobile 1940-04-25</span>
<span class="go">2  Catwoman   Bullwhip        NaT</span>
</pre></div>
</div>
<p>Keep only the rows with at least 2 non-NA values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">       name        toy       born</span>
<span class="go">1    Batman  Batmobile 1940-04-25</span>
<span class="go">2  Catwoman   Bullwhip        NaT</span>
</pre></div>
</div>
<p>Define in which columns to look for missing values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;born&#39;</span><span class="p">])</span>  
<span class="go">       name        toy       born</span>
<span class="go">1    Batman  Batmobile 1940-04-25</span>
</pre></div>
</div>
<p>Keep the DataFrame with valid entries in the same variable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     name        toy       born</span>
<span class="go">1  Batman  Batmobile 1940-04-25</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.dtypes">
<em class="property">property </em><code class="sig-name descname">dtypes</code><a class="headerlink" href="#dask.dataframe.DataFrame.dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data types</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.eq">
<code class="sig-name descname">eq</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Equal to of dataframe and other, element-wise (binary operator <cite>eq</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.eq.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Among flexible wrappers (<cite>eq</cite>, <cite>ne</cite>, <cite>le</cite>, <cite>lt</cite>, <cite>ge</cite>, <cite>gt</cite>) to comparison
operators.</p>
<p>Equivalent to <cite>==</cite>, <cite>=!</cite>, <cite>&lt;=</cite>, <cite>&lt;</cite>, <cite>&gt;=</cite>, <cite>&gt;</cite> with support to choose axis
(rows or columns) and level for comparison.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default ‘columns’</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’).</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the passed
MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame of bool</strong></dt><dd><p>Result of the comparison.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.eq" title="dask.dataframe.DataFrame.eq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.eq</span></code></a></dt><dd><p>Compare DataFrames for equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.ne" title="dask.dataframe.DataFrame.ne"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.ne</span></code></a></dt><dd><p>Compare DataFrames for inequality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.le" title="dask.dataframe.DataFrame.le"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.le</span></code></a></dt><dd><p>Compare DataFrames for less than inequality or equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.lt" title="dask.dataframe.DataFrame.lt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.lt</span></code></a></dt><dd><p>Compare DataFrames for strictly less than inequality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.ge" title="dask.dataframe.DataFrame.ge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.ge</span></code></a></dt><dd><p>Compare DataFrames for greater than inequality or equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.gt" title="dask.dataframe.DataFrame.gt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.gt</span></code></a></dt><dd><p>Compare DataFrames for strictly greater than inequality elementwise.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.
<cite>NaN</cite> values are considered different (i.e. <cite>NaN</cite> != <cite>NaN</cite>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cost&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">300</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   cost  revenue</span>
<span class="go">A   250      100</span>
<span class="go">B   150      250</span>
<span class="go">C   100      300</span>
</pre></div>
</div>
<p>Comparison with a scalar, using either the operator or method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">==</span> <span class="mi">100</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False     True</span>
<span class="go">B  False    False</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False     True</span>
<span class="go">B  False    False</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<p>When <cite>other</cite> is a <a class="reference internal" href="#dask.dataframe.Series" title="dask.dataframe.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>, the columns of a DataFrame are aligned
with the index of <cite>other</cite> and broadcast:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">!=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cost&quot;</span><span class="p">,</span> <span class="s2">&quot;revenue&quot;</span><span class="p">])</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True     True</span>
<span class="go">B   True    False</span>
<span class="go">C  False     True</span>
</pre></div>
</div>
<p>Use the method to control the broadcast axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>  
<span class="go">   cost  revenue</span>
<span class="go">A  True    False</span>
<span class="go">B  True     True</span>
<span class="go">C  True     True</span>
<span class="go">D  True     True</span>
</pre></div>
</div>
<p>When comparing to an arbitrary sequence, the number of columns must
match the number elements in <cite>other</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">==</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True     True</span>
<span class="go">B  False    False</span>
<span class="go">C  False    False</span>
</pre></div>
</div>
<p>Use the method to control the axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eq</span><span class="p">([</span><span class="mi">250</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True    False</span>
<span class="go">B  False     True</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<p>Compare to a DataFrame of different shape.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">   revenue</span>
<span class="go">A      300</span>
<span class="go">B      250</span>
<span class="go">C      100</span>
<span class="go">D      150</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False    False</span>
<span class="go">B  False    False</span>
<span class="go">C  False     True</span>
<span class="go">D  False    False</span>
</pre></div>
</div>
<p>Compare to a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cost&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">220</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">175</span><span class="p">,</span> <span class="mi">225</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">      cost  revenue</span>
<span class="go">Q1 A   250      100</span>
<span class="go">   B   150      250</span>
<span class="go">   C   100      300</span>
<span class="go">Q2 A   150      200</span>
<span class="go">   B   300      175</span>
<span class="go">   C   220      225</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">       cost  revenue</span>
<span class="go">Q1 A   True     True</span>
<span class="go">   B   True     True</span>
<span class="go">   C   True     True</span>
<span class="go">Q2 A  False     True</span>
<span class="go">   B   True    False</span>
<span class="go">   C   True    False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">expr</em>, <em class="sig-param">inplace=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a string describing operations on DataFrame columns.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.eval.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Operates on columns only, not specific rows or elements.  This allows
<cite>eval</cite> to run arbitrary code, which can make you vulnerable to code
injection if you pass user input to this function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>expr</strong><span class="classifier">str</span></dt><dd><p>The expression string to evaluate.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>If the expression contains an assignment, whether to perform the
operation inplace and mutate the existing DataFrame. Otherwise,
a new DataFrame is returned.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>See the documentation for <a class="reference internal" href="#dask.dataframe.DataFrame.eval" title="dask.dataframe.DataFrame.eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> for complete details
on the keyword arguments accepted by
<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query" title="(in pandas v1.0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ndarray, scalar, or pandas object</strong></dt><dd><p>The result of the evaluation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.query" title="dask.dataframe.DataFrame.query"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.query</span></code></a></dt><dd><p>Evaluates a boolean expression to query the columns of a frame.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.assign" title="dask.dataframe.DataFrame.assign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.assign</span></code></a></dt><dd><p>Can evaluate an expression or function to create new values for a column.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.eval" title="dask.dataframe.DataFrame.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a></dt><dd><p>Evaluate a Python expression as a string using various backends.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For more details see the API documentation for <a class="reference internal" href="#dask.dataframe.DataFrame.eval" title="dask.dataframe.DataFrame.eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>.
For detailed examples see <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html#enhancingperf-eval" title="(in pandas v1.0.3)"><span class="xref std std-ref">enhancing performance with eval</span></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A   B</span>
<span class="go">0  1  10</span>
<span class="go">1  2   8</span>
<span class="go">2  3   6</span>
<span class="go">3  4   4</span>
<span class="go">4  5   2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s1">&#39;A + B&#39;</span><span class="p">)</span>  
<span class="go">0    11</span>
<span class="go">1    10</span>
<span class="go">2     9</span>
<span class="go">3     8</span>
<span class="go">4     7</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Assignment is allowed though by default the original DataFrame is not
modified.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s1">&#39;C = A + B&#39;</span><span class="p">)</span>  
<span class="go">   A   B   C</span>
<span class="go">0  1  10  11</span>
<span class="go">1  2   8  10</span>
<span class="go">2  3   6   9</span>
<span class="go">3  4   4   8</span>
<span class="go">4  5   2   7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A   B</span>
<span class="go">0  1  10</span>
<span class="go">1  2   8</span>
<span class="go">2  3   6</span>
<span class="go">3  4   4</span>
<span class="go">4  5   2</span>
</pre></div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code> to modify the original DataFrame.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s1">&#39;C = A + B&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A   B   C</span>
<span class="go">0  1  10  11</span>
<span class="go">1  2   8  10</span>
<span class="go">2  3   6   9</span>
<span class="go">3  4   4   8</span>
<span class="go">4  5   2   7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.explode">
<code class="sig-name descname">explode</code><span class="sig-paren">(</span><em class="sig-param">column</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.explode" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform each element of a list-like to a row, replicating index values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.explode.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.25.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>column</strong><span class="classifier">str or tuple</span></dt><dd><p>Column to explode.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Exploded lists to rows of the subset columns;
index will be duplicated for these rows.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError :</strong></dt><dd><p>if columns of the frame are not unique.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.unstack</span></code></dt><dd><p>Pivot a level of the (necessarily hierarchical) index labels.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.melt" title="dask.dataframe.DataFrame.melt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.melt</span></code></a></dt><dd><p>Unpivot a DataFrame from wide format to long format.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.explode" title="dask.dataframe.Series.explode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.explode</span></code></a></dt><dd><p>Explode a DataFrame from list-like columns to long format.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This routine will explode list-likes including lists, tuples,
Series, and np.ndarray. The result dtype of the subset rows will
be object. Scalars will be returned unchanged. Empty list-likes will
result in a np.nan for that row.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           A  B</span>
<span class="go">0  [1, 2, 3]  1</span>
<span class="go">1        foo  1</span>
<span class="go">2         []  1</span>
<span class="go">3     [3, 4]  1</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>  
<span class="go">     A  B</span>
<span class="go">0    1  1</span>
<span class="go">0    2  1</span>
<span class="go">0    3  1</span>
<span class="go">1  foo  1</span>
<span class="go">2  NaN  1</span>
<span class="go">3    3  1</span>
<span class="go">3    4  1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.ffill">
<code class="sig-name descname">ffill</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.ffill" title="Permalink to this definition">¶</a></dt>
<dd><p>Synonym for <a class="reference internal" href="#dask.dataframe.DataFrame.fillna" title="dask.dataframe.DataFrame.fillna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.fillna()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">method='ffill'</span></code>.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.ffill.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>%(klass)s or None</strong></dt><dd><p>Object with missing values filled or None if <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.fillna">
<code class="sig-name descname">fillna</code><span class="sig-paren">(</span><em class="sig-param">value=None</em>, <em class="sig-param">method=None</em>, <em class="sig-param">limit=None</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.fillna" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill NA/NaN values using the specified method.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.fillna.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">scalar, dict, Series, or DataFrame</span></dt><dd><p>Value to use to fill holes (e.g. 0), alternately a
dict/Series/DataFrame of values specifying which value to use for
each index (for a Series) or column (for a DataFrame).  Values not
in the dict/Series/DataFrame will not be filled. This value cannot
be a list.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘backfill’, ‘bfill’, ‘pad’, ‘ffill’, None}, default None</span></dt><dd><p>Method to use for filling holes in reindexed Series
pad / ffill: propagate last valid observation forward to next valid
backfill / bfill: use next valid observation to fill gap.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Axis along which to fill missing values.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True, fill in-place. Note: this will modify any
other views on this object (e.g., a no-copy slice for a column in a
DataFrame).</p>
</dd>
<dt><strong>limit</strong><span class="classifier">int, default None</span></dt><dd><p>If method is specified, this is the maximum number of consecutive
NaN values to forward/backward fill. In other words, if there is
a gap with more than this number of consecutive NaNs, it will only
be partially filled. If method is not specified, this is the
maximum number of entries along the entire axis where NaNs will be
filled. Must be greater than 0 if not None.</p>
</dd>
<dt><strong>downcast</strong><span class="classifier">dict, default is None  (Not supported in Dask)</span></dt><dd><p>A dict of item-&gt;dtype of what to downcast if possible,
or the string ‘infer’ which will try to downcast to an appropriate
equal type (e.g. float64 to int64 if possible).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame or None</strong></dt><dd><p>Object with missing values filled or None if <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate</span></code></dt><dd><p>Fill NaN values using interpolation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex</span></code></dt><dd><p>Conform object to new index.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">asfreq</span></code></dt><dd><p>Convert TimeSeries to specified frequency.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;ABCD&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     A    B   C  D</span>
<span class="go">0  NaN  2.0 NaN  0</span>
<span class="go">1  3.0  4.0 NaN  1</span>
<span class="go">2  NaN  NaN NaN  5</span>
<span class="go">3  NaN  3.0 NaN  4</span>
</pre></div>
</div>
<p>Replace all NaN elements with 0s.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">    A   B   C   D</span>
<span class="go">0   0.0 2.0 0.0 0</span>
<span class="go">1   3.0 4.0 0.0 1</span>
<span class="go">2   0.0 0.0 0.0 5</span>
<span class="go">3   0.0 3.0 0.0 4</span>
</pre></div>
</div>
<p>We can also propagate non-null values forward or backward.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">)</span>  
<span class="go">    A   B   C   D</span>
<span class="go">0   NaN 2.0 NaN 0</span>
<span class="go">1   3.0 4.0 NaN 1</span>
<span class="go">2   3.0 4.0 NaN 5</span>
<span class="go">3   3.0 3.0 NaN 4</span>
</pre></div>
</div>
<p>Replace all NaN elements in column ‘A’, ‘B’, ‘C’, and ‘D’, with 0, 1,
2, and 3 respectively.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>  
<span class="go">    A   B   C   D</span>
<span class="go">0   0.0 2.0 2.0 0</span>
<span class="go">1   3.0 4.0 2.0 1</span>
<span class="go">2   0.0 1.0 2.0 5</span>
<span class="go">3   0.0 3.0 2.0 4</span>
</pre></div>
</div>
<p>Only replace the first NaN element.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">    A   B   C   D</span>
<span class="go">0   0.0 2.0 2.0 0</span>
<span class="go">1   3.0 4.0 NaN 1</span>
<span class="go">2   NaN 1.0 NaN 5</span>
<span class="go">3   NaN 3.0 NaN 4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.first">
<code class="sig-name descname">first</code><span class="sig-paren">(</span><em class="sig-param">offset</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.first" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to subset initial periods of time series data based on a date offset.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.first.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>offset</strong><span class="classifier">str, DateOffset, dateutil.relativedelta</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>subset</strong><span class="classifier">same type as caller</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>TypeError</strong></dt><dd><p>If the index is not  a <code class="xref py py-class docutils literal notranslate"><span class="pre">DatetimeIndex</span></code></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.last" title="dask.dataframe.DataFrame.last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">last</span></code></a></dt><dd><p>Select final periods of time series based on a date offset.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">at_time</span></code></dt><dd><p>Select values at a particular time of the day.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">between_time</span></code></dt><dd><p>Select values between particular times of the day.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2018-04-09&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;2D&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]},</span> <span class="n">index</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span>  
<span class="go">            A</span>
<span class="go">2018-04-09  1</span>
<span class="go">2018-04-11  2</span>
<span class="go">2018-04-13  3</span>
<span class="go">2018-04-15  4</span>
</pre></div>
</div>
<p>Get the rows for the first 3 days:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="s1">&#39;3D&#39;</span><span class="p">)</span>  
<span class="go">            A</span>
<span class="go">2018-04-09  1</span>
<span class="go">2018-04-11  2</span>
</pre></div>
</div>
<p>Notice the data for 3 first calender days were returned, not the first
3 days observed in the dataset, and therefore data for 2018-04-13 was
not returned.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.floordiv">
<code class="sig-name descname">floordiv</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.floordiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Integer division of dataframe and other, element-wise (binary operator <cite>floordiv</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.floordiv.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">//</span> <span class="pre">other</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>rfloordiv</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.ge">
<code class="sig-name descname">ge</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.ge" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Greater than or equal to of dataframe and other, element-wise (binary operator <cite>ge</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.ge.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Among flexible wrappers (<cite>eq</cite>, <cite>ne</cite>, <cite>le</cite>, <cite>lt</cite>, <cite>ge</cite>, <cite>gt</cite>) to comparison
operators.</p>
<p>Equivalent to <cite>==</cite>, <cite>=!</cite>, <cite>&lt;=</cite>, <cite>&lt;</cite>, <cite>&gt;=</cite>, <cite>&gt;</cite> with support to choose axis
(rows or columns) and level for comparison.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default ‘columns’</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’).</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the passed
MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame of bool</strong></dt><dd><p>Result of the comparison.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.eq" title="dask.dataframe.DataFrame.eq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.eq</span></code></a></dt><dd><p>Compare DataFrames for equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.ne" title="dask.dataframe.DataFrame.ne"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.ne</span></code></a></dt><dd><p>Compare DataFrames for inequality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.le" title="dask.dataframe.DataFrame.le"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.le</span></code></a></dt><dd><p>Compare DataFrames for less than inequality or equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.lt" title="dask.dataframe.DataFrame.lt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.lt</span></code></a></dt><dd><p>Compare DataFrames for strictly less than inequality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.ge" title="dask.dataframe.DataFrame.ge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.ge</span></code></a></dt><dd><p>Compare DataFrames for greater than inequality or equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.gt" title="dask.dataframe.DataFrame.gt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.gt</span></code></a></dt><dd><p>Compare DataFrames for strictly greater than inequality elementwise.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.
<cite>NaN</cite> values are considered different (i.e. <cite>NaN</cite> != <cite>NaN</cite>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cost&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">300</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   cost  revenue</span>
<span class="go">A   250      100</span>
<span class="go">B   150      250</span>
<span class="go">C   100      300</span>
</pre></div>
</div>
<p>Comparison with a scalar, using either the operator or method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">==</span> <span class="mi">100</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False     True</span>
<span class="go">B  False    False</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False     True</span>
<span class="go">B  False    False</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<p>When <cite>other</cite> is a <a class="reference internal" href="#dask.dataframe.Series" title="dask.dataframe.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>, the columns of a DataFrame are aligned
with the index of <cite>other</cite> and broadcast:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">!=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cost&quot;</span><span class="p">,</span> <span class="s2">&quot;revenue&quot;</span><span class="p">])</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True     True</span>
<span class="go">B   True    False</span>
<span class="go">C  False     True</span>
</pre></div>
</div>
<p>Use the method to control the broadcast axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>  
<span class="go">   cost  revenue</span>
<span class="go">A  True    False</span>
<span class="go">B  True     True</span>
<span class="go">C  True     True</span>
<span class="go">D  True     True</span>
</pre></div>
</div>
<p>When comparing to an arbitrary sequence, the number of columns must
match the number elements in <cite>other</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">==</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True     True</span>
<span class="go">B  False    False</span>
<span class="go">C  False    False</span>
</pre></div>
</div>
<p>Use the method to control the axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eq</span><span class="p">([</span><span class="mi">250</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True    False</span>
<span class="go">B  False     True</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<p>Compare to a DataFrame of different shape.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">   revenue</span>
<span class="go">A      300</span>
<span class="go">B      250</span>
<span class="go">C      100</span>
<span class="go">D      150</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False    False</span>
<span class="go">B  False    False</span>
<span class="go">C  False     True</span>
<span class="go">D  False    False</span>
</pre></div>
</div>
<p>Compare to a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cost&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">220</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">175</span><span class="p">,</span> <span class="mi">225</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">      cost  revenue</span>
<span class="go">Q1 A   250      100</span>
<span class="go">   B   150      250</span>
<span class="go">   C   100      300</span>
<span class="go">Q2 A   150      200</span>
<span class="go">   B   300      175</span>
<span class="go">   C   220      225</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">       cost  revenue</span>
<span class="go">Q1 A   True     True</span>
<span class="go">   B   True     True</span>
<span class="go">   C   True     True</span>
<span class="go">Q2 A  False     True</span>
<span class="go">   B   True    False</span>
<span class="go">   C   True    False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.get_partition">
<code class="sig-name descname">get_partition</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.get_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dask DataFrame/Series representing the <cite>nth</cite> partition.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.groupby">
<code class="sig-name descname">groupby</code><span class="sig-paren">(</span><em class="sig-param">by=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Group DataFrame using a mapper or by a Series of columns.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.groupby.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>A groupby operation involves some combination of splitting the
object, applying a function, and combining the results. This can be
used to group large amounts of data and compute operations on these
groups.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>by</strong><span class="classifier">mapping, function, label, or list of labels</span></dt><dd><p>Used to determine the groups for the groupby.
If <code class="docutils literal notranslate"><span class="pre">by</span></code> is a function, it’s called on each value of the object’s
index. If a dict or Series is passed, the Series or dict VALUES
will be used to determine the groups (the Series’ values are first
aligned; see <code class="docutils literal notranslate"><span class="pre">.align()</span></code> method). If an ndarray is passed, the
values are used as-is determine the groups. A label or list of
labels may be passed to group by the columns in <code class="docutils literal notranslate"><span class="pre">self</span></code>. Notice
that a tuple is interpreted as a (single) key.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0  (Not supported in Dask)</span></dt><dd><p>Split along rows (0) or columns (1).</p>
</dd>
<dt><strong>level</strong><span class="classifier">int, level name, or sequence of such, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), group by a particular
level or levels.</p>
</dd>
<dt><strong>as_index</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>For aggregated output, return object with group labels as the
index. Only relevant for DataFrame input. as_index=False is
effectively “SQL-style” grouped output.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>Sort group keys. Get better performance by turning this off.
Note this does not influence the order of observations within each
group. Groupby preserves the order of rows within each group.</p>
</dd>
<dt><strong>group_keys</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>When calling apply, add group keys to index to identify pieces.</p>
</dd>
<dt><strong>squeeze</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Reduce the dimensionality of the return type if possible,
otherwise return a consistent type.</p>
</dd>
<dt><strong>observed</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>This only applies if any of the groupers are Categoricals.
If True: only show observed values for categorical groupers.
If False: show all values for categorical groupers.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.23.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrameGroupBy</strong></dt><dd><p>Returns a groupby object that contains information about the groups.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.resample" title="dask.dataframe.DataFrame.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a></dt><dd><p>Convenience method for frequency conversion and resampling of time series.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>See the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/groupby.html">user guide</a> for more.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Animal&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;Falcon&#39;</span><span class="p">,</span>  
<span class="gp">... </span>                              <span class="s1">&#39;Parrot&#39;</span><span class="p">,</span> <span class="s1">&#39;Parrot&#39;</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;Max Speed&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">380.</span><span class="p">,</span> <span class="mf">370.</span><span class="p">,</span> <span class="mf">24.</span><span class="p">,</span> <span class="mf">26.</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   Animal  Max Speed</span>
<span class="go">0  Falcon      380.0</span>
<span class="go">1  Falcon      370.0</span>
<span class="go">2  Parrot       24.0</span>
<span class="go">3  Parrot       26.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;Animal&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">        Max Speed</span>
<span class="go">Animal</span>
<span class="go">Falcon      375.0</span>
<span class="go">Parrot       25.0</span>
</pre></div>
</div>
<p><strong>Hierarchical Indexes</strong></p>
<p>We can groupby different levels of a hierarchical index
using the <cite>level</cite> parameter:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;Falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;Falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;Parrot&#39;</span><span class="p">,</span> <span class="s1">&#39;Parrot&#39;</span><span class="p">],</span>  
<span class="gp">... </span>          <span class="p">[</span><span class="s1">&#39;Captive&#39;</span><span class="p">,</span> <span class="s1">&#39;Wild&#39;</span><span class="p">,</span> <span class="s1">&#39;Captive&#39;</span><span class="p">,</span> <span class="s1">&#39;Wild&#39;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Animal&#39;</span><span class="p">,</span> <span class="s1">&#39;Type&#39;</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Max Speed&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">390.</span><span class="p">,</span> <span class="mf">350.</span><span class="p">,</span> <span class="mf">30.</span><span class="p">,</span> <span class="mf">20.</span><span class="p">]},</span>  
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">                Max Speed</span>
<span class="go">Animal Type</span>
<span class="go">Falcon Captive      390.0</span>
<span class="go">       Wild         350.0</span>
<span class="go">Parrot Captive       30.0</span>
<span class="go">       Wild          20.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">        Max Speed</span>
<span class="go">Animal</span>
<span class="go">Falcon      370.0</span>
<span class="go">Parrot       25.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s2">&quot;Type&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">         Max Speed</span>
<span class="go">Type</span>
<span class="go">Captive      210.0</span>
<span class="go">Wild         185.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.gt">
<code class="sig-name descname">gt</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.gt" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Greater than of dataframe and other, element-wise (binary operator <cite>gt</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.gt.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Among flexible wrappers (<cite>eq</cite>, <cite>ne</cite>, <cite>le</cite>, <cite>lt</cite>, <cite>ge</cite>, <cite>gt</cite>) to comparison
operators.</p>
<p>Equivalent to <cite>==</cite>, <cite>=!</cite>, <cite>&lt;=</cite>, <cite>&lt;</cite>, <cite>&gt;=</cite>, <cite>&gt;</cite> with support to choose axis
(rows or columns) and level for comparison.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default ‘columns’</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’).</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the passed
MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame of bool</strong></dt><dd><p>Result of the comparison.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.eq" title="dask.dataframe.DataFrame.eq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.eq</span></code></a></dt><dd><p>Compare DataFrames for equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.ne" title="dask.dataframe.DataFrame.ne"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.ne</span></code></a></dt><dd><p>Compare DataFrames for inequality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.le" title="dask.dataframe.DataFrame.le"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.le</span></code></a></dt><dd><p>Compare DataFrames for less than inequality or equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.lt" title="dask.dataframe.DataFrame.lt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.lt</span></code></a></dt><dd><p>Compare DataFrames for strictly less than inequality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.ge" title="dask.dataframe.DataFrame.ge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.ge</span></code></a></dt><dd><p>Compare DataFrames for greater than inequality or equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.gt" title="dask.dataframe.DataFrame.gt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.gt</span></code></a></dt><dd><p>Compare DataFrames for strictly greater than inequality elementwise.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.
<cite>NaN</cite> values are considered different (i.e. <cite>NaN</cite> != <cite>NaN</cite>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cost&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">300</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   cost  revenue</span>
<span class="go">A   250      100</span>
<span class="go">B   150      250</span>
<span class="go">C   100      300</span>
</pre></div>
</div>
<p>Comparison with a scalar, using either the operator or method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">==</span> <span class="mi">100</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False     True</span>
<span class="go">B  False    False</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False     True</span>
<span class="go">B  False    False</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<p>When <cite>other</cite> is a <a class="reference internal" href="#dask.dataframe.Series" title="dask.dataframe.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>, the columns of a DataFrame are aligned
with the index of <cite>other</cite> and broadcast:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">!=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cost&quot;</span><span class="p">,</span> <span class="s2">&quot;revenue&quot;</span><span class="p">])</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True     True</span>
<span class="go">B   True    False</span>
<span class="go">C  False     True</span>
</pre></div>
</div>
<p>Use the method to control the broadcast axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>  
<span class="go">   cost  revenue</span>
<span class="go">A  True    False</span>
<span class="go">B  True     True</span>
<span class="go">C  True     True</span>
<span class="go">D  True     True</span>
</pre></div>
</div>
<p>When comparing to an arbitrary sequence, the number of columns must
match the number elements in <cite>other</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">==</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True     True</span>
<span class="go">B  False    False</span>
<span class="go">C  False    False</span>
</pre></div>
</div>
<p>Use the method to control the axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eq</span><span class="p">([</span><span class="mi">250</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True    False</span>
<span class="go">B  False     True</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<p>Compare to a DataFrame of different shape.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">   revenue</span>
<span class="go">A      300</span>
<span class="go">B      250</span>
<span class="go">C      100</span>
<span class="go">D      150</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False    False</span>
<span class="go">B  False    False</span>
<span class="go">C  False     True</span>
<span class="go">D  False    False</span>
</pre></div>
</div>
<p>Compare to a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cost&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">220</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">175</span><span class="p">,</span> <span class="mi">225</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">      cost  revenue</span>
<span class="go">Q1 A   250      100</span>
<span class="go">   B   150      250</span>
<span class="go">   C   100      300</span>
<span class="go">Q2 A   150      200</span>
<span class="go">   B   300      175</span>
<span class="go">   C   220      225</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">       cost  revenue</span>
<span class="go">Q1 A   True     True</span>
<span class="go">   B   True     True</span>
<span class="go">   C   True     True</span>
<span class="go">Q2 A  False     True</span>
<span class="go">   B   True    False</span>
<span class="go">   C   True    False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.head">
<code class="sig-name descname">head</code><span class="sig-paren">(</span><em class="sig-param">n=5</em>, <em class="sig-param">npartitions=1</em>, <em class="sig-param">compute=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.head" title="Permalink to this definition">¶</a></dt>
<dd><p>First n rows of the dataset</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>The number of rows to return. Default is 5.</p>
</dd>
<dt><strong>npartitions</strong><span class="classifier">int, optional</span></dt><dd><p>Elements are only taken from the first <code class="docutils literal notranslate"><span class="pre">npartitions</span></code>, with a
default of 1. If there are fewer than <code class="docutils literal notranslate"><span class="pre">n</span></code> rows in the first
<code class="docutils literal notranslate"><span class="pre">npartitions</span></code> a warning will be raised and any found rows
returned. Pass -1 to use all partitions.</p>
</dd>
<dt><strong>compute</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to compute the result, default is True.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.idxmax">
<code class="sig-name descname">idxmax</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.idxmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index of first occurrence of maximum over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.idxmax.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>NA/null values are excluded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The axis to use. 0 or ‘index’ for row-wise, 1 or ‘columns’ for column-wise.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Indexes of maxima along the specified axis.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><ul class="simple">
<li><p>If the row/column is empty</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.idxmax" title="dask.dataframe.Series.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmax</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This method is the DataFrame version of <code class="docutils literal notranslate"><span class="pre">ndarray.argmax</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.idxmin">
<code class="sig-name descname">idxmin</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.idxmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index of first occurrence of minimum over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.idxmin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>NA/null values are excluded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The axis to use. 0 or ‘index’ for row-wise, 1 or ‘columns’ for column-wise.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Indexes of minima along the specified axis.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><ul class="simple">
<li><p>If the row/column is empty</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.idxmin" title="dask.dataframe.Series.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmin</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This method is the DataFrame version of <code class="docutils literal notranslate"><span class="pre">ndarray.argmin</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.iloc">
<em class="property">property </em><code class="sig-name descname">iloc</code><a class="headerlink" href="#dask.dataframe.DataFrame.iloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Purely integer-location based indexing for selection by position.</p>
<p>Only indexing the column positions is supported. Trying to select
row positions will raise a ValueError.</p>
<p>See <a class="reference internal" href="dataframe-indexing.html#dataframe-indexing"><span class="std std-ref">Indexing into Dask DataFrames</span></a> for more.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.index">
<em class="property">property </em><code class="sig-name descname">index</code><a class="headerlink" href="#dask.dataframe.DataFrame.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dask Index instance</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.info">
<code class="sig-name descname">info</code><span class="sig-paren">(</span><em class="sig-param">buf=None</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">memory_usage=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Concise summary of a Dask DataFrame.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.isin">
<code class="sig-name descname">isin</code><span class="sig-paren">(</span><em class="sig-param">values</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.isin" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether each element in the DataFrame is contained in values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.isin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">iterable, Series, DataFrame or dict</span></dt><dd><p>The result will only be true at a location if all the
labels match. If <cite>values</cite> is a Series, that’s the index. If
<cite>values</cite> is a dict, the keys must be the column names,
which must match. If <cite>values</cite> is a DataFrame,
then both the index and column labels must match.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>DataFrame of booleans showing whether each element in the DataFrame
is contained in values.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.eq" title="dask.dataframe.DataFrame.eq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.eq</span></code></a></dt><dd><p>Equality test for DataFrame.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.isin" title="dask.dataframe.Series.isin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.isin</span></code></a></dt><dd><p>Equivalent method on Series.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.str.contains</span></code></dt><dd><p>Test if pattern or regex is contained within a string of a Series or Index.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;num_legs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">&#39;num_wings&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]},</span>  
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;dog&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">        num_legs  num_wings</span>
<span class="go">falcon         2          2</span>
<span class="go">dog            4          0</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">values</span></code> is a list check whether every value in the DataFrame
is present in the list (which animals have 0 or 2 legs or wings)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="go">        num_legs  num_wings</span>
<span class="go">falcon      True       True</span>
<span class="go">dog        False       True</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">values</span></code> is a dict, we can pass values to check for each
column separately:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">isin</span><span class="p">({</span><span class="s1">&#39;num_wings&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>  
<span class="go">        num_legs  num_wings</span>
<span class="go">falcon     False      False</span>
<span class="go">dog        False       True</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">values</span></code> is a Series or DataFrame the index and column must
match. Note that ‘falcon’ does not match based on the number of legs
in df2.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;num_legs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;num_wings&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;spider&#39;</span><span class="p">,</span> <span class="s1">&#39;falcon&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  
<span class="go">        num_legs  num_wings</span>
<span class="go">falcon      True       True</span>
<span class="go">dog        False      False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.isna">
<code class="sig-name descname">isna</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.isna" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect missing values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.isna.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return a boolean same-sized object indicating if the values are NA.
NA values, such as None or <code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.NaN</span></code>, gets mapped to True
values.
Everything else gets mapped to False values. Characters such as empty
strings <code class="docutils literal notranslate"><span class="pre">''</span></code> or <code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.inf</span></code> are not considered NA values
(unless you set <code class="docutils literal notranslate"><span class="pre">pandas.options.mode.use_inf_as_na</span> <span class="pre">=</span> <span class="pre">True</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Mask of bool values for each element in DataFrame that
indicates whether an element is not an NA value.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.isnull" title="dask.dataframe.DataFrame.isnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.isnull</span></code></a></dt><dd><p>Alias of isna.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.notna</span></code></dt><dd><p>Boolean inverse of isna.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.dropna" title="dask.dataframe.DataFrame.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.dropna</span></code></a></dt><dd><p>Omit axes labels with missing values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.isna" title="dask.dataframe.DataFrame.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isna</span></code></a></dt><dd><p>Top-level isna.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Show which entries in a DataFrame are NA.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;born&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1939-05-27&#39;</span><span class="p">),</span>
<span class="gp">... </span>                            <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1940-04-25&#39;</span><span class="p">)],</span>
<span class="gp">... </span>                   <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Alfred&#39;</span><span class="p">,</span> <span class="s1">&#39;Batman&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;toy&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Batmobile&#39;</span><span class="p">,</span> <span class="s1">&#39;Joker&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   age       born    name        toy</span>
<span class="go">0  5.0        NaT  Alfred       None</span>
<span class="go">1  6.0 1939-05-27  Batman  Batmobile</span>
<span class="go">2  NaN 1940-04-25              Joker</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>  
<span class="go">     age   born   name    toy</span>
<span class="go">0  False   True  False   True</span>
<span class="go">1  False  False  False  False</span>
<span class="go">2   True  False  False  False</span>
</pre></div>
</div>
<p>Show which entries in a Series are NA.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>  
<span class="go">0    5.0</span>
<span class="go">1    6.0</span>
<span class="go">2    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>  
<span class="go">0    False</span>
<span class="go">1    False</span>
<span class="go">2     True</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.isnull">
<code class="sig-name descname">isnull</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.isnull" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect missing values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.isnull.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return a boolean same-sized object indicating if the values are NA.
NA values, such as None or <code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.NaN</span></code>, gets mapped to True
values.
Everything else gets mapped to False values. Characters such as empty
strings <code class="docutils literal notranslate"><span class="pre">''</span></code> or <code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.inf</span></code> are not considered NA values
(unless you set <code class="docutils literal notranslate"><span class="pre">pandas.options.mode.use_inf_as_na</span> <span class="pre">=</span> <span class="pre">True</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Mask of bool values for each element in DataFrame that
indicates whether an element is not an NA value.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.isnull" title="dask.dataframe.DataFrame.isnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.isnull</span></code></a></dt><dd><p>Alias of isna.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.notna</span></code></dt><dd><p>Boolean inverse of isna.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.dropna" title="dask.dataframe.DataFrame.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.dropna</span></code></a></dt><dd><p>Omit axes labels with missing values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.isna" title="dask.dataframe.DataFrame.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isna</span></code></a></dt><dd><p>Top-level isna.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Show which entries in a DataFrame are NA.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;born&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1939-05-27&#39;</span><span class="p">),</span>
<span class="gp">... </span>                            <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1940-04-25&#39;</span><span class="p">)],</span>
<span class="gp">... </span>                   <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Alfred&#39;</span><span class="p">,</span> <span class="s1">&#39;Batman&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;toy&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Batmobile&#39;</span><span class="p">,</span> <span class="s1">&#39;Joker&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   age       born    name        toy</span>
<span class="go">0  5.0        NaT  Alfred       None</span>
<span class="go">1  6.0 1939-05-27  Batman  Batmobile</span>
<span class="go">2  NaN 1940-04-25              Joker</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>  
<span class="go">     age   born   name    toy</span>
<span class="go">0  False   True  False   True</span>
<span class="go">1  False  False  False  False</span>
<span class="go">2   True  False  False  False</span>
</pre></div>
</div>
<p>Show which entries in a Series are NA.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>  
<span class="go">0    5.0</span>
<span class="go">1    6.0</span>
<span class="go">2    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>  
<span class="go">0    False</span>
<span class="go">1    False</span>
<span class="go">2     True</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.iterrows">
<code class="sig-name descname">iterrows</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.iterrows" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over DataFrame rows as (index, Series) pairs.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.iterrows.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Yields</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">label or tuple of label</span></dt><dd><p>The index of the row. A tuple for a <cite>MultiIndex</cite>.</p>
</dd>
<dt><strong>data</strong><span class="classifier">Series</span></dt><dd><p>The data of the row as a Series.</p>
</dd>
<dt><strong>it</strong><span class="classifier">generator</span></dt><dd><p>A generator that iterates over the rows of the frame.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.itertuples" title="dask.dataframe.DataFrame.itertuples"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.itertuples</span></code></a></dt><dd><p>Iterate over DataFrame rows as namedtuples of the values.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.items</span></code></dt><dd><p>Iterate over (column name, Series) pairs.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ol class="arabic">
<li><p>Because <code class="docutils literal notranslate"><span class="pre">iterrows</span></code> returns a Series for each row,
it does <strong>not</strong> preserve dtypes across the rows (dtypes are
preserved across columns for DataFrames). For example,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">]],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">())[</span><span class="mi">1</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span>  
<span class="go">int      1.0</span>
<span class="go">float    1.5</span>
<span class="go">Name: 0, dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  
<span class="go">float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  
<span class="go">int64</span>
</pre></div>
</div>
<p>To preserve dtypes while iterating over the rows, it is better
to use <a class="reference internal" href="#dask.dataframe.DataFrame.itertuples" title="dask.dataframe.DataFrame.itertuples"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itertuples()</span></code></a> which returns namedtuples of the values
and which is generally faster than <code class="docutils literal notranslate"><span class="pre">iterrows</span></code>.</p>
</li>
<li><p>You should <strong>never modify</strong> something you are iterating over.
This is not guaranteed to work in all cases. Depending on the
data types, the iterator returns a copy and not a view, and writing
to it will have no effect.</p></li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.itertuples">
<code class="sig-name descname">itertuples</code><span class="sig-paren">(</span><em class="sig-param">index=True</em>, <em class="sig-param">name='Pandas'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.itertuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over DataFrame rows as namedtuples.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.itertuples.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, return the index as the first element of the tuple.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str or None, default “Pandas”</span></dt><dd><p>The name of the returned namedtuples or None to return regular
tuples.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>iterator</strong></dt><dd><p>An object to iterate over namedtuples for each row in the
DataFrame with the first field possibly being the index and
following fields being the column values.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.iterrows" title="dask.dataframe.DataFrame.iterrows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.iterrows</span></code></a></dt><dd><p>Iterate over DataFrame rows as (index, Series) pairs.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.items</span></code></dt><dd><p>Iterate over (column name, Series) pairs.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The column names will be renamed to positional names if they are
invalid Python identifiers, repeated, or start with an underscore.
On python versions &lt; 3.7 regular tuples are returned for DataFrames
with a large number of columns (&gt;254).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;num_legs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;num_wings&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span>  
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="s1">&#39;hawk&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">      num_legs  num_wings</span>
<span class="go">dog          4          0</span>
<span class="go">hawk         2          2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Pandas(Index=&#39;dog&#39;, num_legs=4, num_wings=0)</span>
<span class="go">Pandas(Index=&#39;hawk&#39;, num_legs=2, num_wings=2)</span>
</pre></div>
</div>
<p>By setting the <cite>index</cite> parameter to False we can remove the index
as the first element of the tuple:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Pandas(num_legs=4, num_wings=0)</span>
<span class="go">Pandas(num_legs=2, num_wings=2)</span>
</pre></div>
</div>
<p>With the <cite>name</cite> parameter set we set a custom name for the yielded
namedtuples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Animal&#39;</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Animal(Index=&#39;dog&#39;, num_legs=4, num_wings=0)</span>
<span class="go">Animal(Index=&#39;hawk&#39;, num_legs=2, num_wings=2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.join">
<code class="sig-name descname">join</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">on=None</em>, <em class="sig-param">how='left'</em>, <em class="sig-param">lsuffix=''</em>, <em class="sig-param">rsuffix=''</em>, <em class="sig-param">npartitions=None</em>, <em class="sig-param">shuffle=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join columns of another DataFrame.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.join.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Join columns with <cite>other</cite> DataFrame either on index or on a key
column. Efficiently join multiple DataFrame objects by index at once by
passing a list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">DataFrame, Series, or list of DataFrame</span></dt><dd><p>Index should be similar to one of the columns in this one. If a
Series is passed, its name attribute must be set, and that will be
used as the column name in the resulting joined DataFrame.</p>
</dd>
<dt><strong>on</strong><span class="classifier">str, list of str, or array-like, optional</span></dt><dd><p>Column or index level name(s) in the caller to join on the index
in <cite>other</cite>, otherwise joins index-on-index. If multiple
values given, the <cite>other</cite> DataFrame must have a MultiIndex. Can
pass an array as the join key if it is not already contained in
the calling DataFrame. Like an Excel VLOOKUP operation.</p>
</dd>
<dt><strong>how</strong><span class="classifier">{‘left’, ‘right’, ‘outer’, ‘inner’}, default ‘left’</span></dt><dd><p>How to handle the operation of the two objects.</p>
<ul class="simple">
<li><p>left: use calling frame’s index (or column if on is specified)</p></li>
<li><p>right: use <cite>other</cite>’s index.</p></li>
<li><p>outer: form union of calling frame’s index (or column if on is
specified) with <cite>other</cite>’s index, and sort it.
lexicographically.</p></li>
<li><p>inner: form intersection of calling frame’s index (or column if
on is specified) with <cite>other</cite>’s index, preserving the order
of the calling’s one.</p></li>
</ul>
</dd>
<dt><strong>lsuffix</strong><span class="classifier">str, default ‘’</span></dt><dd><p>Suffix to use from left frame’s overlapping columns.</p>
</dd>
<dt><strong>rsuffix</strong><span class="classifier">str, default ‘’</span></dt><dd><p>Suffix to use from right frame’s overlapping columns.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Order result DataFrame lexicographically by the join key. If False,
the order of the join key depends on the join type (how keyword).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>A dataframe containing columns from both the caller and <cite>other</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.merge" title="dask.dataframe.DataFrame.merge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.merge</span></code></a></dt><dd><p>For column(s)-on-columns(s) operations.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Parameters <cite>on</cite>, <cite>lsuffix</cite>, and <cite>rsuffix</cite> are not supported when
passing a list of <cite>DataFrame</cite> objects.</p>
<p>Support for specifying index levels as the <cite>on</cite> parameter was added
in version 0.23.0.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;K0&#39;</span><span class="p">,</span> <span class="s1">&#39;K1&#39;</span><span class="p">,</span> <span class="s1">&#39;K2&#39;</span><span class="p">,</span> <span class="s1">&#39;K3&#39;</span><span class="p">,</span> <span class="s1">&#39;K4&#39;</span><span class="p">,</span> <span class="s1">&#39;K5&#39;</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;A0&#39;</span><span class="p">,</span> <span class="s1">&#39;A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A2&#39;</span><span class="p">,</span> <span class="s1">&#39;A3&#39;</span><span class="p">,</span> <span class="s1">&#39;A4&#39;</span><span class="p">,</span> <span class="s1">&#39;A5&#39;</span><span class="p">]})</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">  key   A</span>
<span class="go">0  K0  A0</span>
<span class="go">1  K1  A1</span>
<span class="go">2  K2  A2</span>
<span class="go">3  K3  A3</span>
<span class="go">4  K4  A4</span>
<span class="go">5  K5  A5</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;K0&#39;</span><span class="p">,</span> <span class="s1">&#39;K1&#39;</span><span class="p">,</span> <span class="s1">&#39;K2&#39;</span><span class="p">],</span>  
<span class="gp">... </span>                      <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B0&#39;</span><span class="p">,</span> <span class="s1">&#39;B1&#39;</span><span class="p">,</span> <span class="s1">&#39;B2&#39;</span><span class="p">]})</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">  key   B</span>
<span class="go">0  K0  B0</span>
<span class="go">1  K1  B1</span>
<span class="go">2  K2  B2</span>
</pre></div>
</div>
<p>Join DataFrames using their indexes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">lsuffix</span><span class="o">=</span><span class="s1">&#39;_caller&#39;</span><span class="p">,</span> <span class="n">rsuffix</span><span class="o">=</span><span class="s1">&#39;_other&#39;</span><span class="p">)</span>  
<span class="go">  key_caller   A key_other    B</span>
<span class="go">0         K0  A0        K0   B0</span>
<span class="go">1         K1  A1        K1   B1</span>
<span class="go">2         K2  A2        K2   B2</span>
<span class="go">3         K3  A3       NaN  NaN</span>
<span class="go">4         K4  A4       NaN  NaN</span>
<span class="go">5         K5  A5       NaN  NaN</span>
</pre></div>
</div>
<p>If we want to join using the key columns, we need to set key to be
the index in both <cite>df</cite> and <cite>other</cite>. The joined DataFrame will have
key as its index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">))</span>  
<span class="go">      A    B</span>
<span class="go">key</span>
<span class="go">K0   A0   B0</span>
<span class="go">K1   A1   B1</span>
<span class="go">K2   A2   B2</span>
<span class="go">K3   A3  NaN</span>
<span class="go">K4   A4  NaN</span>
<span class="go">K5   A5  NaN</span>
</pre></div>
</div>
<p>Another option to join using the key columns is to use the <cite>on</cite>
parameter. DataFrame.join always uses <cite>other</cite>’s index but we can use
any column in <cite>df</cite>. This method preserves the original DataFrame’s
index in the result.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">),</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;key&#39;</span><span class="p">)</span>  
<span class="go">  key   A    B</span>
<span class="go">0  K0  A0   B0</span>
<span class="go">1  K1  A1   B1</span>
<span class="go">2  K2  A2   B2</span>
<span class="go">3  K3  A3  NaN</span>
<span class="go">4  K4  A4  NaN</span>
<span class="go">5  K5  A5  NaN</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.known_divisions">
<em class="property">property </em><code class="sig-name descname">known_divisions</code><a class="headerlink" href="#dask.dataframe.DataFrame.known_divisions" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether divisions are already known</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.last">
<code class="sig-name descname">last</code><span class="sig-paren">(</span><em class="sig-param">offset</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.last" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to subset final periods of time series data based on a date offset.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.last.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>offset</strong><span class="classifier">str, DateOffset, dateutil.relativedelta</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>subset</strong><span class="classifier">same type as caller</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>TypeError</strong></dt><dd><p>If the index is not  a <code class="xref py py-class docutils literal notranslate"><span class="pre">DatetimeIndex</span></code></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.first" title="dask.dataframe.DataFrame.first"><code class="xref py py-obj docutils literal notranslate"><span class="pre">first</span></code></a></dt><dd><p>Select initial periods of time series based on a date offset.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">at_time</span></code></dt><dd><p>Select values at a particular time of the day.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">between_time</span></code></dt><dd><p>Select values between particular times of the day.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2018-04-09&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;2D&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span> <span class="n">index</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span>  
<span class="go">            A</span>
<span class="go">2018-04-09  1</span>
<span class="go">2018-04-11  2</span>
<span class="go">2018-04-13  3</span>
<span class="go">2018-04-15  4</span>
</pre></div>
</div>
<p>Get the rows for the last 3 days:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="s1">&#39;3D&#39;</span><span class="p">)</span>  
<span class="go">            A</span>
<span class="go">2018-04-13  3</span>
<span class="go">2018-04-15  4</span>
</pre></div>
</div>
<p>Notice the data for 3 last calender days were returned, not the last
3 observed days in the dataset, and therefore data for 2018-04-11 was
not returned.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.le">
<code class="sig-name descname">le</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.le" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Less than or equal to of dataframe and other, element-wise (binary operator <cite>le</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.le.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Among flexible wrappers (<cite>eq</cite>, <cite>ne</cite>, <cite>le</cite>, <cite>lt</cite>, <cite>ge</cite>, <cite>gt</cite>) to comparison
operators.</p>
<p>Equivalent to <cite>==</cite>, <cite>=!</cite>, <cite>&lt;=</cite>, <cite>&lt;</cite>, <cite>&gt;=</cite>, <cite>&gt;</cite> with support to choose axis
(rows or columns) and level for comparison.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default ‘columns’</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’).</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the passed
MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame of bool</strong></dt><dd><p>Result of the comparison.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.eq" title="dask.dataframe.DataFrame.eq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.eq</span></code></a></dt><dd><p>Compare DataFrames for equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.ne" title="dask.dataframe.DataFrame.ne"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.ne</span></code></a></dt><dd><p>Compare DataFrames for inequality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.le" title="dask.dataframe.DataFrame.le"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.le</span></code></a></dt><dd><p>Compare DataFrames for less than inequality or equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.lt" title="dask.dataframe.DataFrame.lt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.lt</span></code></a></dt><dd><p>Compare DataFrames for strictly less than inequality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.ge" title="dask.dataframe.DataFrame.ge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.ge</span></code></a></dt><dd><p>Compare DataFrames for greater than inequality or equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.gt" title="dask.dataframe.DataFrame.gt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.gt</span></code></a></dt><dd><p>Compare DataFrames for strictly greater than inequality elementwise.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.
<cite>NaN</cite> values are considered different (i.e. <cite>NaN</cite> != <cite>NaN</cite>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cost&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">300</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   cost  revenue</span>
<span class="go">A   250      100</span>
<span class="go">B   150      250</span>
<span class="go">C   100      300</span>
</pre></div>
</div>
<p>Comparison with a scalar, using either the operator or method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">==</span> <span class="mi">100</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False     True</span>
<span class="go">B  False    False</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False     True</span>
<span class="go">B  False    False</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<p>When <cite>other</cite> is a <a class="reference internal" href="#dask.dataframe.Series" title="dask.dataframe.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>, the columns of a DataFrame are aligned
with the index of <cite>other</cite> and broadcast:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">!=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cost&quot;</span><span class="p">,</span> <span class="s2">&quot;revenue&quot;</span><span class="p">])</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True     True</span>
<span class="go">B   True    False</span>
<span class="go">C  False     True</span>
</pre></div>
</div>
<p>Use the method to control the broadcast axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>  
<span class="go">   cost  revenue</span>
<span class="go">A  True    False</span>
<span class="go">B  True     True</span>
<span class="go">C  True     True</span>
<span class="go">D  True     True</span>
</pre></div>
</div>
<p>When comparing to an arbitrary sequence, the number of columns must
match the number elements in <cite>other</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">==</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True     True</span>
<span class="go">B  False    False</span>
<span class="go">C  False    False</span>
</pre></div>
</div>
<p>Use the method to control the axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eq</span><span class="p">([</span><span class="mi">250</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True    False</span>
<span class="go">B  False     True</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<p>Compare to a DataFrame of different shape.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">   revenue</span>
<span class="go">A      300</span>
<span class="go">B      250</span>
<span class="go">C      100</span>
<span class="go">D      150</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False    False</span>
<span class="go">B  False    False</span>
<span class="go">C  False     True</span>
<span class="go">D  False    False</span>
</pre></div>
</div>
<p>Compare to a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cost&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">220</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">175</span><span class="p">,</span> <span class="mi">225</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">      cost  revenue</span>
<span class="go">Q1 A   250      100</span>
<span class="go">   B   150      250</span>
<span class="go">   C   100      300</span>
<span class="go">Q2 A   150      200</span>
<span class="go">   B   300      175</span>
<span class="go">   C   220      225</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">       cost  revenue</span>
<span class="go">Q1 A   True     True</span>
<span class="go">   B   True     True</span>
<span class="go">   C   True     True</span>
<span class="go">Q2 A  False     True</span>
<span class="go">   B   True    False</span>
<span class="go">   C   True    False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.loc">
<em class="property">property </em><code class="sig-name descname">loc</code><a class="headerlink" href="#dask.dataframe.DataFrame.loc" title="Permalink to this definition">¶</a></dt>
<dd><p>Purely label-location based indexer for selection by label.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">:</span><span class="s2">&quot;d&quot;</span><span class="p">]</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.lt">
<code class="sig-name descname">lt</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.lt" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Less than of dataframe and other, element-wise (binary operator <cite>lt</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.lt.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Among flexible wrappers (<cite>eq</cite>, <cite>ne</cite>, <cite>le</cite>, <cite>lt</cite>, <cite>ge</cite>, <cite>gt</cite>) to comparison
operators.</p>
<p>Equivalent to <cite>==</cite>, <cite>=!</cite>, <cite>&lt;=</cite>, <cite>&lt;</cite>, <cite>&gt;=</cite>, <cite>&gt;</cite> with support to choose axis
(rows or columns) and level for comparison.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default ‘columns’</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’).</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the passed
MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame of bool</strong></dt><dd><p>Result of the comparison.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.eq" title="dask.dataframe.DataFrame.eq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.eq</span></code></a></dt><dd><p>Compare DataFrames for equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.ne" title="dask.dataframe.DataFrame.ne"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.ne</span></code></a></dt><dd><p>Compare DataFrames for inequality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.le" title="dask.dataframe.DataFrame.le"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.le</span></code></a></dt><dd><p>Compare DataFrames for less than inequality or equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.lt" title="dask.dataframe.DataFrame.lt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.lt</span></code></a></dt><dd><p>Compare DataFrames for strictly less than inequality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.ge" title="dask.dataframe.DataFrame.ge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.ge</span></code></a></dt><dd><p>Compare DataFrames for greater than inequality or equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.gt" title="dask.dataframe.DataFrame.gt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.gt</span></code></a></dt><dd><p>Compare DataFrames for strictly greater than inequality elementwise.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.
<cite>NaN</cite> values are considered different (i.e. <cite>NaN</cite> != <cite>NaN</cite>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cost&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">300</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   cost  revenue</span>
<span class="go">A   250      100</span>
<span class="go">B   150      250</span>
<span class="go">C   100      300</span>
</pre></div>
</div>
<p>Comparison with a scalar, using either the operator or method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">==</span> <span class="mi">100</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False     True</span>
<span class="go">B  False    False</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False     True</span>
<span class="go">B  False    False</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<p>When <cite>other</cite> is a <a class="reference internal" href="#dask.dataframe.Series" title="dask.dataframe.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>, the columns of a DataFrame are aligned
with the index of <cite>other</cite> and broadcast:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">!=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cost&quot;</span><span class="p">,</span> <span class="s2">&quot;revenue&quot;</span><span class="p">])</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True     True</span>
<span class="go">B   True    False</span>
<span class="go">C  False     True</span>
</pre></div>
</div>
<p>Use the method to control the broadcast axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>  
<span class="go">   cost  revenue</span>
<span class="go">A  True    False</span>
<span class="go">B  True     True</span>
<span class="go">C  True     True</span>
<span class="go">D  True     True</span>
</pre></div>
</div>
<p>When comparing to an arbitrary sequence, the number of columns must
match the number elements in <cite>other</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">==</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True     True</span>
<span class="go">B  False    False</span>
<span class="go">C  False    False</span>
</pre></div>
</div>
<p>Use the method to control the axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eq</span><span class="p">([</span><span class="mi">250</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True    False</span>
<span class="go">B  False     True</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<p>Compare to a DataFrame of different shape.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">   revenue</span>
<span class="go">A      300</span>
<span class="go">B      250</span>
<span class="go">C      100</span>
<span class="go">D      150</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False    False</span>
<span class="go">B  False    False</span>
<span class="go">C  False     True</span>
<span class="go">D  False    False</span>
</pre></div>
</div>
<p>Compare to a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cost&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">220</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">175</span><span class="p">,</span> <span class="mi">225</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">      cost  revenue</span>
<span class="go">Q1 A   250      100</span>
<span class="go">   B   150      250</span>
<span class="go">   C   100      300</span>
<span class="go">Q2 A   150      200</span>
<span class="go">   B   300      175</span>
<span class="go">   C   220      225</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">       cost  revenue</span>
<span class="go">Q1 A   True     True</span>
<span class="go">   B   True     True</span>
<span class="go">   C   True     True</span>
<span class="go">Q2 A  False     True</span>
<span class="go">   B   True    False</span>
<span class="go">   C   True    False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.map_overlap">
<code class="sig-name descname">map_overlap</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">before</em>, <em class="sig-param">after</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.map_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to each partition, sharing rows with adjacent partitions.</p>
<p>This can be useful for implementing windowing functions such as
<code class="docutils literal notranslate"><span class="pre">df.rolling(...).mean()</span></code> or <code class="docutils literal notranslate"><span class="pre">df.diff()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function applied to each partition.</p>
</dd>
<dt><strong>before</strong><span class="classifier">int</span></dt><dd><p>The number of rows to prepend to partition <code class="docutils literal notranslate"><span class="pre">i</span></code> from the end of
partition <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>after</strong><span class="classifier">int</span></dt><dd><p>The number of rows to append to partition <code class="docutils literal notranslate"><span class="pre">i</span></code> from the beginning
of partition <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>args, kwargs :</strong></dt><dd><p>Arguments and keywords to pass to the function. The partition will
be the first argument, and these will be passed <em>after</em>.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes
and column names of the output. This metadata is necessary for
many algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code>
can be provided (note that the order of the names should match the
order of the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span>
<span class="pre">dtype)</span></code> can be used. If not provided, dask will try to infer the
metadata. This may lead to unexpected results, so providing
<code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For more information, see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Given positive integers <code class="docutils literal notranslate"><span class="pre">before</span></code> and <code class="docutils literal notranslate"><span class="pre">after</span></code>, and a function
<code class="docutils literal notranslate"><span class="pre">func</span></code>, <code class="docutils literal notranslate"><span class="pre">map_overlap</span></code> does the following:</p>
<ol class="arabic simple">
<li><p>Prepend <code class="docutils literal notranslate"><span class="pre">before</span></code> rows to each partition <code class="docutils literal notranslate"><span class="pre">i</span></code> from the end of
partition <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">-</span> <span class="pre">1</span></code>. The first partition has no rows prepended.</p></li>
<li><p>Append <code class="docutils literal notranslate"><span class="pre">after</span></code> rows to each partition <code class="docutils literal notranslate"><span class="pre">i</span></code> from the beginning of
partition <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></code>. The last partition has no rows appended.</p></li>
<li><p>Apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to each partition, passing in any extra <code class="docutils literal notranslate"><span class="pre">args</span></code> and
<code class="docutils literal notranslate"><span class="pre">kwargs</span></code> if provided.</p></li>
<li><p>Trim <code class="docutils literal notranslate"><span class="pre">before</span></code> rows from the beginning of all but the first
partition.</p></li>
<li><p>Trim <code class="docutils literal notranslate"><span class="pre">after</span></code> rows from the end of all but the last partition.</p></li>
</ol>
<p>Note that the index and divisions are assumed to remain unchanged.</p>
<p class="rubric">Examples</p>
<p>Given a DataFrame, Series, or Index, such as:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>A rolling sum with a trailing moving window of size 2 can be computed by
overlapping 2 rows before each partition, and then mapping calls to
<code class="docutils literal notranslate"><span class="pre">df.rolling(2).sum()</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">    x    y</span>
<span class="go">0   1  1.0</span>
<span class="go">1   2  2.0</span>
<span class="go">2   4  3.0</span>
<span class="go">3   7  4.0</span>
<span class="go">4  11  5.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">      x    y</span>
<span class="go">0   NaN  NaN</span>
<span class="go">1   3.0  3.0</span>
<span class="go">2   6.0  5.0</span>
<span class="go">3  11.0  7.0</span>
<span class="go">4  18.0  9.0</span>
</pre></div>
</div>
<p>The pandas <code class="docutils literal notranslate"><span class="pre">diff</span></code> method computes a discrete difference shifted by a
number of periods (can be positive or negative). This can be
implemented by mapping calls to <code class="docutils literal notranslate"><span class="pre">df.diff</span></code> to each partition after
prepending/appending that many rows, depending on sign:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">before</span><span class="p">,</span> <span class="n">after</span> <span class="o">=</span> <span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">periods</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">periods</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">periods</span><span class="p">),</span>
<span class="gp">... </span>                          <span class="n">periods</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span><span class="p">(</span><span class="n">ddf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">     x    y</span>
<span class="go">0  NaN  NaN</span>
<span class="go">1  1.0  1.0</span>
<span class="go">2  2.0  1.0</span>
<span class="go">3  3.0  1.0</span>
<span class="go">4  4.0  1.0</span>
</pre></div>
</div>
<p>If you have a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>, you can use a <code class="docutils literal notranslate"><span class="pre">pd.Timedelta</span></code> for time-
based windows.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2017&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dts</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dts</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="s1">&#39;2D&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
<span class="gp">... </span>                <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="s1">&#39;2D&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">2017-01-01     0.0</span>
<span class="go">2017-01-02     1.0</span>
<span class="go">2017-01-03     3.0</span>
<span class="go">2017-01-04     5.0</span>
<span class="go">2017-01-05     7.0</span>
<span class="go">2017-01-06     9.0</span>
<span class="go">2017-01-07    11.0</span>
<span class="go">2017-01-08    13.0</span>
<span class="go">2017-01-09    15.0</span>
<span class="go">2017-01-10    17.0</span>
<span class="go">Freq: D, dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.map_partitions">
<code class="sig-name descname">map_partitions</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.map_partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Python function on each DataFrame partition.</p>
<p>Note that the index and divisions are assumed to remain unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function applied to each partition.</p>
</dd>
<dt><strong>args, kwargs :</strong></dt><dd><p>Arguments and keywords to pass to the function. The partition will
be the first argument, and these will be passed <em>after</em>. Arguments
and keywords may contain <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>, <code class="docutils literal notranslate"><span class="pre">Delayed</span></code> or regular
python objects. DataFrame-like args (both dask and pandas) will be
repartitioned to align (if necessary) before applying the function.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes
and column names of the output. This metadata is necessary for
many algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code>
can be provided (note that the order of the names should match the
order of the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span>
<span class="pre">dtype)</span></code> can be used. If not provided, dask will try to infer the
metadata. This may lead to unexpected results, so providing
<code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For more information, see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Given a DataFrame, Series, or Index, such as:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">map_partitions</span></code> to apply a function on each partition.
Extra arguments and keywords can optionally be provided, and will be
passed to the function after the partition.</p>
<p>Here we apply a function with arguments and keywords to a DataFrame,
resulting in a Series:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">myadd</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">df</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">myadd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<p>By default, dask tries to infer the output metadata by running your
provided function on some fake data. This works well in many cases, but
can sometimes be expensive, or even fail. To avoid this, you can
manually specify the output metadata with the <code class="docutils literal notranslate"><span class="pre">meta</span></code> keyword. This
can be specified in many forms, for more information see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
<p>Here we specify the output is a Series with no name, and dtype
<code class="docutils literal notranslate"><span class="pre">float64</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">myadd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;f8&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Here we map a function that takes in a DataFrame, and returns a
DataFrame with a new column:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">df</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">dtypes</span>
<span class="go">x      int64</span>
<span class="go">y    float64</span>
<span class="go">z    float64</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>As before, the output metadata can also be specified manually. This
time we pass in a <code class="docutils literal notranslate"><span class="pre">dict</span></code>, as the output is a DataFrame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">df</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">meta</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;f8&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;f8&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>In the case where the metadata doesn’t change, you can also pass in
the object itself directly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">(),</span> <span class="n">meta</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>Also note that the index and divisions are assumed to remain unchanged.
If the function you’re mapping changes the index/divisions, you’ll need
to clear them afterwards:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">clear_divisions</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.mask">
<code class="sig-name descname">mask</code><span class="sig-paren">(</span><em class="sig-param">cond</em>, <em class="sig-param">other=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values where the condition is True.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.mask.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cond</strong><span class="classifier">bool Series/DataFrame, array-like, or callable</span></dt><dd><p>Where <cite>cond</cite> is False, keep the original value. Where
True, replace with corresponding value from <cite>other</cite>.
If <cite>cond</cite> is callable, it is computed on the Series/DataFrame and
should return boolean Series/DataFrame or array. The callable must
not change input Series/DataFrame (though pandas doesn’t check it).</p>
</dd>
<dt><strong>other</strong><span class="classifier">scalar, Series/DataFrame, or callable</span></dt><dd><p>Entries where <cite>cond</cite> is True are replaced with
corresponding value from <cite>other</cite>.
If other is callable, it is computed on the Series/DataFrame and
should return scalar or Series/DataFrame. The callable must not
change input Series/DataFrame (though pandas doesn’t check it).</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Whether to perform the operation in place on the data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, default None  (Not supported in Dask)</span></dt><dd><p>Alignment axis if needed.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int, default None  (Not supported in Dask)</span></dt><dd><p>Alignment level if needed.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, {‘raise’, ‘ignore’}, default ‘raise’  (Not supported in Dask)</span></dt><dd><p>Note that currently this parameter won’t affect
the results and will always coerce to a suitable dtype.</p>
<ul class="simple">
<li><p>‘raise’ : allow exceptions to be raised.</p></li>
<li><p>‘ignore’ : suppress exceptions. On error return original object.</p></li>
</ul>
</dd>
<dt><strong>try_cast</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Try to cast the result back to the input type (if possible).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Same type as caller</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.where" title="dask.dataframe.DataFrame.where"><code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.where()</span></code></a></dt><dd><p>Return an object of same shape as self.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The mask method is an application of the if-then idiom. For each
element in the calling DataFrame, if <code class="docutils literal notranslate"><span class="pre">cond</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> the
element is used; otherwise the corresponding element from the DataFrame
<code class="docutils literal notranslate"><span class="pre">other</span></code> is used.</p>
<p>The signature for <a class="reference internal" href="#dask.dataframe.DataFrame.where" title="dask.dataframe.DataFrame.where"><code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.where()</span></code></a> differs from
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html#numpy.where" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.where()</span></code></a>. Roughly <code class="docutils literal notranslate"><span class="pre">df1.where(m,</span> <span class="pre">df2)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">np.where(m,</span> <span class="pre">df1,</span> <span class="pre">df2)</span></code>.</p>
<p>For further details and examples see the <code class="docutils literal notranslate"><span class="pre">mask</span></code> documentation in
<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#indexing-where-mask" title="(in pandas v1.0.3)"><span class="xref std std-ref">indexing</span></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  
<span class="go">0    NaN</span>
<span class="go">1    1.0</span>
<span class="go">2    2.0</span>
<span class="go">3    3.0</span>
<span class="go">4    4.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  
<span class="go">0    0.0</span>
<span class="go">1    NaN</span>
<span class="go">2    NaN</span>
<span class="go">3    NaN</span>
<span class="go">4    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  
<span class="go">0    10</span>
<span class="go">1    10</span>
<span class="go">2    2</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A  B</span>
<span class="go">0  0  1</span>
<span class="go">1  2  3</span>
<span class="go">2  4  5</span>
<span class="go">3  6  7</span>
<span class="go">4  8  9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">df</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>  
<span class="go">   A  B</span>
<span class="go">0  0 -1</span>
<span class="go">1 -2  3</span>
<span class="go">2 -4 -5</span>
<span class="go">3  6 -7</span>
<span class="go">4 -8  9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>  
<span class="go">      A     B</span>
<span class="go">0  True  True</span>
<span class="go">1  True  True</span>
<span class="go">2  True  True</span>
<span class="go">3  True  True</span>
<span class="go">4  True  True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="n">df</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="o">~</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>  
<span class="go">      A     B</span>
<span class="go">0  True  True</span>
<span class="go">1  True  True</span>
<span class="go">2  True  True</span>
<span class="go">3  True  True</span>
<span class="go">4  True  True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of the values for the requested axis.</p>
<blockquote>
<div><p>This docstring was copied from pandas.core.frame.DataFrame.max.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>If you want the <em>index</em> of the maximum, use <code class="docutils literal notranslate"><span class="pre">idxmax</span></code>. This is
the equivalent of the <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> method <code class="docutils literal notranslate"><span class="pre">argmax</span></code>.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd><p>Axis for the function to be applied on.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to be passed to the function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.sum" title="dask.dataframe.Series.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.sum</span></code></a></dt><dd><p>Return the sum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.min" title="dask.dataframe.Series.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.min</span></code></a></dt><dd><p>Return the minimum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.max" title="dask.dataframe.Series.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.max</span></code></a></dt><dd><p>Return the maximum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.idxmin" title="dask.dataframe.Series.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmin</span></code></a></dt><dd><p>Return the index of the minimum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.idxmax" title="dask.dataframe.Series.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmax</span></code></a></dt><dd><p>Return the index of the maximum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sum" title="dask.dataframe.DataFrame.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sum</span></code></a></dt><dd><p>Return the sum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.min" title="dask.dataframe.DataFrame.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.min</span></code></a></dt><dd><p>Return the minimum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.max" title="dask.dataframe.DataFrame.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.max</span></code></a></dt><dd><p>Return the maximum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.idxmin" title="dask.dataframe.DataFrame.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.idxmin</span></code></a></dt><dd><p>Return the index of the minimum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.idxmax" title="dask.dataframe.DataFrame.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.idxmax</span></code></a></dt><dd><p>Return the index of the maximum over the requested axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">([</span>  
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;warm&#39;</span><span class="p">,</span> <span class="s1">&#39;warm&#39;</span><span class="p">,</span> <span class="s1">&#39;cold&#39;</span><span class="p">,</span> <span class="s1">&#39;cold&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="s1">&#39;falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;spider&#39;</span><span class="p">]],</span>
<span class="gp">... </span>    <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;blooded&#39;</span><span class="p">,</span> <span class="s1">&#39;animal&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;legs&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">blooded  animal</span>
<span class="go">warm     dog       4</span>
<span class="go">         falcon    2</span>
<span class="go">cold     fish      0</span>
<span class="go">         spider    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  
<span class="go">8</span>
</pre></div>
</div>
<p>Max using level names, as well as indices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;blooded&#39;</span><span class="p">)</span>  
<span class="go">blooded</span>
<span class="go">warm    4</span>
<span class="go">cold    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">blooded</span>
<span class="go">warm    4</span>
<span class="go">cold    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean of the values for the requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.mean.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd><p>Axis for the function to be applied on.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to be passed to the function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.melt">
<code class="sig-name descname">melt</code><span class="sig-paren">(</span><em class="sig-param">id_vars=None</em>, <em class="sig-param">value_vars=None</em>, <em class="sig-param">var_name=None</em>, <em class="sig-param">value_name='value'</em>, <em class="sig-param">col_level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.melt" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpivots a DataFrame from wide format to long format,
optionally leaving identifier variables set.</p>
<p>This function is useful to massage a DataFrame into a format where
one or more columns are identifier variables (<code class="docutils literal notranslate"><span class="pre">id_vars</span></code>), while
all other columns, considered measured variables (<code class="docutils literal notranslate"><span class="pre">value_vars</span></code>),
are “unpivoted” to the row axis, leaving just two non-identifier
columns, ‘variable’ and ‘value’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frame</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>id_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to use as identifier variables.</p>
</dd>
<dt><strong>value_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to unpivot. If not specified, uses all columns that
are not set as <cite>id_vars</cite>.</p>
</dd>
<dt><strong>var_name</strong><span class="classifier">scalar</span></dt><dd><p>Name to use for the ‘variable’ column. If None it uses
<code class="docutils literal notranslate"><span class="pre">frame.columns.name</span></code> or ‘variable’.</p>
</dd>
<dt><strong>value_name</strong><span class="classifier">scalar, default ‘value’</span></dt><dd><p>Name to use for the ‘value’ column.</p>
</dd>
<dt><strong>col_level</strong><span class="classifier">int or string, optional</span></dt><dd><p>If columns are a MultiIndex then use this level to melt.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Unpivoted DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.melt.html#pandas.DataFrame.melt" title="(in pandas v1.0.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame.melt</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.memory_usage">
<code class="sig-name descname">memory_usage</code><span class="sig-paren">(</span><em class="sig-param">index=True</em>, <em class="sig-param">deep=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.memory_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memory usage of each column in bytes.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.memory_usage.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The memory usage can optionally include the contribution of
the index and elements of <cite>object</cite> dtype.</p>
<p>This value is displayed in <cite>DataFrame.info</cite> by default. This can be
suppressed by setting <code class="docutils literal notranslate"><span class="pre">pandas.options.display.memory_usage</span></code> to False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Specifies whether to include the memory usage of the DataFrame’s
index in returned Series. If <code class="docutils literal notranslate"><span class="pre">index=True</span></code>, the memory usage of
the index is the first item in the output.</p>
</dd>
<dt><strong>deep</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, introspect the data deeply by interrogating
<cite>object</cite> dtypes for system-level memory consumption, and include
it in the returned values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>A Series whose index is the original column names and whose values
is the memory usage of each column in bytes.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.nbytes.html#numpy.ndarray.nbytes" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray.nbytes</span></code></a></dt><dd><p>Total bytes consumed by the elements of an ndarray.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.memory_usage" title="dask.dataframe.Series.memory_usage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.memory_usage</span></code></a></dt><dd><p>Bytes consumed by a Series.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Categorical</span></code></dt><dd><p>Memory-efficient array for string values with many repeated values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.info" title="dask.dataframe.DataFrame.info"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.info</span></code></a></dt><dd><p>Concise summary of a DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;int64&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="s1">&#39;complex128&#39;</span><span class="p">,</span> <span class="s1">&#39;object&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>  
<span class="gp">... </span>             <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">dtypes</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>  
<span class="go">   int64  float64            complex128  object  bool</span>
<span class="go">0      1      1.0    1.000000+0.000000j       1  True</span>
<span class="go">1      1      1.0    1.000000+0.000000j       1  True</span>
<span class="go">2      1      1.0    1.000000+0.000000j       1  True</span>
<span class="go">3      1      1.0    1.000000+0.000000j       1  True</span>
<span class="go">4      1      1.0    1.000000+0.000000j       1  True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">()</span>  
<span class="go">Index           128</span>
<span class="go">int64         40000</span>
<span class="go">float64       40000</span>
<span class="go">complex128    80000</span>
<span class="go">object        40000</span>
<span class="go">bool           5000</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">int64         40000</span>
<span class="go">float64       40000</span>
<span class="go">complex128    80000</span>
<span class="go">object        40000</span>
<span class="go">bool           5000</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>The memory footprint of <cite>object</cite> dtype columns is ignored by default:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">Index            128</span>
<span class="go">int64          40000</span>
<span class="go">float64        40000</span>
<span class="go">complex128     80000</span>
<span class="go">object        160000</span>
<span class="go">bool            5000</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Use a Categorical for efficient storage of an object-dtype column with
many repeated values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;object&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">5216</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.memory_usage_per_partition">
<code class="sig-name descname">memory_usage_per_partition</code><span class="sig-paren">(</span><em class="sig-param">index=True</em>, <em class="sig-param">deep=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.memory_usage_per_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memory usage of each partition</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Specifies whether to include the memory usage of the index in
returned Series.</p>
</dd>
<dt><strong>deep</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, introspect the data deeply by interrogating
<code class="docutils literal notranslate"><span class="pre">object</span></code> dtypes for system-level memory consumption, and include
it in the returned values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>A Series whose index is the parition number and whose values
are the memory usage of each partition in bytes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.merge">
<code class="sig-name descname">merge</code><span class="sig-paren">(</span><em class="sig-param">right</em>, <em class="sig-param">how='inner'</em>, <em class="sig-param">on=None</em>, <em class="sig-param">left_on=None</em>, <em class="sig-param">right_on=None</em>, <em class="sig-param">left_index=False</em>, <em class="sig-param">right_index=False</em>, <em class="sig-param">suffixes=('_x'</em>, <em class="sig-param">'_y')</em>, <em class="sig-param">indicator=False</em>, <em class="sig-param">npartitions=None</em>, <em class="sig-param">shuffle=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the DataFrame with another DataFrame</p>
<p>This will merge the two datasets, either on the indices, a certain column
in each dataset or the index in one dataset and the column in another.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>right: dask.dataframe.DataFrame</strong></dt><dd></dd>
<dt><strong>how</strong><span class="classifier">{‘left’, ‘right’, ‘outer’, ‘inner’}, default: ‘inner’</span></dt><dd><p>How to handle the operation of the two objects:</p>
<ul class="simple">
<li><p>left: use calling frame’s index (or column if on is specified)</p></li>
<li><p>right: use other frame’s index</p></li>
<li><p>outer: form union of calling frame’s index (or column if on is
specified) with other frame’s index, and sort it
lexicographically</p></li>
<li><p>inner: form intersection of calling frame’s index (or column if
on is specified) with other frame’s index, preserving the order
of the calling’s one</p></li>
</ul>
</dd>
<dt><strong>on</strong><span class="classifier">label or list</span></dt><dd><p>Column or index level names to join on. These must be found in both
DataFrames. If on is None and not merging on indexes then this
defaults to the intersection of the columns in both DataFrames.</p>
</dd>
<dt><strong>left_on</strong><span class="classifier">label or list, or array-like</span></dt><dd><p>Column to join on in the left DataFrame. Other than in pandas
arrays and lists are only support if their length is 1.</p>
</dd>
<dt><strong>right_on</strong><span class="classifier">label or list, or array-like</span></dt><dd><p>Column to join on in the right DataFrame. Other than in pandas
arrays and lists are only support if their length is 1.</p>
</dd>
<dt><strong>left_index</strong><span class="classifier">boolean, default False</span></dt><dd><p>Use the index from the left DataFrame as the join key.</p>
</dd>
<dt><strong>right_index</strong><span class="classifier">boolean, default False</span></dt><dd><p>Use the index from the right DataFrame as the join key.</p>
</dd>
<dt><strong>suffixes</strong><span class="classifier">2-length sequence (tuple, list, …)</span></dt><dd><p>Suffix to apply to overlapping column names in the left and
right side, respectively</p>
</dd>
<dt><strong>indicator</strong><span class="classifier">boolean or string, default False</span></dt><dd><p>If True, adds a column to output DataFrame called “_merge” with
information on the source of each row. If string, column with
information on source of each row will be added to output DataFrame,
and column will be named value of string. Information column is
Categorical-type and takes on a value of “left_only” for observations
whose merge key only appears in <cite>left</cite> DataFrame, “right_only” for
observations whose merge key only appears in <cite>right</cite> DataFrame,
and “both” if the observation’s merge key is found in both.</p>
</dd>
<dt><strong>npartitions: int or None, optional</strong></dt><dd><p>The ideal number of output partitions. This is only utilised when
performing a hash_join (merging on columns only). If <code class="docutils literal notranslate"><span class="pre">None</span></code> then
<code class="docutils literal notranslate"><span class="pre">npartitions</span> <span class="pre">=</span> <span class="pre">max(lhs.npartitions,</span> <span class="pre">rhs.npartitions)</span></code>.
Default is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>shuffle: {‘disk’, ‘tasks’}, optional</strong></dt><dd><p>Either <code class="docutils literal notranslate"><span class="pre">'disk'</span></code> for single-node operation or <code class="docutils literal notranslate"><span class="pre">'tasks'</span></code> for
distributed operation.  Will be inferred by your current scheduler.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>There are three ways to join dataframes:</p>
<ol class="arabic simple">
<li><p>Joining on indices. In this case the divisions are
aligned using the function <code class="docutils literal notranslate"><span class="pre">dask.dataframe.multi.align_partitions</span></code>.
Afterwards, each partition is merged with the pandas merge function.</p></li>
<li><p>Joining one on index and one on column. In this case the divisions of
dataframe merged by index (<span class="math notranslate nohighlight">\(d_i\)</span>) are used to divide the column
merged dataframe (<span class="math notranslate nohighlight">\(d_c\)</span>) one using
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.multi.rearrange_by_divisions</span></code>. In this case the
merged dataframe (<span class="math notranslate nohighlight">\(d_m\)</span>) has the exact same divisions
as (<span class="math notranslate nohighlight">\(d_i\)</span>). This can lead to issues if you merge multiple rows from
(<span class="math notranslate nohighlight">\(d_c\)</span>) to one row in (<span class="math notranslate nohighlight">\(d_i\)</span>).</p></li>
<li><p>Joining both on columns. In this case a hash join is performed using
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.multi.hash_join</span></code>.</p></li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum of the values for the requested axis.</p>
<blockquote>
<div><p>This docstring was copied from pandas.core.frame.DataFrame.min.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>If you want the <em>index</em> of the minimum, use <code class="docutils literal notranslate"><span class="pre">idxmin</span></code>. This is
the equivalent of the <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> method <code class="docutils literal notranslate"><span class="pre">argmin</span></code>.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd><p>Axis for the function to be applied on.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to be passed to the function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.sum" title="dask.dataframe.Series.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.sum</span></code></a></dt><dd><p>Return the sum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.min" title="dask.dataframe.Series.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.min</span></code></a></dt><dd><p>Return the minimum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.max" title="dask.dataframe.Series.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.max</span></code></a></dt><dd><p>Return the maximum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.idxmin" title="dask.dataframe.Series.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmin</span></code></a></dt><dd><p>Return the index of the minimum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.idxmax" title="dask.dataframe.Series.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmax</span></code></a></dt><dd><p>Return the index of the maximum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sum" title="dask.dataframe.DataFrame.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sum</span></code></a></dt><dd><p>Return the sum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.min" title="dask.dataframe.DataFrame.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.min</span></code></a></dt><dd><p>Return the minimum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.max" title="dask.dataframe.DataFrame.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.max</span></code></a></dt><dd><p>Return the maximum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.idxmin" title="dask.dataframe.DataFrame.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.idxmin</span></code></a></dt><dd><p>Return the index of the minimum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.idxmax" title="dask.dataframe.DataFrame.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.idxmax</span></code></a></dt><dd><p>Return the index of the maximum over the requested axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">([</span>  
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;warm&#39;</span><span class="p">,</span> <span class="s1">&#39;warm&#39;</span><span class="p">,</span> <span class="s1">&#39;cold&#39;</span><span class="p">,</span> <span class="s1">&#39;cold&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="s1">&#39;falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;spider&#39;</span><span class="p">]],</span>
<span class="gp">... </span>    <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;blooded&#39;</span><span class="p">,</span> <span class="s1">&#39;animal&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;legs&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">blooded  animal</span>
<span class="go">warm     dog       4</span>
<span class="go">         falcon    2</span>
<span class="go">cold     fish      0</span>
<span class="go">         spider    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>  
<span class="go">0</span>
</pre></div>
</div>
<p>Min using level names, as well as indices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;blooded&#39;</span><span class="p">)</span>  
<span class="go">blooded</span>
<span class="go">warm    2</span>
<span class="go">cold    0</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">blooded</span>
<span class="go">warm    2</span>
<span class="go">cold    0</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.mod">
<code class="sig-name descname">mod</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Modulo of dataframe and other, element-wise (binary operator <cite>mod</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.mod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">%</span> <span class="pre">other</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>rmod</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.mul">
<code class="sig-name descname">mul</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Multiplication of dataframe and other, element-wise (binary operator <cite>mul</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.mul.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">*</span> <span class="pre">other</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>rmul</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.ndim">
<em class="property">property </em><code class="sig-name descname">ndim</code><a class="headerlink" href="#dask.dataframe.DataFrame.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dimensionality</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.ne">
<code class="sig-name descname">ne</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.ne" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Not equal to of dataframe and other, element-wise (binary operator <cite>ne</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.ne.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Among flexible wrappers (<cite>eq</cite>, <cite>ne</cite>, <cite>le</cite>, <cite>lt</cite>, <cite>ge</cite>, <cite>gt</cite>) to comparison
operators.</p>
<p>Equivalent to <cite>==</cite>, <cite>=!</cite>, <cite>&lt;=</cite>, <cite>&lt;</cite>, <cite>&gt;=</cite>, <cite>&gt;</cite> with support to choose axis
(rows or columns) and level for comparison.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default ‘columns’</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’).</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the passed
MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame of bool</strong></dt><dd><p>Result of the comparison.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.eq" title="dask.dataframe.DataFrame.eq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.eq</span></code></a></dt><dd><p>Compare DataFrames for equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.ne" title="dask.dataframe.DataFrame.ne"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.ne</span></code></a></dt><dd><p>Compare DataFrames for inequality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.le" title="dask.dataframe.DataFrame.le"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.le</span></code></a></dt><dd><p>Compare DataFrames for less than inequality or equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.lt" title="dask.dataframe.DataFrame.lt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.lt</span></code></a></dt><dd><p>Compare DataFrames for strictly less than inequality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.ge" title="dask.dataframe.DataFrame.ge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.ge</span></code></a></dt><dd><p>Compare DataFrames for greater than inequality or equality elementwise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.gt" title="dask.dataframe.DataFrame.gt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.gt</span></code></a></dt><dd><p>Compare DataFrames for strictly greater than inequality elementwise.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.
<cite>NaN</cite> values are considered different (i.e. <cite>NaN</cite> != <cite>NaN</cite>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cost&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">300</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   cost  revenue</span>
<span class="go">A   250      100</span>
<span class="go">B   150      250</span>
<span class="go">C   100      300</span>
</pre></div>
</div>
<p>Comparison with a scalar, using either the operator or method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">==</span> <span class="mi">100</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False     True</span>
<span class="go">B  False    False</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False     True</span>
<span class="go">B  False    False</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<p>When <cite>other</cite> is a <a class="reference internal" href="#dask.dataframe.Series" title="dask.dataframe.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>, the columns of a DataFrame are aligned
with the index of <cite>other</cite> and broadcast:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">!=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cost&quot;</span><span class="p">,</span> <span class="s2">&quot;revenue&quot;</span><span class="p">])</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True     True</span>
<span class="go">B   True    False</span>
<span class="go">C  False     True</span>
</pre></div>
</div>
<p>Use the method to control the broadcast axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>  
<span class="go">   cost  revenue</span>
<span class="go">A  True    False</span>
<span class="go">B  True     True</span>
<span class="go">C  True     True</span>
<span class="go">D  True     True</span>
</pre></div>
</div>
<p>When comparing to an arbitrary sequence, the number of columns must
match the number elements in <cite>other</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">==</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True     True</span>
<span class="go">B  False    False</span>
<span class="go">C  False    False</span>
</pre></div>
</div>
<p>Use the method to control the axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">eq</span><span class="p">([</span><span class="mi">250</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A   True    False</span>
<span class="go">B  False     True</span>
<span class="go">C   True    False</span>
</pre></div>
</div>
<p>Compare to a DataFrame of different shape.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">   revenue</span>
<span class="go">A      300</span>
<span class="go">B      250</span>
<span class="go">C      100</span>
<span class="go">D      150</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  
<span class="go">    cost  revenue</span>
<span class="go">A  False    False</span>
<span class="go">B  False    False</span>
<span class="go">C  False     True</span>
<span class="go">D  False    False</span>
</pre></div>
</div>
<p>Compare to a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cost&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">220</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;revenue&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">175</span><span class="p">,</span> <span class="mi">225</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Q2&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">      cost  revenue</span>
<span class="go">Q1 A   250      100</span>
<span class="go">   B   150      250</span>
<span class="go">   C   100      300</span>
<span class="go">Q2 A   150      200</span>
<span class="go">   B   300      175</span>
<span class="go">   C   220      225</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">       cost  revenue</span>
<span class="go">Q1 A   True     True</span>
<span class="go">   B   True     True</span>
<span class="go">   C   True     True</span>
<span class="go">Q2 A  False     True</span>
<span class="go">   B   True    False</span>
<span class="go">   C   True    False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.nlargest">
<code class="sig-name descname">nlargest</code><span class="sig-paren">(</span><em class="sig-param">n=5</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">split_every=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.nlargest" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first <cite>n</cite> rows ordered by <cite>columns</cite> in descending order.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.nlargest.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the first <cite>n</cite> rows with the largest values in <cite>columns</cite>, in
descending order. The columns that are not specified are returned as
well, but not used for ordering.</p>
<p>This method is equivalent to
<code class="docutils literal notranslate"><span class="pre">df.sort_values(columns,</span> <span class="pre">ascending=False).head(n)</span></code>, but more
performant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of rows to return.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">label or list of labels</span></dt><dd><p>Column label(s) to order by.</p>
</dd>
<dt><strong>keep</strong><span class="classifier">{‘first’, ‘last’, ‘all’}, default ‘first’  (Not supported in Dask)</span></dt><dd><p>Where there are duplicate values:</p>
<ul class="simple">
<li><p><cite>first</cite> : prioritize the first occurrence(s)</p></li>
<li><p><cite>last</cite> : prioritize the last occurrence(s)</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="classifier">do not drop any duplicates, even it means</span></dt><dd><p>selecting more than <cite>n</cite> items.</p>
</dd>
</dl>
</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>The first <cite>n</cite> rows ordered by the given columns in descending
order.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.nsmallest" title="dask.dataframe.DataFrame.nsmallest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.nsmallest</span></code></a></dt><dd><p>Return the first <cite>n</cite> rows ordered by <cite>columns</cite> in ascending order.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sort_values</span></code></dt><dd><p>Sort DataFrame by the values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.head" title="dask.dataframe.DataFrame.head"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.head</span></code></a></dt><dd><p>Return the first <cite>n</cite> rows without re-ordering.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function cannot be used with all column types. For example, when
specifying columns with <cite>object</cite> or <cite>category</cite> dtypes, <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> is
raised.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;population&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">59000000</span><span class="p">,</span> <span class="mi">65000000</span><span class="p">,</span> <span class="mi">434000</span><span class="p">,</span>  
<span class="gp">... </span>                                  <span class="mi">434000</span><span class="p">,</span> <span class="mi">434000</span><span class="p">,</span> <span class="mi">337000</span><span class="p">,</span> <span class="mi">11300</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="mi">11300</span><span class="p">,</span> <span class="mi">11300</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;GDP&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1937894</span><span class="p">,</span> <span class="mi">2583560</span> <span class="p">,</span> <span class="mi">12011</span><span class="p">,</span> <span class="mi">4520</span><span class="p">,</span> <span class="mi">12128</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="mi">17036</span><span class="p">,</span> <span class="mi">182</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">311</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;alpha-2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;IT&quot;</span><span class="p">,</span> <span class="s2">&quot;FR&quot;</span><span class="p">,</span> <span class="s2">&quot;MT&quot;</span><span class="p">,</span> <span class="s2">&quot;MV&quot;</span><span class="p">,</span> <span class="s2">&quot;BN&quot;</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s2">&quot;IS&quot;</span><span class="p">,</span> <span class="s2">&quot;NR&quot;</span><span class="p">,</span> <span class="s2">&quot;TV&quot;</span><span class="p">,</span> <span class="s2">&quot;AI&quot;</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Italy&quot;</span><span class="p">,</span> <span class="s2">&quot;France&quot;</span><span class="p">,</span> <span class="s2">&quot;Malta&quot;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="s2">&quot;Maldives&quot;</span><span class="p">,</span> <span class="s2">&quot;Brunei&quot;</span><span class="p">,</span> <span class="s2">&quot;Iceland&quot;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="s2">&quot;Nauru&quot;</span><span class="p">,</span> <span class="s2">&quot;Tuvalu&quot;</span><span class="p">,</span> <span class="s2">&quot;Anguilla&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">          population      GDP alpha-2</span>
<span class="go">Italy       59000000  1937894      IT</span>
<span class="go">France      65000000  2583560      FR</span>
<span class="go">Malta         434000    12011      MT</span>
<span class="go">Maldives      434000     4520      MV</span>
<span class="go">Brunei        434000    12128      BN</span>
<span class="go">Iceland       337000    17036      IS</span>
<span class="go">Nauru          11300      182      NR</span>
<span class="go">Tuvalu         11300       38      TV</span>
<span class="go">Anguilla       11300      311      AI</span>
</pre></div>
</div>
<p>In the following example, we will use <code class="docutils literal notranslate"><span class="pre">nlargest</span></code> to select the three
rows having the largest values in column “population”.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;population&#39;</span><span class="p">)</span>  
<span class="go">        population      GDP alpha-2</span>
<span class="go">France    65000000  2583560      FR</span>
<span class="go">Italy     59000000  1937894      IT</span>
<span class="go">Malta       434000    12011      MT</span>
</pre></div>
</div>
<p>When using <code class="docutils literal notranslate"><span class="pre">keep='last'</span></code>, ties are resolved in reverse order:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;population&#39;</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">)</span>  
<span class="go">        population      GDP alpha-2</span>
<span class="go">France    65000000  2583560      FR</span>
<span class="go">Italy     59000000  1937894      IT</span>
<span class="go">Brunei      434000    12128      BN</span>
</pre></div>
</div>
<p>When using <code class="docutils literal notranslate"><span class="pre">keep='all'</span></code>, all duplicate items are maintained:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;population&#39;</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>  
<span class="go">          population      GDP alpha-2</span>
<span class="go">France      65000000  2583560      FR</span>
<span class="go">Italy       59000000  1937894      IT</span>
<span class="go">Malta         434000    12011      MT</span>
<span class="go">Maldives      434000     4520      MV</span>
<span class="go">Brunei        434000    12128      BN</span>
</pre></div>
</div>
<p>To order by the largest values in column “population” and then “GDP”,
we can specify multiple columns like in the next example.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;population&#39;</span><span class="p">,</span> <span class="s1">&#39;GDP&#39;</span><span class="p">])</span>  
<span class="go">        population      GDP alpha-2</span>
<span class="go">France    65000000  2583560      FR</span>
<span class="go">Italy     59000000  1937894      IT</span>
<span class="go">Brunei      434000    12128      BN</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.notnull">
<code class="sig-name descname">notnull</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.notnull" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect existing (non-missing) values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.notnull.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return a boolean same-sized object indicating if the values are not NA.
Non-missing values get mapped to True. Characters such as empty
strings <code class="docutils literal notranslate"><span class="pre">''</span></code> or <code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.inf</span></code> are not considered NA values
(unless you set <code class="docutils literal notranslate"><span class="pre">pandas.options.mode.use_inf_as_na</span> <span class="pre">=</span> <span class="pre">True</span></code>).
NA values, such as None or <code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.NaN</span></code>, get mapped to False
values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Mask of bool values for each element in DataFrame that
indicates whether an element is not an NA value.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.notnull" title="dask.dataframe.DataFrame.notnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.notnull</span></code></a></dt><dd><p>Alias of notna.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.isna" title="dask.dataframe.DataFrame.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.isna</span></code></a></dt><dd><p>Boolean inverse of notna.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.dropna" title="dask.dataframe.DataFrame.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.dropna</span></code></a></dt><dd><p>Omit axes labels with missing values.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">notna</span></code></dt><dd><p>Top-level notna.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Show which entries in a DataFrame are not NA.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;born&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1939-05-27&#39;</span><span class="p">),</span>
<span class="gp">... </span>                            <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1940-04-25&#39;</span><span class="p">)],</span>
<span class="gp">... </span>                   <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Alfred&#39;</span><span class="p">,</span> <span class="s1">&#39;Batman&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;toy&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Batmobile&#39;</span><span class="p">,</span> <span class="s1">&#39;Joker&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   age       born    name        toy</span>
<span class="go">0  5.0        NaT  Alfred       None</span>
<span class="go">1  6.0 1939-05-27  Batman  Batmobile</span>
<span class="go">2  NaN 1940-04-25              Joker</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>  
<span class="go">     age   born  name    toy</span>
<span class="go">0   True  False  True  False</span>
<span class="go">1   True   True  True   True</span>
<span class="go">2  False   True  True   True</span>
</pre></div>
</div>
<p>Show which entries in a Series are not NA.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>  
<span class="go">0    5.0</span>
<span class="go">1    6.0</span>
<span class="go">2    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>  
<span class="go">0     True</span>
<span class="go">1     True</span>
<span class="go">2    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.npartitions">
<em class="property">property </em><code class="sig-name descname">npartitions</code><a class="headerlink" href="#dask.dataframe.DataFrame.npartitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of partitions</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.nsmallest">
<code class="sig-name descname">nsmallest</code><span class="sig-paren">(</span><em class="sig-param">n=5</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">split_every=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.nsmallest" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first <cite>n</cite> rows ordered by <cite>columns</cite> in ascending order.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.nsmallest.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the first <cite>n</cite> rows with the smallest values in <cite>columns</cite>, in
ascending order. The columns that are not specified are returned as
well, but not used for ordering.</p>
<p>This method is equivalent to
<code class="docutils literal notranslate"><span class="pre">df.sort_values(columns,</span> <span class="pre">ascending=True).head(n)</span></code>, but more
performant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of items to retrieve.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list or str</span></dt><dd><p>Column name or names to order by.</p>
</dd>
<dt><strong>keep</strong><span class="classifier">{‘first’, ‘last’, ‘all’}, default ‘first’  (Not supported in Dask)</span></dt><dd><p>Where there are duplicate values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">first</span></code> : take the first occurrence.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">last</span></code> : take the last occurrence.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">all</span></code> : do not drop any duplicates, even it means
selecting more than <cite>n</cite> items.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.nlargest" title="dask.dataframe.DataFrame.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.nlargest</span></code></a></dt><dd><p>Return the first <cite>n</cite> rows ordered by <cite>columns</cite> in descending order.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sort_values</span></code></dt><dd><p>Sort DataFrame by the values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.head" title="dask.dataframe.DataFrame.head"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.head</span></code></a></dt><dd><p>Return the first <cite>n</cite> rows without re-ordering.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;population&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">59000000</span><span class="p">,</span> <span class="mi">65000000</span><span class="p">,</span> <span class="mi">434000</span><span class="p">,</span>  
<span class="gp">... </span>                                  <span class="mi">434000</span><span class="p">,</span> <span class="mi">434000</span><span class="p">,</span> <span class="mi">337000</span><span class="p">,</span> <span class="mi">11300</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="mi">11300</span><span class="p">,</span> <span class="mi">11300</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;GDP&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1937894</span><span class="p">,</span> <span class="mi">2583560</span> <span class="p">,</span> <span class="mi">12011</span><span class="p">,</span> <span class="mi">4520</span><span class="p">,</span> <span class="mi">12128</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="mi">17036</span><span class="p">,</span> <span class="mi">182</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">311</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;alpha-2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;IT&quot;</span><span class="p">,</span> <span class="s2">&quot;FR&quot;</span><span class="p">,</span> <span class="s2">&quot;MT&quot;</span><span class="p">,</span> <span class="s2">&quot;MV&quot;</span><span class="p">,</span> <span class="s2">&quot;BN&quot;</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s2">&quot;IS&quot;</span><span class="p">,</span> <span class="s2">&quot;NR&quot;</span><span class="p">,</span> <span class="s2">&quot;TV&quot;</span><span class="p">,</span> <span class="s2">&quot;AI&quot;</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Italy&quot;</span><span class="p">,</span> <span class="s2">&quot;France&quot;</span><span class="p">,</span> <span class="s2">&quot;Malta&quot;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="s2">&quot;Maldives&quot;</span><span class="p">,</span> <span class="s2">&quot;Brunei&quot;</span><span class="p">,</span> <span class="s2">&quot;Iceland&quot;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="s2">&quot;Nauru&quot;</span><span class="p">,</span> <span class="s2">&quot;Tuvalu&quot;</span><span class="p">,</span> <span class="s2">&quot;Anguilla&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">          population      GDP alpha-2</span>
<span class="go">Italy       59000000  1937894      IT</span>
<span class="go">France      65000000  2583560      FR</span>
<span class="go">Malta         434000    12011      MT</span>
<span class="go">Maldives      434000     4520      MV</span>
<span class="go">Brunei        434000    12128      BN</span>
<span class="go">Iceland       337000    17036      IS</span>
<span class="go">Nauru          11300      182      NR</span>
<span class="go">Tuvalu         11300       38      TV</span>
<span class="go">Anguilla       11300      311      AI</span>
</pre></div>
</div>
<p>In the following example, we will use <code class="docutils literal notranslate"><span class="pre">nsmallest</span></code> to select the
three rows having the smallest values in column “a”.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;population&#39;</span><span class="p">)</span>  
<span class="go">          population  GDP alpha-2</span>
<span class="go">Nauru          11300  182      NR</span>
<span class="go">Tuvalu         11300   38      TV</span>
<span class="go">Anguilla       11300  311      AI</span>
</pre></div>
</div>
<p>When using <code class="docutils literal notranslate"><span class="pre">keep='last'</span></code>, ties are resolved in reverse order:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;population&#39;</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">)</span>  
<span class="go">          population  GDP alpha-2</span>
<span class="go">Anguilla       11300  311      AI</span>
<span class="go">Tuvalu         11300   38      TV</span>
<span class="go">Nauru          11300  182      NR</span>
</pre></div>
</div>
<p>When using <code class="docutils literal notranslate"><span class="pre">keep='all'</span></code>, all duplicate items are maintained:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;population&#39;</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>  
<span class="go">          population  GDP alpha-2</span>
<span class="go">Nauru          11300  182      NR</span>
<span class="go">Tuvalu         11300   38      TV</span>
<span class="go">Anguilla       11300  311      AI</span>
</pre></div>
</div>
<p>To order by the largest values in column “a” and then “c”, we can
specify multiple columns like in the next example.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;population&#39;</span><span class="p">,</span> <span class="s1">&#39;GDP&#39;</span><span class="p">])</span>  
<span class="go">          population  GDP alpha-2</span>
<span class="go">Tuvalu         11300   38      TV</span>
<span class="go">Nauru          11300  182      NR</span>
<span class="go">Anguilla       11300  311      AI</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.nunique_approx">
<code class="sig-name descname">nunique_approx</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.nunique_approx" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate number of unique rows.</p>
<p>This method uses the HyperLogLog algorithm for cardinality
estimation to compute the approximate number of unique rows.
The approximate error is 0.406%.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>split_every</strong><span class="classifier">int, optional</span></dt><dd><p>Group partitions into groups of this size while performing a
tree-reduction. If set to False, no tree-reduction will be used.
Default is 8.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a float representing the approximate number of elements</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.partitions">
<em class="property">property </em><code class="sig-name descname">partitions</code><a class="headerlink" href="#dask.dataframe.DataFrame.partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice dataframe by partitions</p>
<p>This allows partitionwise slicing of a Dask Dataframe.  You can perform normal
Numpy-style slicing but now rather than slice elements of the array you
slice along partitions so, for example, <code class="docutils literal notranslate"><span class="pre">df.partitions[:5]</span></code> produces a new
Dask Dataframe of the first five partitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A Dask DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">partitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">partitions</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">partitions</span><span class="p">[::</span><span class="mi">10</span><span class="p">]</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.persist">
<code class="sig-name descname">persist</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.persist" title="Permalink to this definition">¶</a></dt>
<dd><p>Persist this dask collection into memory</p>
<p>This turns a lazy Dask collection into a Dask collection with the same
metadata, but now with the results fully computed or actively computing
in the background.</p>
<p>The action of function differs significantly depending on the active
task scheduler.  If the task scheduler supports asynchronous computing,
such as is the case of the dask.distributed scheduler, then persist
will return <em>immediately</em> and the return value’s task graph will
contain Dask Future objects.  However if the task scheduler only
supports blocking computation then the call to persist will <em>block</em>
and the return value’s task graph will contain concrete Python results.</p>
<p>This function is particularly useful when using distributed systems,
because the results will be kept in distributed memory, rather than
returned to the local process as with compute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scheduler</strong><span class="classifier">string, optional</span></dt><dd><p>Which scheduler to use like “threads”, “synchronous” or “processes”.
If not provided, the default is to check the global settings first,
and then fall back to the collection defaults.</p>
</dd>
<dt><strong>optimize_graph</strong><span class="classifier">bool, optional</span></dt><dd><p>If True [default], the graph is optimized before computation.
Otherwise the graph is run as is. This can be useful for debugging.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Extra keywords to forward to the scheduler function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>New dask collections backed by in-memory data</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.base.persist</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.pipe">
<code class="sig-name descname">pipe</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply func(self, *args, **kwargs).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.pipe.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function to apply to the Series/DataFrame.
<code class="docutils literal notranslate"><span class="pre">args</span></code>, and <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> are passed into <code class="docutils literal notranslate"><span class="pre">func</span></code>.
Alternatively a <code class="docutils literal notranslate"><span class="pre">(callable,</span> <span class="pre">data_keyword)</span></code> tuple where
<code class="docutils literal notranslate"><span class="pre">data_keyword</span></code> is a string indicating the keyword of
<code class="docutils literal notranslate"><span class="pre">callable</span></code> that expects the Series/DataFrame.</p>
</dd>
<dt><strong>args</strong><span class="classifier">iterable, optional</span></dt><dd><p>Positional arguments passed into <code class="docutils literal notranslate"><span class="pre">func</span></code>.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">mapping, optional</span></dt><dd><p>A dictionary of keyword arguments passed into <code class="docutils literal notranslate"><span class="pre">func</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>object</strong><span class="classifier">the return type of <code class="docutils literal notranslate"><span class="pre">func</span></code>.</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.DataFrame.apply" title="dask.dataframe.DataFrame.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.apply</span></code></a>, <a class="reference internal" href="#dask.dataframe.DataFrame.applymap" title="dask.dataframe.DataFrame.applymap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.applymap</span></code></a>, <a class="reference internal" href="#dask.dataframe.Series.map" title="dask.dataframe.Series.map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.map</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">.pipe</span></code> when chaining together functions that expect
Series, DataFrames or GroupBy objects. Instead of writing</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">arg1</span><span class="o">=</span><span class="n">a</span><span class="p">),</span> <span class="n">arg2</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">arg3</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>  
</pre></div>
</div>
<p>You can write</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>  
<span class="gp">... </span>   <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">arg1</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="gp">... </span>   <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">arg2</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">arg3</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>If you have a function that takes the data as (say) the second
argument, pass a tuple indicating which keyword expects the
data. For example, suppose <code class="docutils literal notranslate"><span class="pre">f</span></code> takes its data as <code class="docutils literal notranslate"><span class="pre">arg2</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>  
<span class="gp">... </span>   <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">arg1</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="gp">... </span>   <span class="o">.</span><span class="n">pipe</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;arg2&#39;</span><span class="p">),</span> <span class="n">arg1</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">arg3</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
<span class="gp">... </span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.pivot_table">
<code class="sig-name descname">pivot_table</code><span class="sig-paren">(</span><em class="sig-param">index=None</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">values=None</em>, <em class="sig-param">aggfunc='mean'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.pivot_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a spreadsheet-style pivot table as a DataFrame. Target <code class="docutils literal notranslate"><span class="pre">columns</span></code>
must have category dtype to infer result’s <code class="docutils literal notranslate"><span class="pre">columns</span></code>.
<code class="docutils literal notranslate"><span class="pre">index</span></code>, <code class="docutils literal notranslate"><span class="pre">columns</span></code>, <code class="docutils literal notranslate"><span class="pre">values</span></code> and <code class="docutils literal notranslate"><span class="pre">aggfunc</span></code> must be all scalar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">scalar</span></dt><dd><p>column to aggregate</p>
</dd>
<dt><strong>index</strong><span class="classifier">scalar</span></dt><dd><p>column to be index</p>
</dd>
<dt><strong>columns</strong><span class="classifier">scalar</span></dt><dd><p>column to be columns</p>
</dd>
<dt><strong>aggfunc</strong><span class="classifier">{‘mean’, ‘sum’, ‘count’}, default ‘mean’</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>table</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.pop">
<code class="sig-name descname">pop</code><span class="sig-paren">(</span><em class="sig-param">item</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Return item and drop from frame. Raise KeyError if not found.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.pop.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>item</strong><span class="classifier">str</span></dt><dd><p>Label of column to be popped.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([(</span><span class="s1">&#39;falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;bird&#39;</span><span class="p">,</span> <span class="mf">389.0</span><span class="p">),</span>  
<span class="gp">... </span>                   <span class="p">(</span><span class="s1">&#39;parrot&#39;</span><span class="p">,</span> <span class="s1">&#39;bird&#39;</span><span class="p">,</span> <span class="mf">24.0</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="p">(</span><span class="s1">&#39;lion&#39;</span><span class="p">,</span> <span class="s1">&#39;mammal&#39;</span><span class="p">,</span> <span class="mf">80.5</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="p">(</span><span class="s1">&#39;monkey&#39;</span><span class="p">,</span> <span class="s1">&#39;mammal&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)],</span>
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;class&#39;</span><span class="p">,</span> <span class="s1">&#39;max_speed&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     name   class  max_speed</span>
<span class="go">0  falcon    bird      389.0</span>
<span class="go">1  parrot    bird       24.0</span>
<span class="go">2    lion  mammal       80.5</span>
<span class="go">3  monkey  mammal        NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">)</span>  
<span class="go">0      bird</span>
<span class="go">1      bird</span>
<span class="go">2    mammal</span>
<span class="go">3    mammal</span>
<span class="go">Name: class, dtype: object</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     name  max_speed</span>
<span class="go">0  falcon      389.0</span>
<span class="go">1  parrot       24.0</span>
<span class="go">2    lion       80.5</span>
<span class="go">3  monkey        NaN</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.pow">
<code class="sig-name descname">pow</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.pow" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Exponential power of dataframe and other, element-wise (binary operator <cite>pow</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.pow.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">**</span> <span class="pre">other</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>rpow</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.prod">
<code class="sig-name descname">prod</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">min_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of the values for the requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.prod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd><p>Axis for the function to be applied on.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
<dt><strong>min_count</strong><span class="classifier">int, default 0</span></dt><dd><p>The required number of valid values to perform the operation. If fewer than
<code class="docutils literal notranslate"><span class="pre">min_count</span></code> non-NA values are present the result will be NA.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.22.0: </span>Added with the default being 0. This means the sum of an all-NA
or empty Series is 0, and the product of an all-NA or empty
Series is 1.</p>
</div>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to be passed to the function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>By default, the product of an empty or all-NA Series is <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>  
<span class="go">1.0</span>
</pre></div>
</div>
<p>This can be controlled with the <code class="docutils literal notranslate"><span class="pre">min_count</span></code> parameter</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">nan</span>
</pre></div>
</div>
<p>Thanks to the <code class="docutils literal notranslate"><span class="pre">skipna</span></code> parameter, <code class="docutils literal notranslate"><span class="pre">min_count</span></code> handles all-NA and
empty series identically.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>  
<span class="go">1.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.quantile">
<code class="sig-name descname">quantile</code><span class="sig-paren">(</span><em class="sig-param">q=0.5</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">method='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate row-wise and precise column-wise quantiles of DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q</strong><span class="classifier">list/array of floats, default 0.5 (50%)</span></dt><dd><p>Iterable of numbers ranging from 0 to 1 for the desired quantiles</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0, 1, ‘index’, ‘columns’} (default 0)</span></dt><dd><p>0 or ‘index’ for row-wise, 1 or ‘columns’ for column-wise</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘default’, ‘tdigest’, ‘dask’}, optional</span></dt><dd><p>What method to use. By default will use dask’s internal custom
algorithm (<code class="docutils literal notranslate"><span class="pre">'dask'</span></code>).  If set to <code class="docutils literal notranslate"><span class="pre">'tdigest'</span></code> will use tdigest
for floats and ints and fallback to the <code class="docutils literal notranslate"><span class="pre">'dask'</span></code> otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.query">
<code class="sig-name descname">query</code><span class="sig-paren">(</span><em class="sig-param">expr</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter dataframe with complex expression</p>
<p>Blocked version of pd.DataFrame.query</p>
<p>This is like the sequential version except that this will also happen
in many threads.  This may conflict with <code class="docutils literal notranslate"><span class="pre">numexpr</span></code> which will use
multiple threads itself.  We recommend that you set numexpr to use a
single thread</p>
<blockquote>
<div><p>import numexpr
numexpr.set_num_threads(1)</p>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query" title="(in pandas v1.0.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame.query</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.radd">
<code class="sig-name descname">radd</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.radd" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Addition of dataframe and other, element-wise (binary operator <cite>radd</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.radd.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">+</span> <span class="pre">dataframe</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>add</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.random_split">
<code class="sig-name descname">random_split</code><span class="sig-paren">(</span><em class="sig-param">frac</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">shuffle=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.random_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Pseudorandomly split dataframe into different pieces row-wise</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frac</strong><span class="classifier">list</span></dt><dd><p>List of floats that should sum to one.</p>
</dd>
<dt><strong>random_state</strong><span class="classifier">int or np.random.RandomState</span></dt><dd><p>If int create a new RandomState with this as the seed.
Otherwise draw from the passed RandomState.</p>
</dd>
<dt><strong>shuffle</strong><span class="classifier">bool, default False</span></dt><dd><p>If set to True, the dataframe is shuffled (within partition)
before the split.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.DataFrame.sample</span></code></p>
</div>
<p class="rubric">Examples</p>
<p>50/50 split</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">random_split</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>  
</pre></div>
</div>
<p>80/10/10 split, consistent random_state</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">random_split</span><span class="p">([</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.rdiv">
<code class="sig-name descname">rdiv</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.rdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Floating division of dataframe and other, element-wise (binary operator <cite>rtruediv</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.rdiv.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">/</span> <span class="pre">dataframe</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>truediv</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.reduction">
<code class="sig-name descname">reduction</code><span class="sig-paren">(</span><em class="sig-param">chunk</em>, <em class="sig-param">aggregate=None</em>, <em class="sig-param">combine=None</em>, <em class="sig-param">meta='__no_default__'</em>, <em class="sig-param">token=None</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">chunk_kwargs=None</em>, <em class="sig-param">aggregate_kwargs=None</em>, <em class="sig-param">combine_kwargs=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.reduction" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic row-wise reductions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>chunk</strong><span class="classifier">callable</span></dt><dd><p>Function to operate on each partition. Should return a
<code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>, <code class="docutils literal notranslate"><span class="pre">pandas.Series</span></code>, or a scalar.</p>
</dd>
<dt><strong>aggregate</strong><span class="classifier">callable, optional</span></dt><dd><p>Function to operate on the concatenated result of <code class="docutils literal notranslate"><span class="pre">chunk</span></code>. If not
specified, defaults to <code class="docutils literal notranslate"><span class="pre">chunk</span></code>. Used to do the final aggregation
in a tree reduction.</p>
<p>The input to <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> depends on the output of <code class="docutils literal notranslate"><span class="pre">chunk</span></code>.
If the output of <code class="docutils literal notranslate"><span class="pre">chunk</span></code> is a:</p>
<ul class="simple">
<li><p>scalar: Input is a Series, with one row per partition.</p></li>
<li><p>Series: Input is a DataFrame, with one row per partition. Columns
are the rows in the output series.</p></li>
<li><p>DataFrame: Input is a DataFrame, with one row per partition.
Columns are the columns in the output dataframes.</p></li>
</ul>
<p>Should return a <code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>, <code class="docutils literal notranslate"><span class="pre">pandas.Series</span></code>, or a
scalar.</p>
</dd>
<dt><strong>combine</strong><span class="classifier">callable, optional</span></dt><dd><p>Function to operate on intermediate concatenated results of
<code class="docutils literal notranslate"><span class="pre">chunk</span></code> in a tree-reduction. If not provided, defaults to
<code class="docutils literal notranslate"><span class="pre">aggregate</span></code>. The input/output requirements should match that of
<code class="docutils literal notranslate"><span class="pre">aggregate</span></code> described above.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes
and column names of the output. This metadata is necessary for
many algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code>
can be provided (note that the order of the names should match the
order of the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span>
<span class="pre">dtype)</span></code> can be used. If not provided, dask will try to infer the
metadata. This may lead to unexpected results, so providing
<code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For more information, see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
<dt><strong>token</strong><span class="classifier">str, optional</span></dt><dd><p>The name to use for the output keys.</p>
</dd>
<dt><strong>split_every</strong><span class="classifier">int, optional</span></dt><dd><p>Group partitions into groups of this size while performing a
tree-reduction. If set to False, no tree-reduction will be used,
and all intermediates will be concatenated and passed to
<code class="docutils literal notranslate"><span class="pre">aggregate</span></code>. Default is 8.</p>
</dd>
<dt><strong>chunk_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword arguments to pass on to <code class="docutils literal notranslate"><span class="pre">chunk</span></code> only.</p>
</dd>
<dt><strong>aggregate_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword arguments to pass on to <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> only.</p>
</dd>
<dt><strong>combine_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword arguments to pass on to <code class="docutils literal notranslate"><span class="pre">combine</span></code> only.</p>
</dd>
<dt><strong>kwargs :</strong></dt><dd><p>All remaining keywords will be passed to <code class="docutils literal notranslate"><span class="pre">chunk</span></code>, <code class="docutils literal notranslate"><span class="pre">combine</span></code>,
and <code class="docutils literal notranslate"><span class="pre">aggregate</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>Count the number of rows in a DataFrame. To do this, count the number
of rows in each partition, then sum the results:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">reduction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span>
<span class="gp">... </span>                    <span class="n">aggregate</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">x    50</span>
<span class="go">y    50</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Count the number of rows in a Series with elements greater than or
equal to a value (provided via a keyword).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">count_greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">reduction</span><span class="p">(</span><span class="n">count_greater</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
<span class="gp">... </span>                      <span class="n">chunk_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">25</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">25</span>
</pre></div>
</div>
<p>Aggregate both the sum and count of a Series at the same time:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sum_and_count</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span><span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()},</span>
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;sum&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">reduction</span><span class="p">(</span><span class="n">sum_and_count</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">count      50</span>
<span class="go">sum      1225</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Doing the same, but for a DataFrame. Here <code class="docutils literal notranslate"><span class="pre">chunk</span></code> returns a
DataFrame, meaning the input to <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> is a DataFrame with an
index with non-unique entries for both ‘x’ and ‘y’. We groupby the
index, and sum each group to get the final result.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sum_and_count</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()},</span>
<span class="gp">... </span>                        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;sum&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">reduction</span><span class="p">(</span><span class="n">sum_and_count</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">aggregate</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">   count   sum</span>
<span class="go">x     50  1225</span>
<span class="go">y     50  3725</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.rename">
<code class="sig-name descname">rename</code><span class="sig-paren">(</span><em class="sig-param">index=None</em>, <em class="sig-param">columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter axes labels.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.rename.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Function / dict values must be unique (1-to-1). Labels not contained in
a dict / Series will be left as-is. Extra labels listed don’t throw an
error.</p>
<p>See the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/getting_started/basics.html#basics-rename" title="(in pandas v1.0.3)"><span class="xref std std-ref">user guide</span></a> for more.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mapper</strong><span class="classifier">dict-like or function  (Not supported in Dask)</span></dt><dd><p>Dict-like or functions transformations to apply to
that axis’ values. Use either <code class="docutils literal notranslate"><span class="pre">mapper</span></code> and <code class="docutils literal notranslate"><span class="pre">axis</span></code> to
specify the axis to target with <code class="docutils literal notranslate"><span class="pre">mapper</span></code>, or <code class="docutils literal notranslate"><span class="pre">index</span></code> and
<code class="docutils literal notranslate"><span class="pre">columns</span></code>.</p>
</dd>
<dt><strong>index</strong><span class="classifier">dict-like or function  (Not supported in Dask)</span></dt><dd><p>Alternative to specifying axis (<code class="docutils literal notranslate"><span class="pre">mapper,</span> <span class="pre">axis=0</span></code>
is equivalent to <code class="docutils literal notranslate"><span class="pre">index=mapper</span></code>).</p>
</dd>
<dt><strong>columns</strong><span class="classifier">dict-like or function</span></dt><dd><p>Alternative to specifying axis (<code class="docutils literal notranslate"><span class="pre">mapper,</span> <span class="pre">axis=1</span></code>
is equivalent to <code class="docutils literal notranslate"><span class="pre">columns=mapper</span></code>).</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or str  (Not supported in Dask)</span></dt><dd><p>Axis to target with <code class="docutils literal notranslate"><span class="pre">mapper</span></code>. Can be either the axis name
(‘index’, ‘columns’) or number (0, 1). The default is ‘index’.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>Also copy underlying data.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Whether to return a new DataFrame. If True then value of copy is
ignored.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>In case of a MultiIndex, only rename labels in the specified
level.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">{‘ignore’, ‘raise’}, default ‘ignore’  (Not supported in Dask)</span></dt><dd><p>If ‘raise’, raise a <cite>KeyError</cite> when a dict-like <cite>mapper</cite>, <cite>index</cite>,
or <cite>columns</cite> contains labels that are not present in the Index
being transformed.
If ‘ignore’, existing keys will be renamed and extra keys will be
ignored.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>DataFrame with the renamed axis labels.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>KeyError</strong></dt><dd><p>If any of the labels is not found in the selected axis and
“errors=’raise’”.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.rename_axis</span></code></dt><dd><p>Set the name of the axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p><code class="docutils literal notranslate"><span class="pre">DataFrame.rename</span></code> supports two calling conventions</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(index=index_mapper,</span> <span class="pre">columns=columns_mapper,</span> <span class="pre">...)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(mapper,</span> <span class="pre">axis={'index',</span> <span class="pre">'columns'},</span> <span class="pre">...)</span></code></p></li>
</ul>
<p>We <em>highly</em> recommend using keyword arguments to clarify your
intent.</p>
<p>Rename columns using a mapping:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="s2">&quot;c&quot;</span><span class="p">})</span>  
<span class="go">   a  c</span>
<span class="go">0  1  4</span>
<span class="go">1  2  5</span>
<span class="go">2  3  6</span>
</pre></div>
</div>
<p>Rename index using a mapping:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;z&quot;</span><span class="p">})</span>  
<span class="go">   A  B</span>
<span class="go">x  1  4</span>
<span class="go">y  2  5</span>
<span class="go">z  3  6</span>
</pre></div>
</div>
<p>Cast index labels to a different type:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">index</span>  
<span class="go">RangeIndex(start=0, stop=3, step=1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>  
<span class="go">Index([&#39;0&#39;, &#39;1&#39;, &#39;2&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span> <span class="s2">&quot;c&quot;</span><span class="p">},</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">KeyError</span>: <span class="n">[&#39;C&#39;] not found in axis</span>
</pre></div>
</div>
<p>Using axis-style parameters</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">   a  b</span>
<span class="go">0  1  4</span>
<span class="go">1  2  5</span>
<span class="go">2  3  6</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>  
<span class="go">   A  B</span>
<span class="go">0  1  4</span>
<span class="go">2  2  5</span>
<span class="go">4  3  6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.repartition">
<code class="sig-name descname">repartition</code><span class="sig-paren">(</span><em class="sig-param">divisions=None</em>, <em class="sig-param">npartitions=None</em>, <em class="sig-param">partition_size=None</em>, <em class="sig-param">freq=None</em>, <em class="sig-param">force=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.repartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Repartition dataframe along new divisions</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>divisions</strong><span class="classifier">list, optional</span></dt><dd><p>List of partitions to be used. Only used if npartitions and
partition_size isn’t specified.</p>
</dd>
<dt><strong>npartitions</strong><span class="classifier">int, optional</span></dt><dd><p>Number of partitions of output. Only used if partition_size
isn’t specified.</p>
</dd>
<dt><strong>partition_size: int or string, optional</strong></dt><dd><p>Max number of bytes of memory for each partition. Use numbers or
strings like 5MB. If specified npartitions and divisions will be
ignored.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This keyword argument triggers computation to determine
the memory size of each partition, which may be expensive.</p>
</div>
</dd>
<dt><strong>freq</strong><span class="classifier">str, pd.Timedelta</span></dt><dd><p>A period on which to partition timeseries data like <code class="docutils literal notranslate"><span class="pre">'7D'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'12h'</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Timedelta(hours=12)</span></code>.  Assumes a datetime index.</p>
</dd>
<dt><strong>force</strong><span class="classifier">bool, default False</span></dt><dd><p>Allows the expansion of the existing divisions.
If False then the new divisions lower and upper bounds must be
the same as the old divisions.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Exactly one of <cite>divisions</cite>, <cite>npartitions</cite>, <cite>partition_size</cite>, or <cite>freq</cite>
should be specified. A <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> will be raised when that is
not the case.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">npartitions</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">divisions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="s1">&#39;7d&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">to_replace=None</em>, <em class="sig-param">value=None</em>, <em class="sig-param">regex=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values given in <cite>to_replace</cite> with <cite>value</cite>.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.replace.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Values of the DataFrame are replaced with other values dynamically.
This differs from updating with <code class="docutils literal notranslate"><span class="pre">.loc</span></code> or <code class="docutils literal notranslate"><span class="pre">.iloc</span></code>, which require
you to specify a location to update with some value.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>to_replace</strong><span class="classifier">str, regex, list, dict, Series, int, float, or None</span></dt><dd><p>How to find the values that will be replaced.</p>
<ul>
<li><p>numeric, str or regex:</p>
<blockquote>
<div><ul class="simple">
<li><p>numeric: numeric values equal to <cite>to_replace</cite> will be
replaced with <cite>value</cite></p></li>
<li><p>str: string exactly matching <cite>to_replace</cite> will be replaced
with <cite>value</cite></p></li>
<li><p>regex: regexs matching <cite>to_replace</cite> will be replaced with
<cite>value</cite></p></li>
</ul>
</div></blockquote>
</li>
<li><p>list of str, regex, or numeric:</p>
<blockquote>
<div><ul class="simple">
<li><p>First, if <cite>to_replace</cite> and <cite>value</cite> are both lists, they
<strong>must</strong> be the same length.</p></li>
<li><p>Second, if <code class="docutils literal notranslate"><span class="pre">regex=True</span></code> then all of the strings in <strong>both</strong>
lists will be interpreted as regexs otherwise they will match
directly. This doesn’t matter much for <cite>value</cite> since there
are only a few possible substitution regexes you can use.</p></li>
<li><p>str, regex and numeric rules apply as above.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>dict:</p>
<blockquote>
<div><ul class="simple">
<li><p>Dicts can be used to specify different replacement values
for different existing values. For example,
<code class="docutils literal notranslate"><span class="pre">{'a':</span> <span class="pre">'b',</span> <span class="pre">'y':</span> <span class="pre">'z'}</span></code> replaces the value ‘a’ with ‘b’ and
‘y’ with ‘z’. To use a dict in this way the <cite>value</cite>
parameter should be <cite>None</cite>.</p></li>
<li><p>For a DataFrame a dict can specify that different values
should be replaced in different columns. For example,
<code class="docutils literal notranslate"><span class="pre">{'a':</span> <span class="pre">1,</span> <span class="pre">'b':</span> <span class="pre">'z'}</span></code> looks for the value 1 in column ‘a’
and the value ‘z’ in column ‘b’ and replaces these values
with whatever is specified in <cite>value</cite>. The <cite>value</cite> parameter
should not be <code class="docutils literal notranslate"><span class="pre">None</span></code> in this case. You can treat this as a
special case of passing two lists except that you are
specifying the column to search in.</p></li>
<li><p>For a DataFrame nested dictionaries, e.g.,
<code class="docutils literal notranslate"><span class="pre">{'a':</span> <span class="pre">{'b':</span> <span class="pre">np.nan}}</span></code>, are read as follows: look in column
‘a’ for the value ‘b’ and replace it with NaN. The <cite>value</cite>
parameter should be <code class="docutils literal notranslate"><span class="pre">None</span></code> to use a nested dict in this
way. You can nest regular expressions as well. Note that
column names (the top-level dictionary keys in a nested
dictionary) <strong>cannot</strong> be regular expressions.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>None:</p>
<blockquote>
<div><ul class="simple">
<li><p>This means that the <cite>regex</cite> argument must be a string,
compiled regular expression, or list, dict, ndarray or
Series of such elements. If <cite>value</cite> is also <code class="docutils literal notranslate"><span class="pre">None</span></code> then
this <strong>must</strong> be a nested dictionary or Series.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>See the examples section for examples of each of these.</p>
</dd>
<dt><strong>value</strong><span class="classifier">scalar, dict, list, str, regex, default None</span></dt><dd><p>Value to replace any values matching <cite>to_replace</cite> with.
For a DataFrame a dict of values can be used to specify which
value to use for each column (columns not in the dict will not be
filled). Regular expressions, strings and lists or dicts of such
objects are also allowed.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True, in place. Note: this will modify any
other views on this object (e.g. a column from a DataFrame).
Returns the caller if this is True.</p>
</dd>
<dt><strong>limit</strong><span class="classifier">int, default None  (Not supported in Dask)</span></dt><dd><p>Maximum size gap to forward or backward fill.</p>
</dd>
<dt><strong>regex</strong><span class="classifier">bool or same types as <cite>to_replace</cite>, default False</span></dt><dd><p>Whether to interpret <cite>to_replace</cite> and/or <cite>value</cite> as regular
expressions. If this is <code class="docutils literal notranslate"><span class="pre">True</span></code> then <cite>to_replace</cite> <em>must</em> be a
string. Alternatively, this could be a regular expression or a
list, dict, or array of regular expressions in which case
<cite>to_replace</cite> must be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘pad’, ‘ffill’, ‘bfill’, <cite>None</cite>}  (Not supported in Dask)</span></dt><dd><p>The method to use when for replacement, when <cite>to_replace</cite> is a
scalar, list or tuple and <cite>value</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.23.0: </span>Added to DataFrame.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Object after replacement.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>AssertionError</strong></dt><dd><ul class="simple">
<li><p>If <cite>regex</cite> is not a <code class="docutils literal notranslate"><span class="pre">bool</span></code> and <cite>to_replace</cite> is not
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
</dd>
<dt><strong>TypeError</strong></dt><dd><ul class="simple">
<li><p>If <cite>to_replace</cite> is a <code class="docutils literal notranslate"><span class="pre">dict</span></code> and <cite>value</cite> is not a <code class="docutils literal notranslate"><span class="pre">list</span></code>,
<code class="docutils literal notranslate"><span class="pre">dict</span></code>, <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>, or <code class="docutils literal notranslate"><span class="pre">Series</span></code></p></li>
<li><p>If <cite>to_replace</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code> and <cite>regex</cite> is not compilable
into a regular expression or is a list, dict, ndarray, or
Series.</p></li>
<li><p>When replacing multiple <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">datetime64</span></code> objects and
the arguments to <cite>to_replace</cite> does not match the type of the
value being replaced</p></li>
</ul>
</dd>
<dt><strong>ValueError</strong></dt><dd><ul class="simple">
<li><p>If a <code class="docutils literal notranslate"><span class="pre">list</span></code> or an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> is passed to <cite>to_replace</cite> and
<cite>value</cite> but they are not the same length.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.fillna" title="dask.dataframe.DataFrame.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.fillna</span></code></a></dt><dd><p>Fill NA values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.where" title="dask.dataframe.DataFrame.where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.where</span></code></a></dt><dd><p>Replace values based on boolean condition.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.str.replace</span></code></dt><dd><p>Simple string replacement.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Regex substitution is performed under the hood with <code class="docutils literal notranslate"><span class="pre">re.sub</span></code>. The
rules for substitution for <code class="docutils literal notranslate"><span class="pre">re.sub</span></code> are the same.</p></li>
<li><p>Regular expressions will only substitute on strings, meaning you
cannot provide, for example, a regular expression matching floating
point numbers and expect the columns in your frame that have a
numeric dtype to be matched. However, if those floating point
numbers <em>are</em> strings, then you can do this.</p></li>
<li><p>This method has <em>a lot</em> of options. You are encouraged to experiment
and play with this method to gain intuition about how it works.</p></li>
<li><p>When dict is used as the <cite>to_replace</cite> value, it is like
key(s) in the dict are the to_replace part and
value(s) in the dict are the value parameter.</p></li>
</ul>
<p class="rubric">Examples</p>
<p><strong>Scalar `to_replace` and `value`</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  
<span class="go">0    5</span>
<span class="go">1    1</span>
<span class="go">2    2</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  
<span class="go">   A  B  C</span>
<span class="go">0  5  5  a</span>
<span class="go">1  1  6  b</span>
<span class="go">2  2  7  c</span>
<span class="go">3  3  8  d</span>
<span class="go">4  4  9  e</span>
</pre></div>
</div>
<p><strong>List-like `to_replace`</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>  
<span class="go">   A  B  C</span>
<span class="go">0  4  5  a</span>
<span class="go">1  4  6  b</span>
<span class="go">2  4  7  c</span>
<span class="go">3  4  8  d</span>
<span class="go">4  4  9  e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  
<span class="go">   A  B  C</span>
<span class="go">0  4  5  a</span>
<span class="go">1  3  6  b</span>
<span class="go">2  2  7  c</span>
<span class="go">3  1  8  d</span>
<span class="go">4  4  9  e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfill&#39;</span><span class="p">)</span>  
<span class="go">0    0</span>
<span class="go">1    3</span>
<span class="go">2    3</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p><strong>dict-like `to_replace`</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">100</span><span class="p">})</span>  
<span class="go">     A  B  C</span>
<span class="go">0   10  5  a</span>
<span class="go">1  100  6  b</span>
<span class="go">2    2  7  c</span>
<span class="go">3    3  8  d</span>
<span class="go">4    4  9  e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="mi">100</span><span class="p">)</span>  
<span class="go">     A    B  C</span>
<span class="go">0  100  100  a</span>
<span class="go">1    1    6  b</span>
<span class="go">2    2    7  c</span>
<span class="go">3    3    8  d</span>
<span class="go">4    4    9  e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">400</span><span class="p">}})</span>  
<span class="go">     A  B  C</span>
<span class="go">0  100  5  a</span>
<span class="go">1    1  6  b</span>
<span class="go">2    2  7  c</span>
<span class="go">3    3  8  d</span>
<span class="go">4  400  9  e</span>
</pre></div>
</div>
<p><strong>Regular expression `to_replace`</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;bat&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bait&#39;</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;xyz&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;^ba.$&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;new&#39;</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">      A    B</span>
<span class="go">0   new  abc</span>
<span class="go">1   foo  new</span>
<span class="go">2  bait  xyz</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="sa">r</span><span class="s1">&#39;^ba.$&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="s1">&#39;new&#39;</span><span class="p">},</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">      A    B</span>
<span class="go">0   new  abc</span>
<span class="go">1   foo  bar</span>
<span class="go">2  bait  xyz</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">regex</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;^ba.$&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;new&#39;</span><span class="p">)</span>  
<span class="go">      A    B</span>
<span class="go">0   new  abc</span>
<span class="go">1   foo  new</span>
<span class="go">2  bait  xyz</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">regex</span><span class="o">=</span><span class="p">{</span><span class="sa">r</span><span class="s1">&#39;^ba.$&#39;</span><span class="p">:</span> <span class="s1">&#39;new&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="s1">&#39;xyz&#39;</span><span class="p">})</span>  
<span class="go">      A    B</span>
<span class="go">0   new  abc</span>
<span class="go">1   xyz  new</span>
<span class="go">2  bait  xyz</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">regex</span><span class="o">=</span><span class="p">[</span><span class="sa">r</span><span class="s1">&#39;^ba.$&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">],</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;new&#39;</span><span class="p">)</span>  
<span class="go">      A    B</span>
<span class="go">0   new  abc</span>
<span class="go">1   new  new</span>
<span class="go">2  bait  xyz</span>
</pre></div>
</div>
<p>Note that when replacing multiple <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">datetime64</span></code> objects,
the data types in the <cite>to_replace</cite> parameter must match the data
type of the value being replaced:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s1">&#39;a string&#39;</span><span class="p">:</span> <span class="s1">&#39;new value&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>  <span class="c1"># raises  </span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TypeError</span>: <span class="n">Cannot compare types &#39;ndarray(dtype=bool)&#39; and &#39;str&#39;</span>
</pre></div>
</div>
<p>This raises a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> because one of the <code class="docutils literal notranslate"><span class="pre">dict</span></code> keys is not of
the correct type for replacement.</p>
<p>Compare the behavior of <code class="docutils literal notranslate"><span class="pre">s.replace({'a':</span> <span class="pre">None})</span></code> and
<code class="docutils literal notranslate"><span class="pre">s.replace('a',</span> <span class="pre">None)</span></code> to understand the peculiarities
of the <cite>to_replace</cite> parameter:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>  
</pre></div>
</div>
<p>When one uses a dict as the <cite>to_replace</cite> value, it is like the
value(s) in the dict are equal to the <cite>value</cite> parameter.
<code class="docutils literal notranslate"><span class="pre">s.replace({'a':</span> <span class="pre">None})</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">s.replace(to_replace={'a':</span> <span class="pre">None},</span> <span class="pre">value=None,</span> <span class="pre">method=None)</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>  
<span class="go">0      10</span>
<span class="go">1    None</span>
<span class="go">2    None</span>
<span class="go">3       b</span>
<span class="go">4    None</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">value=None</span></code> and <cite>to_replace</cite> is a scalar, list or
tuple, <cite>replace</cite> uses the method parameter (default ‘pad’) to do the
replacement. So this is why the ‘a’ values are being replaced by 10
in rows 1 and 2 and ‘b’ in row 4 in this case.
The command <code class="docutils literal notranslate"><span class="pre">s.replace('a',</span> <span class="pre">None)</span></code> is actually equivalent to
<code class="docutils literal notranslate"><span class="pre">s.replace(to_replace='a',</span> <span class="pre">value=None,</span> <span class="pre">method='pad')</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  
<span class="go">0    10</span>
<span class="go">1    10</span>
<span class="go">2    10</span>
<span class="go">3     b</span>
<span class="go">4     b</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.resample">
<code class="sig-name descname">resample</code><span class="sig-paren">(</span><em class="sig-param">rule</em>, <em class="sig-param">closed=None</em>, <em class="sig-param">label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample time-series data.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.resample.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Convenience method for frequency conversion and resampling of time
series. Object must have a datetime-like index (<cite>DatetimeIndex</cite>,
<cite>PeriodIndex</cite>, or <cite>TimedeltaIndex</cite>), or pass datetime-like values
to the <cite>on</cite> or <cite>level</cite> keyword.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rule</strong><span class="classifier">DateOffset, Timedelta or str</span></dt><dd><p>The offset string or object representing target conversion.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0  (Not supported in Dask)</span></dt><dd><p>Which axis to use for up- or down-sampling. For <cite>Series</cite> this
will default to 0, i.e. along the rows. Must be
<cite>DatetimeIndex</cite>, <cite>TimedeltaIndex</cite> or <cite>PeriodIndex</cite>.</p>
</dd>
<dt><strong>closed</strong><span class="classifier">{‘right’, ‘left’}, default None</span></dt><dd><p>Which side of bin interval is closed. The default is ‘left’
for all frequency offsets except for ‘M’, ‘A’, ‘Q’, ‘BM’,
‘BA’, ‘BQ’, and ‘W’ which all have a default of ‘right’.</p>
</dd>
<dt><strong>label</strong><span class="classifier">{‘right’, ‘left’}, default None</span></dt><dd><p>Which bin edge label to label bucket with. The default is ‘left’
for all frequency offsets except for ‘M’, ‘A’, ‘Q’, ‘BM’,
‘BA’, ‘BQ’, and ‘W’ which all have a default of ‘right’.</p>
</dd>
<dt><strong>convention</strong><span class="classifier">{‘start’, ‘end’, ‘s’, ‘e’}, default ‘start’  (Not supported in Dask)</span></dt><dd><p>For <cite>PeriodIndex</cite> only, controls whether to use the start or
end of <cite>rule</cite>.</p>
</dd>
<dt><strong>kind</strong><span class="classifier">{‘timestamp’, ‘period’}, optional, default None  (Not supported in Dask)</span></dt><dd><p>Pass ‘timestamp’ to convert the resulting index to a
<cite>DateTimeIndex</cite> or ‘period’ to convert it to a <cite>PeriodIndex</cite>.
By default the input representation is retained.</p>
</dd>
<dt><strong>loffset</strong><span class="classifier">timedelta, default None  (Not supported in Dask)</span></dt><dd><p>Adjust the resampled time labels.</p>
</dd>
<dt><strong>base</strong><span class="classifier">int, default 0  (Not supported in Dask)</span></dt><dd><p>For frequencies that evenly subdivide 1 day, the “origin” of the
aggregated intervals. For example, for ‘5min’ frequency, base could
range from 0 through 4. Defaults to 0.</p>
</dd>
<dt><strong>on</strong><span class="classifier">str, optional  (Not supported in Dask)</span></dt><dd><p>For a DataFrame, column to use instead of index for resampling.
Column must be datetime-like.</p>
</dd>
<dt><strong>level</strong><span class="classifier">str or int, optional  (Not supported in Dask)</span></dt><dd><p>For a MultiIndex, level (name or number) to use for
resampling. <cite>level</cite> must be datetime-like.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Resampler object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.groupby" title="dask.dataframe.DataFrame.groupby"><code class="xref py py-obj docutils literal notranslate"><span class="pre">groupby</span></code></a></dt><dd><p>Group by mapping, function, label, or list of labels.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.resample" title="dask.dataframe.Series.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.resample</span></code></a></dt><dd><p>Resample a Series.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.resample" title="dask.dataframe.DataFrame.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.resample</span></code></a></dt><dd><p>Resample a DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>See the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#resampling">user guide</a>
for more.</p>
<p>To learn more about the offset strings, please see <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects">this link</a>.</p>
<p class="rubric">Examples</p>
<p>Start by creating a series with 9 one minute timestamps.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;1/1/2000&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">series</span>  
<span class="go">2000-01-01 00:00:00    0</span>
<span class="go">2000-01-01 00:01:00    1</span>
<span class="go">2000-01-01 00:02:00    2</span>
<span class="go">2000-01-01 00:03:00    3</span>
<span class="go">2000-01-01 00:04:00    4</span>
<span class="go">2000-01-01 00:05:00    5</span>
<span class="go">2000-01-01 00:06:00    6</span>
<span class="go">2000-01-01 00:07:00    7</span>
<span class="go">2000-01-01 00:08:00    8</span>
<span class="go">Freq: T, dtype: int64</span>
</pre></div>
</div>
<p>Downsample the series into 3 minute bins and sum the values
of the timestamps falling into a bin.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;3T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  
<span class="go">2000-01-01 00:00:00     3</span>
<span class="go">2000-01-01 00:03:00    12</span>
<span class="go">2000-01-01 00:06:00    21</span>
<span class="go">Freq: 3T, dtype: int64</span>
</pre></div>
</div>
<p>Downsample the series into 3 minute bins as above, but label each
bin using the right edge instead of the left. Please note that the
value in the bucket used as the label is not included in the bucket,
which it labels. For example, in the original series the
bucket <code class="docutils literal notranslate"><span class="pre">2000-01-01</span> <span class="pre">00:03:00</span></code> contains the value 3, but the summed
value in the resampled bucket with the label <code class="docutils literal notranslate"><span class="pre">2000-01-01</span> <span class="pre">00:03:00</span></code>
does not include 3 (if it did, the summed value would be 6, not 3).
To include this value close the right side of the bin interval as
illustrated in the example below this one.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;3T&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  
<span class="go">2000-01-01 00:03:00     3</span>
<span class="go">2000-01-01 00:06:00    12</span>
<span class="go">2000-01-01 00:09:00    21</span>
<span class="go">Freq: 3T, dtype: int64</span>
</pre></div>
</div>
<p>Downsample the series into 3 minute bins as above, but close the right
side of the bin interval.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;3T&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  
<span class="go">2000-01-01 00:00:00     0</span>
<span class="go">2000-01-01 00:03:00     6</span>
<span class="go">2000-01-01 00:06:00    15</span>
<span class="go">2000-01-01 00:09:00    15</span>
<span class="go">Freq: 3T, dtype: int64</span>
</pre></div>
</div>
<p>Upsample the series into 30 second bins.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;30S&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">asfreq</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>   <span class="c1"># Select first 5 rows  </span>
<span class="go">2000-01-01 00:00:00   0.0</span>
<span class="go">2000-01-01 00:00:30   NaN</span>
<span class="go">2000-01-01 00:01:00   1.0</span>
<span class="go">2000-01-01 00:01:30   NaN</span>
<span class="go">2000-01-01 00:02:00   2.0</span>
<span class="go">Freq: 30S, dtype: float64</span>
</pre></div>
</div>
<p>Upsample the series into 30 second bins and fill the <code class="docutils literal notranslate"><span class="pre">NaN</span></code>
values using the <code class="docutils literal notranslate"><span class="pre">pad</span></code> method.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;30S&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">pad</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>  
<span class="go">2000-01-01 00:00:00    0</span>
<span class="go">2000-01-01 00:00:30    0</span>
<span class="go">2000-01-01 00:01:00    1</span>
<span class="go">2000-01-01 00:01:30    1</span>
<span class="go">2000-01-01 00:02:00    2</span>
<span class="go">Freq: 30S, dtype: int64</span>
</pre></div>
</div>
<p>Upsample the series into 30 second bins and fill the
<code class="docutils literal notranslate"><span class="pre">NaN</span></code> values using the <code class="docutils literal notranslate"><span class="pre">bfill</span></code> method.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;30S&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bfill</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>  
<span class="go">2000-01-01 00:00:00    0</span>
<span class="go">2000-01-01 00:00:30    1</span>
<span class="go">2000-01-01 00:01:00    1</span>
<span class="go">2000-01-01 00:01:30    2</span>
<span class="go">2000-01-01 00:02:00    2</span>
<span class="go">Freq: 30S, dtype: int64</span>
</pre></div>
</div>
<p>Pass a custom function via <code class="docutils literal notranslate"><span class="pre">apply</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">custom_resampler</span><span class="p">(</span><span class="n">array_like</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">array_like</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;3T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">custom_resampler</span><span class="p">)</span>  
<span class="go">2000-01-01 00:00:00     8</span>
<span class="go">2000-01-01 00:03:00    17</span>
<span class="go">2000-01-01 00:06:00    26</span>
<span class="go">Freq: 3T, dtype: int64</span>
</pre></div>
</div>
<p>For a Series with a PeriodIndex, the keyword <cite>convention</cite> can be
used to control whether to use the start or end of <cite>rule</cite>.</p>
<p>Resample a year by quarter using ‘start’ <cite>convention</cite>. Values are
assigned to the first quarter of the period.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="s1">&#39;2012-01-01&#39;</span><span class="p">,</span>  
<span class="gp">... </span>                                            <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                            <span class="n">periods</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">2012    1</span>
<span class="go">2013    2</span>
<span class="go">Freq: A-DEC, dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="n">convention</span><span class="o">=</span><span class="s1">&#39;start&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">asfreq</span><span class="p">()</span>  
<span class="go">2012Q1    1.0</span>
<span class="go">2012Q2    NaN</span>
<span class="go">2012Q3    NaN</span>
<span class="go">2012Q4    NaN</span>
<span class="go">2013Q1    2.0</span>
<span class="go">2013Q2    NaN</span>
<span class="go">2013Q3    NaN</span>
<span class="go">2013Q4    NaN</span>
<span class="go">Freq: Q-DEC, dtype: float64</span>
</pre></div>
</div>
<p>Resample quarters by month using ‘end’ <cite>convention</cite>. Values are
assigned to the last month of the period.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="s1">&#39;2018-01-01&#39;</span><span class="p">,</span>  
<span class="gp">... </span>                                                  <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                                  <span class="n">periods</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span>  
<span class="go">2018Q1    1</span>
<span class="go">2018Q2    2</span>
<span class="go">2018Q3    3</span>
<span class="go">2018Q4    4</span>
<span class="go">Freq: Q-DEC, dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">convention</span><span class="o">=</span><span class="s1">&#39;end&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">asfreq</span><span class="p">()</span>  
<span class="go">2018-03    1.0</span>
<span class="go">2018-04    NaN</span>
<span class="go">2018-05    NaN</span>
<span class="go">2018-06    2.0</span>
<span class="go">2018-07    NaN</span>
<span class="go">2018-08    NaN</span>
<span class="go">2018-09    3.0</span>
<span class="go">2018-10    NaN</span>
<span class="go">2018-11    NaN</span>
<span class="go">2018-12    4.0</span>
<span class="go">Freq: M, dtype: float64</span>
</pre></div>
</div>
<p>For DataFrame objects, the keyword <cite>on</cite> can be used to specify the
column instead of the index for resampling.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">],</span>  
<span class="gp">... </span>          <span class="s1">&#39;volume&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;week_starting&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;01/01/2018&#39;</span><span class="p">,</span>  
<span class="gp">... </span>                                    <span class="n">periods</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   price  volume week_starting</span>
<span class="go">0     10      50    2018-01-07</span>
<span class="go">1     11      60    2018-01-14</span>
<span class="go">2      9      40    2018-01-21</span>
<span class="go">3     13     100    2018-01-28</span>
<span class="go">4     14      50    2018-02-04</span>
<span class="go">5     18     100    2018-02-11</span>
<span class="go">6     17      40    2018-02-18</span>
<span class="go">7     19      50    2018-02-25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;week_starting&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">               price  volume</span>
<span class="go">week_starting</span>
<span class="go">2018-01-31     10.75    62.5</span>
<span class="go">2018-02-28     17.00    60.0</span>
</pre></div>
</div>
<p>For a DataFrame with MultiIndex, the keyword <cite>level</cite> can be used to
specify on which level the resampling needs to take place.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">days</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;1/1/2000&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">d2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">],</span>  
<span class="gp">... </span>           <span class="s1">&#39;volume&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span>  
<span class="gp">... </span>                   <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">days</span><span class="p">,</span>
<span class="gp">... </span>                                                    <span class="p">[</span><span class="s1">&#39;morning&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="s1">&#39;afternoon&#39;</span><span class="p">]]</span>
<span class="gp">... </span>                                                    <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span>  
<span class="go">                      price  volume</span>
<span class="go">2000-01-01 morning       10      50</span>
<span class="go">           afternoon     11      60</span>
<span class="go">2000-01-02 morning        9      40</span>
<span class="go">           afternoon     13     100</span>
<span class="go">2000-01-03 morning       14      50</span>
<span class="go">           afternoon     18     100</span>
<span class="go">2000-01-04 morning       17      40</span>
<span class="go">           afternoon     19      50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  
<span class="go">            price  volume</span>
<span class="go">2000-01-01     21     110</span>
<span class="go">2000-01-02     22     140</span>
<span class="go">2000-01-03     32     150</span>
<span class="go">2000-01-04     36      90</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.reset_index">
<code class="sig-name descname">reset_index</code><span class="sig-paren">(</span><em class="sig-param">drop=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.reset_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the index to the default index.</p>
<p>Note that unlike in <code class="docutils literal notranslate"><span class="pre">pandas</span></code>, the reset <code class="docutils literal notranslate"><span class="pre">dask.dataframe</span></code> index will
not be monotonically increasing from 0. Instead, it will restart at 0
for each partition (e.g. <code class="docutils literal notranslate"><span class="pre">index1</span> <span class="pre">=</span> <span class="pre">[0,</span> <span class="pre">...,</span> <span class="pre">10],</span> <span class="pre">index2</span> <span class="pre">=</span> <span class="pre">[0,</span> <span class="pre">...]</span></code>).
This is due to the inability to statically know the full length of the
index.</p>
<p>For DataFrame with multi-level index, returns a new DataFrame with
labeling information in the columns under the index names, defaulting
to ‘level_0’, ‘level_1’, etc. if any are None. For a standard index,
the index name will be used (if set), otherwise a default ‘index’ or
‘level_0’ (if ‘index’ is already taken) will be used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>drop</strong><span class="classifier">boolean, default False</span></dt><dd><p>Do not try to insert index into dataframe columns.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.rfloordiv">
<code class="sig-name descname">rfloordiv</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.rfloordiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Integer division of dataframe and other, element-wise (binary operator <cite>rfloordiv</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.rfloordiv.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">//</span> <span class="pre">dataframe</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>floordiv</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.rmod">
<code class="sig-name descname">rmod</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.rmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Modulo of dataframe and other, element-wise (binary operator <cite>rmod</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.rmod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">%</span> <span class="pre">dataframe</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>mod</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.rmul">
<code class="sig-name descname">rmul</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.rmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Multiplication of dataframe and other, element-wise (binary operator <cite>rmul</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.rmul.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">*</span> <span class="pre">dataframe</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>mul</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.rolling">
<code class="sig-name descname">rolling</code><span class="sig-paren">(</span><em class="sig-param">window</em>, <em class="sig-param">min_periods=None</em>, <em class="sig-param">center=False</em>, <em class="sig-param">win_type=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.rolling" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides rolling transformations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>window</strong><span class="classifier">int, str, offset</span></dt><dd><p>Size of the moving window. This is the number of observations used
for calculating the statistic. When not using a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>,
the window size must not be so large as to span more than one
adjacent partition. If using an offset or offset alias like ‘5D’,
the data must have a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code></p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.15.0: </span>Now accepts offsets and string offset aliases</p>
</div>
</dd>
<dt><strong>min_periods</strong><span class="classifier">int, default None</span></dt><dd><p>Minimum number of observations in window required to have a value
(otherwise result is NA).</p>
</dd>
<dt><strong>center</strong><span class="classifier">boolean, default False</span></dt><dd><p>Set the labels at the center of the window.</p>
</dd>
<dt><strong>win_type</strong><span class="classifier">string, default None</span></dt><dd><p>Provide a window type. The recognized window types are identical
to pandas.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, default 0</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a Rolling object on which to call a method to compute a statistic</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.round">
<code class="sig-name descname">round</code><span class="sig-paren">(</span><em class="sig-param">decimals=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Round a DataFrame to a variable number of decimal places.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.round.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>decimals</strong><span class="classifier">int, dict, Series</span></dt><dd><p>Number of decimal places to round each column to. If an int is
given, round each column to the same number of places.
Otherwise dict and Series round to variable numbers of places.
Column names should be in the keys if <cite>decimals</cite> is a
dict-like, or in the index if <cite>decimals</cite> is a Series. Any
columns not included in <cite>decimals</cite> will be left as is. Elements
of <cite>decimals</cite> which are not columns of the input will be
ignored.</p>
</dd>
<dt><strong>*args</strong></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with numpy.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with numpy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>A DataFrame with the affected columns rounded to the specified
number of decimal places.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.around.html#numpy.around" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.around</span></code></a></dt><dd><p>Round a numpy array to the given number of decimals.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.round" title="dask.dataframe.Series.round"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.round</span></code></a></dt><dd><p>Round a Series to the given number of decimals.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([(</span><span class="o">.</span><span class="mi">21</span><span class="p">,</span> <span class="o">.</span><span class="mi">32</span><span class="p">),</span> <span class="p">(</span><span class="o">.</span><span class="mi">01</span><span class="p">,</span> <span class="o">.</span><span class="mi">67</span><span class="p">),</span> <span class="p">(</span><span class="o">.</span><span class="mi">66</span><span class="p">,</span> <span class="o">.</span><span class="mi">03</span><span class="p">),</span> <span class="p">(</span><span class="o">.</span><span class="mi">21</span><span class="p">,</span> <span class="o">.</span><span class="mi">18</span><span class="p">)],</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dogs&#39;</span><span class="p">,</span> <span class="s1">&#39;cats&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">    dogs  cats</span>
<span class="go">0  0.21  0.32</span>
<span class="go">1  0.01  0.67</span>
<span class="go">2  0.66  0.03</span>
<span class="go">3  0.21  0.18</span>
</pre></div>
</div>
<p>By providing an integer each column is rounded to the same number
of decimal places</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">    dogs  cats</span>
<span class="go">0   0.2   0.3</span>
<span class="go">1   0.0   0.7</span>
<span class="go">2   0.7   0.0</span>
<span class="go">3   0.2   0.2</span>
</pre></div>
</div>
<p>With a dict, the number of places for specific columns can be
specified with the column names as key and the number of decimal
places as value</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">round</span><span class="p">({</span><span class="s1">&#39;dogs&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;cats&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>  
<span class="go">    dogs  cats</span>
<span class="go">0   0.2   0.0</span>
<span class="go">1   0.0   1.0</span>
<span class="go">2   0.7   0.0</span>
<span class="go">3   0.2   0.0</span>
</pre></div>
</div>
<p>Using a Series, the number of places for specific columns can be
specified with the column names as index and the number of
decimal places as value</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">decimals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cats&#39;</span><span class="p">,</span> <span class="s1">&#39;dogs&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>  
<span class="go">    dogs  cats</span>
<span class="go">0   0.2   0.0</span>
<span class="go">1   0.0   1.0</span>
<span class="go">2   0.7   0.0</span>
<span class="go">3   0.2   0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.rpow">
<code class="sig-name descname">rpow</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.rpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Exponential power of dataframe and other, element-wise (binary operator <cite>rpow</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.rpow.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">**</span> <span class="pre">dataframe</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>pow</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.rsub">
<code class="sig-name descname">rsub</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.rsub" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Subtraction of dataframe and other, element-wise (binary operator <cite>rsub</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.rsub.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">-</span> <span class="pre">dataframe</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>sub</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.rtruediv">
<code class="sig-name descname">rtruediv</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.rtruediv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Floating division of dataframe and other, element-wise (binary operator <cite>rtruediv</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.rtruediv.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">/</span> <span class="pre">dataframe</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>truediv</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">n=None</em>, <em class="sig-param">frac=None</em>, <em class="sig-param">replace=False</em>, <em class="sig-param">random_state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Random sample of items</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>Number of items to return is not supported by dask. Use frac
instead.</p>
</dd>
<dt><strong>frac</strong><span class="classifier">float, optional</span></dt><dd><p>Fraction of axis items to return.</p>
</dd>
<dt><strong>replace</strong><span class="classifier">boolean, optional</span></dt><dd><p>Sample with or without replacement. Default = False.</p>
</dd>
<dt><strong>random_state</strong><span class="classifier">int or <code class="docutils literal notranslate"><span class="pre">np.random.RandomState</span></code></span></dt><dd><p>If int we create a new RandomState with this as the seed
Otherwise we draw from the passed RandomState</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.DataFrame.random_split" title="dask.dataframe.DataFrame.random_split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.random_split</span></code></a>, <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sample.html#pandas.DataFrame.sample" title="(in pandas v1.0.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame.sample</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.select_dtypes">
<code class="sig-name descname">select_dtypes</code><span class="sig-paren">(</span><em class="sig-param">include=None</em>, <em class="sig-param">exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.select_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of the DataFrame’s columns based on the column dtypes.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.select_dtypes.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>include, exclude</strong><span class="classifier">scalar or list-like</span></dt><dd><p>A selection of dtypes or strings to be included/excluded. At least
one of these parameters must be supplied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>The subset of the frame including the dtypes in <code class="docutils literal notranslate"><span class="pre">include</span></code> and
excluding the dtypes in <code class="docutils literal notranslate"><span class="pre">exclude</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><ul class="simple">
<li><p>If both of <code class="docutils literal notranslate"><span class="pre">include</span></code> and <code class="docutils literal notranslate"><span class="pre">exclude</span></code> are empty</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">include</span></code> and <code class="docutils literal notranslate"><span class="pre">exclude</span></code> have overlapping elements</p></li>
<li><p>If any kind of string dtype is passed in.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>To select all <em>numeric</em> types, use <code class="docutils literal notranslate"><span class="pre">np.number</span></code> or <code class="docutils literal notranslate"><span class="pre">'number'</span></code></p></li>
<li><p>To select strings you must use the <code class="docutils literal notranslate"><span class="pre">object</span></code> dtype, but note that
this will return <em>all</em> object dtype columns</p></li>
<li><p>See the <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/arrays.scalars.html">numpy dtype hierarchy</a></p></li>
<li><p>To select datetimes, use <code class="docutils literal notranslate"><span class="pre">np.datetime64</span></code>, <code class="docutils literal notranslate"><span class="pre">'datetime'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'datetime64'</span></code></p></li>
<li><p>To select timedeltas, use <code class="docutils literal notranslate"><span class="pre">np.timedelta64</span></code>, <code class="docutils literal notranslate"><span class="pre">'timedelta'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'timedelta64'</span></code></p></li>
<li><p>To select Pandas categorical dtypes, use <code class="docutils literal notranslate"><span class="pre">'category'</span></code></p></li>
<li><p>To select Pandas datetimetz dtypes, use <code class="docutils literal notranslate"><span class="pre">'datetimetz'</span></code> (new in
0.20.0) or <code class="docutils literal notranslate"><span class="pre">'datetime64[ns,</span> <span class="pre">tz]'</span></code></p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>  
<span class="gp">... </span>                   <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>                   <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">        a      b  c</span>
<span class="go">0       1   True  1.0</span>
<span class="go">1       2  False  2.0</span>
<span class="go">2       1   True  1.0</span>
<span class="go">3       2  False  2.0</span>
<span class="go">4       1   True  1.0</span>
<span class="go">5       2  False  2.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>  
<span class="go">   b</span>
<span class="go">0  True</span>
<span class="go">1  False</span>
<span class="go">2  True</span>
<span class="go">3  False</span>
<span class="go">4  True</span>
<span class="go">5  False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;float64&#39;</span><span class="p">])</span>  
<span class="go">   c</span>
<span class="go">0  1.0</span>
<span class="go">1  2.0</span>
<span class="go">2  1.0</span>
<span class="go">3  2.0</span>
<span class="go">4  1.0</span>
<span class="go">5  2.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">])</span>  
<span class="go">       b    c</span>
<span class="go">0   True  1.0</span>
<span class="go">1  False  2.0</span>
<span class="go">2   True  1.0</span>
<span class="go">3  False  2.0</span>
<span class="go">4   True  1.0</span>
<span class="go">5  False  2.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.sem">
<code class="sig-name descname">sem</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=None</em>, <em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.sem" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unbiased standard error of the mean over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.sem.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Normalized by N-1 by default. This can be changed using the ddof argument</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd></dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, default 1</span></dt><dd><p>Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
where N represents the number of elements.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.set_index">
<code class="sig-name descname">set_index</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">drop=True</em>, <em class="sig-param">sorted=False</em>, <em class="sig-param">npartitions=None</em>, <em class="sig-param">divisions=None</em>, <em class="sig-param">inplace=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.set_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the DataFrame index (row labels) using an existing column.</p>
<p>This realigns the dataset to be sorted by a new column.  This can have a
significant impact on performance, because joins, groupbys, lookups, etc.
are all much faster on that column.  However, this performance increase
comes with a cost, sorting a parallel dataset requires expensive shuffles.
Often we <code class="docutils literal notranslate"><span class="pre">set_index</span></code> once directly after data ingest and filtering and
then perform many cheap computations off of the sorted dataset.</p>
<p>This function operates exactly like <code class="docutils literal notranslate"><span class="pre">pandas.set_index</span></code> except with
different performance costs (dask dataframe <code class="docutils literal notranslate"><span class="pre">set_index</span></code> is much more expensive).  Under normal
operation this function does an initial pass over the index column to
compute approximate qunatiles to serve as future divisions.  It then passes
over the data a second time, splitting up each input partition into several
pieces and sharing those pieces to all of the output partitions now in
sorted order.</p>
<p>In some cases we can alleviate those costs, for example if your dataset is
sorted already then we can avoid making many small pieces or if you know
good values to split the new index column then we can avoid the initial
pass over the data.  For example if your new index is a datetime index and
your data is already sorted by day then this entire operation can be done
for free.  You can control these options with the following parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: Dask DataFrame</strong></dt><dd></dd>
<dt><strong>index: string or Dask Series</strong></dt><dd></dd>
<dt><strong>npartitions: int, None, or ‘auto’</strong></dt><dd><p>The ideal number of output partitions.   If None use the same as
the input.  If ‘auto’ then decide by memory use.</p>
</dd>
<dt><strong>shuffle: string, optional</strong></dt><dd><p>Either <code class="docutils literal notranslate"><span class="pre">'disk'</span></code> for single-node operation or <code class="docutils literal notranslate"><span class="pre">'tasks'</span></code> for
distributed operation.  Will be inferred by your current scheduler.</p>
</dd>
<dt><strong>sorted: bool, optional</strong></dt><dd><p>If the index column is already sorted in increasing order.
Defaults to False</p>
</dd>
<dt><strong>divisions: list, optional</strong></dt><dd><p>Known values on which to separate index values of the partitions.
See <a class="reference external" href="https://docs.dask.org/en/latest/dataframe-design.html#partitions">https://docs.dask.org/en/latest/dataframe-design.html#partitions</a>
Defaults to computing this with a single pass over the data. Note
that if <code class="docutils literal notranslate"><span class="pre">sorted=True</span></code>, specified divisions are assumed to match
the existing partitions in the data. If <code class="docutils literal notranslate"><span class="pre">sorted=False</span></code>, you should
leave divisions empty and call <code class="docutils literal notranslate"><span class="pre">repartition</span></code> after <code class="docutils literal notranslate"><span class="pre">set_index</span></code>.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, optional</span></dt><dd><p>Modifying the DataFrame in place is not supported by Dask.
Defaults to False.</p>
</dd>
<dt><strong>compute: bool</strong></dt><dd><p>Whether or not to trigger an immediate computation. Defaults to False.
Note, that even if you set <code class="docutils literal notranslate"><span class="pre">compute=False</span></code>, an immediate computation
will still be triggered if <code class="docutils literal notranslate"><span class="pre">divisions</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
</pre></div>
</div>
<p>A common case is when we have a datetime column that we know to be
sorted and is cleanly divided by day.  We can set this index for free
by specifying both that the column is pre-sorted and the particular
divisions along which is is separated</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divisions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2000&#39;</span><span class="p">,</span> <span class="s1">&#39;2010&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;1D&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;timestamp&#39;</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">divisions</span><span class="o">=</span><span class="n">divisions</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#dask.dataframe.DataFrame.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple representing the dimensionality of the DataFrame.</p>
<p>The number of rows is a Delayed result. The number of columns
is a concrete integer.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">size</span>  
<span class="go">(Delayed(&#39;int-07f06075-5ecc-4d77-817e-63c69a9188a8&#39;), 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.shift">
<code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">periods=1</em>, <em class="sig-param">freq=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift index by desired number of periods with an optional time <cite>freq</cite>.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.shift.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>When <cite>freq</cite> is not passed, shift the index without realigning the data.
If <cite>freq</cite> is passed (in this case, the index must be date or datetime,
or it will raise a <cite>NotImplementedError</cite>), the index will be
increased using the periods and the <cite>freq</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>periods</strong><span class="classifier">int</span></dt><dd><p>Number of periods to shift. Can be positive or negative.</p>
</dd>
<dt><strong>freq</strong><span class="classifier">DateOffset, tseries.offsets, timedelta, or str, optional</span></dt><dd><p>Offset to use from the tseries module or time rule (e.g. ‘EOM’).
If <cite>freq</cite> is specified then the index values are shifted but the
data is not realigned. That is, use <cite>freq</cite> if you would like to
extend the index when shifting and preserve the original data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’, None}, default None</span></dt><dd><p>Shift direction.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">object, optional  (Not supported in Dask)</span></dt><dd><p>The scalar value to use for newly introduced missing values.
the default depends on the dtype of <cite>self</cite>.
For numeric data, <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> is used.
For datetime, timedelta, or period data, etc. <code class="xref py py-attr docutils literal notranslate"><span class="pre">NaT</span></code> is used.
For extension dtypes, <code class="docutils literal notranslate"><span class="pre">self.dtype.na_value</span></code> is used.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.24.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Copy of input object, shifted.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Index.shift</span></code></dt><dd><p>Shift values of Index.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DatetimeIndex.shift</span></code></dt><dd><p>Shift values of DatetimeIndex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">PeriodIndex.shift</span></code></dt><dd><p>Shift values of PeriodIndex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">tshift</span></code></dt><dd><p>Shift the time index, using the index’s frequency if available.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Col1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;Col2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">48</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;Col3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">52</span><span class="p">]})</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  
<span class="go">   Col1  Col2  Col3</span>
<span class="go">0   NaN   NaN   NaN</span>
<span class="go">1   NaN   NaN   NaN</span>
<span class="go">2   NaN   NaN   NaN</span>
<span class="go">3  10.0  13.0  17.0</span>
<span class="go">4  20.0  23.0  27.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">   Col1  Col2  Col3</span>
<span class="go">0   NaN  10.0  13.0</span>
<span class="go">1   NaN  20.0  23.0</span>
<span class="go">2   NaN  15.0  18.0</span>
<span class="go">3   NaN  30.0  33.0</span>
<span class="go">4   NaN  45.0  48.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">   Col1  Col2  Col3</span>
<span class="go">0     0     0     0</span>
<span class="go">1     0     0     0</span>
<span class="go">2     0     0     0</span>
<span class="go">3    10    13    17</span>
<span class="go">4    20    23    27</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.size">
<em class="property">property </em><code class="sig-name descname">size</code><a class="headerlink" href="#dask.dataframe.DataFrame.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the Series or DataFrame as a Delayed object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">size</span>  
<span class="go">dd.Scalar&lt;size-ag..., dtype=int64&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.squeeze">
<code class="sig-name descname">squeeze</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Squeeze 1 dimensional axis objects into scalars.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.squeeze.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Series or DataFrames with a single element are squeezed to a scalar.
DataFrames with a single column or a single row are squeezed to a
Series. Otherwise the object is unchanged.</p>
<p>This method is most useful when you don’t know if your
object is a Series or DataFrame, but you do know it has just a single
column. In that case you can safely call <cite>squeeze</cite> to ensure you have a
Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’, None}, default None</span></dt><dd><p>A specific axis to squeeze. By default, all length-1 axes are
squeezed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame, Series, or scalar</strong></dt><dd><p>The projection after squeezing <cite>axis</cite> or all the axes.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.iloc</span></code></dt><dd><p>Integer-location based indexing for selecting scalars.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.iloc" title="dask.dataframe.DataFrame.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.iloc</span></code></a></dt><dd><p>Integer-location based indexing for selecting Series.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.to_frame" title="dask.dataframe.Series.to_frame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.to_frame</span></code></a></dt><dd><p>Inverse of DataFrame.squeeze for a single-column DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">primes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>  
</pre></div>
</div>
<p>Slicing might produce a Series with a single value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">even_primes</span> <span class="o">=</span> <span class="n">primes</span><span class="p">[</span><span class="n">primes</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">even_primes</span>  
<span class="go">0    2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">even_primes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>  
<span class="go">2</span>
</pre></div>
</div>
<p>Squeezing objects with more than one value in every axis does nothing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">odd_primes</span> <span class="o">=</span> <span class="n">primes</span><span class="p">[</span><span class="n">primes</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">odd_primes</span>  
<span class="go">1    3</span>
<span class="go">2    5</span>
<span class="go">3    7</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">odd_primes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>  
<span class="go">1    3</span>
<span class="go">2    5</span>
<span class="go">3    7</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Squeezing is even more effective when used with DataFrames.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   a  b</span>
<span class="go">0  1  2</span>
<span class="go">1  3  4</span>
</pre></div>
</div>
<p>Slicing a single column will produce a DataFrame with the columns
having only one value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">]]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span>  
<span class="go">   a</span>
<span class="go">0  1</span>
<span class="go">1  3</span>
</pre></div>
</div>
<p>So the columns can be squeezed down, resulting in a Series:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">0    1</span>
<span class="go">1    3</span>
<span class="go">Name: a, dtype: int64</span>
</pre></div>
</div>
<p>Slicing a single row from a single column will produce a single
scalar DataFrame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_0a</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_0a</span>  
<span class="go">   a</span>
<span class="go">0  1</span>
</pre></div>
</div>
<p>Squeezing the rows produces a single scalar Series:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_0a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s1">&#39;rows&#39;</span><span class="p">)</span>  
<span class="go">a    1</span>
<span class="go">Name: 0, dtype: int64</span>
</pre></div>
</div>
<p>Squeezing all axes will project directly into a scalar:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_0a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>  
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sample standard deviation over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.std.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Normalized by N-1 by default. This can be changed using the ddof argument</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd></dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, default 1</span></dt><dd><p>Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
where N represents the number of elements.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.sub">
<code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Subtraction of dataframe and other, element-wise (binary operator <cite>sub</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.sub.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">-</span> <span class="pre">other</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>rsub</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">min_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of the values for the requested axis.</p>
<blockquote>
<div><p>This docstring was copied from pandas.core.frame.DataFrame.sum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This is equivalent to the method <code class="docutils literal notranslate"><span class="pre">numpy.sum</span></code>.</p>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd><p>Axis for the function to be applied on.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
<dt><strong>min_count</strong><span class="classifier">int, default 0</span></dt><dd><p>The required number of valid values to perform the operation. If fewer than
<code class="docutils literal notranslate"><span class="pre">min_count</span></code> non-NA values are present the result will be NA.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.22.0: </span>Added with the default being 0. This means the sum of an all-NA
or empty Series is 0, and the product of an all-NA or empty
Series is 1.</p>
</div>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to be passed to the function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.sum" title="dask.dataframe.Series.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.sum</span></code></a></dt><dd><p>Return the sum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.min" title="dask.dataframe.Series.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.min</span></code></a></dt><dd><p>Return the minimum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.max" title="dask.dataframe.Series.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.max</span></code></a></dt><dd><p>Return the maximum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.idxmin" title="dask.dataframe.Series.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmin</span></code></a></dt><dd><p>Return the index of the minimum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.idxmax" title="dask.dataframe.Series.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmax</span></code></a></dt><dd><p>Return the index of the maximum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sum" title="dask.dataframe.DataFrame.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sum</span></code></a></dt><dd><p>Return the sum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.min" title="dask.dataframe.DataFrame.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.min</span></code></a></dt><dd><p>Return the minimum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.max" title="dask.dataframe.DataFrame.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.max</span></code></a></dt><dd><p>Return the maximum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.idxmin" title="dask.dataframe.DataFrame.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.idxmin</span></code></a></dt><dd><p>Return the index of the minimum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.idxmax" title="dask.dataframe.DataFrame.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.idxmax</span></code></a></dt><dd><p>Return the index of the maximum over the requested axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">([</span>  
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;warm&#39;</span><span class="p">,</span> <span class="s1">&#39;warm&#39;</span><span class="p">,</span> <span class="s1">&#39;cold&#39;</span><span class="p">,</span> <span class="s1">&#39;cold&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="s1">&#39;falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;spider&#39;</span><span class="p">]],</span>
<span class="gp">... </span>    <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;blooded&#39;</span><span class="p">,</span> <span class="s1">&#39;animal&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;legs&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">blooded  animal</span>
<span class="go">warm     dog       4</span>
<span class="go">         falcon    2</span>
<span class="go">cold     fish      0</span>
<span class="go">         spider    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  
<span class="go">14</span>
</pre></div>
</div>
<p>Sum using level names, as well as indices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;blooded&#39;</span><span class="p">)</span>  
<span class="go">blooded</span>
<span class="go">warm    6</span>
<span class="go">cold    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">blooded</span>
<span class="go">warm    6</span>
<span class="go">cold    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<p>By default, the sum of an empty or all-NA Series is <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># min_count=0 is the default  </span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>This can be controlled with the <code class="docutils literal notranslate"><span class="pre">min_count</span></code> parameter. For example, if
you’d like the sum of an empty series to be NaN, pass <code class="docutils literal notranslate"><span class="pre">min_count=1</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">nan</span>
</pre></div>
</div>
<p>Thanks to the <code class="docutils literal notranslate"><span class="pre">skipna</span></code> parameter, <code class="docutils literal notranslate"><span class="pre">min_count</span></code> handles all-NA and
empty series identically.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  
<span class="go">0.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.tail">
<code class="sig-name descname">tail</code><span class="sig-paren">(</span><em class="sig-param">n=5</em>, <em class="sig-param">compute=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Last n rows of the dataset</p>
<p>Caveat, the only checks the last n rows of the last partition.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.to_bag">
<code class="sig-name descname">to_bag</code><span class="sig-paren">(</span><em class="sig-param">index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.to_bag" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Dask Bag from a Dask DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the elements are tuples of <code class="docutils literal notranslate"><span class="pre">(index,</span> <span class="pre">value)</span></code>, otherwise
they’re just the <code class="docutils literal notranslate"><span class="pre">value</span></code>.  Default is False.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bag</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_bag</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.to_csv">
<code class="sig-name descname">to_csv</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.to_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Store Dask DataFrame to CSV files</p>
<p>One filename per partition will be created. You can specify the
filenames in a variety of ways.</p>
<p>Use a globstring:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;/path/to/data/export-*.csv&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>The * will be replaced by the increasing sequence 0, 1, 2, …</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">export</span><span class="o">-</span><span class="mf">0.</span><span class="n">csv</span>
<span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">export</span><span class="o">-</span><span class="mf">1.</span><span class="n">csv</span>
</pre></div>
</div>
<p>Use a globstring and a <code class="docutils literal notranslate"><span class="pre">name_function=</span></code> keyword argument.  The
name_function function should expect an integer and produce a string.
Strings produced by name_function must preserve the order of their
respective partition indices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">date</span><span class="p">(</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;2015-01-01&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="go">&#39;2015-01-16&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;/path/to/data/export-*.csv&#39;</span><span class="p">,</span> <span class="n">name_function</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>  
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">export</span><span class="o">-</span><span class="mi">2015</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mf">01.</span><span class="n">csv</span>
<span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">export</span><span class="o">-</span><span class="mi">2015</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mf">02.</span><span class="n">csv</span>
<span class="o">...</span>
</pre></div>
</div>
<p>You can also provide an explicit list of paths:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;/path/to/data/alice.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;/path/to/data/bob.csv&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> 
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">string</span></dt><dd><p>Path glob indicating the naming scheme for the output files</p>
</dd>
<dt><strong>name_function</strong><span class="classifier">callable, default None</span></dt><dd><p>Function accepting an integer (partition index) and producing a
string to replace the asterisk in the given filename globstring.
Should preserve the lexicographic order of partitions. Not
supported when <cite>single_file</cite> is <cite>True</cite>.</p>
</dd>
<dt><strong>single_file</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether to save everything into a single CSV file. Under the
single file mode, each partition is appended at the end of the
specified CSV file. Note that not all filesystems support the
append mode and thus the single file mode, especially on cloud
storage systems such as S3 or GCS. A warning will be issued when
writing to a file that is not backed by a local filesystem.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">string or None</span></dt><dd><p>String like ‘gzip’ or ‘xz’.  Must support efficient random access.
Filenames with extensions corresponding to known compression
algorithms (gz, bz2) will be compressed accordingly automatically</p>
</dd>
<dt><strong>sep</strong><span class="classifier">character, default ‘,’</span></dt><dd><p>Field delimiter for the output file</p>
</dd>
<dt><strong>na_rep</strong><span class="classifier">string, default ‘’</span></dt><dd><p>Missing data representation</p>
</dd>
<dt><strong>float_format</strong><span class="classifier">string, default None</span></dt><dd><p>Format string for floating point numbers</p>
</dd>
<dt><strong>columns</strong><span class="classifier">sequence, optional</span></dt><dd><p>Columns to write</p>
</dd>
<dt><strong>header</strong><span class="classifier">boolean or list of string, default True</span></dt><dd><p>Write out column names. If a list of string is given it is assumed
to be aliases for the column names</p>
</dd>
<dt><strong>header_first_partition_only</strong><span class="classifier">boolean, default None</span></dt><dd><p>If set to <cite>True</cite>, only write the header row in the first output
file. By default, headers are written to all partitions under
the multiple file mode (<cite>single_file</cite> is <cite>False</cite>) and written
only once under the single file mode (<cite>single_file</cite> is <cite>True</cite>).
It must not be <cite>False</cite> under the single file mode.</p>
</dd>
<dt><strong>index</strong><span class="classifier">boolean, default True</span></dt><dd><p>Write row names (index)</p>
</dd>
<dt><strong>index_label</strong><span class="classifier">string or sequence, or False, default None</span></dt><dd><p>Column label for index column(s) if desired. If None is given, and
<cite>header</cite> and <cite>index</cite> are True, then the index names are used. A
sequence should be given if the DataFrame uses MultiIndex.  If
False do not print fields for index names. Use index_label=False
for easier importing in R</p>
</dd>
<dt><strong>nanRep</strong><span class="classifier">None</span></dt><dd><p>deprecated, use na_rep</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str</span></dt><dd><p>Python write mode, default ‘w’</p>
</dd>
<dt><strong>encoding</strong><span class="classifier">string, optional</span></dt><dd><p>A string representing the encoding to use in the output file,
defaults to ‘ascii’ on Python 2 and ‘utf-8’ on Python 3.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">string, optional</span></dt><dd><p>a string representing the compression to use in the output file,
allowed values are ‘gzip’, ‘bz2’, ‘xz’,
only used when the first argument is a filename</p>
</dd>
<dt><strong>line_terminator</strong><span class="classifier">string, default ‘n’</span></dt><dd><p>The newline character or character sequence to use in the output
file</p>
</dd>
<dt><strong>quoting</strong><span class="classifier">optional constant from csv module</span></dt><dd><p>defaults to csv.QUOTE_MINIMAL</p>
</dd>
<dt><strong>quotechar</strong><span class="classifier">string (length 1), default ‘”’</span></dt><dd><p>character used to quote fields</p>
</dd>
<dt><strong>doublequote</strong><span class="classifier">boolean, default True</span></dt><dd><p>Control quoting of <cite>quotechar</cite> inside a field</p>
</dd>
<dt><strong>escapechar</strong><span class="classifier">string (length 1), default None</span></dt><dd><p>character used to escape <cite>sep</cite> and <cite>quotechar</cite> when appropriate</p>
</dd>
<dt><strong>chunksize</strong><span class="classifier">int or None</span></dt><dd><p>rows to write at a time</p>
</dd>
<dt><strong>tupleize_cols</strong><span class="classifier">boolean, default False</span></dt><dd><p>write multi_index columns as a list of tuples (if True)
or new (expanded format) if False)</p>
</dd>
<dt><strong>date_format</strong><span class="classifier">string, default None</span></dt><dd><p>Format string for datetime objects</p>
</dd>
<dt><strong>decimal: string, default ‘.’</strong></dt><dd><p>Character recognized as decimal separator. E.g. use ‘,’ for
European data</p>
</dd>
<dt><strong>storage_options: dict</strong></dt><dd><p>Parameters passed on to the backend filesystem class.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>The names of the file written if they were computed right away</strong></dt><dd></dd>
<dt><strong>If not, the delayed tasks associated to the writing of the files</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If <cite>header_first_partition_only</cite> is set to <cite>False</cite> or
<cite>name_function</cite> is specified when <cite>single_file</cite> is <cite>True</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.to_dask_array">
<code class="sig-name descname">to_dask_array</code><span class="sig-paren">(</span><em class="sig-param">lengths=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.to_dask_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a dask DataFrame to a dask array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lengths</strong><span class="classifier">bool or Sequence of ints, optional</span></dt><dd><p>How to determine the chunks sizes for the output array.
By default, the output array will have unknown chunk lengths
along the first axis, which can cause some later operations
to fail.</p>
<ul class="simple">
<li><p>True : immediately compute the length of each partition</p></li>
<li><p>Sequence : a sequence of integers to use for the chunk sizes
on the first axis. These values are <em>not</em> validated for
correctness, beyond ensuring that the number of items
matches the number of partitions.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.to_delayed">
<code class="sig-name descname">to_delayed</code><span class="sig-paren">(</span><em class="sig-param">optimize_graph=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.to_delayed" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert into a list of <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> objects, one per partition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>optimize_graph</strong><span class="classifier">bool, optional</span></dt><dd><p>If True [default], the graph is optimized before converting into
<code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> objects.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.from_delayed" title="dask.dataframe.from_delayed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.dataframe.from_delayed</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">partitions</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_delayed</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.to_hdf">
<code class="sig-name descname">to_hdf</code><span class="sig-paren">(</span><em class="sig-param">path_or_buf</em>, <em class="sig-param">key</em>, <em class="sig-param">mode='a'</em>, <em class="sig-param">append=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Store Dask Dataframe to Hierarchical Data Format (HDF) files</p>
<p>This is a parallel version of the Pandas function of the same name.  Please
see the Pandas docstring for more detailed information about shared keyword
arguments.</p>
<p>This function differs from the Pandas version by saving the many partitions
of a Dask DataFrame in parallel, either to many files, or to many datasets
within the same file.  You may specify this parallelism with an asterix
<code class="docutils literal notranslate"><span class="pre">*</span></code> within the filename or datapath, and an optional <code class="docutils literal notranslate"><span class="pre">name_function</span></code>.
The asterix will be replaced with an increasing sequence of integers
starting from <code class="docutils literal notranslate"><span class="pre">0</span></code> or with the result of calling <code class="docutils literal notranslate"><span class="pre">name_function</span></code> on each
of those integers.</p>
<p>This function only supports the Pandas <code class="docutils literal notranslate"><span class="pre">'table'</span></code> format, not the more
specialized <code class="docutils literal notranslate"><span class="pre">'fixed'</span></code> format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">string, pathlib.Path</span></dt><dd><p>Path to a target filename. Supports strings, <code class="docutils literal notranslate"><span class="pre">pathlib.Path</span></code>, or any
object implementing the <code class="docutils literal notranslate"><span class="pre">__fspath__</span></code> protocol. May contain a <code class="docutils literal notranslate"><span class="pre">*</span></code> to
denote many filenames.</p>
</dd>
<dt><strong>key</strong><span class="classifier">string</span></dt><dd><p>Datapath within the files.  May contain a <code class="docutils literal notranslate"><span class="pre">*</span></code> to denote many locations</p>
</dd>
<dt><strong>name_function</strong><span class="classifier">function</span></dt><dd><p>A function to convert the <code class="docutils literal notranslate"><span class="pre">*</span></code> in the above options to a string.
Should take in a number from 0 to the number of partitions and return a
string. (see examples below)</p>
</dd>
<dt><strong>compute</strong><span class="classifier">bool</span></dt><dd><p>Whether or not to execute immediately.  If False then this returns a
<code class="docutils literal notranslate"><span class="pre">dask.Delayed</span></code> value.</p>
</dd>
<dt><strong>lock</strong><span class="classifier">Lock, optional</span></dt><dd><p>Lock to use to prevent concurrency issues.  By default a
<code class="docutils literal notranslate"><span class="pre">threading.Lock</span></code>, <code class="docutils literal notranslate"><span class="pre">multiprocessing.Lock</span></code> or <code class="docutils literal notranslate"><span class="pre">SerializableLock</span></code>
will be used depending on your scheduler if a lock is required. See
dask.utils.get_scheduler_lock for more information about lock
selection.</p>
</dd>
<dt><strong>scheduler</strong><span class="classifier">string</span></dt><dd><p>The scheduler to use, like “threads” or “processes”</p>
</dd>
<dt><strong>**other:</strong></dt><dd><p>See pandas.to_hdf for more information</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filenames</strong><span class="classifier">list</span></dt><dd><p>Returned if <code class="docutils literal notranslate"><span class="pre">compute</span></code> is True. List of file names that each partition
is saved to.</p>
</dd>
<dt><strong>delayed</strong><span class="classifier">dask.Delayed</span></dt><dd><p>Returned if <code class="docutils literal notranslate"><span class="pre">compute</span></code> is False. Delayed object to execute <code class="docutils literal notranslate"><span class="pre">to_hdf</span></code>
when computed.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.read_hdf" title="dask.dataframe.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_hdf</span></code></a>, <a class="reference internal" href="#dask.dataframe.to_parquet" title="dask.dataframe.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_parquet</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Save Data to a single file</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;output.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data&#39;</span><span class="p">)</span>            
</pre></div>
</div>
<p>Save data to multiple datapaths within the same file:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;output.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data-*&#39;</span><span class="p">)</span>          
</pre></div>
</div>
<p>Save data to multiple files:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;output-*.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data&#39;</span><span class="p">)</span>          
</pre></div>
</div>
<p>Save data to multiple files, using the multiprocessing scheduler:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;output-*.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data&#39;</span><span class="p">,</span> <span class="n">scheduler</span><span class="o">=</span><span class="s1">&#39;processes&#39;</span><span class="p">)</span> 
</pre></div>
</div>
<p>Specify custom naming scheme.  This writes files as
‘2000-01-01.hdf’, ‘2000-01-02.hdf’, ‘2000-01-03.hdf’, etc..</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">base</span> <span class="o">=</span> <span class="n">date</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">name_function</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&#39;&#39;&#39; Convert integer 0 to n to a string &#39;&#39;&#39;</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">base</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;*.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data&#39;</span><span class="p">,</span> <span class="n">name_function</span><span class="o">=</span><span class="n">name_function</span><span class="p">)</span> 
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.to_html">
<code class="sig-name descname">to_html</code><span class="sig-paren">(</span><em class="sig-param">max_rows=5</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.to_html" title="Permalink to this definition">¶</a></dt>
<dd><p>Render a DataFrame as an HTML table.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>buf</strong><span class="classifier">str, Path or StringIO-like, optional, default None  (Not supported in Dask)</span></dt><dd><p>Buffer to write to. If None, the output is returned as a string.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">sequence, optional, default None  (Not supported in Dask)</span></dt><dd><p>The subset of columns to write. Writes all columns by default.</p>
</dd>
<dt><strong>col_space</strong><span class="classifier">str or int, optional  (Not supported in Dask)</span></dt><dd><p>The minimum width of each column in CSS length units.  An int is assumed to be px units.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.to_html.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.25.0: </span>Ability to use str.</p>
</div>
</dd>
<dt><strong>header</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>Whether to print column labels, default True.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, optional, default True  (Not supported in Dask)</span></dt><dd><p>Whether to print index (row) labels.</p>
</dd>
<dt><strong>na_rep</strong><span class="classifier">str, optional, default ‘NaN’  (Not supported in Dask)</span></dt><dd><p>String representation of NAN to use.</p>
</dd>
<dt><strong>formatters</strong><span class="classifier">list, tuple or dict of one-param. functions, optional  (Not supported in Dask)</span></dt><dd><p>Formatter functions to apply to columns’ elements by position or
name.
The result of each function must be a unicode string.
List/tuple must be of length equal to the number of columns.</p>
</dd>
<dt><strong>float_format</strong><span class="classifier">one-parameter function, optional, default None  (Not supported in Dask)</span></dt><dd><p>Formatter function to apply to columns’ elements if they are
floats. The result of this function must be a unicode string.</p>
</dd>
<dt><strong>sparsify</strong><span class="classifier">bool, optional, default True  (Not supported in Dask)</span></dt><dd><p>Set to False for a DataFrame with a hierarchical index to print
every multiindex key at each row.</p>
</dd>
<dt><strong>index_names</strong><span class="classifier">bool, optional, default True  (Not supported in Dask)</span></dt><dd><p>Prints the names of the indexes.</p>
</dd>
<dt><strong>justify</strong><span class="classifier">str, default None  (Not supported in Dask)</span></dt><dd><p>How to justify the column labels. If None uses the option from
the print configuration (controlled by set_option), ‘right’ out
of the box. Valid values are</p>
<ul class="simple">
<li><p>left</p></li>
<li><p>right</p></li>
<li><p>center</p></li>
<li><p>justify</p></li>
<li><p>justify-all</p></li>
<li><p>start</p></li>
<li><p>end</p></li>
<li><p>inherit</p></li>
<li><p>match-parent</p></li>
<li><p>initial</p></li>
<li><p>unset.</p></li>
</ul>
</dd>
<dt><strong>max_rows</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of rows to display in the console.</p>
</dd>
<dt><strong>min_rows</strong><span class="classifier">int, optional</span></dt><dd><p>The number of rows to display in the console in a truncated repr
(when number of rows is above <cite>max_rows</cite>).</p>
</dd>
<dt><strong>max_cols</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>Maximum number of columns to display in the console.</p>
</dd>
<dt><strong>show_dimensions</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Display DataFrame dimensions (number of rows by number of columns).</p>
</dd>
<dt><strong>decimal</strong><span class="classifier">str, default ‘.’  (Not supported in Dask)</span></dt><dd><p>Character recognized as decimal separator, e.g. ‘,’ in Europe.</p>
</dd>
<dt><strong>bold_rows</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>Make the row labels bold in the output.</p>
</dd>
<dt><strong>classes</strong><span class="classifier">str or list or tuple, default None  (Not supported in Dask)</span></dt><dd><p>CSS class(es) to apply to the resulting html table.</p>
</dd>
<dt><strong>escape</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>Convert the characters &lt;, &gt;, and &amp; to HTML-safe sequences.</p>
</dd>
<dt><strong>notebook</strong><span class="classifier">{True, False}, default False  (Not supported in Dask)</span></dt><dd><p>Whether the generated HTML is for IPython Notebook.</p>
</dd>
<dt><strong>border</strong><span class="classifier">int  (Not supported in Dask)</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">border=border</span></code> attribute is included in the opening
<cite>&lt;table&gt;</cite> tag. Default <code class="docutils literal notranslate"><span class="pre">pd.options.display.html.border</span></code>.</p>
</dd>
<dt><strong>encoding</strong><span class="classifier">str, default “utf-8”  (Not supported in Dask)</span></dt><dd><p>Set character encoding.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.0.</span></p>
</div>
</dd>
<dt><strong>table_id</strong><span class="classifier">str, optional  (Not supported in Dask)</span></dt><dd><p>A css id is included in the opening <cite>&lt;table&gt;</cite> tag if specified.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.23.0.</span></p>
</div>
</dd>
<dt><strong>render_links</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Convert URLs to HTML links.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>str or None</strong></dt><dd><p>If buf is None, returns the result as a string. Otherwise returns
None.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.to_string" title="dask.dataframe.DataFrame.to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_string</span></code></a></dt><dd><p>Convert DataFrame to a string.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.to_json">
<code class="sig-name descname">to_json</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>See dd.to_json docstring for more information</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.to_parquet">
<code class="sig-name descname">to_parquet</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.to_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Store Dask.dataframe to Parquet files</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">dask.dataframe.DataFrame</span></dt><dd></dd>
<dt><strong>path</strong><span class="classifier">string or pathlib.Path</span></dt><dd><p>Destination directory for data.  Prepend with protocol like <code class="docutils literal notranslate"><span class="pre">s3://</span></code>
or <code class="docutils literal notranslate"><span class="pre">hdfs://</span></code> for remote data.</p>
</dd>
<dt><strong>engine</strong><span class="classifier">{‘auto’, ‘fastparquet’, ‘pyarrow’}, default ‘auto’</span></dt><dd><p>Parquet library to use. If only one library is installed, it will use
that one; if both, it will use ‘fastparquet’.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">string or dict, optional</span></dt><dd><p>Either a string like <code class="docutils literal notranslate"><span class="pre">&quot;snappy&quot;</span></code> or a dictionary mapping column names
to compressors like <code class="docutils literal notranslate"><span class="pre">{&quot;name&quot;:</span> <span class="pre">&quot;gzip&quot;,</span> <span class="pre">&quot;values&quot;:</span> <span class="pre">&quot;snappy&quot;}</span></code>. The
default is <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code>, which uses the default compression for
whichever engine is selected.</p>
</dd>
<dt><strong>write_index</strong><span class="classifier">boolean, optional</span></dt><dd><p>Whether or not to write the index. Defaults to True.</p>
</dd>
<dt><strong>append</strong><span class="classifier">bool, optional</span></dt><dd><p>If False (default), construct data-set from scratch. If True, add new
row-group(s) to an existing data-set. In the latter case, the data-set
must exist, and the schema must match the input data.</p>
</dd>
<dt><strong>ignore_divisions</strong><span class="classifier">bool, optional</span></dt><dd><p>If False (default) raises error when previous divisions overlap with
the new appended divisions. Ignored if append=False.</p>
</dd>
<dt><strong>partition_on</strong><span class="classifier">list, optional</span></dt><dd><p>Construct directory-based partitioning by splitting on these fields’
values. Each dask partition will result in one or more datafiles,
there will be no global groupby.</p>
</dd>
<dt><strong>storage_options</strong><span class="classifier">dict, optional</span></dt><dd><p>Key/value pairs to be passed on to the file-system backend, if any.</p>
</dd>
<dt><strong>write_metadata_file</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to write the special “_metadata” file.</p>
</dd>
<dt><strong>compute</strong><span class="classifier">bool, optional</span></dt><dd><p>If True (default) then the result is computed immediately. If False
then a <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> object is returned for future computation.</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Extra options to be passed on to the specific backend.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.read_parquet" title="dask.dataframe.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_parquet</span></code></a></dt><dd><p>Read parquet data to dask.dataframe</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Each partition will be written to a separate file.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s1">&#39;/path/to/output/&#39;</span><span class="p">,</span><span class="o">...</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.to_records">
<code class="sig-name descname">to_records</code><span class="sig-paren">(</span><em class="sig-param">index=False</em>, <em class="sig-param">lengths=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.to_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Dask Array from a Dask Dataframe</p>
<p>Warning: This creates a dask.array without precise shape information.
Operations that depend on shape information, like slicing or reshaping,
will not work.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.dataframe._Frame.values</span></code>, <a class="reference internal" href="#dask.dataframe.from_dask_array" title="dask.dataframe.from_dask_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.dataframe.from_dask_array</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_records</span><span class="p">()</span>  
<span class="go">dask.array&lt;to_records, shape=(nan,), dtype=(numpy.record, [(&#39;ind&#39;, &#39;&lt;f8&#39;), (&#39;x&#39;, &#39;O&#39;), (&#39;y&#39;, &#39;&lt;i8&#39;)]), chunksize=(nan,), chunktype=numpy.ndarray&gt;  # noqa: E501</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.to_sql">
<code class="sig-name descname">to_sql</code><span class="sig-paren">(</span><em class="sig-param">name: str</em>, <em class="sig-param">con</em>, <em class="sig-param">schema=None</em>, <em class="sig-param">if_exists: str = 'fail'</em>, <em class="sig-param">index: bool = True</em>, <em class="sig-param">index_label=None</em>, <em class="sig-param">chunksize=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">method=None</em>, <em class="sig-param">compute=True</em>, <em class="sig-param">parallel=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.to_sql" title="Permalink to this definition">¶</a></dt>
<dd><p>See dd.to_sql docstring for more information</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.to_string">
<code class="sig-name descname">to_string</code><span class="sig-paren">(</span><em class="sig-param">max_rows=5</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Render a DataFrame to a console-friendly tabular output.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>buf</strong><span class="classifier">str, Path or StringIO-like, optional, default None  (Not supported in Dask)</span></dt><dd><p>Buffer to write to. If None, the output is returned as a string.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">sequence, optional, default None  (Not supported in Dask)</span></dt><dd><p>The subset of columns to write. Writes all columns by default.</p>
</dd>
<dt><strong>col_space</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>The minimum width of each column.</p>
</dd>
<dt><strong>header</strong><span class="classifier">bool or sequence, optional  (Not supported in Dask)</span></dt><dd><p>Write out the column names. If a list of strings is given, it is assumed to be aliases for the column names.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, optional, default True  (Not supported in Dask)</span></dt><dd><p>Whether to print index (row) labels.</p>
</dd>
<dt><strong>na_rep</strong><span class="classifier">str, optional, default ‘NaN’  (Not supported in Dask)</span></dt><dd><p>String representation of NAN to use.</p>
</dd>
<dt><strong>formatters</strong><span class="classifier">list, tuple or dict of one-param. functions, optional  (Not supported in Dask)</span></dt><dd><p>Formatter functions to apply to columns’ elements by position or
name.
The result of each function must be a unicode string.
List/tuple must be of length equal to the number of columns.</p>
</dd>
<dt><strong>float_format</strong><span class="classifier">one-parameter function, optional, default None  (Not supported in Dask)</span></dt><dd><p>Formatter function to apply to columns’ elements if they are
floats. The result of this function must be a unicode string.</p>
</dd>
<dt><strong>sparsify</strong><span class="classifier">bool, optional, default True  (Not supported in Dask)</span></dt><dd><p>Set to False for a DataFrame with a hierarchical index to print
every multiindex key at each row.</p>
</dd>
<dt><strong>index_names</strong><span class="classifier">bool, optional, default True  (Not supported in Dask)</span></dt><dd><p>Prints the names of the indexes.</p>
</dd>
<dt><strong>justify</strong><span class="classifier">str, default None  (Not supported in Dask)</span></dt><dd><p>How to justify the column labels. If None uses the option from
the print configuration (controlled by set_option), ‘right’ out
of the box. Valid values are</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.to_string.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<ul class="simple">
<li><p>left</p></li>
<li><p>right</p></li>
<li><p>center</p></li>
<li><p>justify</p></li>
<li><p>justify-all</p></li>
<li><p>start</p></li>
<li><p>end</p></li>
<li><p>inherit</p></li>
<li><p>match-parent</p></li>
<li><p>initial</p></li>
<li><p>unset.</p></li>
</ul>
</dd>
<dt><strong>max_rows</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of rows to display in the console.</p>
</dd>
<dt><strong>min_rows</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>The number of rows to display in the console in a truncated repr
(when number of rows is above <cite>max_rows</cite>).</p>
</dd>
<dt><strong>max_cols</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>Maximum number of columns to display in the console.</p>
</dd>
<dt><strong>show_dimensions</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Display DataFrame dimensions (number of rows by number of columns).</p>
</dd>
<dt><strong>decimal</strong><span class="classifier">str, default ‘.’  (Not supported in Dask)</span></dt><dd><p>Character recognized as decimal separator, e.g. ‘,’ in Europe.</p>
</dd>
<dt><strong>line_width</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>Width to wrap a line in characters.</p>
</dd>
<dt><strong>max_colwidth</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>Max width to truncate each column in characters. By default, no limit.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.0.0.</span></p>
</div>
</dd>
<dt><strong>encoding</strong><span class="classifier">str, default “utf-8”  (Not supported in Dask)</span></dt><dd><p>Set character encoding.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>str or None</strong></dt><dd><p>If buf is None, returns the result as a string. Otherwise returns
None.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.to_html" title="dask.dataframe.DataFrame.to_html"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_html</span></code></a></dt><dd><p>Convert DataFrame to HTML.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;col1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;col2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]}</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span>  
<span class="go">   col1  col2</span>
<span class="go">0     1     4</span>
<span class="go">1     2     5</span>
<span class="go">2     3     6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.to_timestamp">
<code class="sig-name descname">to_timestamp</code><span class="sig-paren">(</span><em class="sig-param">freq=None</em>, <em class="sig-param">how='start'</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.to_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast to DatetimeIndex of timestamps, at <em>beginning</em> of period.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.to_timestamp.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>freq</strong><span class="classifier">str, default frequency of PeriodIndex</span></dt><dd><p>Desired frequency.</p>
</dd>
<dt><strong>how</strong><span class="classifier">{‘s’, ‘e’, ‘start’, ‘end’}</span></dt><dd><p>Convention for converting period to timestamp; start of period
vs. end.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The axis to convert (the index by default).</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>If False then underlying input data is not copied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame with DatetimeIndex</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.truediv">
<code class="sig-name descname">truediv</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">axis='columns'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.truediv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Floating division of dataframe and other, element-wise (binary operator <cite>truediv</cite>).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.truediv.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">/</span> <span class="pre">other</span></code>, but with support to substitute a fill_value
for missing data in one of the inputs. With reverse version, <cite>rtruediv</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Whether to compare by the index (0 or ‘index’) or columns
(1 or ‘columns’). For Series input, axis to match Series index on.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or label</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful DataFrame alignment, with this value before computation.
If data in both corresponding DataFrame locations is missing
the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.add" title="dask.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.add</span></code></a></dt><dd><p>Add DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sub" title="dask.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sub</span></code></a></dt><dd><p>Subtract DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mul" title="dask.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mul</span></code></a></dt><dd><p>Multiply DataFrames.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.div" title="dask.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.div</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.truediv" title="dask.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.truediv</span></code></a></dt><dd><p>Divide DataFrames (float division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.floordiv" title="dask.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.floordiv</span></code></a></dt><dd><p>Divide DataFrames (integer division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mod" title="dask.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mod</span></code></a></dt><dd><p>Calculate modulo (remainder after division).</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.pow" title="dask.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pow</span></code></a></dt><dd><p>Calculate exponential power.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Mismatched indices will be unioned together.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      360</span>
<span class="go">triangle        3      180</span>
<span class="go">rectangle       4      360</span>
</pre></div>
</div>
<p>Add a scalar with operator version which return the same
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
<p>Divide by constant with reverse version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">             angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
<p>Subtract a list and Series by axis with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>       <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="go">           angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
</pre></div>
</div>
<p>Multiply a DataFrame of different shape with operator version.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>  
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span>  
<span class="go">           angles</span>
<span class="go">circle          0</span>
<span class="go">triangle        3</span>
<span class="go">rectangle       4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      NaN</span>
<span class="go">triangle        9      NaN</span>
<span class="go">rectangle      16      NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">           angles  degrees</span>
<span class="go">circle          0      0.0</span>
<span class="go">triangle        9      0.0</span>
<span class="go">rectangle      16      0.0</span>
</pre></div>
</div>
<p>Divide by a MultiIndex by level.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                             <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">720</span><span class="p">]},</span>
<span class="gp">... </span>                            <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">... </span>                                   <span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;pentagon&#39;</span><span class="p">,</span> <span class="s1">&#39;hexagon&#39;</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_multindex</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle          0      360</span>
<span class="go">  triangle        3      180</span>
<span class="go">  rectangle       4      360</span>
<span class="go">B square          4      360</span>
<span class="go">  pentagon        5      540</span>
<span class="go">  hexagon         6      720</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">df_multindex</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">             angles  degrees</span>
<span class="go">A circle        NaN      1.0</span>
<span class="go">  triangle      1.0      1.0</span>
<span class="go">  rectangle     1.0      1.0</span>
<span class="go">B square        0.0      0.0</span>
<span class="go">  pentagon      0.0      0.0</span>
<span class="go">  hexagon       0.0      0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.values">
<em class="property">property </em><code class="sig-name descname">values</code><a class="headerlink" href="#dask.dataframe.DataFrame.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dask.array of the values of this dataframe</p>
<p>Warning: This creates a dask.array without precise shape information.
Operations that depend on shape information, like slicing or reshaping,
will not work.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unbiased variance over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.var.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Normalized by N-1 by default. This can be changed using the ddof argument</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd></dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, default 1</span></dt><dd><p>Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
where N represents the number of elements.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.visualize">
<code class="sig-name descname">visualize</code><span class="sig-paren">(</span><em class="sig-param">filename='mydask'</em>, <em class="sig-param">format=None</em>, <em class="sig-param">optimize_graph=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.visualize" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the computation of this object’s task graph using graphviz.</p>
<p>Requires <code class="docutils literal notranslate"><span class="pre">graphviz</span></code> to be installed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str or None, optional</span></dt><dd><p>The name (without an extension) of the file to write to disk.  If
<cite>filename</cite> is None, no file will be written, and we communicate
with dot using only pipes.</p>
</dd>
<dt><strong>format</strong><span class="classifier">{‘png’, ‘pdf’, ‘dot’, ‘svg’, ‘jpeg’, ‘jpg’}, optional</span></dt><dd><p>Format in which to write output file.  Default is ‘png’.</p>
</dd>
<dt><strong>optimize_graph</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the graph is optimized before rendering.  Otherwise,
the graph is displayed as is. Default is False.</p>
</dd>
<dt><strong>color: {None, ‘order’}, optional</strong></dt><dd><p>Options to color nodes.  Provide <code class="docutils literal notranslate"><span class="pre">cmap=</span></code> keyword for additional
colormap</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to forward to <code class="docutils literal notranslate"><span class="pre">to_graphviz</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">IPython.diplay.Image, IPython.display.SVG, or None</span></dt><dd><p>See dask.dot.dot_graph for more information.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.base.visualize</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.dot.dot_graph</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>For more information on optimization see here:</p>
<p><a class="reference external" href="https://docs.dask.org/en/latest/optimize.html">https://docs.dask.org/en/latest/optimize.html</a></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;dask.pdf&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;dask.pdf&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;order&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.DataFrame.where">
<code class="sig-name descname">where</code><span class="sig-paren">(</span><em class="sig-param">cond</em>, <em class="sig-param">other=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.DataFrame.where" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values where the condition is False.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.where.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cond</strong><span class="classifier">bool Series/DataFrame, array-like, or callable</span></dt><dd><p>Where <cite>cond</cite> is True, keep the original value. Where
False, replace with corresponding value from <cite>other</cite>.
If <cite>cond</cite> is callable, it is computed on the Series/DataFrame and
should return boolean Series/DataFrame or array. The callable must
not change input Series/DataFrame (though pandas doesn’t check it).</p>
</dd>
<dt><strong>other</strong><span class="classifier">scalar, Series/DataFrame, or callable</span></dt><dd><p>Entries where <cite>cond</cite> is False are replaced with
corresponding value from <cite>other</cite>.
If other is callable, it is computed on the Series/DataFrame and
should return scalar or Series/DataFrame. The callable must not
change input Series/DataFrame (though pandas doesn’t check it).</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Whether to perform the operation in place on the data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, default None  (Not supported in Dask)</span></dt><dd><p>Alignment axis if needed.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int, default None  (Not supported in Dask)</span></dt><dd><p>Alignment level if needed.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, {‘raise’, ‘ignore’}, default ‘raise’  (Not supported in Dask)</span></dt><dd><p>Note that currently this parameter won’t affect
the results and will always coerce to a suitable dtype.</p>
<ul class="simple">
<li><p>‘raise’ : allow exceptions to be raised.</p></li>
<li><p>‘ignore’ : suppress exceptions. On error return original object.</p></li>
</ul>
</dd>
<dt><strong>try_cast</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Try to cast the result back to the input type (if possible).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Same type as caller</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mask" title="dask.dataframe.DataFrame.mask"><code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.mask()</span></code></a></dt><dd><p>Return an object of same shape as self.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The where method is an application of the if-then idiom. For each
element in the calling DataFrame, if <code class="docutils literal notranslate"><span class="pre">cond</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> the
element is used; otherwise the corresponding element from the DataFrame
<code class="docutils literal notranslate"><span class="pre">other</span></code> is used.</p>
<p>The signature for <a class="reference internal" href="#dask.dataframe.DataFrame.where" title="dask.dataframe.DataFrame.where"><code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.where()</span></code></a> differs from
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html#numpy.where" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.where()</span></code></a>. Roughly <code class="docutils literal notranslate"><span class="pre">df1.where(m,</span> <span class="pre">df2)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">np.where(m,</span> <span class="pre">df1,</span> <span class="pre">df2)</span></code>.</p>
<p>For further details and examples see the <code class="docutils literal notranslate"><span class="pre">where</span></code> documentation in
<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#indexing-where-mask" title="(in pandas v1.0.3)"><span class="xref std std-ref">indexing</span></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  
<span class="go">0    NaN</span>
<span class="go">1    1.0</span>
<span class="go">2    2.0</span>
<span class="go">3    3.0</span>
<span class="go">4    4.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  
<span class="go">0    0.0</span>
<span class="go">1    NaN</span>
<span class="go">2    NaN</span>
<span class="go">3    NaN</span>
<span class="go">4    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  
<span class="go">0    10</span>
<span class="go">1    10</span>
<span class="go">2    2</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A  B</span>
<span class="go">0  0  1</span>
<span class="go">1  2  3</span>
<span class="go">2  4  5</span>
<span class="go">3  6  7</span>
<span class="go">4  8  9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">df</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>  
<span class="go">   A  B</span>
<span class="go">0  0 -1</span>
<span class="go">1 -2  3</span>
<span class="go">2 -4 -5</span>
<span class="go">3  6 -7</span>
<span class="go">4 -8  9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>  
<span class="go">      A     B</span>
<span class="go">0  True  True</span>
<span class="go">1  True  True</span>
<span class="go">2  True  True</span>
<span class="go">3  True  True</span>
<span class="go">4  True  True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="n">df</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="o">~</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>  
<span class="go">      A     B</span>
<span class="go">0  True  True</span>
<span class="go">1  True  True</span>
<span class="go">2  True  True</span>
<span class="go">3  True  True</span>
<span class="go">4  True  True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="series-methods">
<h2>Series Methods<a class="headerlink" href="#series-methods" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dask.dataframe.Series">
<em class="property">class </em><code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">Series</code><span class="sig-paren">(</span><em class="sig-param">dsk</em>, <em class="sig-param">name</em>, <em class="sig-param">meta</em>, <em class="sig-param">divisions</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel Pandas Series</p>
<p>Do not use this class directly.  Instead use functions like
<code class="docutils literal notranslate"><span class="pre">dd.read_csv</span></code>, <code class="docutils literal notranslate"><span class="pre">dd.read_parquet</span></code>, or <code class="docutils literal notranslate"><span class="pre">dd.from_pandas</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dsk: dict</strong></dt><dd><p>The dask graph to compute this Series</p>
</dd>
<dt><strong>_name: str</strong></dt><dd><p>The key prefix that specifies which keys in the dask comprise this
particular Series</p>
</dd>
<dt><strong>meta: pandas.Series</strong></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pandas.Series</span></code> with names, dtypes, and index matching the
expected output.</p>
</dd>
<dt><strong>divisions: tuple of index values</strong></dt><dd><p>Values along which we partition our blocks on the index</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.DataFrame" title="dask.dataframe.DataFrame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.dataframe.DataFrame</span></code></a></p>
</div>
<dl class="method">
<dt id="dask.dataframe.Series.abs">
<code class="sig-name descname">abs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Series/DataFrame with absolute numeric value of each element.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.abs.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This function only applies to elements that are all numeric.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>abs</strong></dt><dd><p>Series/DataFrame containing the absolute value of each element.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.absolute.html#numpy.absolute" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.absolute</span></code></a></dt><dd><p>Calculate the absolute value element-wise.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For <code class="docutils literal notranslate"><span class="pre">complex</span></code> inputs, <code class="docutils literal notranslate"><span class="pre">1.2</span> <span class="pre">+</span> <span class="pre">1j</span></code>, the absolute value is
<span class="math notranslate nohighlight">\(\sqrt{ a^2 + b^2 }\)</span>.</p>
<p class="rubric">Examples</p>
<p>Absolute numeric values in a Series.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="o">-</span><span class="mf">1.10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.33</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>  
<span class="go">0    1.10</span>
<span class="go">1    2.00</span>
<span class="go">2    3.33</span>
<span class="go">3    4.00</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Absolute numeric values in a Series with complex numbers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">1.2</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>  
<span class="go">0    1.56205</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Absolute numeric values in a Series with a Timedelta element.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="s1">&#39;1 days&#39;</span><span class="p">)])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>  
<span class="go">0   1 days</span>
<span class="go">dtype: timedelta64[ns]</span>
</pre></div>
</div>
<p>Select rows with data closest to certain value using argsort (from
<a class="reference external" href="https://stackoverflow.com/a/17758115">StackOverflow</a>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>  
<span class="gp">... </span>    <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>    <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span>
<span class="gp">... </span>    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">]</span>
<span class="gp">... </span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     a    b    c</span>
<span class="go">0    4   10  100</span>
<span class="go">1    5   20   50</span>
<span class="go">2    6   30  -30</span>
<span class="go">3    7   40  -50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">df</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span> <span class="mi">43</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>  
<span class="go">     a    b    c</span>
<span class="go">1    5   20   50</span>
<span class="go">0    4   10  100</span>
<span class="go">2    6   30  -30</span>
<span class="go">3    7   40  -50</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Addition of series and other, element-wise (binary operator <cite>add</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.add.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">+</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.radd" title="dask.dataframe.Series.radd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.radd</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    2.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.align">
<code class="sig-name descname">align</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">join='outer'</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align two objects on their axes with the specified join method.</p>
<p>This docstring was copied from pandas.core.series.Series.align.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Join method is specified for each axis Index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">DataFrame or Series</span></dt><dd></dd>
<dt><strong>join</strong><span class="classifier">{‘outer’, ‘inner’, ‘left’, ‘right’}, default ‘outer’</span></dt><dd></dd>
<dt><strong>axis</strong><span class="classifier">allowed axis of the other object, default None</span></dt><dd><p>Align on index (0), columns (1), or both (None).</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>Always returns new objects. If copy=False and no reindexing is
required then original objects are returned.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">scalar, default np.NaN</span></dt><dd><p>Value to use for missing values. Defaults to NaN, but can be any
“compatible” value.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘backfill’, ‘bfill’, ‘pad’, ‘ffill’, None}, default None  (Not supported in Dask)</span></dt><dd><p>Method to use for filling holes in reindexed Series:</p>
<ul class="simple">
<li><p>pad / ffill: propagate last valid observation forward to next valid.</p></li>
<li><p>backfill / bfill: use NEXT valid observation to fill gap.</p></li>
</ul>
</dd>
<dt><strong>limit</strong><span class="classifier">int, default None  (Not supported in Dask)</span></dt><dd><p>If method is specified, this is the maximum number of consecutive
NaN values to forward/backward fill. In other words, if there is
a gap with more than this number of consecutive NaNs, it will only
be partially filled. If method is not specified, this is the
maximum number of entries along the entire axis where NaNs will be
filled. Must be greater than 0 if not None.</p>
</dd>
<dt><strong>fill_axis</strong><span class="classifier">{0 or ‘index’}, default 0  (Not supported in Dask)</span></dt><dd><p>Filling axis, method and limit.</p>
</dd>
<dt><strong>broadcast_axis</strong><span class="classifier">{0 or ‘index’}, default None  (Not supported in Dask)</span></dt><dd><p>Broadcast values along this axis, if aligning two objects of
different dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>(left, right)</strong><span class="classifier">(Series, type of other)</span></dt><dd><p>Aligned objects.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.all">
<code class="sig-name descname">all</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether all elements are True, potentially over an axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.all.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns True unless there at least one element within a series or
along a Dataframe axis that is False or equivalent (e.g. zero or
empty).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’, None}, default 0</span></dt><dd><p>Indicate which axis or axes should be reduced.</p>
<ul class="simple">
<li><p>0 / ‘index’ : reduce the index, return a Series whose index is the
original column labels.</p></li>
<li><p>1 / ‘columns’ : reduce the columns, return a Series whose index is the
original index.</p></li>
<li><p>None : reduce all axes, return a scalar.</p></li>
</ul>
</dd>
<dt><strong>bool_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only boolean columns. If None, will attempt to use everything,
then use only boolean data. Not implemented for Series.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If the entire row/column is NA and skipna is
True, then the result will be True, as for an empty row/column.
If skipna is False, then NA are treated as True, because these are not
equal to zero.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">any, default None</span></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with NumPy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>If level is specified, then, DataFrame is returned; otherwise, Series
is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.all" title="dask.dataframe.Series.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.all</span></code></a></dt><dd><p>Return True if all elements are True.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.any" title="dask.dataframe.DataFrame.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.any</span></code></a></dt><dd><p>Return True if one (or more) elements are True.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p><strong>Series</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">True</span>
</pre></div>
</div>
<p><strong>DataFrames</strong></p>
<p>Create a dataframe from a dictionary.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;col1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="s1">&#39;col2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   col1   col2</span>
<span class="go">0  True   True</span>
<span class="go">1  True  False</span>
</pre></div>
</div>
<p>Default behaviour checks if column-wise values all return True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  
<span class="go">col1     True</span>
<span class="go">col2    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>Specify <code class="docutils literal notranslate"><span class="pre">axis='columns'</span></code> to check if row-wise values all return True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">0     True</span>
<span class="go">1    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>Or <code class="docutils literal notranslate"><span class="pre">axis=None</span></code> for whether every value is True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.any">
<code class="sig-name descname">any</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether any element is True, potentially over an axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.any.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns False unless there at least one element within a series or
along a Dataframe axis that is True or equivalent (e.g. non-zero or
non-empty).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’, None}, default 0</span></dt><dd><p>Indicate which axis or axes should be reduced.</p>
<ul class="simple">
<li><p>0 / ‘index’ : reduce the index, return a Series whose index is the
original column labels.</p></li>
<li><p>1 / ‘columns’ : reduce the columns, return a Series whose index is the
original index.</p></li>
<li><p>None : reduce all axes, return a scalar.</p></li>
</ul>
</dd>
<dt><strong>bool_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only boolean columns. If None, will attempt to use everything,
then use only boolean data. Not implemented for Series.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If the entire row/column is NA and skipna is
True, then the result will be False, as for an empty row/column.
If skipna is False, then NA are treated as True, because these are not
equal to zero.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">any, default None</span></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with NumPy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>If level is specified, then, DataFrame is returned; otherwise, Series
is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.any.html#numpy.any" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.any</span></code></a></dt><dd><p>Numpy version of this method.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.any" title="dask.dataframe.Series.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.any</span></code></a></dt><dd><p>Return whether any element is True.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.all" title="dask.dataframe.Series.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.all</span></code></a></dt><dd><p>Return whether all elements are True.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.any" title="dask.dataframe.DataFrame.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.any</span></code></a></dt><dd><p>Return whether any element is True over requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.all" title="dask.dataframe.DataFrame.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.all</span></code></a></dt><dd><p>Return whether all elements are True over requested axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p><strong>Series</strong></p>
<p>For Series input, the output is a scalar indicating whether any element
is True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">True</span>
</pre></div>
</div>
<p><strong>DataFrame</strong></p>
<p>Whether each column contains at least one True element (the default).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A  B  C</span>
<span class="go">0  1  0  0</span>
<span class="go">1  2  2  0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>  
<span class="go">A     True</span>
<span class="go">B     True</span>
<span class="go">C    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>Aggregating over the columns.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">       A  B</span>
<span class="go">0   True  1</span>
<span class="go">1  False  2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">0    True</span>
<span class="go">1    True</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">       A  B</span>
<span class="go">0   True  1</span>
<span class="go">1  False  0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">0    True</span>
<span class="go">1    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>Aggregating over the entire DataFrame with <code class="docutils literal notranslate"><span class="pre">axis=None</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  
<span class="go">True</span>
</pre></div>
</div>
<p><cite>any</cite> for an empty DataFrame is an empty Series.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>  
<span class="go">Series([], dtype: bool)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">interleave_partitions=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate two or more Series.</p>
<p>This docstring was copied from pandas.core.series.Series.append.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>to_append</strong><span class="classifier">Series or list/tuple of Series  (Not supported in Dask)</span></dt><dd><p>Series to append with self.</p>
</dd>
<dt><strong>ignore_index</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True, do not use the index labels.</p>
</dd>
<dt><strong>verify_integrity</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True, raise Exception on creating index with duplicates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Concatenated Series.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">concat</span></code></dt><dd><p>General function to concatenate DataFrame or Series objects.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Iteratively appending to a Series can be more computationally intensive
than a single concatenate. A better solution is to append values to a
list and then concatenate the list with the original Series all at
once.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">0    4</span>
<span class="go">1    5</span>
<span class="go">2    6</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s3</span><span class="p">)</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">3    4</span>
<span class="go">4    5</span>
<span class="go">5    6</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>With <cite>ignore_index</cite> set to True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">3    4</span>
<span class="go">4    5</span>
<span class="go">5    6</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>With <cite>verify_integrity</cite> set to True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Indexes have overlapping values: [0, 1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">convert_dtype=True</em>, <em class="sig-param">meta='__no_default__'</em>, <em class="sig-param">args=()</em>, <em class="sig-param">**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel version of pandas.Series.apply</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function to apply</p>
</dd>
<dt><strong>convert_dtype</strong><span class="classifier">boolean, default True</span></dt><dd><p>Try to find better dtype for elementwise function results.
If False, leave as dtype=object.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes
and column names of the output. This metadata is necessary for
many algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code>
can be provided (note that the order of the names should match the
order of the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span>
<span class="pre">dtype)</span></code> can be used. If not provided, dask will try to infer the
metadata. This may lead to unexpected results, so providing
<code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For more information, see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
<dt><strong>args</strong><span class="classifier">tuple</span></dt><dd><p>Positional arguments to pass to function in addition to the value.</p>
</dd>
<dt><strong>Additional keyword arguments will be passed as keywords to the function.</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>applied</strong><span class="classifier">Series or DataFrame if func returns a Series.</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.Series.map_partitions</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply a function elementwise across the Series, passing in extra
arguments in <code class="docutils literal notranslate"><span class="pre">args</span></code> and <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">myadd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">myadd</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>  
</pre></div>
</div>
<p>By default, dask tries to infer the output metadata by running your
provided function on some fake data. This works well in many cases, but
can sometimes be expensive, or even fail. To avoid this, you can
manually specify the output metadata with the <code class="docutils literal notranslate"><span class="pre">meta</span></code> keyword. This
can be specified in many forms, for more information see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
<p>Here we specify the output is a Series with name <code class="docutils literal notranslate"><span class="pre">'x'</span></code>, and dtype
<code class="docutils literal notranslate"><span class="pre">float64</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">myadd</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;f8&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>In the case where the metadata doesn’t change, you can also pass in
the object itself directly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">ds</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.astype">
<code class="sig-name descname">astype</code><span class="sig-paren">(</span><em class="sig-param">dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast a pandas object to a specified dtype <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.astype.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data type, or dict of column name -&gt; data type</span></dt><dd><p>Use a numpy.dtype or Python type to cast entire pandas object to
the same type. Alternatively, use {col: dtype, …}, where col is a
column label and dtype is a numpy.dtype or Python type to cast one
or more of the DataFrame’s columns to column-specific types.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>Return a copy when <code class="docutils literal notranslate"><span class="pre">copy=True</span></code> (be very careful setting
<code class="docutils literal notranslate"><span class="pre">copy=False</span></code> as changes to values then may propagate to other
pandas objects).</p>
</dd>
<dt><strong>errors</strong><span class="classifier">{‘raise’, ‘ignore’}, default ‘raise’  (Not supported in Dask)</span></dt><dd><p>Control raising of exceptions on invalid data for provided dtype.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">raise</span></code> : allow exceptions to be raised</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ignore</span></code> : suppress exceptions. On error return original object.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>casted</strong><span class="classifier">same type as caller</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.to_datetime" title="dask.dataframe.to_datetime"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_datetime</span></code></a></dt><dd><p>Convert argument to datetime.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_timedelta</span></code></dt><dd><p>Convert argument to timedelta.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.to_numeric" title="dask.dataframe.to_numeric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_numeric</span></code></a></dt><dd><p>Convert argument to a numeric type.</p>
</dd>
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray.astype</span></code></a></dt><dd><p>Cast a numpy array to a specified type.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Create a DataFrame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;col1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;col2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]}</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span>  
<span class="go">col1    int64</span>
<span class="go">col2    int64</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Cast all columns to int32:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dtypes</span>  
<span class="go">col1    int32</span>
<span class="go">col2    int32</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Cast col1 to int32 using a dictionary:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s1">&#39;col1&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">dtypes</span>  
<span class="go">col1    int32</span>
<span class="go">col2    int64</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Create a series:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Convert to categorical type:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: category</span>
<span class="go">Categories (2, int64): [1, 2]</span>
</pre></div>
</div>
<p>Convert to ordered categorical type with custom ordering:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cat_dtype</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">CategoricalDtype</span><span class="p">(</span>  
<span class="gp">... </span>    <span class="n">categories</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cat_dtype</span><span class="p">)</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: category</span>
<span class="go">Categories (2, int64): [2 &lt; 1]</span>
</pre></div>
</div>
<p>Note that using <code class="docutils literal notranslate"><span class="pre">copy=False</span></code> and changing data on a new
pandas object may propagate changes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span>  <span class="c1"># note that s1[0] has changed too  </span>
<span class="go">0    10</span>
<span class="go">1     2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.autocorr">
<code class="sig-name descname">autocorr</code><span class="sig-paren">(</span><em class="sig-param">lag=1</em>, <em class="sig-param">split_every=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.autocorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the lag-N autocorrelation.</p>
<p>This docstring was copied from pandas.core.series.Series.autocorr.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This method computes the Pearson correlation between
the Series and its shifted self.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lag</strong><span class="classifier">int, default 1</span></dt><dd><p>Number of lags to apply before performing autocorrelation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>float</strong></dt><dd><p>The Pearson correlation between self and self.shift(lag).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.corr" title="dask.dataframe.Series.corr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.corr</span></code></a></dt><dd><p>Compute the correlation between two Series.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.shift" title="dask.dataframe.Series.shift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.shift</span></code></a></dt><dd><p>Shift index by desired number of periods.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.corr" title="dask.dataframe.DataFrame.corr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.corr</span></code></a></dt><dd><p>Compute pairwise correlation of columns.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.corrwith</span></code></dt><dd><p>Compute pairwise correlation between rows or columns of two DataFrame objects.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If the Pearson correlation is not well defined return ‘NaN’.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.05</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">autocorr</span><span class="p">()</span>  
<span class="go">0.10355...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">autocorr</span><span class="p">(</span><span class="n">lag</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">-0.99999...</span>
</pre></div>
</div>
<p>If the Pearson correlation is not well defined, then ‘NaN’ is returned.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">autocorr</span><span class="p">()</span>  
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.between">
<code class="sig-name descname">between</code><span class="sig-paren">(</span><em class="sig-param">left</em>, <em class="sig-param">right</em>, <em class="sig-param">inclusive=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.between" title="Permalink to this definition">¶</a></dt>
<dd><p>Return boolean Series equivalent to left &lt;= series &lt;= right.</p>
<p>This docstring was copied from pandas.core.series.Series.between.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This function returns a boolean vector containing <cite>True</cite> wherever the
corresponding Series element is between the boundary values <cite>left</cite> and
<cite>right</cite>. NA values are treated as <cite>False</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>left</strong><span class="classifier">scalar or list-like</span></dt><dd><p>Left boundary.</p>
</dd>
<dt><strong>right</strong><span class="classifier">scalar or list-like</span></dt><dd><p>Right boundary.</p>
</dd>
<dt><strong>inclusive</strong><span class="classifier">bool, default True</span></dt><dd><p>Include boundaries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Series representing whether each element is between left and
right (inclusive).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.gt" title="dask.dataframe.Series.gt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.gt</span></code></a></dt><dd><p>Greater than of series and other.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.lt" title="dask.dataframe.Series.lt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.lt</span></code></a></dt><dd><p>Less than of series and other.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function is equivalent to <code class="docutils literal notranslate"><span class="pre">(left</span> <span class="pre">&lt;=</span> <span class="pre">ser)</span> <span class="pre">&amp;</span> <span class="pre">(ser</span> <span class="pre">&lt;=</span> <span class="pre">right)</span></code></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
</pre></div>
</div>
<p>Boundary values are included by default:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  
<span class="go">0     True</span>
<span class="go">1    False</span>
<span class="go">2     True</span>
<span class="go">3    False</span>
<span class="go">4    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>With <cite>inclusive</cite> set to <code class="docutils literal notranslate"><span class="pre">False</span></code> boundary values are excluded:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">0     True</span>
<span class="go">1    False</span>
<span class="go">2    False</span>
<span class="go">3    False</span>
<span class="go">4    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p><cite>left</cite> and <cite>right</cite> can be any scalar value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Carol&#39;</span><span class="p">,</span> <span class="s1">&#39;Eve&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="s1">&#39;Anna&#39;</span><span class="p">,</span> <span class="s1">&#39;Daniel&#39;</span><span class="p">)</span>  
<span class="go">0    False</span>
<span class="go">1     True</span>
<span class="go">2     True</span>
<span class="go">3    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.bfill">
<code class="sig-name descname">bfill</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.bfill" title="Permalink to this definition">¶</a></dt>
<dd><p>Synonym for <a class="reference internal" href="#dask.dataframe.DataFrame.fillna" title="dask.dataframe.DataFrame.fillna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.fillna()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">method='bfill'</span></code>.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.bfill.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>%(klass)s or None</strong></dt><dd><p>Object with missing values filled or None if <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.clear_divisions">
<code class="sig-name descname">clear_divisions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.clear_divisions" title="Permalink to this definition">¶</a></dt>
<dd><p>Forget division information</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.clip">
<code class="sig-name descname">clip</code><span class="sig-paren">(</span><em class="sig-param">lower=None</em>, <em class="sig-param">upper=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Trim values at input threshold(s).</p>
<p>This docstring was copied from pandas.core.series.Series.clip.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Assigns values outside boundary to boundary values. Thresholds
can be singular values or array like, and in the latter case
the clipping is performed element-wise in the specified axis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>lower</strong><span class="classifier">float or array_like, default None</span></dt><dd><p>Minimum threshold value. All values below this
threshold will be set to it.</p>
</dd>
<dt><strong>upper</strong><span class="classifier">float or array_like, default None</span></dt><dd><p>Maximum threshold value. All values above this
threshold will be set to it.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or str axis name, optional  (Not supported in Dask)</span></dt><dd><p>Align object with lower and upper along the given axis.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Whether to perform the operation in place on the data.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.21.0.</span></p>
</div>
</dd>
<dt><strong>*args, **kwargs</strong></dt><dd><p>Additional keywords have no effect but might be accepted
for compatibility with numpy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Same type as calling object with the values outside the
clip boundaries replaced.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;col_0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="s1">&#39;col_1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]}</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   col_0  col_1</span>
<span class="go">0      9     -2</span>
<span class="go">1     -3     -7</span>
<span class="go">2      0      6</span>
<span class="go">3     -1      8</span>
<span class="go">4      5     -5</span>
</pre></div>
</div>
<p>Clips per column using lower and upper thresholds:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>  
<span class="go">   col_0  col_1</span>
<span class="go">0      6     -2</span>
<span class="go">1     -3     -4</span>
<span class="go">2      0      6</span>
<span class="go">3     -1      6</span>
<span class="go">4      5     -4</span>
</pre></div>
</div>
<p>Clips using specific lower and upper thresholds per column element:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span>  
<span class="go">0    2</span>
<span class="go">1   -4</span>
<span class="go">2   -1</span>
<span class="go">3    6</span>
<span class="go">4    3</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">   col_0  col_1</span>
<span class="go">0      6      2</span>
<span class="go">1     -3     -4</span>
<span class="go">2      0      3</span>
<span class="go">3      6      8</span>
<span class="go">4      5      3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.combine">
<code class="sig-name descname">combine</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">func</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the Series with a Series or scalar according to <cite>func</cite>.</p>
<p>This docstring was copied from pandas.core.series.Series.combine.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Combine the Series and <cite>other</cite> using <cite>func</cite> to perform elementwise
selection for combined Series.
<cite>fill_value</cite> is assumed when value is missing at some index
from one of the two objects being combined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar</span></dt><dd><p>The value(s) to be combined with the <cite>Series</cite>.</p>
</dd>
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function that takes two scalars as inputs and returns an element.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">scalar, optional</span></dt><dd><p>The value to assume when an index is missing from
one Series or the other. The default specifies to use the
appropriate NaN value for the underlying dtype of the Series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of combining the Series with the other object.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.combine_first" title="dask.dataframe.Series.combine_first"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.combine_first</span></code></a></dt><dd><p>Combine Series values, choosing the calling Series’ values first.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Consider 2 Datasets <code class="docutils literal notranslate"><span class="pre">s1</span></code> and <code class="docutils literal notranslate"><span class="pre">s2</span></code> containing
highest clocked speeds of different birds.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span><span class="s1">&#39;falcon&#39;</span><span class="p">:</span> <span class="mf">330.0</span><span class="p">,</span> <span class="s1">&#39;eagle&#39;</span><span class="p">:</span> <span class="mf">160.0</span><span class="p">})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span>  
<span class="go">falcon    330.0</span>
<span class="go">eagle     160.0</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span><span class="s1">&#39;falcon&#39;</span><span class="p">:</span> <span class="mf">345.0</span><span class="p">,</span> <span class="s1">&#39;eagle&#39;</span><span class="p">:</span> <span class="mf">200.0</span><span class="p">,</span> <span class="s1">&#39;duck&#39;</span><span class="p">:</span> <span class="mf">30.0</span><span class="p">})</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span>  
<span class="go">falcon    345.0</span>
<span class="go">eagle     200.0</span>
<span class="go">duck       30.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Now, to combine the two datasets and view the highest speeds
of the birds across the two datasets</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>  
<span class="go">duck        NaN</span>
<span class="go">eagle     200.0</span>
<span class="go">falcon    345.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>In the previous example, the resulting value for duck is missing,
because the maximum of a NaN and a float is a NaN.
So, in the example, we set <code class="docutils literal notranslate"><span class="pre">fill_value=0</span></code>,
so the maximum value returned will be the value from some dataset.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">duck       30.0</span>
<span class="go">eagle     200.0</span>
<span class="go">falcon    345.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.combine_first">
<code class="sig-name descname">combine_first</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.combine_first" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine Series values, choosing the calling Series’s values first.</p>
<p>This docstring was copied from pandas.core.series.Series.combine_first.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series</span></dt><dd><p>The value(s) to be combined with the <cite>Series</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of combining the Series with the other object.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.combine" title="dask.dataframe.Series.combine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.combine</span></code></a></dt><dd><p>Perform elementwise operation on two Series using a given function.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Result index will be the union of the two indexes.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">combine_first</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>  
<span class="go">0    1.0</span>
<span class="go">1    4.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.compute">
<code class="sig-name descname">compute</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute this dask collection</p>
<p>This turns a lazy Dask collection into its in-memory equivalent.
For example a Dask.array turns into a  <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html#numpy.array" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.array()</span></code></a> and a Dask.dataframe
turns into a Pandas dataframe.  The entire dataset must fit into memory
before calling this operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scheduler</strong><span class="classifier">string, optional</span></dt><dd><p>Which scheduler to use like “threads”, “synchronous” or “processes”.
If not provided, the default is to check the global settings first,
and then fall back to the collection defaults.</p>
</dd>
<dt><strong>optimize_graph</strong><span class="classifier">bool, optional</span></dt><dd><p>If True [default], the graph is optimized before computation.
Otherwise the graph is run as is. This can be useful for debugging.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Extra keywords to forward to the scheduler function.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.base.compute</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of the dataframe</p>
<p>This is strictly a shallow copy of the underlying computational graph.
It does not affect the underlying data</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.corr">
<code class="sig-name descname">corr</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">method='pearson'</em>, <em class="sig-param">min_periods=None</em>, <em class="sig-param">split_every=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute correlation with <cite>other</cite> Series, excluding missing values.</p>
<p>This docstring was copied from pandas.core.series.Series.corr.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier">Series</span></dt><dd><p>Series with which to compute the correlation.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘pearson’, ‘kendall’, ‘spearman’} or callable</span></dt><dd><p>Method used to compute correlation:</p>
<ul class="simple">
<li><p>pearson : Standard correlation coefficient</p></li>
<li><p>kendall : Kendall Tau correlation coefficient</p></li>
<li><p>spearman : Spearman rank correlation</p></li>
<li><p>callable: Callable with input two 1d ndarrays and returning a float.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0: </span>Note that the returned matrix from corr will have 1 along the
diagonals and will be symmetric regardless of the callable’s
behavior.</p>
</div>
</dd>
<dt><strong>min_periods</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum number of observations needed to have a valid result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>float</strong></dt><dd><p>Correlation with other.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">histogram_intersection</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">v</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">6</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="o">.</span><span class="mi">6</span><span class="p">,</span> <span class="o">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">histogram_intersection</span><span class="p">)</span>  
<span class="go">0.3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">split_every=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of non-NA/null observations in the Series.</p>
<p>This docstring was copied from pandas.core.series.Series.count.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a smaller Series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>int or Series (if level specified)</strong></dt><dd><p>Number of non-null values in the Series.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>  
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.cov">
<code class="sig-name descname">cov</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">min_periods=None</em>, <em class="sig-param">split_every=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute covariance with Series, excluding missing values.</p>
<p>This docstring was copied from pandas.core.series.Series.cov.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series</span></dt><dd><p>Series with which to compute the covariance.</p>
</dd>
<dt><strong>min_periods</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum number of observations needed to have a valid result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>float</strong></dt><dd><p>Covariance between Series and other normalized by N-1
(unbiased estimator).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">0.90010907</span><span class="p">,</span> <span class="mf">0.13484424</span><span class="p">,</span> <span class="mf">0.62036035</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">0.12528585</span><span class="p">,</span> <span class="mf">0.26962463</span><span class="p">,</span> <span class="mf">0.51111198</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>  
<span class="go">-0.01685762652715874</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.cummax">
<code class="sig-name descname">cummax</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.cummax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative maximum over a DataFrame or Series axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.cummax.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns a DataFrame or Series of the same size containing the cumulative
maximum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The index or the name of the axis. 0 is equivalent to None or ‘index’.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>*args, **kwargs :</strong></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with NumPy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Expanding.max</span></code></dt><dd><p>Similar functionality but ignores <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.max" title="dask.dataframe.DataFrame.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.max</span></code></a></dt><dd><p>Return the maximum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummax" title="dask.dataframe.DataFrame.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummax</span></code></a></dt><dd><p>Return cumulative maximum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummin" title="dask.dataframe.DataFrame.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummin</span></code></a></dt><dd><p>Return cumulative minimum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumsum" title="dask.dataframe.DataFrame.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumsum</span></code></a></dt><dd><p>Return cumulative sum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumprod" title="dask.dataframe.DataFrame.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumprod</span></code></a></dt><dd><p>Return cumulative product over DataFrame axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p><strong>Series</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    5.0</span>
<span class="go">3   -1.0</span>
<span class="go">4    0.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>By default, NA values are ignored.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cummax</span><span class="p">()</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    5.0</span>
<span class="go">3    5.0</span>
<span class="go">4    5.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>To include NA values in the operation, use <code class="docutils literal notranslate"><span class="pre">skipna=False</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cummax</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    NaN</span>
<span class="go">3    NaN</span>
<span class="go">4    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p><strong>DataFrame</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]],</span>
<span class="gp">... </span>                   <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
<p>By default, iterates over rows and finds the maximum
in each column. This is equivalent to <code class="docutils literal notranslate"><span class="pre">axis=None</span></code> or <code class="docutils literal notranslate"><span class="pre">axis='index'</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cummax</span><span class="p">()</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  3.0  1.0</span>
</pre></div>
</div>
<p>To iterate over columns and find the maximum in each row,
use <code class="docutils literal notranslate"><span class="pre">axis=1</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cummax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  2.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.cummin">
<code class="sig-name descname">cummin</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.cummin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative minimum over a DataFrame or Series axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.cummin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns a DataFrame or Series of the same size containing the cumulative
minimum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The index or the name of the axis. 0 is equivalent to None or ‘index’.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>*args, **kwargs :</strong></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with NumPy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Expanding.min</span></code></dt><dd><p>Similar functionality but ignores <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.min" title="dask.dataframe.DataFrame.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.min</span></code></a></dt><dd><p>Return the minimum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummax" title="dask.dataframe.DataFrame.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummax</span></code></a></dt><dd><p>Return cumulative maximum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummin" title="dask.dataframe.DataFrame.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummin</span></code></a></dt><dd><p>Return cumulative minimum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumsum" title="dask.dataframe.DataFrame.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumsum</span></code></a></dt><dd><p>Return cumulative sum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumprod" title="dask.dataframe.DataFrame.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumprod</span></code></a></dt><dd><p>Return cumulative product over DataFrame axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p><strong>Series</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    5.0</span>
<span class="go">3   -1.0</span>
<span class="go">4    0.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>By default, NA values are ignored.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cummin</span><span class="p">()</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    2.0</span>
<span class="go">3   -1.0</span>
<span class="go">4   -1.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>To include NA values in the operation, use <code class="docutils literal notranslate"><span class="pre">skipna=False</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cummin</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    NaN</span>
<span class="go">3    NaN</span>
<span class="go">4    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p><strong>DataFrame</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]],</span>
<span class="gp">... </span>                   <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
<p>By default, iterates over rows and finds the minimum
in each column. This is equivalent to <code class="docutils literal notranslate"><span class="pre">axis=None</span></code> or <code class="docutils literal notranslate"><span class="pre">axis='index'</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cummin</span><span class="p">()</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  2.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
<p>To iterate over columns and find the minimum in each row,
use <code class="docutils literal notranslate"><span class="pre">axis=1</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cummin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.cumprod">
<code class="sig-name descname">cumprod</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative product over a DataFrame or Series axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.cumprod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns a DataFrame or Series of the same size containing the cumulative
product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The index or the name of the axis. 0 is equivalent to None or ‘index’.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>*args, **kwargs :</strong></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with NumPy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Expanding.prod</span></code></dt><dd><p>Similar functionality but ignores <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.prod" title="dask.dataframe.DataFrame.prod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.prod</span></code></a></dt><dd><p>Return the product over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummax" title="dask.dataframe.DataFrame.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummax</span></code></a></dt><dd><p>Return cumulative maximum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummin" title="dask.dataframe.DataFrame.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummin</span></code></a></dt><dd><p>Return cumulative minimum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumsum" title="dask.dataframe.DataFrame.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumsum</span></code></a></dt><dd><p>Return cumulative sum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumprod" title="dask.dataframe.DataFrame.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumprod</span></code></a></dt><dd><p>Return cumulative product over DataFrame axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p><strong>Series</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    5.0</span>
<span class="go">3   -1.0</span>
<span class="go">4    0.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>By default, NA values are ignored.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cumprod</span><span class="p">()</span>  
<span class="go">0     2.0</span>
<span class="go">1     NaN</span>
<span class="go">2    10.0</span>
<span class="go">3   -10.0</span>
<span class="go">4    -0.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>To include NA values in the operation, use <code class="docutils literal notranslate"><span class="pre">skipna=False</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    NaN</span>
<span class="go">3    NaN</span>
<span class="go">4    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p><strong>DataFrame</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]],</span>
<span class="gp">... </span>                   <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
<p>By default, iterates over rows and finds the product
in each column. This is equivalent to <code class="docutils literal notranslate"><span class="pre">axis=None</span></code> or <code class="docutils literal notranslate"><span class="pre">axis='index'</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cumprod</span><span class="p">()</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  6.0  NaN</span>
<span class="go">2  6.0  0.0</span>
</pre></div>
</div>
<p>To iterate over columns and find the product in each row,
use <code class="docutils literal notranslate"><span class="pre">axis=1</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  2.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.cumsum">
<code class="sig-name descname">cumsum</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative sum over a DataFrame or Series axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.cumsum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns a DataFrame or Series of the same size containing the cumulative
sum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The index or the name of the axis. 0 is equivalent to None or ‘index’.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>*args, **kwargs :</strong></dt><dd><p>Additional keywords have no effect but might be accepted for
compatibility with NumPy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Expanding.sum</span></code></dt><dd><p>Similar functionality but ignores <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sum" title="dask.dataframe.DataFrame.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sum</span></code></a></dt><dd><p>Return the sum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummax" title="dask.dataframe.DataFrame.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummax</span></code></a></dt><dd><p>Return cumulative maximum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cummin" title="dask.dataframe.DataFrame.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cummin</span></code></a></dt><dd><p>Return cumulative minimum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumsum" title="dask.dataframe.DataFrame.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumsum</span></code></a></dt><dd><p>Return cumulative sum over DataFrame axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.cumprod" title="dask.dataframe.DataFrame.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.cumprod</span></code></a></dt><dd><p>Return cumulative product over DataFrame axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p><strong>Series</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    5.0</span>
<span class="go">3   -1.0</span>
<span class="go">4    0.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>By default, NA values are ignored.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    7.0</span>
<span class="go">3    6.0</span>
<span class="go">4    6.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>To include NA values in the operation, use <code class="docutils literal notranslate"><span class="pre">skipna=False</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">0    2.0</span>
<span class="go">1    NaN</span>
<span class="go">2    NaN</span>
<span class="go">3    NaN</span>
<span class="go">4    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p><strong>DataFrame</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]],</span>
<span class="gp">... </span>                   <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  0.0</span>
</pre></div>
</div>
<p>By default, iterates over rows and finds the sum
in each column. This is equivalent to <code class="docutils literal notranslate"><span class="pre">axis=None</span></code> or <code class="docutils literal notranslate"><span class="pre">axis='index'</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  1.0</span>
<span class="go">1  5.0  NaN</span>
<span class="go">2  6.0  1.0</span>
</pre></div>
</div>
<p>To iterate over columns and find the sum in each row,
use <code class="docutils literal notranslate"><span class="pre">axis=1</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">     A    B</span>
<span class="go">0  2.0  3.0</span>
<span class="go">1  3.0  NaN</span>
<span class="go">2  1.0  1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.describe">
<code class="sig-name descname">describe</code><span class="sig-paren">(</span><em class="sig-param">split_every=False</em>, <em class="sig-param">percentiles=None</em>, <em class="sig-param">percentiles_method='default'</em>, <em class="sig-param">include=None</em>, <em class="sig-param">exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate descriptive statistics.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.describe.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Descriptive statistics include those that summarize the central
tendency, dispersion and shape of a
dataset’s distribution, excluding <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values.</p>
<p>Analyzes both numeric and object series, as well
as <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> column sets of mixed data types. The output
will vary depending on what is provided. Refer to the notes
below for more detail.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>percentiles</strong><span class="classifier">list-like of numbers, optional</span></dt><dd><p>The percentiles to include in the output. All should
fall between 0 and 1. The default is
<code class="docutils literal notranslate"><span class="pre">[.25,</span> <span class="pre">.5,</span> <span class="pre">.75]</span></code>, which returns the 25th, 50th, and
75th percentiles.</p>
</dd>
<dt><strong>include</strong><span class="classifier">‘all’, list-like of dtypes or None (default), optional</span></dt><dd><p>A white list of data types to include in the result. Ignored
for <code class="docutils literal notranslate"><span class="pre">Series</span></code>. Here are the options:</p>
<ul class="simple">
<li><p>‘all’ : All columns of the input will be included in the output.</p></li>
<li><p>A list-like of dtypes : Limits the results to the
provided data types.
To limit the result to numeric types submit
<code class="docutils literal notranslate"><span class="pre">numpy.number</span></code>. To limit it instead to object columns submit
the <code class="docutils literal notranslate"><span class="pre">numpy.object</span></code> data type. Strings
can also be used in the style of
<code class="docutils literal notranslate"><span class="pre">select_dtypes</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">df.describe(include=['O'])</span></code>). To
select pandas categorical columns, use <code class="docutils literal notranslate"><span class="pre">'category'</span></code></p></li>
<li><p>None (default) : The result will include all numeric columns.</p></li>
</ul>
</dd>
<dt><strong>exclude</strong><span class="classifier">list-like of dtypes or None (default), optional,</span></dt><dd><p>A black list of data types to omit from the result. Ignored
for <code class="docutils literal notranslate"><span class="pre">Series</span></code>. Here are the options:</p>
<ul class="simple">
<li><p>A list-like of dtypes : Excludes the provided data types
from the result. To exclude numeric types submit
<code class="docutils literal notranslate"><span class="pre">numpy.number</span></code>. To exclude object columns submit the data
type <code class="docutils literal notranslate"><span class="pre">numpy.object</span></code>. Strings can also be used in the style of
<code class="docutils literal notranslate"><span class="pre">select_dtypes</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">df.describe(include=['O'])</span></code>). To
exclude pandas categorical columns, use <code class="docutils literal notranslate"><span class="pre">'category'</span></code></p></li>
<li><p>None (default) : The result will exclude nothing.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Summary statistics of the Series or Dataframe provided.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.count" title="dask.dataframe.DataFrame.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.count</span></code></a></dt><dd><p>Count number of non-NA/null observations.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.max" title="dask.dataframe.DataFrame.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.max</span></code></a></dt><dd><p>Maximum of the values in the object.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.min" title="dask.dataframe.DataFrame.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.min</span></code></a></dt><dd><p>Minimum of the values in the object.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mean" title="dask.dataframe.DataFrame.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.mean</span></code></a></dt><dd><p>Mean of the values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.std" title="dask.dataframe.DataFrame.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.std</span></code></a></dt><dd><p>Standard deviation of the observations.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.select_dtypes" title="dask.dataframe.DataFrame.select_dtypes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.select_dtypes</span></code></a></dt><dd><p>Subset of a DataFrame including/excluding columns based on their dtype.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For numeric data, the result’s index will include <code class="docutils literal notranslate"><span class="pre">count</span></code>,
<code class="docutils literal notranslate"><span class="pre">mean</span></code>, <code class="docutils literal notranslate"><span class="pre">std</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code> as well as lower, <code class="docutils literal notranslate"><span class="pre">50</span></code> and
upper percentiles. By default the lower percentile is <code class="docutils literal notranslate"><span class="pre">25</span></code> and the
upper percentile is <code class="docutils literal notranslate"><span class="pre">75</span></code>. The <code class="docutils literal notranslate"><span class="pre">50</span></code> percentile is the
same as the median.</p>
<p>For object data (e.g. strings or timestamps), the result’s index
will include <code class="docutils literal notranslate"><span class="pre">count</span></code>, <code class="docutils literal notranslate"><span class="pre">unique</span></code>, <code class="docutils literal notranslate"><span class="pre">top</span></code>, and <code class="docutils literal notranslate"><span class="pre">freq</span></code>. The <code class="docutils literal notranslate"><span class="pre">top</span></code>
is the most common value. The <code class="docutils literal notranslate"><span class="pre">freq</span></code> is the most common value’s
frequency. Timestamps also include the <code class="docutils literal notranslate"><span class="pre">first</span></code> and <code class="docutils literal notranslate"><span class="pre">last</span></code> items.</p>
<p>If multiple object values have the highest count, then the
<code class="docutils literal notranslate"><span class="pre">count</span></code> and <code class="docutils literal notranslate"><span class="pre">top</span></code> results will be arbitrarily chosen from
among those with the highest count.</p>
<p>For mixed data types provided via a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, the default is to
return only an analysis of numeric columns. If the dataframe consists
only of object and categorical data without any numeric columns, the
default is to return an analysis of both the object and categorical
columns. If <code class="docutils literal notranslate"><span class="pre">include='all'</span></code> is provided as an option, the result
will include a union of attributes of each type.</p>
<p>The <cite>include</cite> and <cite>exclude</cite> parameters can be used to limit
which columns in a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> are analyzed for the output.
The parameters are ignored when analyzing a <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p>
<p class="rubric">Examples</p>
<p>Describing a numeric <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>  
<span class="go">count    3.0</span>
<span class="go">mean     2.0</span>
<span class="go">std      1.0</span>
<span class="go">min      1.0</span>
<span class="go">25%      1.5</span>
<span class="go">50%      2.0</span>
<span class="go">75%      2.5</span>
<span class="go">max      3.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Describing a categorical <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>  
<span class="go">count     4</span>
<span class="go">unique    3</span>
<span class="go">top       a</span>
<span class="go">freq      2</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Describing a timestamp <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span>  
<span class="gp">... </span>  <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;2000-01-01&quot;</span><span class="p">),</span>
<span class="gp">... </span>  <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;2010-01-01&quot;</span><span class="p">),</span>
<span class="gp">... </span>  <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;2010-01-01&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>  
<span class="go">count                       3</span>
<span class="go">unique                      2</span>
<span class="go">top       2010-01-01 00:00:00</span>
<span class="go">freq                        2</span>
<span class="go">first     2000-01-01 00:00:00</span>
<span class="go">last      2010-01-01 00:00:00</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Describing a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. By default only numeric fields
are returned.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;categorical&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">([</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">]),</span>  
<span class="gp">... </span>                   <span class="s1">&#39;numeric&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;object&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>
<span class="gp">... </span>                  <span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>  
<span class="go">       numeric</span>
<span class="go">count      3.0</span>
<span class="go">mean       2.0</span>
<span class="go">std        1.0</span>
<span class="go">min        1.0</span>
<span class="go">25%        1.5</span>
<span class="go">50%        2.0</span>
<span class="go">75%        2.5</span>
<span class="go">max        3.0</span>
</pre></div>
</div>
<p>Describing all columns of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> regardless of data type.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>  
<span class="go">        categorical  numeric object</span>
<span class="go">count            3      3.0      3</span>
<span class="go">unique           3      NaN      3</span>
<span class="go">top              f      NaN      c</span>
<span class="go">freq             1      NaN      1</span>
<span class="go">mean           NaN      2.0    NaN</span>
<span class="go">std            NaN      1.0    NaN</span>
<span class="go">min            NaN      1.0    NaN</span>
<span class="go">25%            NaN      1.5    NaN</span>
<span class="go">50%            NaN      2.0    NaN</span>
<span class="go">75%            NaN      2.5    NaN</span>
<span class="go">max            NaN      3.0    NaN</span>
</pre></div>
</div>
<p>Describing a column from a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> by accessing it as
an attribute.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">numeric</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>  
<span class="go">count    3.0</span>
<span class="go">mean     2.0</span>
<span class="go">std      1.0</span>
<span class="go">min      1.0</span>
<span class="go">25%      1.5</span>
<span class="go">50%      2.0</span>
<span class="go">75%      2.5</span>
<span class="go">max      3.0</span>
<span class="go">Name: numeric, dtype: float64</span>
</pre></div>
</div>
<p>Including only numeric columns in a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> description.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>  
<span class="go">       numeric</span>
<span class="go">count      3.0</span>
<span class="go">mean       2.0</span>
<span class="go">std        1.0</span>
<span class="go">min        1.0</span>
<span class="go">25%        1.5</span>
<span class="go">50%        2.0</span>
<span class="go">75%        2.5</span>
<span class="go">max        3.0</span>
</pre></div>
</div>
<p>Including only string columns in a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> description.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">])</span>  
<span class="go">       object</span>
<span class="go">count       3</span>
<span class="go">unique      3</span>
<span class="go">top         c</span>
<span class="go">freq        1</span>
</pre></div>
</div>
<p>Including only categorical columns from a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> description.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;category&#39;</span><span class="p">])</span>  
<span class="go">       categorical</span>
<span class="go">count            3</span>
<span class="go">unique           3</span>
<span class="go">top              f</span>
<span class="go">freq             1</span>
</pre></div>
</div>
<p>Excluding numeric columns from a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> description.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>  
<span class="go">       categorical object</span>
<span class="go">count            3      3</span>
<span class="go">unique           3      3</span>
<span class="go">top              f      c</span>
<span class="go">freq             1      1</span>
</pre></div>
</div>
<p>Excluding object columns from a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> description.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">])</span>  
<span class="go">       categorical  numeric</span>
<span class="go">count            3      3.0</span>
<span class="go">unique           3      NaN</span>
<span class="go">top              f      NaN</span>
<span class="go">freq             1      NaN</span>
<span class="go">mean           NaN      2.0</span>
<span class="go">std            NaN      1.0</span>
<span class="go">min            NaN      1.0</span>
<span class="go">25%            NaN      1.5</span>
<span class="go">50%            NaN      2.0</span>
<span class="go">75%            NaN      2.5</span>
<span class="go">max            NaN      3.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.diff">
<code class="sig-name descname">diff</code><span class="sig-paren">(</span><em class="sig-param">periods=1</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>First discrete difference of element.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.diff.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Pandas currently uses an <code class="docutils literal notranslate"><span class="pre">object</span></code>-dtype column to represent
boolean data with missing values. This can cause issues for
boolean-specific operations, like <code class="docutils literal notranslate"><span class="pre">|</span></code>. To enable boolean-
specific operations, at the cost of metadata that doesn’t match
pandas, use <code class="docutils literal notranslate"><span class="pre">.astype(bool)</span></code> after the <code class="docutils literal notranslate"><span class="pre">shift</span></code>.</p>
</div>
<p>Calculates the difference of a DataFrame element compared with another
element in the DataFrame (default is the element in the same column
of the previous row).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>periods</strong><span class="classifier">int, default 1</span></dt><dd><p>Periods to shift for calculating difference, accepts negative
values.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>Take difference over rows (0) or columns (1).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.diff" title="dask.dataframe.Series.diff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.diff</span></code></a></dt><dd><p>First discrete difference for a Series.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.pct_change</span></code></dt><dd><p>Percent change over given number of periods.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.shift" title="dask.dataframe.DataFrame.shift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.shift</span></code></a></dt><dd><p>Shift index by desired number of periods with an optional time freq.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For boolean dtypes, this uses <code class="xref py py-meth docutils literal notranslate"><span class="pre">operator.xor()</span></code> rather than
<code class="xref py py-meth docutils literal notranslate"><span class="pre">operator.sub()</span></code>.</p>
<p class="rubric">Examples</p>
<p>Difference with previous row</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   a  b   c</span>
<span class="go">0  1  1   1</span>
<span class="go">1  2  1   4</span>
<span class="go">2  3  2   9</span>
<span class="go">3  4  3  16</span>
<span class="go">4  5  5  25</span>
<span class="go">5  6  8  36</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>  
<span class="go">     a    b     c</span>
<span class="go">0  NaN  NaN   NaN</span>
<span class="go">1  1.0  0.0   3.0</span>
<span class="go">2  1.0  1.0   5.0</span>
<span class="go">3  1.0  1.0   7.0</span>
<span class="go">4  1.0  2.0   9.0</span>
<span class="go">5  1.0  3.0  11.0</span>
</pre></div>
</div>
<p>Difference with previous column</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">    a    b     c</span>
<span class="go">0 NaN  0.0   0.0</span>
<span class="go">1 NaN -1.0   3.0</span>
<span class="go">2 NaN -1.0   7.0</span>
<span class="go">3 NaN -1.0  13.0</span>
<span class="go">4 NaN  0.0  20.0</span>
<span class="go">5 NaN  2.0  28.0</span>
</pre></div>
</div>
<p>Difference with 3rd previous row</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  
<span class="go">     a    b     c</span>
<span class="go">0  NaN  NaN   NaN</span>
<span class="go">1  NaN  NaN   NaN</span>
<span class="go">2  NaN  NaN   NaN</span>
<span class="go">3  3.0  2.0  15.0</span>
<span class="go">4  3.0  4.0  21.0</span>
<span class="go">5  3.0  6.0  27.0</span>
</pre></div>
</div>
<p>Difference with following row</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">periods</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">     a    b     c</span>
<span class="go">0 -1.0  0.0  -3.0</span>
<span class="go">1 -1.0 -1.0  -5.0</span>
<span class="go">2 -1.0 -1.0  -7.0</span>
<span class="go">3 -1.0 -2.0  -9.0</span>
<span class="go">4 -1.0 -3.0 -11.0</span>
<span class="go">5  NaN  NaN   NaN</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.div">
<code class="sig-name descname">div</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.div" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Floating division of series and other, element-wise (binary operator <cite>truediv</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.div.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">/</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.rtruediv" title="dask.dataframe.Series.rtruediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.rtruediv</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    1.0</span>
<span class="go">b    inf</span>
<span class="go">c    inf</span>
<span class="go">d    0.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.divide">
<code class="sig-name descname">divide</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.divide" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Floating division of series and other, element-wise (binary operator <cite>truediv</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.divide.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">/</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.rtruediv" title="dask.dataframe.Series.rtruediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.rtruediv</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    1.0</span>
<span class="go">b    inf</span>
<span class="go">c    inf</span>
<span class="go">d    0.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.drop_duplicates">
<code class="sig-name descname">drop_duplicates</code><span class="sig-paren">(</span><em class="sig-param">subset=None</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.drop_duplicates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return DataFrame with duplicate rows removed.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.drop_duplicates.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Considering certain columns is optional. Indexes, including time indexes
are ignored.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>subset</strong><span class="classifier">column label or sequence of labels, optional</span></dt><dd><p>Only consider certain columns for identifying duplicates, by
default use all of the columns.</p>
</dd>
<dt><strong>keep</strong><span class="classifier">{‘first’, ‘last’, False}, default ‘first’  (Not supported in Dask)</span></dt><dd><p>Determines which duplicates (if any) to keep.
- <code class="docutils literal notranslate"><span class="pre">first</span></code> : Drop duplicates except for the first occurrence.
- <code class="docutils literal notranslate"><span class="pre">last</span></code> : Drop duplicates except for the last occurrence.
- False : Drop all duplicates.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Whether to drop duplicates in place or to return a copy.</p>
</dd>
<dt><strong>ignore_index</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True, the resulting axis will be labeled 0, 1, …, n - 1.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.0.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>DataFrame with duplicates removed or None if <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.dropna">
<code class="sig-name descname">dropna</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.dropna" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new Series with missing values removed.</p>
<p>This docstring was copied from pandas.core.series.Series.dropna.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>See the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html#missing-data" title="(in pandas v1.0.3)"><span class="xref std std-ref">User Guide</span></a> for more on which values are
considered missing, and how to work with missing data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’}, default 0  (Not supported in Dask)</span></dt><dd><p>There is only one axis to drop values from.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True, do operation inplace and return None.</p>
</dd>
<dt><strong>how</strong><span class="classifier">str, optional  (Not supported in Dask)</span></dt><dd><p>Not in use. Kept for compatibility.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Series with NA entries dropped from it.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.isna" title="dask.dataframe.Series.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.isna</span></code></a></dt><dd><p>Indicate missing values.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.notna</span></code></dt><dd><p>Indicate existing (non-missing) values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.fillna" title="dask.dataframe.Series.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.fillna</span></code></a></dt><dd><p>Replace missing values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.dropna" title="dask.dataframe.DataFrame.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.dropna</span></code></a></dt><dd><p>Drop rows or columns which contain NA values.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Index.dropna</span></code></dt><dd><p>Drop missing indices.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>  
<span class="go">0    1.0</span>
<span class="go">1    2.0</span>
<span class="go">2    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Drop NA values from a Series.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>  
<span class="go">0    1.0</span>
<span class="go">1    2.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Keep the Series with valid entries in the same variable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>  
<span class="go">0    1.0</span>
<span class="go">1    2.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Empty strings are not considered NA values. <code class="docutils literal notranslate"><span class="pre">None</span></code> is considered an
NA value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;I stay&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>  
<span class="go">0       NaN</span>
<span class="go">1         2</span>
<span class="go">2       NaT</span>
<span class="go">3</span>
<span class="go">4      None</span>
<span class="go">5    I stay</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>  
<span class="go">1         2</span>
<span class="go">3</span>
<span class="go">5    I stay</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="dask.dataframe.Series.dt">
<code class="sig-name descname">dt</code><a class="headerlink" href="#dask.dataframe.Series.dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Namespace of datetime methods</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.dtype">
<em class="property">property </em><code class="sig-name descname">dtype</code><a class="headerlink" href="#dask.dataframe.Series.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data type</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.eq">
<code class="sig-name descname">eq</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Equal to of series and other, element-wise (binary operator <cite>eq</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.eq.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">==</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.None</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.explode">
<code class="sig-name descname">explode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.explode" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform each element of a list-like to a row, replicating the
index values.</p>
<p>This docstring was copied from pandas.core.series.Series.explode.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.25.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Exploded lists to rows; index will be duplicated for these rows.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.str.split</span></code></dt><dd><p>Split string values on specified separator.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.unstack</span></code></dt><dd><p>Unstack, a.k.a. pivot, Series with MultiIndex to produce DataFrame.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.melt" title="dask.dataframe.DataFrame.melt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.melt</span></code></a></dt><dd><p>Unpivot a DataFrame from wide format to long format.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.explode" title="dask.dataframe.DataFrame.explode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.explode</span></code></a></dt><dd><p>Explode a DataFrame from list-like columns to long format.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This routine will explode list-likes including lists, tuples,
Series, and np.ndarray. The result dtype of the subset rows will
be object. Scalars will be returned unchanged. Empty list-likes will
result in a np.nan for that row.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">0    [1, 2, 3]</span>
<span class="go">1          foo</span>
<span class="go">2           []</span>
<span class="go">3       [3, 4]</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">explode</span><span class="p">()</span>  
<span class="go">0      1</span>
<span class="go">0      2</span>
<span class="go">0      3</span>
<span class="go">1    foo</span>
<span class="go">2    NaN</span>
<span class="go">3      3</span>
<span class="go">3      4</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.ffill">
<code class="sig-name descname">ffill</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.ffill" title="Permalink to this definition">¶</a></dt>
<dd><p>Synonym for <a class="reference internal" href="#dask.dataframe.DataFrame.fillna" title="dask.dataframe.DataFrame.fillna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.fillna()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">method='ffill'</span></code>.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.ffill.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>%(klass)s or None</strong></dt><dd><p>Object with missing values filled or None if <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.fillna">
<code class="sig-name descname">fillna</code><span class="sig-paren">(</span><em class="sig-param">value=None</em>, <em class="sig-param">method=None</em>, <em class="sig-param">limit=None</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.fillna" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill NA/NaN values using the specified method.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.fillna.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">scalar, dict, Series, or DataFrame</span></dt><dd><p>Value to use to fill holes (e.g. 0), alternately a
dict/Series/DataFrame of values specifying which value to use for
each index (for a Series) or column (for a DataFrame).  Values not
in the dict/Series/DataFrame will not be filled. This value cannot
be a list.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘backfill’, ‘bfill’, ‘pad’, ‘ffill’, None}, default None</span></dt><dd><p>Method to use for filling holes in reindexed Series
pad / ffill: propagate last valid observation forward to next valid
backfill / bfill: use next valid observation to fill gap.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Axis along which to fill missing values.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True, fill in-place. Note: this will modify any
other views on this object (e.g., a no-copy slice for a column in a
DataFrame).</p>
</dd>
<dt><strong>limit</strong><span class="classifier">int, default None</span></dt><dd><p>If method is specified, this is the maximum number of consecutive
NaN values to forward/backward fill. In other words, if there is
a gap with more than this number of consecutive NaNs, it will only
be partially filled. If method is not specified, this is the
maximum number of entries along the entire axis where NaNs will be
filled. Must be greater than 0 if not None.</p>
</dd>
<dt><strong>downcast</strong><span class="classifier">dict, default is None  (Not supported in Dask)</span></dt><dd><p>A dict of item-&gt;dtype of what to downcast if possible,
or the string ‘infer’ which will try to downcast to an appropriate
equal type (e.g. float64 to int64 if possible).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame or None</strong></dt><dd><p>Object with missing values filled or None if <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate</span></code></dt><dd><p>Fill NaN values using interpolation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex</span></code></dt><dd><p>Conform object to new index.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">asfreq</span></code></dt><dd><p>Convert TimeSeries to specified frequency.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;ABCD&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">     A    B   C  D</span>
<span class="go">0  NaN  2.0 NaN  0</span>
<span class="go">1  3.0  4.0 NaN  1</span>
<span class="go">2  NaN  NaN NaN  5</span>
<span class="go">3  NaN  3.0 NaN  4</span>
</pre></div>
</div>
<p>Replace all NaN elements with 0s.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">    A   B   C   D</span>
<span class="go">0   0.0 2.0 0.0 0</span>
<span class="go">1   3.0 4.0 0.0 1</span>
<span class="go">2   0.0 0.0 0.0 5</span>
<span class="go">3   0.0 3.0 0.0 4</span>
</pre></div>
</div>
<p>We can also propagate non-null values forward or backward.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">)</span>  
<span class="go">    A   B   C   D</span>
<span class="go">0   NaN 2.0 NaN 0</span>
<span class="go">1   3.0 4.0 NaN 1</span>
<span class="go">2   3.0 4.0 NaN 5</span>
<span class="go">3   3.0 3.0 NaN 4</span>
</pre></div>
</div>
<p>Replace all NaN elements in column ‘A’, ‘B’, ‘C’, and ‘D’, with 0, 1,
2, and 3 respectively.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>  
<span class="go">    A   B   C   D</span>
<span class="go">0   0.0 2.0 2.0 0</span>
<span class="go">1   3.0 4.0 2.0 1</span>
<span class="go">2   0.0 1.0 2.0 5</span>
<span class="go">3   0.0 3.0 2.0 4</span>
</pre></div>
</div>
<p>Only replace the first NaN element.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">    A   B   C   D</span>
<span class="go">0   0.0 2.0 2.0 0</span>
<span class="go">1   3.0 4.0 NaN 1</span>
<span class="go">2   NaN 1.0 NaN 5</span>
<span class="go">3   NaN 3.0 NaN 4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.first">
<code class="sig-name descname">first</code><span class="sig-paren">(</span><em class="sig-param">offset</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.first" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to subset initial periods of time series data based on a date offset.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.first.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>offset</strong><span class="classifier">str, DateOffset, dateutil.relativedelta</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>subset</strong><span class="classifier">same type as caller</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>TypeError</strong></dt><dd><p>If the index is not  a <code class="xref py py-class docutils literal notranslate"><span class="pre">DatetimeIndex</span></code></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.last" title="dask.dataframe.Series.last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">last</span></code></a></dt><dd><p>Select final periods of time series based on a date offset.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">at_time</span></code></dt><dd><p>Select values at a particular time of the day.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">between_time</span></code></dt><dd><p>Select values between particular times of the day.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2018-04-09&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;2D&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]},</span> <span class="n">index</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span>  
<span class="go">            A</span>
<span class="go">2018-04-09  1</span>
<span class="go">2018-04-11  2</span>
<span class="go">2018-04-13  3</span>
<span class="go">2018-04-15  4</span>
</pre></div>
</div>
<p>Get the rows for the first 3 days:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="s1">&#39;3D&#39;</span><span class="p">)</span>  
<span class="go">            A</span>
<span class="go">2018-04-09  1</span>
<span class="go">2018-04-11  2</span>
</pre></div>
</div>
<p>Notice the data for 3 first calender days were returned, not the first
3 days observed in the dataset, and therefore data for 2018-04-13 was
not returned.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.floordiv">
<code class="sig-name descname">floordiv</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.floordiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Integer division of series and other, element-wise (binary operator <cite>floordiv</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.floordiv.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">//</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.rfloordiv" title="dask.dataframe.Series.rfloordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.rfloordiv</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">floordiv</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">c    NaN</span>
<span class="go">d    0.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.ge">
<code class="sig-name descname">ge</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.ge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Greater than or equal to of series and other, element-wise (binary operator <cite>ge</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.ge.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">&gt;=</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.None</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.get_partition">
<code class="sig-name descname">get_partition</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.get_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dask DataFrame/Series representing the <cite>nth</cite> partition.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.groupby">
<code class="sig-name descname">groupby</code><span class="sig-paren">(</span><em class="sig-param">by=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Group Series using a mapper or by a Series of columns.</p>
<p>This docstring was copied from pandas.core.series.Series.groupby.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>A groupby operation involves some combination of splitting the
object, applying a function, and combining the results. This can be
used to group large amounts of data and compute operations on these
groups.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>by</strong><span class="classifier">mapping, function, label, or list of labels</span></dt><dd><p>Used to determine the groups for the groupby.
If <code class="docutils literal notranslate"><span class="pre">by</span></code> is a function, it’s called on each value of the object’s
index. If a dict or Series is passed, the Series or dict VALUES
will be used to determine the groups (the Series’ values are first
aligned; see <code class="docutils literal notranslate"><span class="pre">.align()</span></code> method). If an ndarray is passed, the
values are used as-is determine the groups. A label or list of
labels may be passed to group by the columns in <code class="docutils literal notranslate"><span class="pre">self</span></code>. Notice
that a tuple is interpreted as a (single) key.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0  (Not supported in Dask)</span></dt><dd><p>Split along rows (0) or columns (1).</p>
</dd>
<dt><strong>level</strong><span class="classifier">int, level name, or sequence of such, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), group by a particular
level or levels.</p>
</dd>
<dt><strong>as_index</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>For aggregated output, return object with group labels as the
index. Only relevant for DataFrame input. as_index=False is
effectively “SQL-style” grouped output.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>Sort group keys. Get better performance by turning this off.
Note this does not influence the order of observations within each
group. Groupby preserves the order of rows within each group.</p>
</dd>
<dt><strong>group_keys</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>When calling apply, add group keys to index to identify pieces.</p>
</dd>
<dt><strong>squeeze</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Reduce the dimensionality of the return type if possible,
otherwise return a consistent type.</p>
</dd>
<dt><strong>observed</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>This only applies if any of the groupers are Categoricals.
If True: only show observed values for categorical groupers.
If False: show all values for categorical groupers.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.23.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>SeriesGroupBy</strong></dt><dd><p>Returns a groupby object that contains information about the groups.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.resample" title="dask.dataframe.Series.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a></dt><dd><p>Convenience method for frequency conversion and resampling of time series.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>See the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/groupby.html">user guide</a> for more.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">390.</span><span class="p">,</span> <span class="mf">350.</span><span class="p">,</span> <span class="mf">30.</span><span class="p">,</span> <span class="mf">20.</span><span class="p">],</span>  
<span class="gp">... </span>                <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;Falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;Parrot&#39;</span><span class="p">,</span> <span class="s1">&#39;Parrot&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Max Speed&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>  
<span class="go">Falcon    390.0</span>
<span class="go">Falcon    350.0</span>
<span class="go">Parrot     30.0</span>
<span class="go">Parrot     20.0</span>
<span class="go">Name: Max Speed, dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">a    210.0</span>
<span class="go">b    185.0</span>
<span class="go">Name: Max Speed, dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">Falcon    370.0</span>
<span class="go">Parrot     25.0</span>
<span class="go">Name: Max Speed, dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">ser</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">Max Speed</span>
<span class="go">False     25.0</span>
<span class="go">True     370.0</span>
<span class="go">Name: Max Speed, dtype: float64</span>
</pre></div>
</div>
<p><strong>Grouping by Indexes</strong></p>
<p>We can groupby different levels of a hierarchical index
using the <cite>level</cite> parameter:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;Falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;Falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;Parrot&#39;</span><span class="p">,</span> <span class="s1">&#39;Parrot&#39;</span><span class="p">],</span>  
<span class="gp">... </span>          <span class="p">[</span><span class="s1">&#39;Captive&#39;</span><span class="p">,</span> <span class="s1">&#39;Wild&#39;</span><span class="p">,</span> <span class="s1">&#39;Captive&#39;</span><span class="p">,</span> <span class="s1">&#39;Wild&#39;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Animal&#39;</span><span class="p">,</span> <span class="s1">&#39;Type&#39;</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">390.</span><span class="p">,</span> <span class="mf">350.</span><span class="p">,</span> <span class="mf">30.</span><span class="p">,</span> <span class="mf">20.</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Max Speed&quot;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>  
<span class="go">Animal  Type</span>
<span class="go">Falcon  Captive    390.0</span>
<span class="go">        Wild       350.0</span>
<span class="go">Parrot  Captive     30.0</span>
<span class="go">        Wild        20.0</span>
<span class="go">Name: Max Speed, dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">Animal</span>
<span class="go">Falcon    370.0</span>
<span class="go">Parrot     25.0</span>
<span class="go">Name: Max Speed, dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s2">&quot;Type&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">Type</span>
<span class="go">Captive    210.0</span>
<span class="go">Wild       185.0</span>
<span class="go">Name: Max Speed, dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.gt">
<code class="sig-name descname">gt</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.gt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Greater than of series and other, element-wise (binary operator <cite>gt</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.gt.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">&gt;</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.None</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.head">
<code class="sig-name descname">head</code><span class="sig-paren">(</span><em class="sig-param">n=5</em>, <em class="sig-param">npartitions=1</em>, <em class="sig-param">compute=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.head" title="Permalink to this definition">¶</a></dt>
<dd><p>First n rows of the dataset</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>The number of rows to return. Default is 5.</p>
</dd>
<dt><strong>npartitions</strong><span class="classifier">int, optional</span></dt><dd><p>Elements are only taken from the first <code class="docutils literal notranslate"><span class="pre">npartitions</span></code>, with a
default of 1. If there are fewer than <code class="docutils literal notranslate"><span class="pre">n</span></code> rows in the first
<code class="docutils literal notranslate"><span class="pre">npartitions</span></code> a warning will be raised and any found rows
returned. Pass -1 to use all partitions.</p>
</dd>
<dt><strong>compute</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to compute the result, default is True.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.idxmax">
<code class="sig-name descname">idxmax</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.idxmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index of first occurrence of maximum over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.idxmax.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>NA/null values are excluded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The axis to use. 0 or ‘index’ for row-wise, 1 or ‘columns’ for column-wise.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Indexes of maxima along the specified axis.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><ul class="simple">
<li><p>If the row/column is empty</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.idxmax" title="dask.dataframe.Series.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmax</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This method is the DataFrame version of <code class="docutils literal notranslate"><span class="pre">ndarray.argmax</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.idxmin">
<code class="sig-name descname">idxmin</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.idxmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index of first occurrence of minimum over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.idxmin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>NA/null values are excluded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The axis to use. 0 or ‘index’ for row-wise, 1 or ‘columns’ for column-wise.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Indexes of minima along the specified axis.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><ul class="simple">
<li><p>If the row/column is empty</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.idxmin" title="dask.dataframe.Series.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmin</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This method is the DataFrame version of <code class="docutils literal notranslate"><span class="pre">ndarray.argmin</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.index">
<em class="property">property </em><code class="sig-name descname">index</code><a class="headerlink" href="#dask.dataframe.Series.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dask Index instance</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.isin">
<code class="sig-name descname">isin</code><span class="sig-paren">(</span><em class="sig-param">values</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.isin" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <cite>values</cite> are contained in Series.</p>
<p>This docstring was copied from pandas.core.series.Series.isin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return a boolean Series showing whether each element in the Series
matches an element in the passed sequence of <cite>values</cite> exactly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">set or list-like</span></dt><dd><p>The sequence of values to test. Passing in a single string will
raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>. Instead, turn a single string into a
list of one element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Series of booleans indicating if each element is in values.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>TypeError</strong></dt><dd><ul class="simple">
<li><p>If <cite>values</cite> is a string</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.isin" title="dask.dataframe.DataFrame.isin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.isin</span></code></a></dt><dd><p>Equivalent method on DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">&#39;lama&#39;</span><span class="p">,</span> <span class="s1">&#39;cow&#39;</span><span class="p">,</span> <span class="s1">&#39;lama&#39;</span><span class="p">,</span> <span class="s1">&#39;beetle&#39;</span><span class="p">,</span> <span class="s1">&#39;lama&#39;</span><span class="p">,</span>  
<span class="gp">... </span>               <span class="s1">&#39;hippo&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;animal&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s1">&#39;cow&#39;</span><span class="p">,</span> <span class="s1">&#39;lama&#39;</span><span class="p">])</span>  
<span class="go">0     True</span>
<span class="go">1     True</span>
<span class="go">2     True</span>
<span class="go">3    False</span>
<span class="go">4     True</span>
<span class="go">5    False</span>
<span class="go">Name: animal, dtype: bool</span>
</pre></div>
</div>
<p>Passing a single string as <code class="docutils literal notranslate"><span class="pre">s.isin('lama')</span></code> will raise an error. Use
a list of one element instead:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s1">&#39;lama&#39;</span><span class="p">])</span>  
<span class="go">0     True</span>
<span class="go">1    False</span>
<span class="go">2     True</span>
<span class="go">3    False</span>
<span class="go">4     True</span>
<span class="go">5    False</span>
<span class="go">Name: animal, dtype: bool</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.isna">
<code class="sig-name descname">isna</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.isna" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect missing values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.isna.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return a boolean same-sized object indicating if the values are NA.
NA values, such as None or <code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.NaN</span></code>, gets mapped to True
values.
Everything else gets mapped to False values. Characters such as empty
strings <code class="docutils literal notranslate"><span class="pre">''</span></code> or <code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.inf</span></code> are not considered NA values
(unless you set <code class="docutils literal notranslate"><span class="pre">pandas.options.mode.use_inf_as_na</span> <span class="pre">=</span> <span class="pre">True</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Mask of bool values for each element in DataFrame that
indicates whether an element is not an NA value.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.isnull" title="dask.dataframe.DataFrame.isnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.isnull</span></code></a></dt><dd><p>Alias of isna.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.notna</span></code></dt><dd><p>Boolean inverse of isna.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.dropna" title="dask.dataframe.DataFrame.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.dropna</span></code></a></dt><dd><p>Omit axes labels with missing values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.isna" title="dask.dataframe.Series.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isna</span></code></a></dt><dd><p>Top-level isna.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Show which entries in a DataFrame are NA.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;born&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1939-05-27&#39;</span><span class="p">),</span>
<span class="gp">... </span>                            <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1940-04-25&#39;</span><span class="p">)],</span>
<span class="gp">... </span>                   <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Alfred&#39;</span><span class="p">,</span> <span class="s1">&#39;Batman&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;toy&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Batmobile&#39;</span><span class="p">,</span> <span class="s1">&#39;Joker&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   age       born    name        toy</span>
<span class="go">0  5.0        NaT  Alfred       None</span>
<span class="go">1  6.0 1939-05-27  Batman  Batmobile</span>
<span class="go">2  NaN 1940-04-25              Joker</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>  
<span class="go">     age   born   name    toy</span>
<span class="go">0  False   True  False   True</span>
<span class="go">1  False  False  False  False</span>
<span class="go">2   True  False  False  False</span>
</pre></div>
</div>
<p>Show which entries in a Series are NA.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>  
<span class="go">0    5.0</span>
<span class="go">1    6.0</span>
<span class="go">2    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>  
<span class="go">0    False</span>
<span class="go">1    False</span>
<span class="go">2     True</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.isnull">
<code class="sig-name descname">isnull</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.isnull" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect missing values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.isnull.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return a boolean same-sized object indicating if the values are NA.
NA values, such as None or <code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.NaN</span></code>, gets mapped to True
values.
Everything else gets mapped to False values. Characters such as empty
strings <code class="docutils literal notranslate"><span class="pre">''</span></code> or <code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.inf</span></code> are not considered NA values
(unless you set <code class="docutils literal notranslate"><span class="pre">pandas.options.mode.use_inf_as_na</span> <span class="pre">=</span> <span class="pre">True</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Mask of bool values for each element in DataFrame that
indicates whether an element is not an NA value.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.isnull" title="dask.dataframe.DataFrame.isnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.isnull</span></code></a></dt><dd><p>Alias of isna.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.notna</span></code></dt><dd><p>Boolean inverse of isna.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.dropna" title="dask.dataframe.DataFrame.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.dropna</span></code></a></dt><dd><p>Omit axes labels with missing values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.isna" title="dask.dataframe.Series.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isna</span></code></a></dt><dd><p>Top-level isna.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Show which entries in a DataFrame are NA.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;born&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1939-05-27&#39;</span><span class="p">),</span>
<span class="gp">... </span>                            <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1940-04-25&#39;</span><span class="p">)],</span>
<span class="gp">... </span>                   <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Alfred&#39;</span><span class="p">,</span> <span class="s1">&#39;Batman&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;toy&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Batmobile&#39;</span><span class="p">,</span> <span class="s1">&#39;Joker&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   age       born    name        toy</span>
<span class="go">0  5.0        NaT  Alfred       None</span>
<span class="go">1  6.0 1939-05-27  Batman  Batmobile</span>
<span class="go">2  NaN 1940-04-25              Joker</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>  
<span class="go">     age   born   name    toy</span>
<span class="go">0  False   True  False   True</span>
<span class="go">1  False  False  False  False</span>
<span class="go">2   True  False  False  False</span>
</pre></div>
</div>
<p>Show which entries in a Series are NA.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>  
<span class="go">0    5.0</span>
<span class="go">1    6.0</span>
<span class="go">2    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>  
<span class="go">0    False</span>
<span class="go">1    False</span>
<span class="go">2     True</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.iteritems">
<code class="sig-name descname">iteritems</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.iteritems" title="Permalink to this definition">¶</a></dt>
<dd><p>Lazily iterate over (index, value) tuples.</p>
<p>This docstring was copied from pandas.core.series.Series.iteritems.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This method returns an iterable tuple (index, value). This is
convenient if you want to create a lazy iterator.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>iterable</strong></dt><dd><p>Iterable of tuples containing the (index, value) pairs from a
Series.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.items</span></code></dt><dd><p>Iterate over (column name, Series) pairs.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.iterrows" title="dask.dataframe.DataFrame.iterrows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.iterrows</span></code></a></dt><dd><p>Iterate over DataFrame rows as (index, Series) pairs.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Index : </span><span class="si">{index}</span><span class="s2">, Value : </span><span class="si">{value}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">Index : 0, Value : A</span>
<span class="go">Index : 1, Value : B</span>
<span class="go">Index : 2, Value : C</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.known_divisions">
<em class="property">property </em><code class="sig-name descname">known_divisions</code><a class="headerlink" href="#dask.dataframe.Series.known_divisions" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether divisions are already known</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.last">
<code class="sig-name descname">last</code><span class="sig-paren">(</span><em class="sig-param">offset</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.last" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to subset final periods of time series data based on a date offset.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.last.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>offset</strong><span class="classifier">str, DateOffset, dateutil.relativedelta</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>subset</strong><span class="classifier">same type as caller</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>TypeError</strong></dt><dd><p>If the index is not  a <code class="xref py py-class docutils literal notranslate"><span class="pre">DatetimeIndex</span></code></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.first" title="dask.dataframe.Series.first"><code class="xref py py-obj docutils literal notranslate"><span class="pre">first</span></code></a></dt><dd><p>Select initial periods of time series based on a date offset.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">at_time</span></code></dt><dd><p>Select values at a particular time of the day.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">between_time</span></code></dt><dd><p>Select values between particular times of the day.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2018-04-09&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;2D&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span> <span class="n">index</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span>  
<span class="go">            A</span>
<span class="go">2018-04-09  1</span>
<span class="go">2018-04-11  2</span>
<span class="go">2018-04-13  3</span>
<span class="go">2018-04-15  4</span>
</pre></div>
</div>
<p>Get the rows for the last 3 days:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="s1">&#39;3D&#39;</span><span class="p">)</span>  
<span class="go">            A</span>
<span class="go">2018-04-13  3</span>
<span class="go">2018-04-15  4</span>
</pre></div>
</div>
<p>Notice the data for 3 last calender days were returned, not the last
3 observed days in the dataset, and therefore data for 2018-04-11 was
not returned.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.le">
<code class="sig-name descname">le</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.le" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Less than or equal to of series and other, element-wise (binary operator <cite>le</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.le.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">&lt;=</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.None</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.loc">
<em class="property">property </em><code class="sig-name descname">loc</code><a class="headerlink" href="#dask.dataframe.Series.loc" title="Permalink to this definition">¶</a></dt>
<dd><p>Purely label-location based indexer for selection by label.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">:</span><span class="s2">&quot;d&quot;</span><span class="p">]</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.lt">
<code class="sig-name descname">lt</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.lt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Less than of series and other, element-wise (binary operator <cite>lt</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.lt.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">&lt;</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.None</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.map">
<code class="sig-name descname">map</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">na_action=None</em>, <em class="sig-param">meta='__no_default__'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Map values of Series according to input correspondence.</p>
<p>This docstring was copied from pandas.core.series.Series.map.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Used for substituting each value in a Series with another value,
that may be derived from a function, a <code class="docutils literal notranslate"><span class="pre">dict</span></code> or
a <a class="reference internal" href="#dask.dataframe.Series" title="dask.dataframe.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arg</strong><span class="classifier">function, collections.abc.Mapping subclass or Series</span></dt><dd><p>Mapping correspondence.</p>
</dd>
<dt><strong>na_action</strong><span class="classifier">{None, ‘ignore’}, default None</span></dt><dd><p>If ‘ignore’, propagate NaN values, without passing them to the
mapping correspondence.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes
and column names of the output. This metadata is necessary for
many algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code>
can be provided (note that the order of the names should match the
order of the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span>
<span class="pre">dtype)</span></code> can be used. If not provided, dask will try to infer the
metadata. This may lead to unexpected results, so providing
<code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For more information, see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Same index as caller.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.apply" title="dask.dataframe.Series.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.apply</span></code></a></dt><dd><p>For applying more complex functions on a Series.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.apply" title="dask.dataframe.DataFrame.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.apply</span></code></a></dt><dd><p>Apply a function row-/column-wise.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.applymap" title="dask.dataframe.DataFrame.applymap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.applymap</span></code></a></dt><dd><p>Apply a function elementwise on a whole DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When <code class="docutils literal notranslate"><span class="pre">arg</span></code> is a dictionary, values in Series that are not in the
dictionary (as keys) are converted to <code class="docutils literal notranslate"><span class="pre">NaN</span></code>. However, if the
dictionary is a <code class="docutils literal notranslate"><span class="pre">dict</span></code> subclass that defines <code class="docutils literal notranslate"><span class="pre">__missing__</span></code> (i.e.
provides a method for default values), then this default is used
rather than <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">&#39;cat&#39;</span><span class="p">,</span> <span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;rabbit&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">0      cat</span>
<span class="go">1      dog</span>
<span class="go">2      NaN</span>
<span class="go">3   rabbit</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">map</span></code> accepts a <code class="docutils literal notranslate"><span class="pre">dict</span></code> or a <code class="docutils literal notranslate"><span class="pre">Series</span></code>. Values that are not found
in the <code class="docutils literal notranslate"><span class="pre">dict</span></code> are converted to <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, unless the dict has a default
value (e.g. <code class="docutils literal notranslate"><span class="pre">defaultdict</span></code>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">map</span><span class="p">({</span><span class="s1">&#39;cat&#39;</span><span class="p">:</span> <span class="s1">&#39;kitten&#39;</span><span class="p">,</span> <span class="s1">&#39;dog&#39;</span><span class="p">:</span> <span class="s1">&#39;puppy&#39;</span><span class="p">})</span>  
<span class="go">0   kitten</span>
<span class="go">1    puppy</span>
<span class="go">2      NaN</span>
<span class="go">3      NaN</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>It also accepts a function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="s1">&#39;I am a </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>  
<span class="go">0       I am a cat</span>
<span class="go">1       I am a dog</span>
<span class="go">2       I am a nan</span>
<span class="go">3    I am a rabbit</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>To avoid applying the function to missing values (and keep them as
<code class="docutils literal notranslate"><span class="pre">NaN</span></code>) <code class="docutils literal notranslate"><span class="pre">na_action='ignore'</span></code> can be used:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="s1">&#39;I am a </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>  
<span class="go">0     I am a cat</span>
<span class="go">1     I am a dog</span>
<span class="go">2            NaN</span>
<span class="go">3  I am a rabbit</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.map_overlap">
<code class="sig-name descname">map_overlap</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">before</em>, <em class="sig-param">after</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.map_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to each partition, sharing rows with adjacent partitions.</p>
<p>This can be useful for implementing windowing functions such as
<code class="docutils literal notranslate"><span class="pre">df.rolling(...).mean()</span></code> or <code class="docutils literal notranslate"><span class="pre">df.diff()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function applied to each partition.</p>
</dd>
<dt><strong>before</strong><span class="classifier">int</span></dt><dd><p>The number of rows to prepend to partition <code class="docutils literal notranslate"><span class="pre">i</span></code> from the end of
partition <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>after</strong><span class="classifier">int</span></dt><dd><p>The number of rows to append to partition <code class="docutils literal notranslate"><span class="pre">i</span></code> from the beginning
of partition <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>args, kwargs :</strong></dt><dd><p>Arguments and keywords to pass to the function. The partition will
be the first argument, and these will be passed <em>after</em>.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes
and column names of the output. This metadata is necessary for
many algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code>
can be provided (note that the order of the names should match the
order of the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span>
<span class="pre">dtype)</span></code> can be used. If not provided, dask will try to infer the
metadata. This may lead to unexpected results, so providing
<code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For more information, see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Given positive integers <code class="docutils literal notranslate"><span class="pre">before</span></code> and <code class="docutils literal notranslate"><span class="pre">after</span></code>, and a function
<code class="docutils literal notranslate"><span class="pre">func</span></code>, <code class="docutils literal notranslate"><span class="pre">map_overlap</span></code> does the following:</p>
<ol class="arabic simple">
<li><p>Prepend <code class="docutils literal notranslate"><span class="pre">before</span></code> rows to each partition <code class="docutils literal notranslate"><span class="pre">i</span></code> from the end of
partition <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">-</span> <span class="pre">1</span></code>. The first partition has no rows prepended.</p></li>
<li><p>Append <code class="docutils literal notranslate"><span class="pre">after</span></code> rows to each partition <code class="docutils literal notranslate"><span class="pre">i</span></code> from the beginning of
partition <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></code>. The last partition has no rows appended.</p></li>
<li><p>Apply <code class="docutils literal notranslate"><span class="pre">func</span></code> to each partition, passing in any extra <code class="docutils literal notranslate"><span class="pre">args</span></code> and
<code class="docutils literal notranslate"><span class="pre">kwargs</span></code> if provided.</p></li>
<li><p>Trim <code class="docutils literal notranslate"><span class="pre">before</span></code> rows from the beginning of all but the first
partition.</p></li>
<li><p>Trim <code class="docutils literal notranslate"><span class="pre">after</span></code> rows from the end of all but the last partition.</p></li>
</ol>
<p>Note that the index and divisions are assumed to remain unchanged.</p>
<p class="rubric">Examples</p>
<p>Given a DataFrame, Series, or Index, such as:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>A rolling sum with a trailing moving window of size 2 can be computed by
overlapping 2 rows before each partition, and then mapping calls to
<code class="docutils literal notranslate"><span class="pre">df.rolling(2).sum()</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">    x    y</span>
<span class="go">0   1  1.0</span>
<span class="go">1   2  2.0</span>
<span class="go">2   4  3.0</span>
<span class="go">3   7  4.0</span>
<span class="go">4  11  5.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">      x    y</span>
<span class="go">0   NaN  NaN</span>
<span class="go">1   3.0  3.0</span>
<span class="go">2   6.0  5.0</span>
<span class="go">3  11.0  7.0</span>
<span class="go">4  18.0  9.0</span>
</pre></div>
</div>
<p>The pandas <code class="docutils literal notranslate"><span class="pre">diff</span></code> method computes a discrete difference shifted by a
number of periods (can be positive or negative). This can be
implemented by mapping calls to <code class="docutils literal notranslate"><span class="pre">df.diff</span></code> to each partition after
prepending/appending that many rows, depending on sign:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">before</span><span class="p">,</span> <span class="n">after</span> <span class="o">=</span> <span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">periods</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">periods</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">periods</span><span class="p">),</span>
<span class="gp">... </span>                          <span class="n">periods</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span><span class="p">(</span><span class="n">ddf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">     x    y</span>
<span class="go">0  NaN  NaN</span>
<span class="go">1  1.0  1.0</span>
<span class="go">2  2.0  1.0</span>
<span class="go">3  3.0  1.0</span>
<span class="go">4  4.0  1.0</span>
</pre></div>
</div>
<p>If you have a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>, you can use a <code class="docutils literal notranslate"><span class="pre">pd.Timedelta</span></code> for time-
based windows.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2017&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dts</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dts</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="s1">&#39;2D&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
<span class="gp">... </span>                <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="s1">&#39;2D&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">2017-01-01     0.0</span>
<span class="go">2017-01-02     1.0</span>
<span class="go">2017-01-03     3.0</span>
<span class="go">2017-01-04     5.0</span>
<span class="go">2017-01-05     7.0</span>
<span class="go">2017-01-06     9.0</span>
<span class="go">2017-01-07    11.0</span>
<span class="go">2017-01-08    13.0</span>
<span class="go">2017-01-09    15.0</span>
<span class="go">2017-01-10    17.0</span>
<span class="go">Freq: D, dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.map_partitions">
<code class="sig-name descname">map_partitions</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.map_partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Python function on each DataFrame partition.</p>
<p>Note that the index and divisions are assumed to remain unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function applied to each partition.</p>
</dd>
<dt><strong>args, kwargs :</strong></dt><dd><p>Arguments and keywords to pass to the function. The partition will
be the first argument, and these will be passed <em>after</em>. Arguments
and keywords may contain <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>, <code class="docutils literal notranslate"><span class="pre">Delayed</span></code> or regular
python objects. DataFrame-like args (both dask and pandas) will be
repartitioned to align (if necessary) before applying the function.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes
and column names of the output. This metadata is necessary for
many algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code>
can be provided (note that the order of the names should match the
order of the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span>
<span class="pre">dtype)</span></code> can be used. If not provided, dask will try to infer the
metadata. This may lead to unexpected results, so providing
<code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For more information, see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Given a DataFrame, Series, or Index, such as:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">map_partitions</span></code> to apply a function on each partition.
Extra arguments and keywords can optionally be provided, and will be
passed to the function after the partition.</p>
<p>Here we apply a function with arguments and keywords to a DataFrame,
resulting in a Series:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">myadd</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">df</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">myadd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<p>By default, dask tries to infer the output metadata by running your
provided function on some fake data. This works well in many cases, but
can sometimes be expensive, or even fail. To avoid this, you can
manually specify the output metadata with the <code class="docutils literal notranslate"><span class="pre">meta</span></code> keyword. This
can be specified in many forms, for more information see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
<p>Here we specify the output is a Series with no name, and dtype
<code class="docutils literal notranslate"><span class="pre">float64</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">myadd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;f8&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Here we map a function that takes in a DataFrame, and returns a
DataFrame with a new column:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">df</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">dtypes</span>
<span class="go">x      int64</span>
<span class="go">y    float64</span>
<span class="go">z    float64</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>As before, the output metadata can also be specified manually. This
time we pass in a <code class="docutils literal notranslate"><span class="pre">dict</span></code>, as the output is a DataFrame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">df</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">meta</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;f8&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;f8&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>In the case where the metadata doesn’t change, you can also pass in
the object itself directly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">(),</span> <span class="n">meta</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>Also note that the index and divisions are assumed to remain unchanged.
If the function you’re mapping changes the index/divisions, you’ll need
to clear them afterwards:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">clear_divisions</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.mask">
<code class="sig-name descname">mask</code><span class="sig-paren">(</span><em class="sig-param">cond</em>, <em class="sig-param">other=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values where the condition is True.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.mask.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cond</strong><span class="classifier">bool Series/DataFrame, array-like, or callable</span></dt><dd><p>Where <cite>cond</cite> is False, keep the original value. Where
True, replace with corresponding value from <cite>other</cite>.
If <cite>cond</cite> is callable, it is computed on the Series/DataFrame and
should return boolean Series/DataFrame or array. The callable must
not change input Series/DataFrame (though pandas doesn’t check it).</p>
</dd>
<dt><strong>other</strong><span class="classifier">scalar, Series/DataFrame, or callable</span></dt><dd><p>Entries where <cite>cond</cite> is True are replaced with
corresponding value from <cite>other</cite>.
If other is callable, it is computed on the Series/DataFrame and
should return scalar or Series/DataFrame. The callable must not
change input Series/DataFrame (though pandas doesn’t check it).</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Whether to perform the operation in place on the data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, default None  (Not supported in Dask)</span></dt><dd><p>Alignment axis if needed.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int, default None  (Not supported in Dask)</span></dt><dd><p>Alignment level if needed.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, {‘raise’, ‘ignore’}, default ‘raise’  (Not supported in Dask)</span></dt><dd><p>Note that currently this parameter won’t affect
the results and will always coerce to a suitable dtype.</p>
<ul class="simple">
<li><p>‘raise’ : allow exceptions to be raised.</p></li>
<li><p>‘ignore’ : suppress exceptions. On error return original object.</p></li>
</ul>
</dd>
<dt><strong>try_cast</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Try to cast the result back to the input type (if possible).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Same type as caller</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.where" title="dask.dataframe.DataFrame.where"><code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.where()</span></code></a></dt><dd><p>Return an object of same shape as self.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The mask method is an application of the if-then idiom. For each
element in the calling DataFrame, if <code class="docutils literal notranslate"><span class="pre">cond</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> the
element is used; otherwise the corresponding element from the DataFrame
<code class="docutils literal notranslate"><span class="pre">other</span></code> is used.</p>
<p>The signature for <a class="reference internal" href="#dask.dataframe.DataFrame.where" title="dask.dataframe.DataFrame.where"><code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.where()</span></code></a> differs from
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html#numpy.where" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.where()</span></code></a>. Roughly <code class="docutils literal notranslate"><span class="pre">df1.where(m,</span> <span class="pre">df2)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">np.where(m,</span> <span class="pre">df1,</span> <span class="pre">df2)</span></code>.</p>
<p>For further details and examples see the <code class="docutils literal notranslate"><span class="pre">mask</span></code> documentation in
<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#indexing-where-mask" title="(in pandas v1.0.3)"><span class="xref std std-ref">indexing</span></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  
<span class="go">0    NaN</span>
<span class="go">1    1.0</span>
<span class="go">2    2.0</span>
<span class="go">3    3.0</span>
<span class="go">4    4.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  
<span class="go">0    0.0</span>
<span class="go">1    NaN</span>
<span class="go">2    NaN</span>
<span class="go">3    NaN</span>
<span class="go">4    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  
<span class="go">0    10</span>
<span class="go">1    10</span>
<span class="go">2    2</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A  B</span>
<span class="go">0  0  1</span>
<span class="go">1  2  3</span>
<span class="go">2  4  5</span>
<span class="go">3  6  7</span>
<span class="go">4  8  9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">df</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>  
<span class="go">   A  B</span>
<span class="go">0  0 -1</span>
<span class="go">1 -2  3</span>
<span class="go">2 -4 -5</span>
<span class="go">3  6 -7</span>
<span class="go">4 -8  9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>  
<span class="go">      A     B</span>
<span class="go">0  True  True</span>
<span class="go">1  True  True</span>
<span class="go">2  True  True</span>
<span class="go">3  True  True</span>
<span class="go">4  True  True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="n">df</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="o">~</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>  
<span class="go">      A     B</span>
<span class="go">0  True  True</span>
<span class="go">1  True  True</span>
<span class="go">2  True  True</span>
<span class="go">3  True  True</span>
<span class="go">4  True  True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of the values for the requested axis.</p>
<blockquote>
<div><p>This docstring was copied from pandas.core.frame.DataFrame.max.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>If you want the <em>index</em> of the maximum, use <code class="docutils literal notranslate"><span class="pre">idxmax</span></code>. This is
the equivalent of the <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> method <code class="docutils literal notranslate"><span class="pre">argmax</span></code>.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd><p>Axis for the function to be applied on.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to be passed to the function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.sum" title="dask.dataframe.Series.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.sum</span></code></a></dt><dd><p>Return the sum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.min" title="dask.dataframe.Series.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.min</span></code></a></dt><dd><p>Return the minimum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.max" title="dask.dataframe.Series.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.max</span></code></a></dt><dd><p>Return the maximum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.idxmin" title="dask.dataframe.Series.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmin</span></code></a></dt><dd><p>Return the index of the minimum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.idxmax" title="dask.dataframe.Series.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmax</span></code></a></dt><dd><p>Return the index of the maximum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sum" title="dask.dataframe.DataFrame.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sum</span></code></a></dt><dd><p>Return the sum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.min" title="dask.dataframe.DataFrame.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.min</span></code></a></dt><dd><p>Return the minimum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.max" title="dask.dataframe.DataFrame.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.max</span></code></a></dt><dd><p>Return the maximum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.idxmin" title="dask.dataframe.DataFrame.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.idxmin</span></code></a></dt><dd><p>Return the index of the minimum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.idxmax" title="dask.dataframe.DataFrame.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.idxmax</span></code></a></dt><dd><p>Return the index of the maximum over the requested axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">([</span>  
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;warm&#39;</span><span class="p">,</span> <span class="s1">&#39;warm&#39;</span><span class="p">,</span> <span class="s1">&#39;cold&#39;</span><span class="p">,</span> <span class="s1">&#39;cold&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="s1">&#39;falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;spider&#39;</span><span class="p">]],</span>
<span class="gp">... </span>    <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;blooded&#39;</span><span class="p">,</span> <span class="s1">&#39;animal&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;legs&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">blooded  animal</span>
<span class="go">warm     dog       4</span>
<span class="go">         falcon    2</span>
<span class="go">cold     fish      0</span>
<span class="go">         spider    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  
<span class="go">8</span>
</pre></div>
</div>
<p>Max using level names, as well as indices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;blooded&#39;</span><span class="p">)</span>  
<span class="go">blooded</span>
<span class="go">warm    4</span>
<span class="go">cold    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">blooded</span>
<span class="go">warm    4</span>
<span class="go">cold    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean of the values for the requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.mean.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd><p>Axis for the function to be applied on.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to be passed to the function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.memory_usage">
<code class="sig-name descname">memory_usage</code><span class="sig-paren">(</span><em class="sig-param">index=True</em>, <em class="sig-param">deep=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.memory_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memory usage of the Series.</p>
<p>This docstring was copied from pandas.core.series.Series.memory_usage.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The memory usage can optionally include the contribution of
the index and of elements of <cite>object</cite> dtype.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Specifies whether to include the memory usage of the Series index.</p>
</dd>
<dt><strong>deep</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, introspect the data deeply by interrogating
<cite>object</cite> dtypes for system-level memory consumption, and include
it in the returned value.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>int</strong></dt><dd><p>Bytes of memory consumed.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.nbytes.html#numpy.ndarray.nbytes" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray.nbytes</span></code></a></dt><dd><p>Total bytes consumed by the elements of the array.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.memory_usage" title="dask.dataframe.DataFrame.memory_usage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.memory_usage</span></code></a></dt><dd><p>Bytes consumed by a DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">()</span>  
<span class="go">152</span>
</pre></div>
</div>
<p>Not including the index gives the size of the rest of the data, which
is necessarily smaller:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">24</span>
</pre></div>
</div>
<p>The memory footprint of <cite>object</cite> values is ignored by default:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">values</span>  
<span class="go">array([&#39;a&#39;, &#39;b&#39;], dtype=object)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">()</span>  
<span class="go">144</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">260</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.memory_usage_per_partition">
<code class="sig-name descname">memory_usage_per_partition</code><span class="sig-paren">(</span><em class="sig-param">index=True</em>, <em class="sig-param">deep=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.memory_usage_per_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memory usage of each partition</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Specifies whether to include the memory usage of the index in
returned Series.</p>
</dd>
<dt><strong>deep</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, introspect the data deeply by interrogating
<code class="docutils literal notranslate"><span class="pre">object</span></code> dtypes for system-level memory consumption, and include
it in the returned values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>A Series whose index is the parition number and whose values
are the memory usage of each partition in bytes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum of the values for the requested axis.</p>
<blockquote>
<div><p>This docstring was copied from pandas.core.frame.DataFrame.min.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>If you want the <em>index</em> of the minimum, use <code class="docutils literal notranslate"><span class="pre">idxmin</span></code>. This is
the equivalent of the <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> method <code class="docutils literal notranslate"><span class="pre">argmin</span></code>.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd><p>Axis for the function to be applied on.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to be passed to the function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.sum" title="dask.dataframe.Series.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.sum</span></code></a></dt><dd><p>Return the sum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.min" title="dask.dataframe.Series.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.min</span></code></a></dt><dd><p>Return the minimum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.max" title="dask.dataframe.Series.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.max</span></code></a></dt><dd><p>Return the maximum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.idxmin" title="dask.dataframe.Series.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmin</span></code></a></dt><dd><p>Return the index of the minimum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.idxmax" title="dask.dataframe.Series.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmax</span></code></a></dt><dd><p>Return the index of the maximum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sum" title="dask.dataframe.DataFrame.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sum</span></code></a></dt><dd><p>Return the sum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.min" title="dask.dataframe.DataFrame.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.min</span></code></a></dt><dd><p>Return the minimum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.max" title="dask.dataframe.DataFrame.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.max</span></code></a></dt><dd><p>Return the maximum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.idxmin" title="dask.dataframe.DataFrame.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.idxmin</span></code></a></dt><dd><p>Return the index of the minimum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.idxmax" title="dask.dataframe.DataFrame.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.idxmax</span></code></a></dt><dd><p>Return the index of the maximum over the requested axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">([</span>  
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;warm&#39;</span><span class="p">,</span> <span class="s1">&#39;warm&#39;</span><span class="p">,</span> <span class="s1">&#39;cold&#39;</span><span class="p">,</span> <span class="s1">&#39;cold&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="s1">&#39;falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;spider&#39;</span><span class="p">]],</span>
<span class="gp">... </span>    <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;blooded&#39;</span><span class="p">,</span> <span class="s1">&#39;animal&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;legs&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">blooded  animal</span>
<span class="go">warm     dog       4</span>
<span class="go">         falcon    2</span>
<span class="go">cold     fish      0</span>
<span class="go">         spider    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>  
<span class="go">0</span>
</pre></div>
</div>
<p>Min using level names, as well as indices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;blooded&#39;</span><span class="p">)</span>  
<span class="go">blooded</span>
<span class="go">warm    2</span>
<span class="go">cold    0</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">blooded</span>
<span class="go">warm    2</span>
<span class="go">cold    0</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.mod">
<code class="sig-name descname">mod</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Modulo of series and other, element-wise (binary operator <cite>mod</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.mod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">%</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.rmod" title="dask.dataframe.Series.rmod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.rmod</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    0.0</span>
<span class="go">b    NaN</span>
<span class="go">c    NaN</span>
<span class="go">d    0.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.mul">
<code class="sig-name descname">mul</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Multiplication of series and other, element-wise (binary operator <cite>mul</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.mul.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">*</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.rmul" title="dask.dataframe.Series.rmul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.rmul</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    1.0</span>
<span class="go">b    0.0</span>
<span class="go">c    0.0</span>
<span class="go">d    0.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.nbytes">
<em class="property">property </em><code class="sig-name descname">nbytes</code><a class="headerlink" href="#dask.dataframe.Series.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of bytes</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.ndim">
<em class="property">property </em><code class="sig-name descname">ndim</code><a class="headerlink" href="#dask.dataframe.Series.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dimensionality</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.ne">
<code class="sig-name descname">ne</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.ne" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Not equal to of series and other, element-wise (binary operator <cite>ne</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.ne.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">!=</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.None</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.nlargest">
<code class="sig-name descname">nlargest</code><span class="sig-paren">(</span><em class="sig-param">n=5</em>, <em class="sig-param">split_every=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.nlargest" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the largest <cite>n</cite> elements.</p>
<p>This docstring was copied from pandas.core.series.Series.nlargest.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int, default 5</span></dt><dd><p>Return this many descending sorted values.</p>
</dd>
<dt><strong>keep</strong><span class="classifier">{‘first’, ‘last’, ‘all’}, default ‘first’  (Not supported in Dask)</span></dt><dd><p>When there are duplicate values that cannot all fit in a
Series of <cite>n</cite> elements:</p>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">first</span></code><span class="classifier">return the first <cite>n</cite> occurrences in order</span></dt><dd><p>of appearance.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">last</span></code><span class="classifier">return the last <cite>n</cite> occurrences in reverse</span></dt><dd><p>order of appearance.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="classifier">keep all occurrences. This can result in a Series of</span></dt><dd><p>size larger than <cite>n</cite>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The <cite>n</cite> largest values in the Series, sorted in decreasing order.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.nsmallest" title="dask.dataframe.Series.nsmallest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.nsmallest</span></code></a></dt><dd><p>Get the <cite>n</cite> smallest elements.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.sort_values</span></code></dt><dd><p>Sort Series by values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.head" title="dask.dataframe.Series.head"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.head</span></code></a></dt><dd><p>Return the first <cite>n</cite> rows.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Faster than <code class="docutils literal notranslate"><span class="pre">.sort_values(ascending=False).head(n)</span></code> for small <cite>n</cite>
relative to the size of the <code class="docutils literal notranslate"><span class="pre">Series</span></code> object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">countries_population</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Italy&quot;</span><span class="p">:</span> <span class="mi">59000000</span><span class="p">,</span> <span class="s2">&quot;France&quot;</span><span class="p">:</span> <span class="mi">65000000</span><span class="p">,</span>  
<span class="gp">... </span>                        <span class="s2">&quot;Malta&quot;</span><span class="p">:</span> <span class="mi">434000</span><span class="p">,</span> <span class="s2">&quot;Maldives&quot;</span><span class="p">:</span> <span class="mi">434000</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="s2">&quot;Brunei&quot;</span><span class="p">:</span> <span class="mi">434000</span><span class="p">,</span> <span class="s2">&quot;Iceland&quot;</span><span class="p">:</span> <span class="mi">337000</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="s2">&quot;Nauru&quot;</span><span class="p">:</span> <span class="mi">11300</span><span class="p">,</span> <span class="s2">&quot;Tuvalu&quot;</span><span class="p">:</span> <span class="mi">11300</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="s2">&quot;Anguilla&quot;</span><span class="p">:</span> <span class="mi">11300</span><span class="p">,</span> <span class="s2">&quot;Monserat&quot;</span><span class="p">:</span> <span class="mi">5200</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">countries_population</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">Italy       59000000</span>
<span class="go">France      65000000</span>
<span class="go">Malta         434000</span>
<span class="go">Maldives      434000</span>
<span class="go">Brunei        434000</span>
<span class="go">Iceland       337000</span>
<span class="go">Nauru          11300</span>
<span class="go">Tuvalu         11300</span>
<span class="go">Anguilla       11300</span>
<span class="go">Monserat        5200</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>The <cite>n</cite> largest elements where <code class="docutils literal notranslate"><span class="pre">n=5</span></code> by default.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">nlargest</span><span class="p">()</span>  
<span class="go">France      65000000</span>
<span class="go">Italy       59000000</span>
<span class="go">Malta         434000</span>
<span class="go">Maldives      434000</span>
<span class="go">Brunei        434000</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>The <cite>n</cite> largest elements where <code class="docutils literal notranslate"><span class="pre">n=3</span></code>. Default <cite>keep</cite> value is ‘first’
so Malta will be kept.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  
<span class="go">France    65000000</span>
<span class="go">Italy     59000000</span>
<span class="go">Malta       434000</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>The <cite>n</cite> largest elements where <code class="docutils literal notranslate"><span class="pre">n=3</span></code> and keeping the last duplicates.
Brunei will be kept since it is the last with value 434000 based on
the index order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">)</span>  
<span class="go">France      65000000</span>
<span class="go">Italy       59000000</span>
<span class="go">Brunei        434000</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>The <cite>n</cite> largest elements where <code class="docutils literal notranslate"><span class="pre">n=3</span></code> with all duplicates kept. Note
that the returned Series has five elements due to the three duplicates.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>  
<span class="go">France      65000000</span>
<span class="go">Italy       59000000</span>
<span class="go">Malta         434000</span>
<span class="go">Maldives      434000</span>
<span class="go">Brunei        434000</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.notnull">
<code class="sig-name descname">notnull</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.notnull" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect existing (non-missing) values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.notnull.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return a boolean same-sized object indicating if the values are not NA.
Non-missing values get mapped to True. Characters such as empty
strings <code class="docutils literal notranslate"><span class="pre">''</span></code> or <code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.inf</span></code> are not considered NA values
(unless you set <code class="docutils literal notranslate"><span class="pre">pandas.options.mode.use_inf_as_na</span> <span class="pre">=</span> <span class="pre">True</span></code>).
NA values, such as None or <code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.NaN</span></code>, get mapped to False
values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Mask of bool values for each element in DataFrame that
indicates whether an element is not an NA value.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.notnull" title="dask.dataframe.DataFrame.notnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.notnull</span></code></a></dt><dd><p>Alias of notna.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.isna" title="dask.dataframe.DataFrame.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.isna</span></code></a></dt><dd><p>Boolean inverse of notna.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.dropna" title="dask.dataframe.DataFrame.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.dropna</span></code></a></dt><dd><p>Omit axes labels with missing values.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">notna</span></code></dt><dd><p>Top-level notna.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Show which entries in a DataFrame are not NA.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;born&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1939-05-27&#39;</span><span class="p">),</span>
<span class="gp">... </span>                            <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1940-04-25&#39;</span><span class="p">)],</span>
<span class="gp">... </span>                   <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Alfred&#39;</span><span class="p">,</span> <span class="s1">&#39;Batman&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;toy&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Batmobile&#39;</span><span class="p">,</span> <span class="s1">&#39;Joker&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   age       born    name        toy</span>
<span class="go">0  5.0        NaT  Alfred       None</span>
<span class="go">1  6.0 1939-05-27  Batman  Batmobile</span>
<span class="go">2  NaN 1940-04-25              Joker</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>  
<span class="go">     age   born  name    toy</span>
<span class="go">0   True  False  True  False</span>
<span class="go">1   True   True  True   True</span>
<span class="go">2  False   True  True   True</span>
</pre></div>
</div>
<p>Show which entries in a Series are not NA.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>  
<span class="go">0    5.0</span>
<span class="go">1    6.0</span>
<span class="go">2    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>  
<span class="go">0     True</span>
<span class="go">1     True</span>
<span class="go">2    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.npartitions">
<em class="property">property </em><code class="sig-name descname">npartitions</code><a class="headerlink" href="#dask.dataframe.Series.npartitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of partitions</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.nsmallest">
<code class="sig-name descname">nsmallest</code><span class="sig-paren">(</span><em class="sig-param">n=5</em>, <em class="sig-param">split_every=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.nsmallest" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the smallest <cite>n</cite> elements.</p>
<p>This docstring was copied from pandas.core.series.Series.nsmallest.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int, default 5</span></dt><dd><p>Return this many ascending sorted values.</p>
</dd>
<dt><strong>keep</strong><span class="classifier">{‘first’, ‘last’, ‘all’}, default ‘first’  (Not supported in Dask)</span></dt><dd><p>When there are duplicate values that cannot all fit in a
Series of <cite>n</cite> elements:</p>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">first</span></code><span class="classifier">return the first <cite>n</cite> occurrences in order</span></dt><dd><p>of appearance.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">last</span></code><span class="classifier">return the last <cite>n</cite> occurrences in reverse</span></dt><dd><p>order of appearance.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="classifier">keep all occurrences. This can result in a Series of</span></dt><dd><p>size larger than <cite>n</cite>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The <cite>n</cite> smallest values in the Series, sorted in increasing order.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.nlargest" title="dask.dataframe.Series.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.nlargest</span></code></a></dt><dd><p>Get the <cite>n</cite> largest elements.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.sort_values</span></code></dt><dd><p>Sort Series by values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.head" title="dask.dataframe.Series.head"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.head</span></code></a></dt><dd><p>Return the first <cite>n</cite> rows.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Faster than <code class="docutils literal notranslate"><span class="pre">.sort_values().head(n)</span></code> for small <cite>n</cite> relative to
the size of the <code class="docutils literal notranslate"><span class="pre">Series</span></code> object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">countries_population</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Italy&quot;</span><span class="p">:</span> <span class="mi">59000000</span><span class="p">,</span> <span class="s2">&quot;France&quot;</span><span class="p">:</span> <span class="mi">65000000</span><span class="p">,</span>  
<span class="gp">... </span>                        <span class="s2">&quot;Brunei&quot;</span><span class="p">:</span> <span class="mi">434000</span><span class="p">,</span> <span class="s2">&quot;Malta&quot;</span><span class="p">:</span> <span class="mi">434000</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="s2">&quot;Maldives&quot;</span><span class="p">:</span> <span class="mi">434000</span><span class="p">,</span> <span class="s2">&quot;Iceland&quot;</span><span class="p">:</span> <span class="mi">337000</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="s2">&quot;Nauru&quot;</span><span class="p">:</span> <span class="mi">11300</span><span class="p">,</span> <span class="s2">&quot;Tuvalu&quot;</span><span class="p">:</span> <span class="mi">11300</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="s2">&quot;Anguilla&quot;</span><span class="p">:</span> <span class="mi">11300</span><span class="p">,</span> <span class="s2">&quot;Monserat&quot;</span><span class="p">:</span> <span class="mi">5200</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">countries_population</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">Italy       59000000</span>
<span class="go">France      65000000</span>
<span class="go">Brunei        434000</span>
<span class="go">Malta         434000</span>
<span class="go">Maldives      434000</span>
<span class="go">Iceland       337000</span>
<span class="go">Nauru          11300</span>
<span class="go">Tuvalu         11300</span>
<span class="go">Anguilla       11300</span>
<span class="go">Monserat        5200</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>The <cite>n</cite> smallest elements where <code class="docutils literal notranslate"><span class="pre">n=5</span></code> by default.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">()</span>  
<span class="go">Monserat      5200</span>
<span class="go">Nauru        11300</span>
<span class="go">Tuvalu       11300</span>
<span class="go">Anguilla     11300</span>
<span class="go">Iceland     337000</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>The <cite>n</cite> smallest elements where <code class="docutils literal notranslate"><span class="pre">n=3</span></code>. Default <cite>keep</cite> value is
‘first’ so Nauru and Tuvalu will be kept.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  
<span class="go">Monserat     5200</span>
<span class="go">Nauru       11300</span>
<span class="go">Tuvalu      11300</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>The <cite>n</cite> smallest elements where <code class="docutils literal notranslate"><span class="pre">n=3</span></code> and keeping the last
duplicates. Anguilla and Tuvalu will be kept since they are the last
with value 11300 based on the index order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">)</span>  
<span class="go">Monserat     5200</span>
<span class="go">Anguilla    11300</span>
<span class="go">Tuvalu      11300</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>The <cite>n</cite> smallest elements where <code class="docutils literal notranslate"><span class="pre">n=3</span></code> with all duplicates kept. Note
that the returned Series has four elements due to the three duplicates.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>  
<span class="go">Monserat     5200</span>
<span class="go">Nauru       11300</span>
<span class="go">Tuvalu      11300</span>
<span class="go">Anguilla    11300</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.nunique">
<code class="sig-name descname">nunique</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.nunique" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of unique elements in the object.</p>
<p>This docstring was copied from pandas.core.series.Series.nunique.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Excludes NA values by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dropna</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>Don’t include NaN in the count.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>int</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.nunique</span></code></dt><dd><p>Method nunique for DataFrame.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.count" title="dask.dataframe.Series.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.count</span></code></a></dt><dd><p>Count non-NA/null observations in the Series.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">0    1</span>
<span class="go">1    3</span>
<span class="go">2    5</span>
<span class="go">3    7</span>
<span class="go">4    7</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span>  
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.nunique_approx">
<code class="sig-name descname">nunique_approx</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.nunique_approx" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate number of unique rows.</p>
<p>This method uses the HyperLogLog algorithm for cardinality
estimation to compute the approximate number of unique rows.
The approximate error is 0.406%.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>split_every</strong><span class="classifier">int, optional</span></dt><dd><p>Group partitions into groups of this size while performing a
tree-reduction. If set to False, no tree-reduction will be used.
Default is 8.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a float representing the approximate number of elements</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.partitions">
<em class="property">property </em><code class="sig-name descname">partitions</code><a class="headerlink" href="#dask.dataframe.Series.partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice dataframe by partitions</p>
<p>This allows partitionwise slicing of a Dask Dataframe.  You can perform normal
Numpy-style slicing but now rather than slice elements of the array you
slice along partitions so, for example, <code class="docutils literal notranslate"><span class="pre">df.partitions[:5]</span></code> produces a new
Dask Dataframe of the first five partitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A Dask DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">partitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">partitions</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">partitions</span><span class="p">[::</span><span class="mi">10</span><span class="p">]</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.persist">
<code class="sig-name descname">persist</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.persist" title="Permalink to this definition">¶</a></dt>
<dd><p>Persist this dask collection into memory</p>
<p>This turns a lazy Dask collection into a Dask collection with the same
metadata, but now with the results fully computed or actively computing
in the background.</p>
<p>The action of function differs significantly depending on the active
task scheduler.  If the task scheduler supports asynchronous computing,
such as is the case of the dask.distributed scheduler, then persist
will return <em>immediately</em> and the return value’s task graph will
contain Dask Future objects.  However if the task scheduler only
supports blocking computation then the call to persist will <em>block</em>
and the return value’s task graph will contain concrete Python results.</p>
<p>This function is particularly useful when using distributed systems,
because the results will be kept in distributed memory, rather than
returned to the local process as with compute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scheduler</strong><span class="classifier">string, optional</span></dt><dd><p>Which scheduler to use like “threads”, “synchronous” or “processes”.
If not provided, the default is to check the global settings first,
and then fall back to the collection defaults.</p>
</dd>
<dt><strong>optimize_graph</strong><span class="classifier">bool, optional</span></dt><dd><p>If True [default], the graph is optimized before computation.
Otherwise the graph is run as is. This can be useful for debugging.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Extra keywords to forward to the scheduler function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>New dask collections backed by in-memory data</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.base.persist</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.pipe">
<code class="sig-name descname">pipe</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply func(self, *args, **kwargs).</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.pipe.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function to apply to the Series/DataFrame.
<code class="docutils literal notranslate"><span class="pre">args</span></code>, and <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> are passed into <code class="docutils literal notranslate"><span class="pre">func</span></code>.
Alternatively a <code class="docutils literal notranslate"><span class="pre">(callable,</span> <span class="pre">data_keyword)</span></code> tuple where
<code class="docutils literal notranslate"><span class="pre">data_keyword</span></code> is a string indicating the keyword of
<code class="docutils literal notranslate"><span class="pre">callable</span></code> that expects the Series/DataFrame.</p>
</dd>
<dt><strong>args</strong><span class="classifier">iterable, optional</span></dt><dd><p>Positional arguments passed into <code class="docutils literal notranslate"><span class="pre">func</span></code>.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">mapping, optional</span></dt><dd><p>A dictionary of keyword arguments passed into <code class="docutils literal notranslate"><span class="pre">func</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>object</strong><span class="classifier">the return type of <code class="docutils literal notranslate"><span class="pre">func</span></code>.</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.DataFrame.apply" title="dask.dataframe.DataFrame.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.apply</span></code></a>, <a class="reference internal" href="#dask.dataframe.DataFrame.applymap" title="dask.dataframe.DataFrame.applymap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.applymap</span></code></a>, <a class="reference internal" href="#dask.dataframe.Series.map" title="dask.dataframe.Series.map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.map</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">.pipe</span></code> when chaining together functions that expect
Series, DataFrames or GroupBy objects. Instead of writing</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">arg1</span><span class="o">=</span><span class="n">a</span><span class="p">),</span> <span class="n">arg2</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">arg3</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>  
</pre></div>
</div>
<p>You can write</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>  
<span class="gp">... </span>   <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">arg1</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="gp">... </span>   <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">arg2</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">arg3</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>If you have a function that takes the data as (say) the second
argument, pass a tuple indicating which keyword expects the
data. For example, suppose <code class="docutils literal notranslate"><span class="pre">f</span></code> takes its data as <code class="docutils literal notranslate"><span class="pre">arg2</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>  
<span class="gp">... </span>   <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">arg1</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="gp">... </span>   <span class="o">.</span><span class="n">pipe</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;arg2&#39;</span><span class="p">),</span> <span class="n">arg1</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">arg3</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
<span class="gp">... </span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.pow">
<code class="sig-name descname">pow</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.pow" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Exponential power of series and other, element-wise (binary operator <cite>pow</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.pow.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">**</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.rpow" title="dask.dataframe.Series.rpow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.rpow</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    0.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.prod">
<code class="sig-name descname">prod</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">min_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of the values for the requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.prod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd><p>Axis for the function to be applied on.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
<dt><strong>min_count</strong><span class="classifier">int, default 0</span></dt><dd><p>The required number of valid values to perform the operation. If fewer than
<code class="docutils literal notranslate"><span class="pre">min_count</span></code> non-NA values are present the result will be NA.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.22.0: </span>Added with the default being 0. This means the sum of an all-NA
or empty Series is 0, and the product of an all-NA or empty
Series is 1.</p>
</div>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to be passed to the function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>By default, the product of an empty or all-NA Series is <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>  
<span class="go">1.0</span>
</pre></div>
</div>
<p>This can be controlled with the <code class="docutils literal notranslate"><span class="pre">min_count</span></code> parameter</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">nan</span>
</pre></div>
</div>
<p>Thanks to the <code class="docutils literal notranslate"><span class="pre">skipna</span></code> parameter, <code class="docutils literal notranslate"><span class="pre">min_count</span></code> handles all-NA and
empty series identically.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>  
<span class="go">1.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.quantile">
<code class="sig-name descname">quantile</code><span class="sig-paren">(</span><em class="sig-param">q=0.5</em>, <em class="sig-param">method='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate quantiles of Series</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q</strong><span class="classifier">list/array of floats, default 0.5 (50%)</span></dt><dd><p>Iterable of numbers ranging from 0 to 1 for the desired quantiles</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘default’, ‘tdigest’, ‘dask’}, optional</span></dt><dd><p>What method to use. By default will use dask’s internal custom
algorithm (<code class="docutils literal notranslate"><span class="pre">'dask'</span></code>).  If set to <code class="docutils literal notranslate"><span class="pre">'tdigest'</span></code> will use tdigest
for floats and ints and fallback to the <code class="docutils literal notranslate"><span class="pre">'dask'</span></code> otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.radd">
<code class="sig-name descname">radd</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.radd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Addition of series and other, element-wise (binary operator <cite>radd</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.radd.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">+</span> <span class="pre">series</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.add" title="dask.dataframe.Series.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.add</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    2.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.random_split">
<code class="sig-name descname">random_split</code><span class="sig-paren">(</span><em class="sig-param">frac</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">shuffle=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.random_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Pseudorandomly split dataframe into different pieces row-wise</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frac</strong><span class="classifier">list</span></dt><dd><p>List of floats that should sum to one.</p>
</dd>
<dt><strong>random_state</strong><span class="classifier">int or np.random.RandomState</span></dt><dd><p>If int create a new RandomState with this as the seed.
Otherwise draw from the passed RandomState.</p>
</dd>
<dt><strong>shuffle</strong><span class="classifier">bool, default False</span></dt><dd><p>If set to True, the dataframe is shuffled (within partition)
before the split.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.DataFrame.sample</span></code></p>
</div>
<p class="rubric">Examples</p>
<p>50/50 split</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">random_split</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>  
</pre></div>
</div>
<p>80/10/10 split, consistent random_state</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">random_split</span><span class="p">([</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.rdiv">
<code class="sig-name descname">rdiv</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.rdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Floating division of series and other, element-wise (binary operator <cite>rtruediv</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.rdiv.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">/</span> <span class="pre">series</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.truediv" title="dask.dataframe.Series.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.truediv</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    1.0</span>
<span class="go">b    inf</span>
<span class="go">c    inf</span>
<span class="go">d    0.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.reduction">
<code class="sig-name descname">reduction</code><span class="sig-paren">(</span><em class="sig-param">chunk</em>, <em class="sig-param">aggregate=None</em>, <em class="sig-param">combine=None</em>, <em class="sig-param">meta='__no_default__'</em>, <em class="sig-param">token=None</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">chunk_kwargs=None</em>, <em class="sig-param">aggregate_kwargs=None</em>, <em class="sig-param">combine_kwargs=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.reduction" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic row-wise reductions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>chunk</strong><span class="classifier">callable</span></dt><dd><p>Function to operate on each partition. Should return a
<code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>, <code class="docutils literal notranslate"><span class="pre">pandas.Series</span></code>, or a scalar.</p>
</dd>
<dt><strong>aggregate</strong><span class="classifier">callable, optional</span></dt><dd><p>Function to operate on the concatenated result of <code class="docutils literal notranslate"><span class="pre">chunk</span></code>. If not
specified, defaults to <code class="docutils literal notranslate"><span class="pre">chunk</span></code>. Used to do the final aggregation
in a tree reduction.</p>
<p>The input to <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> depends on the output of <code class="docutils literal notranslate"><span class="pre">chunk</span></code>.
If the output of <code class="docutils literal notranslate"><span class="pre">chunk</span></code> is a:</p>
<ul class="simple">
<li><p>scalar: Input is a Series, with one row per partition.</p></li>
<li><p>Series: Input is a DataFrame, with one row per partition. Columns
are the rows in the output series.</p></li>
<li><p>DataFrame: Input is a DataFrame, with one row per partition.
Columns are the columns in the output dataframes.</p></li>
</ul>
<p>Should return a <code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>, <code class="docutils literal notranslate"><span class="pre">pandas.Series</span></code>, or a
scalar.</p>
</dd>
<dt><strong>combine</strong><span class="classifier">callable, optional</span></dt><dd><p>Function to operate on intermediate concatenated results of
<code class="docutils literal notranslate"><span class="pre">chunk</span></code> in a tree-reduction. If not provided, defaults to
<code class="docutils literal notranslate"><span class="pre">aggregate</span></code>. The input/output requirements should match that of
<code class="docutils literal notranslate"><span class="pre">aggregate</span></code> described above.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes
and column names of the output. This metadata is necessary for
many algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code>
can be provided (note that the order of the names should match the
order of the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span>
<span class="pre">dtype)</span></code> can be used. If not provided, dask will try to infer the
metadata. This may lead to unexpected results, so providing
<code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For more information, see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
<dt><strong>token</strong><span class="classifier">str, optional</span></dt><dd><p>The name to use for the output keys.</p>
</dd>
<dt><strong>split_every</strong><span class="classifier">int, optional</span></dt><dd><p>Group partitions into groups of this size while performing a
tree-reduction. If set to False, no tree-reduction will be used,
and all intermediates will be concatenated and passed to
<code class="docutils literal notranslate"><span class="pre">aggregate</span></code>. Default is 8.</p>
</dd>
<dt><strong>chunk_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword arguments to pass on to <code class="docutils literal notranslate"><span class="pre">chunk</span></code> only.</p>
</dd>
<dt><strong>aggregate_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword arguments to pass on to <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> only.</p>
</dd>
<dt><strong>combine_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword arguments to pass on to <code class="docutils literal notranslate"><span class="pre">combine</span></code> only.</p>
</dd>
<dt><strong>kwargs :</strong></dt><dd><p>All remaining keywords will be passed to <code class="docutils literal notranslate"><span class="pre">chunk</span></code>, <code class="docutils literal notranslate"><span class="pre">combine</span></code>,
and <code class="docutils literal notranslate"><span class="pre">aggregate</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>Count the number of rows in a DataFrame. To do this, count the number
of rows in each partition, then sum the results:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">reduction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span>
<span class="gp">... </span>                    <span class="n">aggregate</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">x    50</span>
<span class="go">y    50</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Count the number of rows in a Series with elements greater than or
equal to a value (provided via a keyword).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">count_greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">reduction</span><span class="p">(</span><span class="n">count_greater</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
<span class="gp">... </span>                      <span class="n">chunk_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">25</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">25</span>
</pre></div>
</div>
<p>Aggregate both the sum and count of a Series at the same time:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sum_and_count</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span><span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()},</span>
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;sum&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">reduction</span><span class="p">(</span><span class="n">sum_and_count</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">count      50</span>
<span class="go">sum      1225</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Doing the same, but for a DataFrame. Here <code class="docutils literal notranslate"><span class="pre">chunk</span></code> returns a
DataFrame, meaning the input to <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> is a DataFrame with an
index with non-unique entries for both ‘x’ and ‘y’. We groupby the
index, and sum each group to get the final result.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sum_and_count</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()},</span>
<span class="gp">... </span>                        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;sum&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">ddf</span><span class="o">.</span><span class="n">reduction</span><span class="p">(</span><span class="n">sum_and_count</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">aggregate</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">   count   sum</span>
<span class="go">x     50  1225</span>
<span class="go">y     50  3725</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.rename">
<code class="sig-name descname">rename</code><span class="sig-paren">(</span><em class="sig-param">index=None</em>, <em class="sig-param">inplace=False</em>, <em class="sig-param">sorted_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter Series index labels or name</p>
<p>Function / dict values must be unique (1-to-1). Labels not contained in
a dict / Series will be left as-is. Extra labels listed don’t throw an
error.</p>
<p>Alternatively, change <code class="docutils literal notranslate"><span class="pre">Series.name</span></code> with a scalar value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">scalar, hashable sequence, dict-like or callable, optional</span></dt><dd><p>If dict-like or callable, the transformation is applied to the
index. Scalar or hashable sequence-like will alter the
<code class="docutils literal notranslate"><span class="pre">Series.name</span></code> attribute.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">boolean, default False</span></dt><dd><p>Whether to return a new Series or modify this one inplace.</p>
</dd>
<dt><strong>sorted_index</strong><span class="classifier">bool, default False</span></dt><dd><p>If true, the output <code class="docutils literal notranslate"><span class="pre">Series</span></code> will have known divisions inferred
from the input series and the transformation. Ignored for
non-callable/dict-like <code class="docutils literal notranslate"><span class="pre">index</span></code> or when the input series has
unknown divisions. Note that this may only be set to <code class="docutils literal notranslate"><span class="pre">True</span></code> if
you know that the transformed index is monotonicly increasing. Dask
will check that transformed divisions are monotonic, but cannot
check all the values between divisions, so incorrectly setting this
can result in bugs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>renamed</strong><span class="classifier">Series</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.rename.html#pandas.Series.rename" title="(in pandas v1.0.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.Series.rename</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.repartition">
<code class="sig-name descname">repartition</code><span class="sig-paren">(</span><em class="sig-param">divisions=None</em>, <em class="sig-param">npartitions=None</em>, <em class="sig-param">partition_size=None</em>, <em class="sig-param">freq=None</em>, <em class="sig-param">force=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.repartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Repartition dataframe along new divisions</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>divisions</strong><span class="classifier">list, optional</span></dt><dd><p>List of partitions to be used. Only used if npartitions and
partition_size isn’t specified.</p>
</dd>
<dt><strong>npartitions</strong><span class="classifier">int, optional</span></dt><dd><p>Number of partitions of output. Only used if partition_size
isn’t specified.</p>
</dd>
<dt><strong>partition_size: int or string, optional</strong></dt><dd><p>Max number of bytes of memory for each partition. Use numbers or
strings like 5MB. If specified npartitions and divisions will be
ignored.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This keyword argument triggers computation to determine
the memory size of each partition, which may be expensive.</p>
</div>
</dd>
<dt><strong>freq</strong><span class="classifier">str, pd.Timedelta</span></dt><dd><p>A period on which to partition timeseries data like <code class="docutils literal notranslate"><span class="pre">'7D'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'12h'</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Timedelta(hours=12)</span></code>.  Assumes a datetime index.</p>
</dd>
<dt><strong>force</strong><span class="classifier">bool, default False</span></dt><dd><p>Allows the expansion of the existing divisions.
If False then the new divisions lower and upper bounds must be
the same as the old divisions.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Exactly one of <cite>divisions</cite>, <cite>npartitions</cite>, <cite>partition_size</cite>, or <cite>freq</cite>
should be specified. A <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> will be raised when that is
not the case.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">npartitions</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">divisions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="s1">&#39;7d&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">to_replace=None</em>, <em class="sig-param">value=None</em>, <em class="sig-param">regex=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values given in <cite>to_replace</cite> with <cite>value</cite>.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.replace.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Values of the DataFrame are replaced with other values dynamically.
This differs from updating with <code class="docutils literal notranslate"><span class="pre">.loc</span></code> or <code class="docutils literal notranslate"><span class="pre">.iloc</span></code>, which require
you to specify a location to update with some value.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>to_replace</strong><span class="classifier">str, regex, list, dict, Series, int, float, or None</span></dt><dd><p>How to find the values that will be replaced.</p>
<ul>
<li><p>numeric, str or regex:</p>
<blockquote>
<div><ul class="simple">
<li><p>numeric: numeric values equal to <cite>to_replace</cite> will be
replaced with <cite>value</cite></p></li>
<li><p>str: string exactly matching <cite>to_replace</cite> will be replaced
with <cite>value</cite></p></li>
<li><p>regex: regexs matching <cite>to_replace</cite> will be replaced with
<cite>value</cite></p></li>
</ul>
</div></blockquote>
</li>
<li><p>list of str, regex, or numeric:</p>
<blockquote>
<div><ul class="simple">
<li><p>First, if <cite>to_replace</cite> and <cite>value</cite> are both lists, they
<strong>must</strong> be the same length.</p></li>
<li><p>Second, if <code class="docutils literal notranslate"><span class="pre">regex=True</span></code> then all of the strings in <strong>both</strong>
lists will be interpreted as regexs otherwise they will match
directly. This doesn’t matter much for <cite>value</cite> since there
are only a few possible substitution regexes you can use.</p></li>
<li><p>str, regex and numeric rules apply as above.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>dict:</p>
<blockquote>
<div><ul class="simple">
<li><p>Dicts can be used to specify different replacement values
for different existing values. For example,
<code class="docutils literal notranslate"><span class="pre">{'a':</span> <span class="pre">'b',</span> <span class="pre">'y':</span> <span class="pre">'z'}</span></code> replaces the value ‘a’ with ‘b’ and
‘y’ with ‘z’. To use a dict in this way the <cite>value</cite>
parameter should be <cite>None</cite>.</p></li>
<li><p>For a DataFrame a dict can specify that different values
should be replaced in different columns. For example,
<code class="docutils literal notranslate"><span class="pre">{'a':</span> <span class="pre">1,</span> <span class="pre">'b':</span> <span class="pre">'z'}</span></code> looks for the value 1 in column ‘a’
and the value ‘z’ in column ‘b’ and replaces these values
with whatever is specified in <cite>value</cite>. The <cite>value</cite> parameter
should not be <code class="docutils literal notranslate"><span class="pre">None</span></code> in this case. You can treat this as a
special case of passing two lists except that you are
specifying the column to search in.</p></li>
<li><p>For a DataFrame nested dictionaries, e.g.,
<code class="docutils literal notranslate"><span class="pre">{'a':</span> <span class="pre">{'b':</span> <span class="pre">np.nan}}</span></code>, are read as follows: look in column
‘a’ for the value ‘b’ and replace it with NaN. The <cite>value</cite>
parameter should be <code class="docutils literal notranslate"><span class="pre">None</span></code> to use a nested dict in this
way. You can nest regular expressions as well. Note that
column names (the top-level dictionary keys in a nested
dictionary) <strong>cannot</strong> be regular expressions.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>None:</p>
<blockquote>
<div><ul class="simple">
<li><p>This means that the <cite>regex</cite> argument must be a string,
compiled regular expression, or list, dict, ndarray or
Series of such elements. If <cite>value</cite> is also <code class="docutils literal notranslate"><span class="pre">None</span></code> then
this <strong>must</strong> be a nested dictionary or Series.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>See the examples section for examples of each of these.</p>
</dd>
<dt><strong>value</strong><span class="classifier">scalar, dict, list, str, regex, default None</span></dt><dd><p>Value to replace any values matching <cite>to_replace</cite> with.
For a DataFrame a dict of values can be used to specify which
value to use for each column (columns not in the dict will not be
filled). Regular expressions, strings and lists or dicts of such
objects are also allowed.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True, in place. Note: this will modify any
other views on this object (e.g. a column from a DataFrame).
Returns the caller if this is True.</p>
</dd>
<dt><strong>limit</strong><span class="classifier">int, default None  (Not supported in Dask)</span></dt><dd><p>Maximum size gap to forward or backward fill.</p>
</dd>
<dt><strong>regex</strong><span class="classifier">bool or same types as <cite>to_replace</cite>, default False</span></dt><dd><p>Whether to interpret <cite>to_replace</cite> and/or <cite>value</cite> as regular
expressions. If this is <code class="docutils literal notranslate"><span class="pre">True</span></code> then <cite>to_replace</cite> <em>must</em> be a
string. Alternatively, this could be a regular expression or a
list, dict, or array of regular expressions in which case
<cite>to_replace</cite> must be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘pad’, ‘ffill’, ‘bfill’, <cite>None</cite>}  (Not supported in Dask)</span></dt><dd><p>The method to use when for replacement, when <cite>to_replace</cite> is a
scalar, list or tuple and <cite>value</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.23.0: </span>Added to DataFrame.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Object after replacement.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>AssertionError</strong></dt><dd><ul class="simple">
<li><p>If <cite>regex</cite> is not a <code class="docutils literal notranslate"><span class="pre">bool</span></code> and <cite>to_replace</cite> is not
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
</dd>
<dt><strong>TypeError</strong></dt><dd><ul class="simple">
<li><p>If <cite>to_replace</cite> is a <code class="docutils literal notranslate"><span class="pre">dict</span></code> and <cite>value</cite> is not a <code class="docutils literal notranslate"><span class="pre">list</span></code>,
<code class="docutils literal notranslate"><span class="pre">dict</span></code>, <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>, or <code class="docutils literal notranslate"><span class="pre">Series</span></code></p></li>
<li><p>If <cite>to_replace</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code> and <cite>regex</cite> is not compilable
into a regular expression or is a list, dict, ndarray, or
Series.</p></li>
<li><p>When replacing multiple <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">datetime64</span></code> objects and
the arguments to <cite>to_replace</cite> does not match the type of the
value being replaced</p></li>
</ul>
</dd>
<dt><strong>ValueError</strong></dt><dd><ul class="simple">
<li><p>If a <code class="docutils literal notranslate"><span class="pre">list</span></code> or an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> is passed to <cite>to_replace</cite> and
<cite>value</cite> but they are not the same length.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.fillna" title="dask.dataframe.DataFrame.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.fillna</span></code></a></dt><dd><p>Fill NA values.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.where" title="dask.dataframe.DataFrame.where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.where</span></code></a></dt><dd><p>Replace values based on boolean condition.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.str.replace</span></code></dt><dd><p>Simple string replacement.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Regex substitution is performed under the hood with <code class="docutils literal notranslate"><span class="pre">re.sub</span></code>. The
rules for substitution for <code class="docutils literal notranslate"><span class="pre">re.sub</span></code> are the same.</p></li>
<li><p>Regular expressions will only substitute on strings, meaning you
cannot provide, for example, a regular expression matching floating
point numbers and expect the columns in your frame that have a
numeric dtype to be matched. However, if those floating point
numbers <em>are</em> strings, then you can do this.</p></li>
<li><p>This method has <em>a lot</em> of options. You are encouraged to experiment
and play with this method to gain intuition about how it works.</p></li>
<li><p>When dict is used as the <cite>to_replace</cite> value, it is like
key(s) in the dict are the to_replace part and
value(s) in the dict are the value parameter.</p></li>
</ul>
<p class="rubric">Examples</p>
<p><strong>Scalar `to_replace` and `value`</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  
<span class="go">0    5</span>
<span class="go">1    1</span>
<span class="go">2    2</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  
<span class="go">   A  B  C</span>
<span class="go">0  5  5  a</span>
<span class="go">1  1  6  b</span>
<span class="go">2  2  7  c</span>
<span class="go">3  3  8  d</span>
<span class="go">4  4  9  e</span>
</pre></div>
</div>
<p><strong>List-like `to_replace`</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>  
<span class="go">   A  B  C</span>
<span class="go">0  4  5  a</span>
<span class="go">1  4  6  b</span>
<span class="go">2  4  7  c</span>
<span class="go">3  4  8  d</span>
<span class="go">4  4  9  e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  
<span class="go">   A  B  C</span>
<span class="go">0  4  5  a</span>
<span class="go">1  3  6  b</span>
<span class="go">2  2  7  c</span>
<span class="go">3  1  8  d</span>
<span class="go">4  4  9  e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfill&#39;</span><span class="p">)</span>  
<span class="go">0    0</span>
<span class="go">1    3</span>
<span class="go">2    3</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p><strong>dict-like `to_replace`</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">100</span><span class="p">})</span>  
<span class="go">     A  B  C</span>
<span class="go">0   10  5  a</span>
<span class="go">1  100  6  b</span>
<span class="go">2    2  7  c</span>
<span class="go">3    3  8  d</span>
<span class="go">4    4  9  e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="mi">100</span><span class="p">)</span>  
<span class="go">     A    B  C</span>
<span class="go">0  100  100  a</span>
<span class="go">1    1    6  b</span>
<span class="go">2    2    7  c</span>
<span class="go">3    3    8  d</span>
<span class="go">4    4    9  e</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">400</span><span class="p">}})</span>  
<span class="go">     A  B  C</span>
<span class="go">0  100  5  a</span>
<span class="go">1    1  6  b</span>
<span class="go">2    2  7  c</span>
<span class="go">3    3  8  d</span>
<span class="go">4  400  9  e</span>
</pre></div>
</div>
<p><strong>Regular expression `to_replace`</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;bat&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bait&#39;</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;xyz&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;^ba.$&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;new&#39;</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">      A    B</span>
<span class="go">0   new  abc</span>
<span class="go">1   foo  new</span>
<span class="go">2  bait  xyz</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="sa">r</span><span class="s1">&#39;^ba.$&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="s1">&#39;new&#39;</span><span class="p">},</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">      A    B</span>
<span class="go">0   new  abc</span>
<span class="go">1   foo  bar</span>
<span class="go">2  bait  xyz</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">regex</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;^ba.$&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;new&#39;</span><span class="p">)</span>  
<span class="go">      A    B</span>
<span class="go">0   new  abc</span>
<span class="go">1   foo  new</span>
<span class="go">2  bait  xyz</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">regex</span><span class="o">=</span><span class="p">{</span><span class="sa">r</span><span class="s1">&#39;^ba.$&#39;</span><span class="p">:</span> <span class="s1">&#39;new&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="s1">&#39;xyz&#39;</span><span class="p">})</span>  
<span class="go">      A    B</span>
<span class="go">0   new  abc</span>
<span class="go">1   xyz  new</span>
<span class="go">2  bait  xyz</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">regex</span><span class="o">=</span><span class="p">[</span><span class="sa">r</span><span class="s1">&#39;^ba.$&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">],</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;new&#39;</span><span class="p">)</span>  
<span class="go">      A    B</span>
<span class="go">0   new  abc</span>
<span class="go">1   new  new</span>
<span class="go">2  bait  xyz</span>
</pre></div>
</div>
<p>Note that when replacing multiple <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">datetime64</span></code> objects,
the data types in the <cite>to_replace</cite> parameter must match the data
type of the value being replaced:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s1">&#39;a string&#39;</span><span class="p">:</span> <span class="s1">&#39;new value&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>  <span class="c1"># raises  </span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TypeError</span>: <span class="n">Cannot compare types &#39;ndarray(dtype=bool)&#39; and &#39;str&#39;</span>
</pre></div>
</div>
<p>This raises a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> because one of the <code class="docutils literal notranslate"><span class="pre">dict</span></code> keys is not of
the correct type for replacement.</p>
<p>Compare the behavior of <code class="docutils literal notranslate"><span class="pre">s.replace({'a':</span> <span class="pre">None})</span></code> and
<code class="docutils literal notranslate"><span class="pre">s.replace('a',</span> <span class="pre">None)</span></code> to understand the peculiarities
of the <cite>to_replace</cite> parameter:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>  
</pre></div>
</div>
<p>When one uses a dict as the <cite>to_replace</cite> value, it is like the
value(s) in the dict are equal to the <cite>value</cite> parameter.
<code class="docutils literal notranslate"><span class="pre">s.replace({'a':</span> <span class="pre">None})</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">s.replace(to_replace={'a':</span> <span class="pre">None},</span> <span class="pre">value=None,</span> <span class="pre">method=None)</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>  
<span class="go">0      10</span>
<span class="go">1    None</span>
<span class="go">2    None</span>
<span class="go">3       b</span>
<span class="go">4    None</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">value=None</span></code> and <cite>to_replace</cite> is a scalar, list or
tuple, <cite>replace</cite> uses the method parameter (default ‘pad’) to do the
replacement. So this is why the ‘a’ values are being replaced by 10
in rows 1 and 2 and ‘b’ in row 4 in this case.
The command <code class="docutils literal notranslate"><span class="pre">s.replace('a',</span> <span class="pre">None)</span></code> is actually equivalent to
<code class="docutils literal notranslate"><span class="pre">s.replace(to_replace='a',</span> <span class="pre">value=None,</span> <span class="pre">method='pad')</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  
<span class="go">0    10</span>
<span class="go">1    10</span>
<span class="go">2    10</span>
<span class="go">3     b</span>
<span class="go">4     b</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.resample">
<code class="sig-name descname">resample</code><span class="sig-paren">(</span><em class="sig-param">rule</em>, <em class="sig-param">closed=None</em>, <em class="sig-param">label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample time-series data.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.resample.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Convenience method for frequency conversion and resampling of time
series. Object must have a datetime-like index (<cite>DatetimeIndex</cite>,
<cite>PeriodIndex</cite>, or <cite>TimedeltaIndex</cite>), or pass datetime-like values
to the <cite>on</cite> or <cite>level</cite> keyword.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rule</strong><span class="classifier">DateOffset, Timedelta or str</span></dt><dd><p>The offset string or object representing target conversion.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0  (Not supported in Dask)</span></dt><dd><p>Which axis to use for up- or down-sampling. For <cite>Series</cite> this
will default to 0, i.e. along the rows. Must be
<cite>DatetimeIndex</cite>, <cite>TimedeltaIndex</cite> or <cite>PeriodIndex</cite>.</p>
</dd>
<dt><strong>closed</strong><span class="classifier">{‘right’, ‘left’}, default None</span></dt><dd><p>Which side of bin interval is closed. The default is ‘left’
for all frequency offsets except for ‘M’, ‘A’, ‘Q’, ‘BM’,
‘BA’, ‘BQ’, and ‘W’ which all have a default of ‘right’.</p>
</dd>
<dt><strong>label</strong><span class="classifier">{‘right’, ‘left’}, default None</span></dt><dd><p>Which bin edge label to label bucket with. The default is ‘left’
for all frequency offsets except for ‘M’, ‘A’, ‘Q’, ‘BM’,
‘BA’, ‘BQ’, and ‘W’ which all have a default of ‘right’.</p>
</dd>
<dt><strong>convention</strong><span class="classifier">{‘start’, ‘end’, ‘s’, ‘e’}, default ‘start’  (Not supported in Dask)</span></dt><dd><p>For <cite>PeriodIndex</cite> only, controls whether to use the start or
end of <cite>rule</cite>.</p>
</dd>
<dt><strong>kind</strong><span class="classifier">{‘timestamp’, ‘period’}, optional, default None  (Not supported in Dask)</span></dt><dd><p>Pass ‘timestamp’ to convert the resulting index to a
<cite>DateTimeIndex</cite> or ‘period’ to convert it to a <cite>PeriodIndex</cite>.
By default the input representation is retained.</p>
</dd>
<dt><strong>loffset</strong><span class="classifier">timedelta, default None  (Not supported in Dask)</span></dt><dd><p>Adjust the resampled time labels.</p>
</dd>
<dt><strong>base</strong><span class="classifier">int, default 0  (Not supported in Dask)</span></dt><dd><p>For frequencies that evenly subdivide 1 day, the “origin” of the
aggregated intervals. For example, for ‘5min’ frequency, base could
range from 0 through 4. Defaults to 0.</p>
</dd>
<dt><strong>on</strong><span class="classifier">str, optional  (Not supported in Dask)</span></dt><dd><p>For a DataFrame, column to use instead of index for resampling.
Column must be datetime-like.</p>
</dd>
<dt><strong>level</strong><span class="classifier">str or int, optional  (Not supported in Dask)</span></dt><dd><p>For a MultiIndex, level (name or number) to use for
resampling. <cite>level</cite> must be datetime-like.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Resampler object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.groupby" title="dask.dataframe.Series.groupby"><code class="xref py py-obj docutils literal notranslate"><span class="pre">groupby</span></code></a></dt><dd><p>Group by mapping, function, label, or list of labels.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.resample" title="dask.dataframe.Series.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.resample</span></code></a></dt><dd><p>Resample a Series.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.resample" title="dask.dataframe.DataFrame.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.resample</span></code></a></dt><dd><p>Resample a DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>See the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#resampling">user guide</a>
for more.</p>
<p>To learn more about the offset strings, please see <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects">this link</a>.</p>
<p class="rubric">Examples</p>
<p>Start by creating a series with 9 one minute timestamps.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;1/1/2000&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">series</span>  
<span class="go">2000-01-01 00:00:00    0</span>
<span class="go">2000-01-01 00:01:00    1</span>
<span class="go">2000-01-01 00:02:00    2</span>
<span class="go">2000-01-01 00:03:00    3</span>
<span class="go">2000-01-01 00:04:00    4</span>
<span class="go">2000-01-01 00:05:00    5</span>
<span class="go">2000-01-01 00:06:00    6</span>
<span class="go">2000-01-01 00:07:00    7</span>
<span class="go">2000-01-01 00:08:00    8</span>
<span class="go">Freq: T, dtype: int64</span>
</pre></div>
</div>
<p>Downsample the series into 3 minute bins and sum the values
of the timestamps falling into a bin.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;3T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  
<span class="go">2000-01-01 00:00:00     3</span>
<span class="go">2000-01-01 00:03:00    12</span>
<span class="go">2000-01-01 00:06:00    21</span>
<span class="go">Freq: 3T, dtype: int64</span>
</pre></div>
</div>
<p>Downsample the series into 3 minute bins as above, but label each
bin using the right edge instead of the left. Please note that the
value in the bucket used as the label is not included in the bucket,
which it labels. For example, in the original series the
bucket <code class="docutils literal notranslate"><span class="pre">2000-01-01</span> <span class="pre">00:03:00</span></code> contains the value 3, but the summed
value in the resampled bucket with the label <code class="docutils literal notranslate"><span class="pre">2000-01-01</span> <span class="pre">00:03:00</span></code>
does not include 3 (if it did, the summed value would be 6, not 3).
To include this value close the right side of the bin interval as
illustrated in the example below this one.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;3T&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  
<span class="go">2000-01-01 00:03:00     3</span>
<span class="go">2000-01-01 00:06:00    12</span>
<span class="go">2000-01-01 00:09:00    21</span>
<span class="go">Freq: 3T, dtype: int64</span>
</pre></div>
</div>
<p>Downsample the series into 3 minute bins as above, but close the right
side of the bin interval.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;3T&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  
<span class="go">2000-01-01 00:00:00     0</span>
<span class="go">2000-01-01 00:03:00     6</span>
<span class="go">2000-01-01 00:06:00    15</span>
<span class="go">2000-01-01 00:09:00    15</span>
<span class="go">Freq: 3T, dtype: int64</span>
</pre></div>
</div>
<p>Upsample the series into 30 second bins.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;30S&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">asfreq</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>   <span class="c1"># Select first 5 rows  </span>
<span class="go">2000-01-01 00:00:00   0.0</span>
<span class="go">2000-01-01 00:00:30   NaN</span>
<span class="go">2000-01-01 00:01:00   1.0</span>
<span class="go">2000-01-01 00:01:30   NaN</span>
<span class="go">2000-01-01 00:02:00   2.0</span>
<span class="go">Freq: 30S, dtype: float64</span>
</pre></div>
</div>
<p>Upsample the series into 30 second bins and fill the <code class="docutils literal notranslate"><span class="pre">NaN</span></code>
values using the <code class="docutils literal notranslate"><span class="pre">pad</span></code> method.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;30S&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">pad</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>  
<span class="go">2000-01-01 00:00:00    0</span>
<span class="go">2000-01-01 00:00:30    0</span>
<span class="go">2000-01-01 00:01:00    1</span>
<span class="go">2000-01-01 00:01:30    1</span>
<span class="go">2000-01-01 00:02:00    2</span>
<span class="go">Freq: 30S, dtype: int64</span>
</pre></div>
</div>
<p>Upsample the series into 30 second bins and fill the
<code class="docutils literal notranslate"><span class="pre">NaN</span></code> values using the <code class="docutils literal notranslate"><span class="pre">bfill</span></code> method.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;30S&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bfill</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>  
<span class="go">2000-01-01 00:00:00    0</span>
<span class="go">2000-01-01 00:00:30    1</span>
<span class="go">2000-01-01 00:01:00    1</span>
<span class="go">2000-01-01 00:01:30    2</span>
<span class="go">2000-01-01 00:02:00    2</span>
<span class="go">Freq: 30S, dtype: int64</span>
</pre></div>
</div>
<p>Pass a custom function via <code class="docutils literal notranslate"><span class="pre">apply</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">custom_resampler</span><span class="p">(</span><span class="n">array_like</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">array_like</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;3T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">custom_resampler</span><span class="p">)</span>  
<span class="go">2000-01-01 00:00:00     8</span>
<span class="go">2000-01-01 00:03:00    17</span>
<span class="go">2000-01-01 00:06:00    26</span>
<span class="go">Freq: 3T, dtype: int64</span>
</pre></div>
</div>
<p>For a Series with a PeriodIndex, the keyword <cite>convention</cite> can be
used to control whether to use the start or end of <cite>rule</cite>.</p>
<p>Resample a year by quarter using ‘start’ <cite>convention</cite>. Values are
assigned to the first quarter of the period.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="s1">&#39;2012-01-01&#39;</span><span class="p">,</span>  
<span class="gp">... </span>                                            <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                            <span class="n">periods</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">2012    1</span>
<span class="go">2013    2</span>
<span class="go">Freq: A-DEC, dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="n">convention</span><span class="o">=</span><span class="s1">&#39;start&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">asfreq</span><span class="p">()</span>  
<span class="go">2012Q1    1.0</span>
<span class="go">2012Q2    NaN</span>
<span class="go">2012Q3    NaN</span>
<span class="go">2012Q4    NaN</span>
<span class="go">2013Q1    2.0</span>
<span class="go">2013Q2    NaN</span>
<span class="go">2013Q3    NaN</span>
<span class="go">2013Q4    NaN</span>
<span class="go">Freq: Q-DEC, dtype: float64</span>
</pre></div>
</div>
<p>Resample quarters by month using ‘end’ <cite>convention</cite>. Values are
assigned to the last month of the period.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="s1">&#39;2018-01-01&#39;</span><span class="p">,</span>  
<span class="gp">... </span>                                                  <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                                  <span class="n">periods</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span>  
<span class="go">2018Q1    1</span>
<span class="go">2018Q2    2</span>
<span class="go">2018Q3    3</span>
<span class="go">2018Q4    4</span>
<span class="go">Freq: Q-DEC, dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">convention</span><span class="o">=</span><span class="s1">&#39;end&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">asfreq</span><span class="p">()</span>  
<span class="go">2018-03    1.0</span>
<span class="go">2018-04    NaN</span>
<span class="go">2018-05    NaN</span>
<span class="go">2018-06    2.0</span>
<span class="go">2018-07    NaN</span>
<span class="go">2018-08    NaN</span>
<span class="go">2018-09    3.0</span>
<span class="go">2018-10    NaN</span>
<span class="go">2018-11    NaN</span>
<span class="go">2018-12    4.0</span>
<span class="go">Freq: M, dtype: float64</span>
</pre></div>
</div>
<p>For DataFrame objects, the keyword <cite>on</cite> can be used to specify the
column instead of the index for resampling.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">],</span>  
<span class="gp">... </span>          <span class="s1">&#39;volume&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;week_starting&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;01/01/2018&#39;</span><span class="p">,</span>  
<span class="gp">... </span>                                    <span class="n">periods</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   price  volume week_starting</span>
<span class="go">0     10      50    2018-01-07</span>
<span class="go">1     11      60    2018-01-14</span>
<span class="go">2      9      40    2018-01-21</span>
<span class="go">3     13     100    2018-01-28</span>
<span class="go">4     14      50    2018-02-04</span>
<span class="go">5     18     100    2018-02-11</span>
<span class="go">6     17      40    2018-02-18</span>
<span class="go">7     19      50    2018-02-25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;week_starting&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">               price  volume</span>
<span class="go">week_starting</span>
<span class="go">2018-01-31     10.75    62.5</span>
<span class="go">2018-02-28     17.00    60.0</span>
</pre></div>
</div>
<p>For a DataFrame with MultiIndex, the keyword <cite>level</cite> can be used to
specify on which level the resampling needs to take place.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">days</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;1/1/2000&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">d2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">],</span>  
<span class="gp">... </span>           <span class="s1">&#39;volume&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span>  
<span class="gp">... </span>                   <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">days</span><span class="p">,</span>
<span class="gp">... </span>                                                    <span class="p">[</span><span class="s1">&#39;morning&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="s1">&#39;afternoon&#39;</span><span class="p">]]</span>
<span class="gp">... </span>                                                    <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span>  
<span class="go">                      price  volume</span>
<span class="go">2000-01-01 morning       10      50</span>
<span class="go">           afternoon     11      60</span>
<span class="go">2000-01-02 morning        9      40</span>
<span class="go">           afternoon     13     100</span>
<span class="go">2000-01-03 morning       14      50</span>
<span class="go">           afternoon     18     100</span>
<span class="go">2000-01-04 morning       17      40</span>
<span class="go">           afternoon     19      50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  
<span class="go">            price  volume</span>
<span class="go">2000-01-01     21     110</span>
<span class="go">2000-01-02     22     140</span>
<span class="go">2000-01-03     32     150</span>
<span class="go">2000-01-04     36      90</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.reset_index">
<code class="sig-name descname">reset_index</code><span class="sig-paren">(</span><em class="sig-param">drop=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.reset_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the index to the default index.</p>
<p>Note that unlike in <code class="docutils literal notranslate"><span class="pre">pandas</span></code>, the reset <code class="docutils literal notranslate"><span class="pre">dask.dataframe</span></code> index will
not be monotonically increasing from 0. Instead, it will restart at 0
for each partition (e.g. <code class="docutils literal notranslate"><span class="pre">index1</span> <span class="pre">=</span> <span class="pre">[0,</span> <span class="pre">...,</span> <span class="pre">10],</span> <span class="pre">index2</span> <span class="pre">=</span> <span class="pre">[0,</span> <span class="pre">...]</span></code>).
This is due to the inability to statically know the full length of the
index.</p>
<p>For DataFrame with multi-level index, returns a new DataFrame with
labeling information in the columns under the index names, defaulting
to ‘level_0’, ‘level_1’, etc. if any are None. For a standard index,
the index name will be used (if set), otherwise a default ‘index’ or
‘level_0’ (if ‘index’ is already taken) will be used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>drop</strong><span class="classifier">boolean, default False</span></dt><dd><p>Do not try to insert index into dataframe columns.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.rfloordiv">
<code class="sig-name descname">rfloordiv</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.rfloordiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Integer division of series and other, element-wise (binary operator <cite>rfloordiv</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.rfloordiv.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">//</span> <span class="pre">series</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.floordiv" title="dask.dataframe.Series.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.floordiv</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">floordiv</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">c    NaN</span>
<span class="go">d    0.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.rmod">
<code class="sig-name descname">rmod</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.rmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Modulo of series and other, element-wise (binary operator <cite>rmod</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.rmod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">%</span> <span class="pre">series</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.mod" title="dask.dataframe.Series.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.mod</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    0.0</span>
<span class="go">b    NaN</span>
<span class="go">c    NaN</span>
<span class="go">d    0.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.rmul">
<code class="sig-name descname">rmul</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.rmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Multiplication of series and other, element-wise (binary operator <cite>rmul</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.rmul.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">*</span> <span class="pre">series</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.mul" title="dask.dataframe.Series.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.mul</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    1.0</span>
<span class="go">b    0.0</span>
<span class="go">c    0.0</span>
<span class="go">d    0.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.rolling">
<code class="sig-name descname">rolling</code><span class="sig-paren">(</span><em class="sig-param">window</em>, <em class="sig-param">min_periods=None</em>, <em class="sig-param">center=False</em>, <em class="sig-param">win_type=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.rolling" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides rolling transformations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>window</strong><span class="classifier">int, str, offset</span></dt><dd><p>Size of the moving window. This is the number of observations used
for calculating the statistic. When not using a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>,
the window size must not be so large as to span more than one
adjacent partition. If using an offset or offset alias like ‘5D’,
the data must have a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code></p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.15.0: </span>Now accepts offsets and string offset aliases</p>
</div>
</dd>
<dt><strong>min_periods</strong><span class="classifier">int, default None</span></dt><dd><p>Minimum number of observations in window required to have a value
(otherwise result is NA).</p>
</dd>
<dt><strong>center</strong><span class="classifier">boolean, default False</span></dt><dd><p>Set the labels at the center of the window.</p>
</dd>
<dt><strong>win_type</strong><span class="classifier">string, default None</span></dt><dd><p>Provide a window type. The recognized window types are identical
to pandas.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, default 0</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a Rolling object on which to call a method to compute a statistic</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.round">
<code class="sig-name descname">round</code><span class="sig-paren">(</span><em class="sig-param">decimals=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Round each value in a Series to the given number of decimals.</p>
<p>This docstring was copied from pandas.core.series.Series.round.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>decimals</strong><span class="classifier">int, default 0</span></dt><dd><p>Number of decimal places to round to. If decimals is negative,
it specifies the number of positions to the left of the decimal point.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Rounded values of the Series.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.around.html#numpy.around" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.around</span></code></a></dt><dd><p>Round values of an np.array.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.round" title="dask.dataframe.DataFrame.round"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.round</span></code></a></dt><dd><p>Round values of a DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">2.7</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>  
<span class="go">0    0.0</span>
<span class="go">1    1.0</span>
<span class="go">2    3.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.rpow">
<code class="sig-name descname">rpow</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.rpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Exponential power of series and other, element-wise (binary operator <cite>rpow</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.rpow.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">**</span> <span class="pre">series</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.pow" title="dask.dataframe.Series.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.pow</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    0.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.rsub">
<code class="sig-name descname">rsub</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.rsub" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Subtraction of series and other, element-wise (binary operator <cite>rsub</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.rsub.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">-</span> <span class="pre">series</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.sub" title="dask.dataframe.Series.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.sub</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    0.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d   -1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.rtruediv">
<code class="sig-name descname">rtruediv</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.rtruediv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Floating division of series and other, element-wise (binary operator <cite>rtruediv</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.rtruediv.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">/</span> <span class="pre">series</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.truediv" title="dask.dataframe.Series.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.truediv</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    1.0</span>
<span class="go">b    inf</span>
<span class="go">c    inf</span>
<span class="go">d    0.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">n=None</em>, <em class="sig-param">frac=None</em>, <em class="sig-param">replace=False</em>, <em class="sig-param">random_state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Random sample of items</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>Number of items to return is not supported by dask. Use frac
instead.</p>
</dd>
<dt><strong>frac</strong><span class="classifier">float, optional</span></dt><dd><p>Fraction of axis items to return.</p>
</dd>
<dt><strong>replace</strong><span class="classifier">boolean, optional</span></dt><dd><p>Sample with or without replacement. Default = False.</p>
</dd>
<dt><strong>random_state</strong><span class="classifier">int or <code class="docutils literal notranslate"><span class="pre">np.random.RandomState</span></code></span></dt><dd><p>If int we create a new RandomState with this as the seed
Otherwise we draw from the passed RandomState</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.DataFrame.random_split" title="dask.dataframe.DataFrame.random_split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.random_split</span></code></a>, <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sample.html#pandas.DataFrame.sample" title="(in pandas v1.0.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame.sample</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.sem">
<code class="sig-name descname">sem</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=None</em>, <em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.sem" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unbiased standard error of the mean over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.sem.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Normalized by N-1 by default. This can be changed using the ddof argument</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd></dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, default 1</span></dt><dd><p>Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
where N represents the number of elements.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#dask.dataframe.Series.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple representing the dimensionality of a Series.</p>
<p>The single element of the tuple is a Delayed result.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">shape</span>  
<span class="go"># (dd.Scalar&lt;size-ag..., dtype=int64&gt;,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.shift">
<code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">periods=1</em>, <em class="sig-param">freq=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift index by desired number of periods with an optional time <cite>freq</cite>.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.shift.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>When <cite>freq</cite> is not passed, shift the index without realigning the data.
If <cite>freq</cite> is passed (in this case, the index must be date or datetime,
or it will raise a <cite>NotImplementedError</cite>), the index will be
increased using the periods and the <cite>freq</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>periods</strong><span class="classifier">int</span></dt><dd><p>Number of periods to shift. Can be positive or negative.</p>
</dd>
<dt><strong>freq</strong><span class="classifier">DateOffset, tseries.offsets, timedelta, or str, optional</span></dt><dd><p>Offset to use from the tseries module or time rule (e.g. ‘EOM’).
If <cite>freq</cite> is specified then the index values are shifted but the
data is not realigned. That is, use <cite>freq</cite> if you would like to
extend the index when shifting and preserve the original data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’, None}, default None</span></dt><dd><p>Shift direction.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">object, optional  (Not supported in Dask)</span></dt><dd><p>The scalar value to use for newly introduced missing values.
the default depends on the dtype of <cite>self</cite>.
For numeric data, <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> is used.
For datetime, timedelta, or period data, etc. <code class="xref py py-attr docutils literal notranslate"><span class="pre">NaT</span></code> is used.
For extension dtypes, <code class="docutils literal notranslate"><span class="pre">self.dtype.na_value</span></code> is used.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.24.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Copy of input object, shifted.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Index.shift</span></code></dt><dd><p>Shift values of Index.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DatetimeIndex.shift</span></code></dt><dd><p>Shift values of DatetimeIndex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">PeriodIndex.shift</span></code></dt><dd><p>Shift values of PeriodIndex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">tshift</span></code></dt><dd><p>Shift the time index, using the index’s frequency if available.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Col1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;Col2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">48</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;Col3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">52</span><span class="p">]})</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  
<span class="go">   Col1  Col2  Col3</span>
<span class="go">0   NaN   NaN   NaN</span>
<span class="go">1   NaN   NaN   NaN</span>
<span class="go">2   NaN   NaN   NaN</span>
<span class="go">3  10.0  13.0  17.0</span>
<span class="go">4  20.0  23.0  27.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">   Col1  Col2  Col3</span>
<span class="go">0   NaN  10.0  13.0</span>
<span class="go">1   NaN  20.0  23.0</span>
<span class="go">2   NaN  15.0  18.0</span>
<span class="go">3   NaN  30.0  33.0</span>
<span class="go">4   NaN  45.0  48.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">   Col1  Col2  Col3</span>
<span class="go">0     0     0     0</span>
<span class="go">1     0     0     0</span>
<span class="go">2     0     0     0</span>
<span class="go">3    10    13    17</span>
<span class="go">4    20    23    27</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.size">
<em class="property">property </em><code class="sig-name descname">size</code><a class="headerlink" href="#dask.dataframe.Series.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the Series or DataFrame as a Delayed object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">series</span><span class="o">.</span><span class="n">size</span>  
<span class="go">dd.Scalar&lt;size-ag..., dtype=int64&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.squeeze">
<code class="sig-name descname">squeeze</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Squeeze 1 dimensional axis objects into scalars.</p>
<p>This docstring was copied from pandas.core.series.Series.squeeze.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Series or DataFrames with a single element are squeezed to a scalar.
DataFrames with a single column or a single row are squeezed to a
Series. Otherwise the object is unchanged.</p>
<p>This method is most useful when you don’t know if your
object is a Series or DataFrame, but you do know it has just a single
column. In that case you can safely call <cite>squeeze</cite> to ensure you have a
Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’, None}, default None  (Not supported in Dask)</span></dt><dd><p>A specific axis to squeeze. By default, all length-1 axes are
squeezed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame, Series, or scalar</strong></dt><dd><p>The projection after squeezing <cite>axis</cite> or all the axes.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.iloc</span></code></dt><dd><p>Integer-location based indexing for selecting scalars.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.iloc" title="dask.dataframe.DataFrame.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.iloc</span></code></a></dt><dd><p>Integer-location based indexing for selecting Series.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.to_frame" title="dask.dataframe.Series.to_frame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.to_frame</span></code></a></dt><dd><p>Inverse of DataFrame.squeeze for a single-column DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">primes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>  
</pre></div>
</div>
<p>Slicing might produce a Series with a single value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">even_primes</span> <span class="o">=</span> <span class="n">primes</span><span class="p">[</span><span class="n">primes</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">even_primes</span>  
<span class="go">0    2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">even_primes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>  
<span class="go">2</span>
</pre></div>
</div>
<p>Squeezing objects with more than one value in every axis does nothing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">odd_primes</span> <span class="o">=</span> <span class="n">primes</span><span class="p">[</span><span class="n">primes</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">odd_primes</span>  
<span class="go">1    3</span>
<span class="go">2    5</span>
<span class="go">3    7</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">odd_primes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>  
<span class="go">1    3</span>
<span class="go">2    5</span>
<span class="go">3    7</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Squeezing is even more effective when used with DataFrames.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   a  b</span>
<span class="go">0  1  2</span>
<span class="go">1  3  4</span>
</pre></div>
</div>
<p>Slicing a single column will produce a DataFrame with the columns
having only one value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">]]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span>  
<span class="go">   a</span>
<span class="go">0  1</span>
<span class="go">1  3</span>
</pre></div>
</div>
<p>So the columns can be squeezed down, resulting in a Series:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>  
<span class="go">0    1</span>
<span class="go">1    3</span>
<span class="go">Name: a, dtype: int64</span>
</pre></div>
</div>
<p>Slicing a single row from a single column will produce a single
scalar DataFrame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_0a</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_0a</span>  
<span class="go">   a</span>
<span class="go">0  1</span>
</pre></div>
</div>
<p>Squeezing the rows produces a single scalar Series:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_0a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s1">&#39;rows&#39;</span><span class="p">)</span>  
<span class="go">a    1</span>
<span class="go">Name: 0, dtype: int64</span>
</pre></div>
</div>
<p>Squeezing all axes will project directly into a scalar:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df_0a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>  
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sample standard deviation over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.std.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Normalized by N-1 by default. This can be changed using the ddof argument</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd></dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, default 1</span></dt><dd><p>Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
where N represents the number of elements.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dask.dataframe.Series.str">
<code class="sig-name descname">str</code><a class="headerlink" href="#dask.dataframe.Series.str" title="Permalink to this definition">¶</a></dt>
<dd><p>Namespace for string methods</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.sub">
<code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Subtraction of series and other, element-wise (binary operator <cite>sub</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.sub.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">-</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.rsub" title="dask.dataframe.Series.rsub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.rsub</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    0.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d   -1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">min_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of the values for the requested axis.</p>
<blockquote>
<div><p>This docstring was copied from pandas.core.frame.DataFrame.sum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This is equivalent to the method <code class="docutils literal notranslate"><span class="pre">numpy.sum</span></code>.</p>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd><p>Axis for the function to be applied on.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
<dt><strong>min_count</strong><span class="classifier">int, default 0</span></dt><dd><p>The required number of valid values to perform the operation. If fewer than
<code class="docutils literal notranslate"><span class="pre">min_count</span></code> non-NA values are present the result will be NA.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.22.0: </span>Added with the default being 0. This means the sum of an all-NA
or empty Series is 0, and the product of an all-NA or empty
Series is 1.</p>
</div>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to be passed to the function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.sum" title="dask.dataframe.Series.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.sum</span></code></a></dt><dd><p>Return the sum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.min" title="dask.dataframe.Series.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.min</span></code></a></dt><dd><p>Return the minimum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.max" title="dask.dataframe.Series.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.max</span></code></a></dt><dd><p>Return the maximum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.idxmin" title="dask.dataframe.Series.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmin</span></code></a></dt><dd><p>Return the index of the minimum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.Series.idxmax" title="dask.dataframe.Series.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmax</span></code></a></dt><dd><p>Return the index of the maximum.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.sum" title="dask.dataframe.DataFrame.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.sum</span></code></a></dt><dd><p>Return the sum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.min" title="dask.dataframe.DataFrame.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.min</span></code></a></dt><dd><p>Return the minimum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.max" title="dask.dataframe.DataFrame.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.max</span></code></a></dt><dd><p>Return the maximum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.idxmin" title="dask.dataframe.DataFrame.idxmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.idxmin</span></code></a></dt><dd><p>Return the index of the minimum over the requested axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.idxmax" title="dask.dataframe.DataFrame.idxmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.idxmax</span></code></a></dt><dd><p>Return the index of the maximum over the requested axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">([</span>  
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;warm&#39;</span><span class="p">,</span> <span class="s1">&#39;warm&#39;</span><span class="p">,</span> <span class="s1">&#39;cold&#39;</span><span class="p">,</span> <span class="s1">&#39;cold&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="s1">&#39;falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;spider&#39;</span><span class="p">]],</span>
<span class="gp">... </span>    <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;blooded&#39;</span><span class="p">,</span> <span class="s1">&#39;animal&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;legs&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">blooded  animal</span>
<span class="go">warm     dog       4</span>
<span class="go">         falcon    2</span>
<span class="go">cold     fish      0</span>
<span class="go">         spider    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  
<span class="go">14</span>
</pre></div>
</div>
<p>Sum using level names, as well as indices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;blooded&#39;</span><span class="p">)</span>  
<span class="go">blooded</span>
<span class="go">warm    6</span>
<span class="go">cold    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">blooded</span>
<span class="go">warm    6</span>
<span class="go">cold    8</span>
<span class="go">Name: legs, dtype: int64</span>
</pre></div>
</div>
<p>By default, the sum of an empty or all-NA Series is <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># min_count=0 is the default  </span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>This can be controlled with the <code class="docutils literal notranslate"><span class="pre">min_count</span></code> parameter. For example, if
you’d like the sum of an empty series to be NaN, pass <code class="docutils literal notranslate"><span class="pre">min_count=1</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">nan</span>
</pre></div>
</div>
<p>Thanks to the <code class="docutils literal notranslate"><span class="pre">skipna</span></code> parameter, <code class="docutils literal notranslate"><span class="pre">min_count</span></code> handles all-NA and
empty series identically.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  
<span class="go">0.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.tail">
<code class="sig-name descname">tail</code><span class="sig-paren">(</span><em class="sig-param">n=5</em>, <em class="sig-param">compute=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Last n rows of the dataset</p>
<p>Caveat, the only checks the last n rows of the last partition.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.to_bag">
<code class="sig-name descname">to_bag</code><span class="sig-paren">(</span><em class="sig-param">index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.to_bag" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Dask Bag from a Series</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.to_csv">
<code class="sig-name descname">to_csv</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.to_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Store Dask DataFrame to CSV files</p>
<p>One filename per partition will be created. You can specify the
filenames in a variety of ways.</p>
<p>Use a globstring:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;/path/to/data/export-*.csv&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>The * will be replaced by the increasing sequence 0, 1, 2, …</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">export</span><span class="o">-</span><span class="mf">0.</span><span class="n">csv</span>
<span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">export</span><span class="o">-</span><span class="mf">1.</span><span class="n">csv</span>
</pre></div>
</div>
<p>Use a globstring and a <code class="docutils literal notranslate"><span class="pre">name_function=</span></code> keyword argument.  The
name_function function should expect an integer and produce a string.
Strings produced by name_function must preserve the order of their
respective partition indices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">date</span><span class="p">(</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;2015-01-01&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="go">&#39;2015-01-16&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;/path/to/data/export-*.csv&#39;</span><span class="p">,</span> <span class="n">name_function</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>  
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">export</span><span class="o">-</span><span class="mi">2015</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mf">01.</span><span class="n">csv</span>
<span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">export</span><span class="o">-</span><span class="mi">2015</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mf">02.</span><span class="n">csv</span>
<span class="o">...</span>
</pre></div>
</div>
<p>You can also provide an explicit list of paths:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;/path/to/data/alice.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;/path/to/data/bob.csv&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> 
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">string</span></dt><dd><p>Path glob indicating the naming scheme for the output files</p>
</dd>
<dt><strong>name_function</strong><span class="classifier">callable, default None</span></dt><dd><p>Function accepting an integer (partition index) and producing a
string to replace the asterisk in the given filename globstring.
Should preserve the lexicographic order of partitions. Not
supported when <cite>single_file</cite> is <cite>True</cite>.</p>
</dd>
<dt><strong>single_file</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether to save everything into a single CSV file. Under the
single file mode, each partition is appended at the end of the
specified CSV file. Note that not all filesystems support the
append mode and thus the single file mode, especially on cloud
storage systems such as S3 or GCS. A warning will be issued when
writing to a file that is not backed by a local filesystem.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">string or None</span></dt><dd><p>String like ‘gzip’ or ‘xz’.  Must support efficient random access.
Filenames with extensions corresponding to known compression
algorithms (gz, bz2) will be compressed accordingly automatically</p>
</dd>
<dt><strong>sep</strong><span class="classifier">character, default ‘,’</span></dt><dd><p>Field delimiter for the output file</p>
</dd>
<dt><strong>na_rep</strong><span class="classifier">string, default ‘’</span></dt><dd><p>Missing data representation</p>
</dd>
<dt><strong>float_format</strong><span class="classifier">string, default None</span></dt><dd><p>Format string for floating point numbers</p>
</dd>
<dt><strong>columns</strong><span class="classifier">sequence, optional</span></dt><dd><p>Columns to write</p>
</dd>
<dt><strong>header</strong><span class="classifier">boolean or list of string, default True</span></dt><dd><p>Write out column names. If a list of string is given it is assumed
to be aliases for the column names</p>
</dd>
<dt><strong>header_first_partition_only</strong><span class="classifier">boolean, default None</span></dt><dd><p>If set to <cite>True</cite>, only write the header row in the first output
file. By default, headers are written to all partitions under
the multiple file mode (<cite>single_file</cite> is <cite>False</cite>) and written
only once under the single file mode (<cite>single_file</cite> is <cite>True</cite>).
It must not be <cite>False</cite> under the single file mode.</p>
</dd>
<dt><strong>index</strong><span class="classifier">boolean, default True</span></dt><dd><p>Write row names (index)</p>
</dd>
<dt><strong>index_label</strong><span class="classifier">string or sequence, or False, default None</span></dt><dd><p>Column label for index column(s) if desired. If None is given, and
<cite>header</cite> and <cite>index</cite> are True, then the index names are used. A
sequence should be given if the DataFrame uses MultiIndex.  If
False do not print fields for index names. Use index_label=False
for easier importing in R</p>
</dd>
<dt><strong>nanRep</strong><span class="classifier">None</span></dt><dd><p>deprecated, use na_rep</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str</span></dt><dd><p>Python write mode, default ‘w’</p>
</dd>
<dt><strong>encoding</strong><span class="classifier">string, optional</span></dt><dd><p>A string representing the encoding to use in the output file,
defaults to ‘ascii’ on Python 2 and ‘utf-8’ on Python 3.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">string, optional</span></dt><dd><p>a string representing the compression to use in the output file,
allowed values are ‘gzip’, ‘bz2’, ‘xz’,
only used when the first argument is a filename</p>
</dd>
<dt><strong>line_terminator</strong><span class="classifier">string, default ‘n’</span></dt><dd><p>The newline character or character sequence to use in the output
file</p>
</dd>
<dt><strong>quoting</strong><span class="classifier">optional constant from csv module</span></dt><dd><p>defaults to csv.QUOTE_MINIMAL</p>
</dd>
<dt><strong>quotechar</strong><span class="classifier">string (length 1), default ‘”’</span></dt><dd><p>character used to quote fields</p>
</dd>
<dt><strong>doublequote</strong><span class="classifier">boolean, default True</span></dt><dd><p>Control quoting of <cite>quotechar</cite> inside a field</p>
</dd>
<dt><strong>escapechar</strong><span class="classifier">string (length 1), default None</span></dt><dd><p>character used to escape <cite>sep</cite> and <cite>quotechar</cite> when appropriate</p>
</dd>
<dt><strong>chunksize</strong><span class="classifier">int or None</span></dt><dd><p>rows to write at a time</p>
</dd>
<dt><strong>tupleize_cols</strong><span class="classifier">boolean, default False</span></dt><dd><p>write multi_index columns as a list of tuples (if True)
or new (expanded format) if False)</p>
</dd>
<dt><strong>date_format</strong><span class="classifier">string, default None</span></dt><dd><p>Format string for datetime objects</p>
</dd>
<dt><strong>decimal: string, default ‘.’</strong></dt><dd><p>Character recognized as decimal separator. E.g. use ‘,’ for
European data</p>
</dd>
<dt><strong>storage_options: dict</strong></dt><dd><p>Parameters passed on to the backend filesystem class.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>The names of the file written if they were computed right away</strong></dt><dd></dd>
<dt><strong>If not, the delayed tasks associated to the writing of the files</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If <cite>header_first_partition_only</cite> is set to <cite>False</cite> or
<cite>name_function</cite> is specified when <cite>single_file</cite> is <cite>True</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.to_dask_array">
<code class="sig-name descname">to_dask_array</code><span class="sig-paren">(</span><em class="sig-param">lengths=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.to_dask_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a dask DataFrame to a dask array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lengths</strong><span class="classifier">bool or Sequence of ints, optional</span></dt><dd><p>How to determine the chunks sizes for the output array.
By default, the output array will have unknown chunk lengths
along the first axis, which can cause some later operations
to fail.</p>
<ul class="simple">
<li><p>True : immediately compute the length of each partition</p></li>
<li><p>Sequence : a sequence of integers to use for the chunk sizes
on the first axis. These values are <em>not</em> validated for
correctness, beyond ensuring that the number of items
matches the number of partitions.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.to_delayed">
<code class="sig-name descname">to_delayed</code><span class="sig-paren">(</span><em class="sig-param">optimize_graph=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.to_delayed" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert into a list of <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> objects, one per partition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>optimize_graph</strong><span class="classifier">bool, optional</span></dt><dd><p>If True [default], the graph is optimized before converting into
<code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> objects.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.from_delayed" title="dask.dataframe.from_delayed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.dataframe.from_delayed</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">partitions</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_delayed</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.to_frame">
<code class="sig-name descname">to_frame</code><span class="sig-paren">(</span><em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.to_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Series to DataFrame.</p>
<p>This docstring was copied from pandas.core.series.Series.to_frame.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">object, default None</span></dt><dd><p>The passed name should substitute for the series name (if it has
one).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>DataFrame representation of Series.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">],</span>  
<span class="gp">... </span>              <span class="n">name</span><span class="o">=</span><span class="s2">&quot;vals&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>  
<span class="go">  vals</span>
<span class="go">0    a</span>
<span class="go">1    b</span>
<span class="go">2    c</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.to_hdf">
<code class="sig-name descname">to_hdf</code><span class="sig-paren">(</span><em class="sig-param">path_or_buf</em>, <em class="sig-param">key</em>, <em class="sig-param">mode='a'</em>, <em class="sig-param">append=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Store Dask Dataframe to Hierarchical Data Format (HDF) files</p>
<p>This is a parallel version of the Pandas function of the same name.  Please
see the Pandas docstring for more detailed information about shared keyword
arguments.</p>
<p>This function differs from the Pandas version by saving the many partitions
of a Dask DataFrame in parallel, either to many files, or to many datasets
within the same file.  You may specify this parallelism with an asterix
<code class="docutils literal notranslate"><span class="pre">*</span></code> within the filename or datapath, and an optional <code class="docutils literal notranslate"><span class="pre">name_function</span></code>.
The asterix will be replaced with an increasing sequence of integers
starting from <code class="docutils literal notranslate"><span class="pre">0</span></code> or with the result of calling <code class="docutils literal notranslate"><span class="pre">name_function</span></code> on each
of those integers.</p>
<p>This function only supports the Pandas <code class="docutils literal notranslate"><span class="pre">'table'</span></code> format, not the more
specialized <code class="docutils literal notranslate"><span class="pre">'fixed'</span></code> format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">string, pathlib.Path</span></dt><dd><p>Path to a target filename. Supports strings, <code class="docutils literal notranslate"><span class="pre">pathlib.Path</span></code>, or any
object implementing the <code class="docutils literal notranslate"><span class="pre">__fspath__</span></code> protocol. May contain a <code class="docutils literal notranslate"><span class="pre">*</span></code> to
denote many filenames.</p>
</dd>
<dt><strong>key</strong><span class="classifier">string</span></dt><dd><p>Datapath within the files.  May contain a <code class="docutils literal notranslate"><span class="pre">*</span></code> to denote many locations</p>
</dd>
<dt><strong>name_function</strong><span class="classifier">function</span></dt><dd><p>A function to convert the <code class="docutils literal notranslate"><span class="pre">*</span></code> in the above options to a string.
Should take in a number from 0 to the number of partitions and return a
string. (see examples below)</p>
</dd>
<dt><strong>compute</strong><span class="classifier">bool</span></dt><dd><p>Whether or not to execute immediately.  If False then this returns a
<code class="docutils literal notranslate"><span class="pre">dask.Delayed</span></code> value.</p>
</dd>
<dt><strong>lock</strong><span class="classifier">Lock, optional</span></dt><dd><p>Lock to use to prevent concurrency issues.  By default a
<code class="docutils literal notranslate"><span class="pre">threading.Lock</span></code>, <code class="docutils literal notranslate"><span class="pre">multiprocessing.Lock</span></code> or <code class="docutils literal notranslate"><span class="pre">SerializableLock</span></code>
will be used depending on your scheduler if a lock is required. See
dask.utils.get_scheduler_lock for more information about lock
selection.</p>
</dd>
<dt><strong>scheduler</strong><span class="classifier">string</span></dt><dd><p>The scheduler to use, like “threads” or “processes”</p>
</dd>
<dt><strong>**other:</strong></dt><dd><p>See pandas.to_hdf for more information</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filenames</strong><span class="classifier">list</span></dt><dd><p>Returned if <code class="docutils literal notranslate"><span class="pre">compute</span></code> is True. List of file names that each partition
is saved to.</p>
</dd>
<dt><strong>delayed</strong><span class="classifier">dask.Delayed</span></dt><dd><p>Returned if <code class="docutils literal notranslate"><span class="pre">compute</span></code> is False. Delayed object to execute <code class="docutils literal notranslate"><span class="pre">to_hdf</span></code>
when computed.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.read_hdf" title="dask.dataframe.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_hdf</span></code></a>, <a class="reference internal" href="#dask.dataframe.to_parquet" title="dask.dataframe.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_parquet</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Save Data to a single file</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;output.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data&#39;</span><span class="p">)</span>            
</pre></div>
</div>
<p>Save data to multiple datapaths within the same file:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;output.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data-*&#39;</span><span class="p">)</span>          
</pre></div>
</div>
<p>Save data to multiple files:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;output-*.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data&#39;</span><span class="p">)</span>          
</pre></div>
</div>
<p>Save data to multiple files, using the multiprocessing scheduler:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;output-*.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data&#39;</span><span class="p">,</span> <span class="n">scheduler</span><span class="o">=</span><span class="s1">&#39;processes&#39;</span><span class="p">)</span> 
</pre></div>
</div>
<p>Specify custom naming scheme.  This writes files as
‘2000-01-01.hdf’, ‘2000-01-02.hdf’, ‘2000-01-03.hdf’, etc..</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">base</span> <span class="o">=</span> <span class="n">date</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">name_function</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&#39;&#39;&#39; Convert integer 0 to n to a string &#39;&#39;&#39;</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">base</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;*.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data&#39;</span><span class="p">,</span> <span class="n">name_function</span><span class="o">=</span><span class="n">name_function</span><span class="p">)</span> 
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.to_json">
<code class="sig-name descname">to_json</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>See dd.to_json docstring for more information</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.to_sql">
<code class="sig-name descname">to_sql</code><span class="sig-paren">(</span><em class="sig-param">name: str</em>, <em class="sig-param">con</em>, <em class="sig-param">schema=None</em>, <em class="sig-param">if_exists: str = 'fail'</em>, <em class="sig-param">index: bool = True</em>, <em class="sig-param">index_label=None</em>, <em class="sig-param">chunksize=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">method=None</em>, <em class="sig-param">compute=True</em>, <em class="sig-param">parallel=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.to_sql" title="Permalink to this definition">¶</a></dt>
<dd><p>See dd.to_sql docstring for more information</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.to_string">
<code class="sig-name descname">to_string</code><span class="sig-paren">(</span><em class="sig-param">max_rows=5</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Render a string representation of the Series.</p>
<p>This docstring was copied from pandas.core.series.Series.to_string.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>buf</strong><span class="classifier">StringIO-like, optional  (Not supported in Dask)</span></dt><dd><p>Buffer to write to.</p>
</dd>
<dt><strong>na_rep</strong><span class="classifier">str, optional  (Not supported in Dask)</span></dt><dd><p>String representation of NaN to use, default ‘NaN’.</p>
</dd>
<dt><strong>float_format</strong><span class="classifier">one-parameter function, optional  (Not supported in Dask)</span></dt><dd><p>Formatter function to apply to columns’ elements if they are
floats, default None.</p>
</dd>
<dt><strong>header</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>Add the Series header (index name).</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>Add index (row) labels, default True.</p>
</dd>
<dt><strong>length</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Add the Series length.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Add the Series dtype.</p>
</dd>
<dt><strong>name</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Add the Series name if not None.</p>
</dd>
<dt><strong>max_rows</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of rows to show before truncating. If None, show
all.</p>
</dd>
<dt><strong>min_rows</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>The number of rows to display in a truncated repr (when number
of rows is above <cite>max_rows</cite>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>str or None</strong></dt><dd><p>String representation of Series if <code class="docutils literal notranslate"><span class="pre">buf=None</span></code>, otherwise None.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.to_timestamp">
<code class="sig-name descname">to_timestamp</code><span class="sig-paren">(</span><em class="sig-param">freq=None</em>, <em class="sig-param">how='start'</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.to_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast to DatetimeIndex of timestamps, at <em>beginning</em> of period.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.to_timestamp.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>freq</strong><span class="classifier">str, default frequency of PeriodIndex</span></dt><dd><p>Desired frequency.</p>
</dd>
<dt><strong>how</strong><span class="classifier">{‘s’, ‘e’, ‘start’, ‘end’}</span></dt><dd><p>Convention for converting period to timestamp; start of period
vs. end.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The axis to convert (the index by default).</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>If False then underlying input data is not copied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame with DatetimeIndex</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.truediv">
<code class="sig-name descname">truediv</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.truediv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Floating division of series and other, element-wise (binary operator <cite>truediv</cite>).</p>
<p>This docstring was copied from pandas.core.series.Series.truediv.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">series</span> <span class="pre">/</span> <span class="pre">other</span></code>, but with support to substitute a fill_value for
missing data in one of the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or float value, default None (NaN)</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result will be missing.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or name</span></dt><dd><p>Broadcast across a level, matching Index values on the
passed MultiIndex level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>The result of the operation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.Series.rtruediv" title="dask.dataframe.Series.rtruediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.rtruediv</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">a    1.0</span>
<span class="go">b    1.0</span>
<span class="go">c    1.0</span>
<span class="go">d    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">a    1.0</span>
<span class="go">b    NaN</span>
<span class="go">d    1.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">a    1.0</span>
<span class="go">b    inf</span>
<span class="go">c    inf</span>
<span class="go">d    0.0</span>
<span class="go">e    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.unique">
<code class="sig-name descname">unique</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Series of unique values in the object. Includes NA values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>uniques</strong><span class="classifier">Series</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.value_counts">
<code class="sig-name descname">value_counts</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.value_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Series containing counts of unique values.</p>
<p>This docstring was copied from pandas.core.series.Series.value_counts.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The resulting object will be in descending order so that the
first element is the most frequently-occurring element.
Excludes NA values by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>normalize</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>If True then the object returned will contain the relative
frequencies of the unique values.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>Sort by frequencies.</p>
</dd>
<dt><strong>ascending</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Sort in ascending order.</p>
</dd>
<dt><strong>bins</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>Rather than count values, group them into half-open bins,
a convenience for <code class="docutils literal notranslate"><span class="pre">pd.cut</span></code>, only works with numeric data.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>Don’t include counts of NaN.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.Series.count" title="dask.dataframe.Series.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.count</span></code></a></dt><dd><p>Number of non-NA elements in a Series.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.count" title="dask.dataframe.DataFrame.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.count</span></code></a></dt><dd><p>Number of non-NA elements in a DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">index</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>  
<span class="go">3.0    2</span>
<span class="go">4.0    1</span>
<span class="go">2.0    1</span>
<span class="go">1.0    1</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>With <cite>normalize</cite> set to <cite>True</cite>, returns the relative frequency by
dividing all values by the sum of values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">3.0    0.4</span>
<span class="go">4.0    0.2</span>
<span class="go">2.0    0.2</span>
<span class="go">1.0    0.2</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p><strong>bins</strong></p>
<p>Bins can be useful for going from a continuous variable to a
categorical variable; instead of counting unique
apparitions of values, divide the index in the specified
number of half-open bins.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  
<span class="go">(2.0, 3.0]      2</span>
<span class="go">(0.996, 2.0]    2</span>
<span class="go">(3.0, 4.0]      1</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p><strong>dropna</strong></p>
<p>With <cite>dropna</cite> set to <cite>False</cite> we can also see NaN index values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">dropna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">3.0    2</span>
<span class="go">NaN    1</span>
<span class="go">4.0    1</span>
<span class="go">2.0    1</span>
<span class="go">1.0    1</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.values">
<em class="property">property </em><code class="sig-name descname">values</code><a class="headerlink" href="#dask.dataframe.Series.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dask.array of the values of this dataframe</p>
<p>Warning: This creates a dask.array without precise shape information.
Operations that depend on shape information, like slicing or reshaping,
will not work.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=False</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unbiased variance over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.var.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Normalized by N-1 by default. This can be changed using the ddof argument</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd></dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None  (Not supported in Dask)</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, default 1</span></dt><dd><p>Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
where N represents the number of elements.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None  (Not supported in Dask)</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to use
everything, then use only numeric data. Not implemented for Series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame (if level specified)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.visualize">
<code class="sig-name descname">visualize</code><span class="sig-paren">(</span><em class="sig-param">filename='mydask'</em>, <em class="sig-param">format=None</em>, <em class="sig-param">optimize_graph=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.visualize" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the computation of this object’s task graph using graphviz.</p>
<p>Requires <code class="docutils literal notranslate"><span class="pre">graphviz</span></code> to be installed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str or None, optional</span></dt><dd><p>The name (without an extension) of the file to write to disk.  If
<cite>filename</cite> is None, no file will be written, and we communicate
with dot using only pipes.</p>
</dd>
<dt><strong>format</strong><span class="classifier">{‘png’, ‘pdf’, ‘dot’, ‘svg’, ‘jpeg’, ‘jpg’}, optional</span></dt><dd><p>Format in which to write output file.  Default is ‘png’.</p>
</dd>
<dt><strong>optimize_graph</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the graph is optimized before rendering.  Otherwise,
the graph is displayed as is. Default is False.</p>
</dd>
<dt><strong>color: {None, ‘order’}, optional</strong></dt><dd><p>Options to color nodes.  Provide <code class="docutils literal notranslate"><span class="pre">cmap=</span></code> keyword for additional
colormap</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to forward to <code class="docutils literal notranslate"><span class="pre">to_graphviz</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">IPython.diplay.Image, IPython.display.SVG, or None</span></dt><dd><p>See dask.dot.dot_graph for more information.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.base.visualize</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.dot.dot_graph</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>For more information on optimization see here:</p>
<p><a class="reference external" href="https://docs.dask.org/en/latest/optimize.html">https://docs.dask.org/en/latest/optimize.html</a></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;dask.pdf&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;dask.pdf&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;order&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.Series.where">
<code class="sig-name descname">where</code><span class="sig-paren">(</span><em class="sig-param">cond</em>, <em class="sig-param">other=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.Series.where" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values where the condition is False.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.where.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cond</strong><span class="classifier">bool Series/DataFrame, array-like, or callable</span></dt><dd><p>Where <cite>cond</cite> is True, keep the original value. Where
False, replace with corresponding value from <cite>other</cite>.
If <cite>cond</cite> is callable, it is computed on the Series/DataFrame and
should return boolean Series/DataFrame or array. The callable must
not change input Series/DataFrame (though pandas doesn’t check it).</p>
</dd>
<dt><strong>other</strong><span class="classifier">scalar, Series/DataFrame, or callable</span></dt><dd><p>Entries where <cite>cond</cite> is False are replaced with
corresponding value from <cite>other</cite>.
If other is callable, it is computed on the Series/DataFrame and
should return scalar or Series/DataFrame. The callable must not
change input Series/DataFrame (though pandas doesn’t check it).</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Whether to perform the operation in place on the data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, default None  (Not supported in Dask)</span></dt><dd><p>Alignment axis if needed.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int, default None  (Not supported in Dask)</span></dt><dd><p>Alignment level if needed.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, {‘raise’, ‘ignore’}, default ‘raise’  (Not supported in Dask)</span></dt><dd><p>Note that currently this parameter won’t affect
the results and will always coerce to a suitable dtype.</p>
<ul class="simple">
<li><p>‘raise’ : allow exceptions to be raised.</p></li>
<li><p>‘ignore’ : suppress exceptions. On error return original object.</p></li>
</ul>
</dd>
<dt><strong>try_cast</strong><span class="classifier">bool, default False  (Not supported in Dask)</span></dt><dd><p>Try to cast the result back to the input type (if possible).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Same type as caller</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.mask" title="dask.dataframe.DataFrame.mask"><code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.mask()</span></code></a></dt><dd><p>Return an object of same shape as self.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The where method is an application of the if-then idiom. For each
element in the calling DataFrame, if <code class="docutils literal notranslate"><span class="pre">cond</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> the
element is used; otherwise the corresponding element from the DataFrame
<code class="docutils literal notranslate"><span class="pre">other</span></code> is used.</p>
<p>The signature for <a class="reference internal" href="#dask.dataframe.DataFrame.where" title="dask.dataframe.DataFrame.where"><code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.where()</span></code></a> differs from
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html#numpy.where" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.where()</span></code></a>. Roughly <code class="docutils literal notranslate"><span class="pre">df1.where(m,</span> <span class="pre">df2)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">np.where(m,</span> <span class="pre">df1,</span> <span class="pre">df2)</span></code>.</p>
<p>For further details and examples see the <code class="docutils literal notranslate"><span class="pre">where</span></code> documentation in
<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#indexing-where-mask" title="(in pandas v1.0.3)"><span class="xref std std-ref">indexing</span></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  
<span class="go">0    NaN</span>
<span class="go">1    1.0</span>
<span class="go">2    2.0</span>
<span class="go">3    3.0</span>
<span class="go">4    4.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  
<span class="go">0    0.0</span>
<span class="go">1    NaN</span>
<span class="go">2    NaN</span>
<span class="go">3    NaN</span>
<span class="go">4    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  
<span class="go">0    10</span>
<span class="go">1    10</span>
<span class="go">2    2</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A  B</span>
<span class="go">0  0  1</span>
<span class="go">1  2  3</span>
<span class="go">2  4  5</span>
<span class="go">3  6  7</span>
<span class="go">4  8  9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">df</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>  
<span class="go">   A  B</span>
<span class="go">0  0 -1</span>
<span class="go">1 -2  3</span>
<span class="go">2 -4 -5</span>
<span class="go">3  6 -7</span>
<span class="go">4 -8  9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>  
<span class="go">      A     B</span>
<span class="go">0  True  True</span>
<span class="go">1  True  True</span>
<span class="go">2  True  True</span>
<span class="go">3  True  True</span>
<span class="go">4  True  True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="n">df</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="o">~</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>  
<span class="go">      A     B</span>
<span class="go">0  True  True</span>
<span class="go">1  True  True</span>
<span class="go">2  True  True</span>
<span class="go">3  True  True</span>
<span class="go">4  True  True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="dataframegroupby">
<h2>DataFrameGroupBy<a class="headerlink" href="#dataframegroupby" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dask.dataframe.groupby.DataFrameGroupBy">
<em class="property">class </em><code class="sig-prename descclassname">dask.dataframe.groupby.</code><code class="sig-name descname">DataFrameGroupBy</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">by=None</em>, <em class="sig-param">slice=None</em>, <em class="sig-param">group_keys=True</em>, <em class="sig-param">dropna=None</em>, <em class="sig-param">sort=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.agg">
<code class="sig-name descname">agg</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.agg" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate using one or more operations over the specified axis.</p>
<p>This docstring was copied from pandas.core.groupby.generic.DataFrameGroupBy.agg.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>func</strong><span class="classifier">function, str, list or dict  (Not supported in Dask)</span></dt><dd><p>Function to use for aggregating the data. If a function, must either
work when passed a DataFrame or when passed to DataFrame.apply.</p>
<p>Accepted combinations are:</p>
<ul class="simple">
<li><p>function</p></li>
<li><p>string function name</p></li>
<li><p>list of functions and/or function names, e.g. <code class="docutils literal notranslate"><span class="pre">[np.sum,</span> <span class="pre">'mean']</span></code></p></li>
<li><p>dict of axis labels -&gt; functions, function names or list of such.</p></li>
</ul>
</dd>
<dt><strong>*args</strong></dt><dd><p>Positional arguments to pass to <cite>func</cite>.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Keyword arguments to pass to <cite>func</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>scalar, Series or DataFrame</strong></dt><dd><p>The return can be:</p>
<ul class="simple">
<li><p>scalar : when Series.agg is called with single function</p></li>
<li><p>Series : when DataFrame.agg is called with a single function</p></li>
<li><p>DataFrame : when DataFrame.agg is called with several functions</p></li>
</ul>
<p>Return scalar, Series or DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame.groupby.apply</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame.groupby.transform</span></code>, <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.aggregate.html#pandas.DataFrame.aggregate" title="(in pandas v1.0.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame.aggregate</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p><cite>agg</cite> is an alias for <cite>aggregate</cite>. Use the alias.</p>
<p>A passed user-defined-function will be passed a Series for evaluation.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)})</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A  B         C</span>
<span class="go">0  1  1  0.362838</span>
<span class="go">1  1  2  0.227877</span>
<span class="go">2  2  3  1.267767</span>
<span class="go">3  2  4 -0.562860</span>
</pre></div>
</div>
<p>The aggregation is for each column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">&#39;min&#39;</span><span class="p">)</span>  
<span class="go">   B         C</span>
<span class="go">A</span>
<span class="go">1  1  0.227877</span>
<span class="go">2  3 -0.562860</span>
</pre></div>
</div>
<p>Multiple aggregations</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>  
<span class="go">    B             C</span>
<span class="go">  min max       min       max</span>
<span class="go">A</span>
<span class="go">1   1   2  0.227877  0.362838</span>
<span class="go">2   3   4 -0.562860  1.267767</span>
</pre></div>
</div>
<p>Select a column for aggregation</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>  
<span class="go">   min  max</span>
<span class="go">A</span>
<span class="go">1    1    2</span>
<span class="go">2    3    4</span>
</pre></div>
</div>
<p>Different aggregations per column</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">],</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="s1">&#39;sum&#39;</span><span class="p">})</span>  
<span class="go">    B             C</span>
<span class="go">  min max       sum</span>
<span class="go">A</span>
<span class="go">1   1   2  0.590716</span>
<span class="go">2   3   4  0.704907</span>
</pre></div>
</div>
<p>To control the output names with different aggregations per column,
pandas supports “named aggregation”</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span>  
<span class="gp">... </span>    <span class="n">b_min</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">NamedAgg</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">c_sum</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">NamedAgg</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">))</span>
<span class="go">   b_min     c_sum</span>
<span class="go">A</span>
<span class="go">1      1 -1.956929</span>
<span class="go">2      3 -0.322183</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The keywords are the <em>output</em> column names</p></li>
<li><p>The values are tuples whose first element is the column to select
and the second element is the aggregation to apply to that column.
Pandas provides the <code class="docutils literal notranslate"><span class="pre">pandas.NamedAgg</span></code> namedtuple with the fields
<code class="docutils literal notranslate"><span class="pre">['column',</span> <span class="pre">'aggfunc']</span></code> to make it clearer what the arguments are.
As usual, the aggregation can be a callable or a string alias.</p></li>
</ul>
<p>See <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html#groupby-aggregate-named" title="(in pandas v1.0.3)"><span>Named aggregation</span></a> for more.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.aggregate">
<code class="sig-name descname">aggregate</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate using one or more operations over the specified axis.</p>
<p>This docstring was copied from pandas.core.groupby.generic.DataFrameGroupBy.aggregate.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>func</strong><span class="classifier">function, str, list or dict  (Not supported in Dask)</span></dt><dd><p>Function to use for aggregating the data. If a function, must either
work when passed a DataFrame or when passed to DataFrame.apply.</p>
<p>Accepted combinations are:</p>
<ul class="simple">
<li><p>function</p></li>
<li><p>string function name</p></li>
<li><p>list of functions and/or function names, e.g. <code class="docutils literal notranslate"><span class="pre">[np.sum,</span> <span class="pre">'mean']</span></code></p></li>
<li><p>dict of axis labels -&gt; functions, function names or list of such.</p></li>
</ul>
</dd>
<dt><strong>*args</strong></dt><dd><p>Positional arguments to pass to <cite>func</cite>.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Keyword arguments to pass to <cite>func</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>scalar, Series or DataFrame</strong></dt><dd><p>The return can be:</p>
<ul class="simple">
<li><p>scalar : when Series.agg is called with single function</p></li>
<li><p>Series : when DataFrame.agg is called with a single function</p></li>
<li><p>DataFrame : when DataFrame.agg is called with several functions</p></li>
</ul>
<p>Return scalar, Series or DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame.groupby.apply</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame.groupby.transform</span></code>, <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.aggregate.html#pandas.DataFrame.aggregate" title="(in pandas v1.0.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame.aggregate</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p><cite>agg</cite> is an alias for <cite>aggregate</cite>. Use the alias.</p>
<p>A passed user-defined-function will be passed a Series for evaluation.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)})</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A  B         C</span>
<span class="go">0  1  1  0.362838</span>
<span class="go">1  1  2  0.227877</span>
<span class="go">2  2  3  1.267767</span>
<span class="go">3  2  4 -0.562860</span>
</pre></div>
</div>
<p>The aggregation is for each column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">&#39;min&#39;</span><span class="p">)</span>  
<span class="go">   B         C</span>
<span class="go">A</span>
<span class="go">1  1  0.227877</span>
<span class="go">2  3 -0.562860</span>
</pre></div>
</div>
<p>Multiple aggregations</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>  
<span class="go">    B             C</span>
<span class="go">  min max       min       max</span>
<span class="go">A</span>
<span class="go">1   1   2  0.227877  0.362838</span>
<span class="go">2   3   4 -0.562860  1.267767</span>
</pre></div>
</div>
<p>Select a column for aggregation</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>  
<span class="go">   min  max</span>
<span class="go">A</span>
<span class="go">1    1    2</span>
<span class="go">2    3    4</span>
</pre></div>
</div>
<p>Different aggregations per column</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">],</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="s1">&#39;sum&#39;</span><span class="p">})</span>  
<span class="go">    B             C</span>
<span class="go">  min max       sum</span>
<span class="go">A</span>
<span class="go">1   1   2  0.590716</span>
<span class="go">2   3   4  0.704907</span>
</pre></div>
</div>
<p>To control the output names with different aggregations per column,
pandas supports “named aggregation”</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span>  
<span class="gp">... </span>    <span class="n">b_min</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">NamedAgg</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">c_sum</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">NamedAgg</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">))</span>
<span class="go">   b_min     c_sum</span>
<span class="go">A</span>
<span class="go">1      1 -1.956929</span>
<span class="go">2      3 -0.322183</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The keywords are the <em>output</em> column names</p></li>
<li><p>The values are tuples whose first element is the column to select
and the second element is the aggregation to apply to that column.
Pandas provides the <code class="docutils literal notranslate"><span class="pre">pandas.NamedAgg</span></code> namedtuple with the fields
<code class="docutils literal notranslate"><span class="pre">['column',</span> <span class="pre">'aggfunc']</span></code> to make it clearer what the arguments are.
As usual, the aggregation can be a callable or a string alias.</p></li>
</ul>
<p>See <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html#groupby-aggregate-named" title="(in pandas v1.0.3)"><span>Named aggregation</span></a> for more.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel version of pandas GroupBy.apply</p>
<p>This mimics the pandas version except for the following:</p>
<ol class="arabic simple">
<li><p>If the grouper does not align with the index then this causes a full
shuffle.  The order of rows within each group may not be preserved.</p></li>
<li><p>Dask’s GroupBy.apply is not appropriate for aggregations. For custom
aggregations, use <a class="reference internal" href="#dask.dataframe.groupby.Aggregation" title="dask.dataframe.groupby.Aggregation"><code class="xref py py-class docutils literal notranslate"><span class="pre">dask.dataframe.groupby.Aggregation</span></code></a>.</p></li>
</ol>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Pandas’ groupby-apply can be used to to apply arbitrary functions,
including aggregations that result in one row per group. Dask’s
groupby-apply will apply <code class="docutils literal notranslate"><span class="pre">func</span></code> once to each partition-group pair,
so when <code class="docutils literal notranslate"><span class="pre">func</span></code> is a reduction you’ll end up with one row per
partition-group pair. To apply a custom aggregation with Dask,
use <a class="reference internal" href="#dask.dataframe.groupby.Aggregation" title="dask.dataframe.groupby.Aggregation"><code class="xref py py-class docutils literal notranslate"><span class="pre">dask.dataframe.groupby.Aggregation</span></code></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func: function</strong></dt><dd><p>Function to apply</p>
</dd>
<dt><strong>args, kwargs</strong><span class="classifier">Scalar, Delayed or object</span></dt><dd><p>Arguments and keywords to pass to the function.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes
and column names of the output. This metadata is necessary for
many algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code>
can be provided (note that the order of the names should match the
order of the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span>
<span class="pre">dtype)</span></code> can be used. If not provided, dask will try to infer the
metadata. This may lead to unexpected results, so providing
<code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For more information, see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>applied</strong><span class="classifier">Series or DataFrame depending on columns keyword</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.corr">
<code class="sig-name descname">corr</code><span class="sig-paren">(</span><em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute pairwise correlation of columns, excluding NA/null values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.corr.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Groupby correlation:
corr(X, Y) = cov(X, Y) / (std_x * std_y)</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>method</strong><span class="classifier">{‘pearson’, ‘kendall’, ‘spearman’} or callable  (Not supported in Dask)</span></dt><dd><p>Method of correlation:</p>
<ul>
<li><p>pearson : standard correlation coefficient</p></li>
<li><p>kendall : Kendall Tau correlation coefficient</p></li>
<li><p>spearman : Spearman rank correlation</p></li>
<li><dl>
<dt>callable: callable with input two 1d ndarrays</dt><dd><p>and returning a float. Note that the returned matrix from corr
will have 1 along the diagonals and will be symmetric
regardless of the callable’s behavior.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0.</span></p>
</div>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>min_periods</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>Minimum number of observations required per pair of columns
to have a valid result. Currently only available for Pearson
and Spearman correlation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Correlation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.corrwith</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.corr</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">histogram_intersection</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">v</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([(</span><span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="o">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="o">.</span><span class="mi">6</span><span class="p">,</span> <span class="o">.</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">)],</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dogs&#39;</span><span class="p">,</span> <span class="s1">&#39;cats&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">histogram_intersection</span><span class="p">)</span>  
<span class="go">      dogs  cats</span>
<span class="go">dogs   1.0   0.3</span>
<span class="go">cats   0.3   1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute count of group, excluding missing values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.count.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Count of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.cov">
<code class="sig-name descname">cov</code><span class="sig-paren">(</span><em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em>, <em class="sig-param">std=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute pairwise covariance of columns, excluding NA/null values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.cov.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Groupby covariance is accomplished by</p>
<ol class="arabic simple">
<li><p>Computing intermediate values for sum, count, and the product of
all columns: a b c -&gt; a*a, a*b, b*b, b*c, c*c.</p></li>
<li><p>The values are then aggregated and the final covariance value is calculated:
cov(X, Y) = X*Y - Xbar * Ybar</p></li>
</ol>
<p>When <cite>std</cite> is True calculate Correlation</p>
<p>Compute the pairwise covariance among the series of a DataFrame.
The returned data frame is the <a class="reference external" href="https://en.wikipedia.org/wiki/Covariance_matrix">covariance matrix</a> of the columns
of the DataFrame.</p>
<p>Both NA and null values are automatically excluded from the
calculation. (See the note below about bias from missing values.)
A threshold can be set for the minimum number of
observations for each value created. Comparisons with observations
below this threshold will be returned as <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
<p>This method is generally used for the analysis of time series data to
understand the relationship between different measures
across time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_periods</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>Minimum number of observations required per pair of columns
to have a valid result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>The covariance matrix of the series of the DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.cov</span></code></dt><dd><p>Compute covariance with another Series.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.EWM.cov</span></code></dt><dd><p>Exponential weighted sample covariance.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Expanding.cov</span></code></dt><dd><p>Expanding sample covariance.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Rolling.cov</span></code></dt><dd><p>Rolling sample covariance.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Returns the covariance matrix of the DataFrame’s time series.
The covariance is normalized by N-1.</p>
<p>For DataFrames that have Series that are missing data (assuming that
data is <a class="reference external" href="https://en.wikipedia.org/wiki/Missing_data#Missing_at_random">missing at random</a>)
the returned covariance matrix will be an unbiased estimate
of the variance and covariance between the member Series.</p>
<p>However, for many applications this estimate may not be acceptable
because the estimate covariance matrix is not guaranteed to be positive
semi-definite. This could lead to estimate correlations having
absolute values which are greater than one, and/or a non-invertible
covariance matrix. See <a class="reference external" href="http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices">Estimation of covariance matrices</a> for more details.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dogs&#39;</span><span class="p">,</span> <span class="s1">&#39;cats&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span>  
<span class="go">          dogs      cats</span>
<span class="go">dogs  0.666667 -1.000000</span>
<span class="go">cats -1.000000  1.666667</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span>  
<span class="go">          a         b         c         d         e</span>
<span class="go">a  0.998438 -0.020161  0.059277 -0.008943  0.014144</span>
<span class="go">b -0.020161  1.059352 -0.008543 -0.024738  0.009826</span>
<span class="go">c  0.059277 -0.008543  1.010670 -0.001486 -0.000271</span>
<span class="go">d -0.008943 -0.024738 -0.001486  0.921297 -0.013692</span>
<span class="go">e  0.014144  0.009826 -0.000271 -0.013692  0.977795</span>
</pre></div>
</div>
<p><strong>Minimum number of periods</strong></p>
<p>This method also supports an optional <code class="docutils literal notranslate"><span class="pre">min_periods</span></code> keyword
that specifies the required minimum number of non-NA observations for
each column pair in order to have a valid result:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="mi">5</span><span class="p">],</span> <span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">min_periods</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>  
<span class="go">          a         b         c</span>
<span class="go">a  0.316741       NaN -0.150812</span>
<span class="go">b       NaN  1.248003  0.191417</span>
<span class="go">c -0.150812  0.191417  0.895202</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.cumcount">
<code class="sig-name descname">cumcount</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.cumcount" title="Permalink to this definition">¶</a></dt>
<dd><p>Number each item in each group from 0 to the length of that group - 1.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.cumcount.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Essentially this is equivalent to</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>  
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ascending</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>If False, number in reverse, from length of group - 1 to 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Sequence number of each element within each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ngroup</span></code></dt><dd><p>Number the groups themselves.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]],</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A</span>
<span class="go">0  a</span>
<span class="go">1  a</span>
<span class="go">2  a</span>
<span class="go">3  b</span>
<span class="go">4  b</span>
<span class="go">5  a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span>  
<span class="go">0    0</span>
<span class="go">1    1</span>
<span class="go">2    2</span>
<span class="go">3    0</span>
<span class="go">4    1</span>
<span class="go">5    3</span>
<span class="go">dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cumcount</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">0    3</span>
<span class="go">1    2</span>
<span class="go">2    1</span>
<span class="go">3    1</span>
<span class="go">4    0</span>
<span class="go">5    0</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.cumprod">
<code class="sig-name descname">cumprod</code><span class="sig-paren">(</span><em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative product for each group.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.cumprod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.cumsum">
<code class="sig-name descname">cumsum</code><span class="sig-paren">(</span><em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative sum for each group.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.cumsum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.first">
<code class="sig-name descname">first</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.first" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute first of group values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.first.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed first of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.get_group">
<code class="sig-name descname">get_group</code><span class="sig-paren">(</span><em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.get_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct DataFrame from group with provided name.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.get_group.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">object  (Not supported in Dask)</span></dt><dd><p>The name of the group to get as a DataFrame.</p>
</dd>
<dt><strong>obj</strong><span class="classifier">DataFrame, default None  (Not supported in Dask)</span></dt><dd><p>The DataFrame to take the DataFrame out of.  If
it is None, the object groupby was called on will
be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>group</strong><span class="classifier">same type as obj</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.idxmax">
<code class="sig-name descname">idxmax</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.idxmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index of first occurrence of maximum over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.idxmax.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>NA/null values are excluded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The axis to use. 0 or ‘index’ for row-wise, 1 or ‘columns’ for column-wise.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Indexes of maxima along the specified axis.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><ul class="simple">
<li><p>If the row/column is empty</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmax</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This method is the DataFrame version of <code class="docutils literal notranslate"><span class="pre">ndarray.argmax</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.idxmin">
<code class="sig-name descname">idxmin</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.idxmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index of first occurrence of minimum over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.idxmin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>NA/null values are excluded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The axis to use. 0 or ‘index’ for row-wise, 1 or ‘columns’ for column-wise.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Indexes of minima along the specified axis.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><ul class="simple">
<li><p>If the row/column is empty</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmin</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This method is the DataFrame version of <code class="docutils literal notranslate"><span class="pre">ndarray.argmin</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.last">
<code class="sig-name descname">last</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.last" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute last of group values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.last.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed last of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute max of group values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.max.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed max of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mean of groups, excluding missing values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.mean.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pandas.Series or pandas.DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Groupby one column and return the mean of the remaining columns in
each group.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">     B         C</span>
<span class="go">A</span>
<span class="go">1  3.0  1.333333</span>
<span class="go">2  4.0  1.500000</span>
</pre></div>
</div>
<p>Groupby two columns and return the mean of the remaining column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">       C</span>
<span class="go">A B</span>
<span class="go">1 2.0  2</span>
<span class="go">  4.0  1</span>
<span class="go">2 3.0  1</span>
<span class="go">  5.0  2</span>
</pre></div>
</div>
<p>Groupby one column and return the mean of only particular column in
the group.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">A</span>
<span class="go">1    3.0</span>
<span class="go">2    4.0</span>
<span class="go">Name: B, dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute min of group values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.min.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed min of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.prod">
<code class="sig-name descname">prod</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em>, <em class="sig-param">min_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute prod of group values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.prod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed prod of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.size">
<code class="sig-name descname">size</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute group sizes.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.size.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Number of rows in each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute standard deviation of groups, excluding missing values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.std.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>For multiple groupings, the result index will be a MultiIndex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ddof</strong><span class="classifier">int, default 1</span></dt><dd><p>Degrees of freedom.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Standard deviation of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em>, <em class="sig-param">min_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute sum of group values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.sum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed sum of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel version of pandas GroupBy.transform</p>
<p>This mimics the pandas version except for the following:</p>
<ol class="arabic simple">
<li><p>If the grouper does not align with the index then this causes a full
shuffle.  The order of rows within each group may not be preserved.</p></li>
<li><p>Dask’s GroupBy.transform is not appropriate for aggregations. For custom
aggregations, use <a class="reference internal" href="#dask.dataframe.groupby.Aggregation" title="dask.dataframe.groupby.Aggregation"><code class="xref py py-class docutils literal notranslate"><span class="pre">dask.dataframe.groupby.Aggregation</span></code></a>.</p></li>
</ol>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Pandas’ groupby-transform can be used to to apply arbitrary functions,
including aggregations that result in one row per group. Dask’s
groupby-transform will apply <code class="docutils literal notranslate"><span class="pre">func</span></code> once to each partition-group pair,
so when <code class="docutils literal notranslate"><span class="pre">func</span></code> is a reduction you’ll end up with one row per
partition-group pair. To apply a custom aggregation with Dask,
use <a class="reference internal" href="#dask.dataframe.groupby.Aggregation" title="dask.dataframe.groupby.Aggregation"><code class="xref py py-class docutils literal notranslate"><span class="pre">dask.dataframe.groupby.Aggregation</span></code></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func: function</strong></dt><dd><p>Function to apply</p>
</dd>
<dt><strong>args, kwargs</strong><span class="classifier">Scalar, Delayed or object</span></dt><dd><p>Arguments and keywords to pass to the function.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes
and column names of the output. This metadata is necessary for
many algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code>
can be provided (note that the order of the names should match the
order of the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span>
<span class="pre">dtype)</span></code> can be used. If not provided, dask will try to infer the
metadata. This may lead to unexpected results, so providing
<code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For more information, see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>applied</strong><span class="classifier">Series or DataFrame depending on columns keyword</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.DataFrameGroupBy.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.DataFrameGroupBy.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute variance of groups, excluding missing values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.var.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>For multiple groupings, the result index will be a MultiIndex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ddof</strong><span class="classifier">int, default 1</span></dt><dd><p>Degrees of freedom.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Variance of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="seriesgroupby">
<h2>SeriesGroupBy<a class="headerlink" href="#seriesgroupby" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dask.dataframe.groupby.SeriesGroupBy">
<em class="property">class </em><code class="sig-prename descclassname">dask.dataframe.groupby.</code><code class="sig-name descname">SeriesGroupBy</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">by=None</em>, <em class="sig-param">slice=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.agg">
<code class="sig-name descname">agg</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.agg" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate using one or more operations over the specified axis.</p>
<p>This docstring was copied from pandas.core.groupby.generic.SeriesGroupBy.agg.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>func</strong><span class="classifier">function, str, list or dict  (Not supported in Dask)</span></dt><dd><p>Function to use for aggregating the data. If a function, must either
work when passed a Series or when passed to Series.apply.</p>
<p>Accepted combinations are:</p>
<ul class="simple">
<li><p>function</p></li>
<li><p>string function name</p></li>
<li><p>list of functions and/or function names, e.g. <code class="docutils literal notranslate"><span class="pre">[np.sum,</span> <span class="pre">'mean']</span></code></p></li>
<li><p>dict of axis labels -&gt; functions, function names or list of such.</p></li>
</ul>
</dd>
<dt><strong>*args</strong></dt><dd><p>Positional arguments to pass to <cite>func</cite>.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Keyword arguments to pass to <cite>func</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>scalar, Series or DataFrame</strong></dt><dd><p>The return can be:</p>
<ul class="simple">
<li><p>scalar : when Series.agg is called with single function</p></li>
<li><p>Series : when DataFrame.agg is called with a single function</p></li>
<li><p>DataFrame : when DataFrame.agg is called with several functions</p></li>
</ul>
<p>Return scalar, Series or DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.Series.groupby.apply</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.Series.groupby.transform</span></code>, <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.aggregate.html#pandas.Series.aggregate" title="(in pandas v1.0.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.Series.aggregate</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p><cite>agg</cite> is an alias for <cite>aggregate</cite>. Use the alias.</p>
<p>A passed user-defined-function will be passed a Series for evaluation.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">3    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>  
<span class="go">1    1</span>
<span class="go">2    3</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">&#39;min&#39;</span><span class="p">)</span>  
<span class="go">1    1</span>
<span class="go">2    3</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>  
<span class="go">   min  max</span>
<span class="go">1    1    2</span>
<span class="go">2    3    4</span>
</pre></div>
</div>
<p>The output column names can be controlled by passing
the desired column names and aggregations as keyword arguments.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span>  
<span class="gp">... </span>    <span class="n">minimum</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">maximum</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">   minimum  maximum</span>
<span class="go">1        1        2</span>
<span class="go">2        3        4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.aggregate">
<code class="sig-name descname">aggregate</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate using one or more operations over the specified axis.</p>
<p>This docstring was copied from pandas.core.groupby.generic.SeriesGroupBy.aggregate.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>func</strong><span class="classifier">function, str, list or dict  (Not supported in Dask)</span></dt><dd><p>Function to use for aggregating the data. If a function, must either
work when passed a Series or when passed to Series.apply.</p>
<p>Accepted combinations are:</p>
<ul class="simple">
<li><p>function</p></li>
<li><p>string function name</p></li>
<li><p>list of functions and/or function names, e.g. <code class="docutils literal notranslate"><span class="pre">[np.sum,</span> <span class="pre">'mean']</span></code></p></li>
<li><p>dict of axis labels -&gt; functions, function names or list of such.</p></li>
</ul>
</dd>
<dt><strong>*args</strong></dt><dd><p>Positional arguments to pass to <cite>func</cite>.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Keyword arguments to pass to <cite>func</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>scalar, Series or DataFrame</strong></dt><dd><p>The return can be:</p>
<ul class="simple">
<li><p>scalar : when Series.agg is called with single function</p></li>
<li><p>Series : when DataFrame.agg is called with a single function</p></li>
<li><p>DataFrame : when DataFrame.agg is called with several functions</p></li>
</ul>
<p>Return scalar, Series or DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.Series.groupby.apply</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.Series.groupby.transform</span></code>, <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.aggregate.html#pandas.Series.aggregate" title="(in pandas v1.0.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.Series.aggregate</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p><cite>agg</cite> is an alias for <cite>aggregate</cite>. Use the alias.</p>
<p>A passed user-defined-function will be passed a Series for evaluation.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">3    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>  
<span class="go">1    1</span>
<span class="go">2    3</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">&#39;min&#39;</span><span class="p">)</span>  
<span class="go">1    1</span>
<span class="go">2    3</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>  
<span class="go">   min  max</span>
<span class="go">1    1    2</span>
<span class="go">2    3    4</span>
</pre></div>
</div>
<p>The output column names can be controlled by passing
the desired column names and aggregations as keyword arguments.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span>  
<span class="gp">... </span>    <span class="n">minimum</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">maximum</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">   minimum  maximum</span>
<span class="go">1        1        2</span>
<span class="go">2        3        4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel version of pandas GroupBy.apply</p>
<p>This mimics the pandas version except for the following:</p>
<ol class="arabic simple">
<li><p>If the grouper does not align with the index then this causes a full
shuffle.  The order of rows within each group may not be preserved.</p></li>
<li><p>Dask’s GroupBy.apply is not appropriate for aggregations. For custom
aggregations, use <a class="reference internal" href="#dask.dataframe.groupby.Aggregation" title="dask.dataframe.groupby.Aggregation"><code class="xref py py-class docutils literal notranslate"><span class="pre">dask.dataframe.groupby.Aggregation</span></code></a>.</p></li>
</ol>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Pandas’ groupby-apply can be used to to apply arbitrary functions,
including aggregations that result in one row per group. Dask’s
groupby-apply will apply <code class="docutils literal notranslate"><span class="pre">func</span></code> once to each partition-group pair,
so when <code class="docutils literal notranslate"><span class="pre">func</span></code> is a reduction you’ll end up with one row per
partition-group pair. To apply a custom aggregation with Dask,
use <a class="reference internal" href="#dask.dataframe.groupby.Aggregation" title="dask.dataframe.groupby.Aggregation"><code class="xref py py-class docutils literal notranslate"><span class="pre">dask.dataframe.groupby.Aggregation</span></code></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func: function</strong></dt><dd><p>Function to apply</p>
</dd>
<dt><strong>args, kwargs</strong><span class="classifier">Scalar, Delayed or object</span></dt><dd><p>Arguments and keywords to pass to the function.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes
and column names of the output. This metadata is necessary for
many algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code>
can be provided (note that the order of the names should match the
order of the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span>
<span class="pre">dtype)</span></code> can be used. If not provided, dask will try to infer the
metadata. This may lead to unexpected results, so providing
<code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For more information, see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>applied</strong><span class="classifier">Series or DataFrame depending on columns keyword</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.corr">
<code class="sig-name descname">corr</code><span class="sig-paren">(</span><em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute pairwise correlation of columns, excluding NA/null values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.corr.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Groupby correlation:
corr(X, Y) = cov(X, Y) / (std_x * std_y)</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>method</strong><span class="classifier">{‘pearson’, ‘kendall’, ‘spearman’} or callable  (Not supported in Dask)</span></dt><dd><p>Method of correlation:</p>
<ul>
<li><p>pearson : standard correlation coefficient</p></li>
<li><p>kendall : Kendall Tau correlation coefficient</p></li>
<li><p>spearman : Spearman rank correlation</p></li>
<li><dl>
<dt>callable: callable with input two 1d ndarrays</dt><dd><p>and returning a float. Note that the returned matrix from corr
will have 1 along the diagonals and will be symmetric
regardless of the callable’s behavior.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0.</span></p>
</div>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>min_periods</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>Minimum number of observations required per pair of columns
to have a valid result. Currently only available for Pearson
and Spearman correlation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Correlation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.corrwith</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.corr</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">histogram_intersection</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">v</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([(</span><span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="o">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="o">.</span><span class="mi">6</span><span class="p">,</span> <span class="o">.</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">)],</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dogs&#39;</span><span class="p">,</span> <span class="s1">&#39;cats&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">histogram_intersection</span><span class="p">)</span>  
<span class="go">      dogs  cats</span>
<span class="go">dogs   1.0   0.3</span>
<span class="go">cats   0.3   1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute count of group, excluding missing values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.count.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Count of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.cov">
<code class="sig-name descname">cov</code><span class="sig-paren">(</span><em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em>, <em class="sig-param">std=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute pairwise covariance of columns, excluding NA/null values.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.cov.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Groupby covariance is accomplished by</p>
<ol class="arabic simple">
<li><p>Computing intermediate values for sum, count, and the product of
all columns: a b c -&gt; a*a, a*b, b*b, b*c, c*c.</p></li>
<li><p>The values are then aggregated and the final covariance value is calculated:
cov(X, Y) = X*Y - Xbar * Ybar</p></li>
</ol>
<p>When <cite>std</cite> is True calculate Correlation</p>
<p>Compute the pairwise covariance among the series of a DataFrame.
The returned data frame is the <a class="reference external" href="https://en.wikipedia.org/wiki/Covariance_matrix">covariance matrix</a> of the columns
of the DataFrame.</p>
<p>Both NA and null values are automatically excluded from the
calculation. (See the note below about bias from missing values.)
A threshold can be set for the minimum number of
observations for each value created. Comparisons with observations
below this threshold will be returned as <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
<p>This method is generally used for the analysis of time series data to
understand the relationship between different measures
across time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_periods</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>Minimum number of observations required per pair of columns
to have a valid result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>The covariance matrix of the series of the DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.cov</span></code></dt><dd><p>Compute covariance with another Series.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.EWM.cov</span></code></dt><dd><p>Exponential weighted sample covariance.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Expanding.cov</span></code></dt><dd><p>Expanding sample covariance.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">core.window.Rolling.cov</span></code></dt><dd><p>Rolling sample covariance.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Returns the covariance matrix of the DataFrame’s time series.
The covariance is normalized by N-1.</p>
<p>For DataFrames that have Series that are missing data (assuming that
data is <a class="reference external" href="https://en.wikipedia.org/wiki/Missing_data#Missing_at_random">missing at random</a>)
the returned covariance matrix will be an unbiased estimate
of the variance and covariance between the member Series.</p>
<p>However, for many applications this estimate may not be acceptable
because the estimate covariance matrix is not guaranteed to be positive
semi-definite. This could lead to estimate correlations having
absolute values which are greater than one, and/or a non-invertible
covariance matrix. See <a class="reference external" href="http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices">Estimation of covariance matrices</a> for more details.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dogs&#39;</span><span class="p">,</span> <span class="s1">&#39;cats&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span>  
<span class="go">          dogs      cats</span>
<span class="go">dogs  0.666667 -1.000000</span>
<span class="go">cats -1.000000  1.666667</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span>  
<span class="go">          a         b         c         d         e</span>
<span class="go">a  0.998438 -0.020161  0.059277 -0.008943  0.014144</span>
<span class="go">b -0.020161  1.059352 -0.008543 -0.024738  0.009826</span>
<span class="go">c  0.059277 -0.008543  1.010670 -0.001486 -0.000271</span>
<span class="go">d -0.008943 -0.024738 -0.001486  0.921297 -0.013692</span>
<span class="go">e  0.014144  0.009826 -0.000271 -0.013692  0.977795</span>
</pre></div>
</div>
<p><strong>Minimum number of periods</strong></p>
<p>This method also supports an optional <code class="docutils literal notranslate"><span class="pre">min_periods</span></code> keyword
that specifies the required minimum number of non-NA observations for
each column pair in order to have a valid result:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="mi">5</span><span class="p">],</span> <span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">min_periods</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>  
<span class="go">          a         b         c</span>
<span class="go">a  0.316741       NaN -0.150812</span>
<span class="go">b       NaN  1.248003  0.191417</span>
<span class="go">c -0.150812  0.191417  0.895202</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.cumcount">
<code class="sig-name descname">cumcount</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.cumcount" title="Permalink to this definition">¶</a></dt>
<dd><p>Number each item in each group from 0 to the length of that group - 1.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.cumcount.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Essentially this is equivalent to</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>  
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ascending</strong><span class="classifier">bool, default True  (Not supported in Dask)</span></dt><dd><p>If False, number in reverse, from length of group - 1 to 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Sequence number of each element within each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ngroup</span></code></dt><dd><p>Number the groups themselves.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]],</span>  
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>  
<span class="go">   A</span>
<span class="go">0  a</span>
<span class="go">1  a</span>
<span class="go">2  a</span>
<span class="go">3  b</span>
<span class="go">4  b</span>
<span class="go">5  a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span>  
<span class="go">0    0</span>
<span class="go">1    1</span>
<span class="go">2    2</span>
<span class="go">3    0</span>
<span class="go">4    1</span>
<span class="go">5    3</span>
<span class="go">dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cumcount</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">0    3</span>
<span class="go">1    2</span>
<span class="go">2    1</span>
<span class="go">3    1</span>
<span class="go">4    0</span>
<span class="go">5    0</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.cumprod">
<code class="sig-name descname">cumprod</code><span class="sig-paren">(</span><em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative product for each group.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.cumprod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.cumsum">
<code class="sig-name descname">cumsum</code><span class="sig-paren">(</span><em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative sum for each group.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.cumsum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.first">
<code class="sig-name descname">first</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.first" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute first of group values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.first.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed first of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.get_group">
<code class="sig-name descname">get_group</code><span class="sig-paren">(</span><em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.get_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct DataFrame from group with provided name.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.get_group.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">object  (Not supported in Dask)</span></dt><dd><p>The name of the group to get as a DataFrame.</p>
</dd>
<dt><strong>obj</strong><span class="classifier">DataFrame, default None  (Not supported in Dask)</span></dt><dd><p>The DataFrame to take the DataFrame out of.  If
it is None, the object groupby was called on will
be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>group</strong><span class="classifier">same type as obj</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.idxmax">
<code class="sig-name descname">idxmax</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.idxmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index of first occurrence of maximum over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.idxmax.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>NA/null values are excluded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The axis to use. 0 or ‘index’ for row-wise, 1 or ‘columns’ for column-wise.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Indexes of maxima along the specified axis.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><ul class="simple">
<li><p>If the row/column is empty</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmax</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This method is the DataFrame version of <code class="docutils literal notranslate"><span class="pre">ndarray.argmax</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.idxmin">
<code class="sig-name descname">idxmin</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.idxmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index of first occurrence of minimum over requested axis.</p>
<p>This docstring was copied from pandas.core.frame.DataFrame.idxmin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>NA/null values are excluded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The axis to use. 0 or ‘index’ for row-wise, 1 or ‘columns’ for column-wise.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Indexes of minima along the specified axis.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><ul class="simple">
<li><p>If the row/column is empty</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.idxmin</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This method is the DataFrame version of <code class="docutils literal notranslate"><span class="pre">ndarray.argmin</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.last">
<code class="sig-name descname">last</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.last" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute last of group values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.last.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed last of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute max of group values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.max.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed max of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mean of groups, excluding missing values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.mean.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pandas.Series or pandas.DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Groupby one column and return the mean of the remaining columns in
each group.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">     B         C</span>
<span class="go">A</span>
<span class="go">1  3.0  1.333333</span>
<span class="go">2  4.0  1.500000</span>
</pre></div>
</div>
<p>Groupby two columns and return the mean of the remaining column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">       C</span>
<span class="go">A B</span>
<span class="go">1 2.0  2</span>
<span class="go">  4.0  1</span>
<span class="go">2 3.0  1</span>
<span class="go">  5.0  2</span>
</pre></div>
</div>
<p>Groupby one column and return the mean of only particular column in
the group.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">A</span>
<span class="go">1    3.0</span>
<span class="go">2    4.0</span>
<span class="go">Name: B, dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute min of group values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.min.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed min of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.prod">
<code class="sig-name descname">prod</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em>, <em class="sig-param">min_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute prod of group values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.prod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed prod of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.size">
<code class="sig-name descname">size</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute group sizes.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.size.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Number of rows in each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute standard deviation of groups, excluding missing values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.std.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>For multiple groupings, the result index will be a MultiIndex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ddof</strong><span class="classifier">int, default 1</span></dt><dd><p>Degrees of freedom.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Standard deviation of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em>, <em class="sig-param">min_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute sum of group values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.sum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed sum of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel version of pandas GroupBy.transform</p>
<p>This mimics the pandas version except for the following:</p>
<ol class="arabic simple">
<li><p>If the grouper does not align with the index then this causes a full
shuffle.  The order of rows within each group may not be preserved.</p></li>
<li><p>Dask’s GroupBy.transform is not appropriate for aggregations. For custom
aggregations, use <a class="reference internal" href="#dask.dataframe.groupby.Aggregation" title="dask.dataframe.groupby.Aggregation"><code class="xref py py-class docutils literal notranslate"><span class="pre">dask.dataframe.groupby.Aggregation</span></code></a>.</p></li>
</ol>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Pandas’ groupby-transform can be used to to apply arbitrary functions,
including aggregations that result in one row per group. Dask’s
groupby-transform will apply <code class="docutils literal notranslate"><span class="pre">func</span></code> once to each partition-group pair,
so when <code class="docutils literal notranslate"><span class="pre">func</span></code> is a reduction you’ll end up with one row per
partition-group pair. To apply a custom aggregation with Dask,
use <a class="reference internal" href="#dask.dataframe.groupby.Aggregation" title="dask.dataframe.groupby.Aggregation"><code class="xref py py-class docutils literal notranslate"><span class="pre">dask.dataframe.groupby.Aggregation</span></code></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func: function</strong></dt><dd><p>Function to apply</p>
</dd>
<dt><strong>args, kwargs</strong><span class="classifier">Scalar, Delayed or object</span></dt><dd><p>Arguments and keywords to pass to the function.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes
and column names of the output. This metadata is necessary for
many algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code>
can be provided (note that the order of the names should match the
order of the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span>
<span class="pre">dtype)</span></code> can be used. If not provided, dask will try to infer the
metadata. This may lead to unexpected results, so providing
<code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For more information, see
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>applied</strong><span class="classifier">Series or DataFrame depending on columns keyword</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.unique">
<code class="sig-name descname">unique</code><span class="sig-paren">(</span><em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique values of Series object.</p>
<p>This docstring was copied from pandas.core.groupby.generic.SeriesGroupBy.unique.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Uniques are returned in order of appearance. Hash table-based unique,
therefore does NOT sort.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ndarray or ExtensionArray</strong></dt><dd><p>The unique values returned as a NumPy array. See Notes.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.groupby.SeriesGroupBy.unique" title="dask.dataframe.groupby.SeriesGroupBy.unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique</span></code></a></dt><dd><p>Top-level unique method for any 1-d array-like object.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Index.unique</span></code></dt><dd><p>Return Index with unique values from an Index object.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Returns the unique values as a NumPy array. In case of an
extension-array backed Series, a new
<code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionArray</span></code> of that type with just
the unique values is returned. This includes</p>
<blockquote>
<div><ul class="simple">
<li><p>Categorical</p></li>
<li><p>Period</p></li>
<li><p>Datetime with Timezone</p></li>
<li><p>Interval</p></li>
<li><p>Sparse</p></li>
<li><p>IntegerNA</p></li>
</ul>
</div></blockquote>
<p>See Examples section.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>  
<span class="go">array([2, 1, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;2016-01-01&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>  
<span class="go">array([&#39;2016-01-01T00:00:00.000000000&#39;], dtype=&#39;datetime64[ns]&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;2016-01-01&#39;</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="s1">&#39;US/Eastern&#39;</span><span class="p">)</span>  
<span class="gp">... </span>           <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
<span class="go">&lt;DatetimeArray&gt;</span>
<span class="go">[&#39;2016-01-01 00:00:00-05:00&#39;]</span>
<span class="go">Length: 1, dtype: datetime64[ns, US/Eastern]</span>
</pre></div>
</div>
<p>An unordered Categorical will return categories in the order of
appearance.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;baabc&#39;</span><span class="p">)))</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>  
<span class="go">[b, a, c]</span>
<span class="go">Categories (3, object): [b, a, c]</span>
</pre></div>
</div>
<p>An ordered Categorical preserves the category ordering.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;baabc&#39;</span><span class="p">),</span> <span class="n">categories</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">),</span>  
<span class="gp">... </span>                         <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
<span class="go">[b, a, c]</span>
<span class="go">Categories (3, object): [a &lt; b &lt; c]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.groupby.SeriesGroupBy.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param">ddof=1</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">split_out=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.SeriesGroupBy.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute variance of groups, excluding missing values.</p>
<p>This docstring was copied from pandas.core.groupby.groupby.GroupBy.var.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>For multiple groupings, the result index will be a MultiIndex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ddof</strong><span class="classifier">int, default 1</span></dt><dd><p>Degrees of freedom.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Variance of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="custom-aggregation">
<h2>Custom Aggregation<a class="headerlink" href="#custom-aggregation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dask.dataframe.groupby.Aggregation">
<em class="property">class </em><code class="sig-prename descclassname">dask.dataframe.groupby.</code><code class="sig-name descname">Aggregation</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">chunk</em>, <em class="sig-param">agg</em>, <em class="sig-param">finalize=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.groupby.Aggregation" title="Permalink to this definition">¶</a></dt>
<dd><p>User defined groupby-aggregation.</p>
<p>This class allows users to define their own custom aggregation in terms of
operations on Pandas dataframes in a map-reduce style. You need to specify
what operation to do on each chunk of data, how to combine those chunks of
data together, and then how to finalize the result.</p>
<p>See <a class="reference internal" href="dataframe-groupby.html#dataframe-groupby-aggregate"><span class="std std-ref">Aggregate</span></a> for more.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>the name of the aggregation. It should be unique, since intermediate
result will be identified by this name.</p>
</dd>
<dt><strong>chunk</strong><span class="classifier">callable</span></dt><dd><p>a function that will be called with the grouped column of each
partition. It can either return a single series or a tuple of series.
The index has to be equal to the groups.</p>
</dd>
<dt><strong>agg</strong><span class="classifier">callable</span></dt><dd><p>a function that will be called to aggregate the results of each chunk.
Again the argument(s) will be grouped series. If <code class="docutils literal notranslate"><span class="pre">chunk</span></code> returned a
tuple, <code class="docutils literal notranslate"><span class="pre">agg</span></code> will be called with all of them as individual positional
arguments.</p>
</dd>
<dt><strong>finalize</strong><span class="classifier">callable</span></dt><dd><p>an optional finalizer that will be called with the results from the
aggregation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We could implement <code class="docutils literal notranslate"><span class="pre">sum</span></code> as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">custom_sum</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">Aggregation</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;custom_sum&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">chunk</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">agg</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s0</span><span class="p">:</span> <span class="n">s0</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">custom_sum</span><span class="p">)</span>  
</pre></div>
</div>
<p>We can implement <code class="docutils literal notranslate"><span class="pre">mean</span></code> as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">custom_mean</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">Aggregation</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;custom_mean&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">chunk</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span>
<span class="gp">... </span>    <span class="n">agg</span><span class="o">=</span><span class="k">lambda</span> <span class="n">count</span><span class="p">,</span> <span class="nb">sum</span><span class="p">:</span> <span class="p">(</span><span class="n">count</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="nb">sum</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span>
<span class="gp">... </span>    <span class="n">finalize</span><span class="o">=</span><span class="k">lambda</span> <span class="n">count</span><span class="p">,</span> <span class="nb">sum</span><span class="p">:</span> <span class="nb">sum</span> <span class="o">/</span> <span class="n">count</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">custom_mean</span><span class="p">)</span>  
</pre></div>
</div>
<p>Though of course, both of these are built-in and so you don’t need to
implement them yourself.</p>
</dd></dl>

</div>
<div class="section" id="storage-and-conversion">
<h2>Storage and Conversion<a class="headerlink" href="#storage-and-conversion" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="dask.dataframe.read_csv">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">read_csv</code><span class="sig-paren">(</span><em class="sig-param">urlpath</em>, <em class="sig-param">blocksize=64000000</em>, <em class="sig-param">collection=True</em>, <em class="sig-param">lineterminator=None</em>, <em class="sig-param">compression=None</em>, <em class="sig-param">sample=256000</em>, <em class="sig-param">enforce=False</em>, <em class="sig-param">assume_missing=False</em>, <em class="sig-param">storage_options=None</em>, <em class="sig-param">include_path_column=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.read_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Read CSV files into a Dask.DataFrame</p>
<p>This parallelizes the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv" title="(in pandas v1.0.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_csv()</span></code></a> function in the following ways:</p>
<ul>
<li><p>It supports loading many files at once using globstrings:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;myfiles.*.csv&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</li>
<li><p>In some cases it can break up large files:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;largefile.csv&#39;</span><span class="p">,</span> <span class="n">blocksize</span><span class="o">=</span><span class="mf">25e6</span><span class="p">)</span>  <span class="c1"># 25MB chunks  </span>
</pre></div>
</div>
</li>
<li><p>It can read CSV files from external resources (e.g. S3, HDFS) by
providing a URL:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;s3://bucket/myfiles.*.csv&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;hdfs:///myfiles.*.csv&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;hdfs://namenode.example.com/myfiles.*.csv&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</li>
</ul>
<p>Internally <code class="docutils literal notranslate"><span class="pre">dd.read_csv</span></code> uses <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv" title="(in pandas v1.0.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_csv()</span></code></a> and supports many of the
same keyword arguments with the same performance guarantees. See the docstring
for <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv" title="(in pandas v1.0.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_csv()</span></code></a> for more information on available keyword arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>urlpath</strong><span class="classifier">string or list</span></dt><dd><p>Absolute or relative filepath(s). Prefix with a protocol like <code class="docutils literal notranslate"><span class="pre">s3://</span></code>
to read from alternative filesystems. To read from multiple files you
can pass a globstring or a list of paths, with the caveat that they
must all have the same protocol.</p>
</dd>
<dt><strong>blocksize</strong><span class="classifier">str, int or None, optional</span></dt><dd><p>Number of bytes by which to cut up larger files. Default value is
computed based on available physical memory and the number of cores.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, use a single block for each file.
Can be a number like 64000000 or a string like “64MB”</p>
</dd>
<dt><strong>collection</strong><span class="classifier">boolean, optional</span></dt><dd><p>Return a dask.dataframe if True or list of dask.delayed objects if False</p>
</dd>
<dt><strong>sample</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bytes to use when determining dtypes</p>
</dd>
<dt><strong>assume_missing</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, all integer columns that aren’t specified in <code class="docutils literal notranslate"><span class="pre">dtype</span></code> are assumed
to contain missing values, and are converted to floats. Default is False.</p>
</dd>
<dt><strong>storage_options</strong><span class="classifier">dict, optional</span></dt><dd><p>Extra options that make sense for a particular storage connection, e.g.
host, port, username, password, etc.</p>
</dd>
<dt><strong>include_path_column</strong><span class="classifier">bool or str, optional</span></dt><dd><p>Whether or not to include the path to each particular file. If True a new
column is added to the dataframe called <code class="docutils literal notranslate"><span class="pre">path</span></code>. If str, sets new column
name. Default is False.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Extra keyword arguments to forward to <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv" title="(in pandas v1.0.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_csv()</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Dask dataframe tries to infer the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> of each column by reading a sample
from the start of the file (or of the first file if it’s a glob). Usually this
works fine, but if the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> is different later in the file (or in other
files) this can cause issues. For example, if all the rows in the sample had
integer dtypes, but later on there was a <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, then this would error at
compute time. To fix this, you have a few options:</p>
<ul class="simple">
<li><p>Provide explicit dtypes for the offending columns using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>
keyword. This is the recommended solution.</p></li>
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">assume_missing</span></code> keyword to assume that all columns inferred as
integers contain missing values, and convert them to floats.</p></li>
<li><p>Increase the size of the sample using the <code class="docutils literal notranslate"><span class="pre">sample</span></code> keyword.</p></li>
</ul>
<p>It should also be noted that this function may fail if a CSV file
includes quoted strings that contain the line terminator. To get around this
you can specify <code class="docutils literal notranslate"><span class="pre">blocksize=None</span></code> to not split files into multiple partitions,
at the cost of reduced parallelism.</p>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.read_table">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">read_table</code><span class="sig-paren">(</span><em class="sig-param">urlpath</em>, <em class="sig-param">blocksize=64000000</em>, <em class="sig-param">collection=True</em>, <em class="sig-param">lineterminator=None</em>, <em class="sig-param">compression=None</em>, <em class="sig-param">sample=256000</em>, <em class="sig-param">enforce=False</em>, <em class="sig-param">assume_missing=False</em>, <em class="sig-param">storage_options=None</em>, <em class="sig-param">include_path_column=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.read_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Read delimited files into a Dask.DataFrame</p>
<p>This parallelizes the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_table.html#pandas.read_table" title="(in pandas v1.0.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_table()</span></code></a> function in the following ways:</p>
<ul>
<li><p>It supports loading many files at once using globstrings:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="s1">&#39;myfiles.*.csv&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</li>
<li><p>In some cases it can break up large files:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="s1">&#39;largefile.csv&#39;</span><span class="p">,</span> <span class="n">blocksize</span><span class="o">=</span><span class="mf">25e6</span><span class="p">)</span>  <span class="c1"># 25MB chunks  </span>
</pre></div>
</div>
</li>
<li><p>It can read CSV files from external resources (e.g. S3, HDFS) by
providing a URL:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="s1">&#39;s3://bucket/myfiles.*.csv&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="s1">&#39;hdfs:///myfiles.*.csv&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="s1">&#39;hdfs://namenode.example.com/myfiles.*.csv&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</li>
</ul>
<p>Internally <code class="docutils literal notranslate"><span class="pre">dd.read_table</span></code> uses <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_table.html#pandas.read_table" title="(in pandas v1.0.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_table()</span></code></a> and supports many of the
same keyword arguments with the same performance guarantees. See the docstring
for <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_table.html#pandas.read_table" title="(in pandas v1.0.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_table()</span></code></a> for more information on available keyword arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>urlpath</strong><span class="classifier">string or list</span></dt><dd><p>Absolute or relative filepath(s). Prefix with a protocol like <code class="docutils literal notranslate"><span class="pre">s3://</span></code>
to read from alternative filesystems. To read from multiple files you
can pass a globstring or a list of paths, with the caveat that they
must all have the same protocol.</p>
</dd>
<dt><strong>blocksize</strong><span class="classifier">str, int or None, optional</span></dt><dd><p>Number of bytes by which to cut up larger files. Default value is
computed based on available physical memory and the number of cores.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, use a single block for each file.
Can be a number like 64000000 or a string like “64MB”</p>
</dd>
<dt><strong>collection</strong><span class="classifier">boolean, optional</span></dt><dd><p>Return a dask.dataframe if True or list of dask.delayed objects if False</p>
</dd>
<dt><strong>sample</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bytes to use when determining dtypes</p>
</dd>
<dt><strong>assume_missing</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, all integer columns that aren’t specified in <code class="docutils literal notranslate"><span class="pre">dtype</span></code> are assumed
to contain missing values, and are converted to floats. Default is False.</p>
</dd>
<dt><strong>storage_options</strong><span class="classifier">dict, optional</span></dt><dd><p>Extra options that make sense for a particular storage connection, e.g.
host, port, username, password, etc.</p>
</dd>
<dt><strong>include_path_column</strong><span class="classifier">bool or str, optional</span></dt><dd><p>Whether or not to include the path to each particular file. If True a new
column is added to the dataframe called <code class="docutils literal notranslate"><span class="pre">path</span></code>. If str, sets new column
name. Default is False.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Extra keyword arguments to forward to <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_table.html#pandas.read_table" title="(in pandas v1.0.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_table()</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Dask dataframe tries to infer the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> of each column by reading a sample
from the start of the file (or of the first file if it’s a glob). Usually this
works fine, but if the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> is different later in the file (or in other
files) this can cause issues. For example, if all the rows in the sample had
integer dtypes, but later on there was a <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, then this would error at
compute time. To fix this, you have a few options:</p>
<ul class="simple">
<li><p>Provide explicit dtypes for the offending columns using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>
keyword. This is the recommended solution.</p></li>
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">assume_missing</span></code> keyword to assume that all columns inferred as
integers contain missing values, and convert them to floats.</p></li>
<li><p>Increase the size of the sample using the <code class="docutils literal notranslate"><span class="pre">sample</span></code> keyword.</p></li>
</ul>
<p>It should also be noted that this function may fail if a delimited file
includes quoted strings that contain the line terminator. To get around this
you can specify <code class="docutils literal notranslate"><span class="pre">blocksize=None</span></code> to not split files into multiple partitions,
at the cost of reduced parallelism.</p>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.read_fwf">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">read_fwf</code><span class="sig-paren">(</span><em class="sig-param">urlpath</em>, <em class="sig-param">blocksize=64000000</em>, <em class="sig-param">collection=True</em>, <em class="sig-param">lineterminator=None</em>, <em class="sig-param">compression=None</em>, <em class="sig-param">sample=256000</em>, <em class="sig-param">enforce=False</em>, <em class="sig-param">assume_missing=False</em>, <em class="sig-param">storage_options=None</em>, <em class="sig-param">include_path_column=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.read_fwf" title="Permalink to this definition">¶</a></dt>
<dd><p>Read fixed-width files into a Dask.DataFrame</p>
<p>This parallelizes the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_fwf.html#pandas.read_fwf" title="(in pandas v1.0.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_fwf()</span></code></a> function in the following ways:</p>
<ul>
<li><p>It supports loading many files at once using globstrings:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_fwf</span><span class="p">(</span><span class="s1">&#39;myfiles.*.csv&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</li>
<li><p>In some cases it can break up large files:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_fwf</span><span class="p">(</span><span class="s1">&#39;largefile.csv&#39;</span><span class="p">,</span> <span class="n">blocksize</span><span class="o">=</span><span class="mf">25e6</span><span class="p">)</span>  <span class="c1"># 25MB chunks  </span>
</pre></div>
</div>
</li>
<li><p>It can read CSV files from external resources (e.g. S3, HDFS) by
providing a URL:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_fwf</span><span class="p">(</span><span class="s1">&#39;s3://bucket/myfiles.*.csv&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_fwf</span><span class="p">(</span><span class="s1">&#39;hdfs:///myfiles.*.csv&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_fwf</span><span class="p">(</span><span class="s1">&#39;hdfs://namenode.example.com/myfiles.*.csv&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</li>
</ul>
<p>Internally <code class="docutils literal notranslate"><span class="pre">dd.read_fwf</span></code> uses <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_fwf.html#pandas.read_fwf" title="(in pandas v1.0.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_fwf()</span></code></a> and supports many of the
same keyword arguments with the same performance guarantees. See the docstring
for <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_fwf.html#pandas.read_fwf" title="(in pandas v1.0.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_fwf()</span></code></a> for more information on available keyword arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>urlpath</strong><span class="classifier">string or list</span></dt><dd><p>Absolute or relative filepath(s). Prefix with a protocol like <code class="docutils literal notranslate"><span class="pre">s3://</span></code>
to read from alternative filesystems. To read from multiple files you
can pass a globstring or a list of paths, with the caveat that they
must all have the same protocol.</p>
</dd>
<dt><strong>blocksize</strong><span class="classifier">str, int or None, optional</span></dt><dd><p>Number of bytes by which to cut up larger files. Default value is
computed based on available physical memory and the number of cores.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, use a single block for each file.
Can be a number like 64000000 or a string like “64MB”</p>
</dd>
<dt><strong>collection</strong><span class="classifier">boolean, optional</span></dt><dd><p>Return a dask.dataframe if True or list of dask.delayed objects if False</p>
</dd>
<dt><strong>sample</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bytes to use when determining dtypes</p>
</dd>
<dt><strong>assume_missing</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, all integer columns that aren’t specified in <code class="docutils literal notranslate"><span class="pre">dtype</span></code> are assumed
to contain missing values, and are converted to floats. Default is False.</p>
</dd>
<dt><strong>storage_options</strong><span class="classifier">dict, optional</span></dt><dd><p>Extra options that make sense for a particular storage connection, e.g.
host, port, username, password, etc.</p>
</dd>
<dt><strong>include_path_column</strong><span class="classifier">bool or str, optional</span></dt><dd><p>Whether or not to include the path to each particular file. If True a new
column is added to the dataframe called <code class="docutils literal notranslate"><span class="pre">path</span></code>. If str, sets new column
name. Default is False.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Extra keyword arguments to forward to <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_fwf.html#pandas.read_fwf" title="(in pandas v1.0.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_fwf()</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Dask dataframe tries to infer the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> of each column by reading a sample
from the start of the file (or of the first file if it’s a glob). Usually this
works fine, but if the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> is different later in the file (or in other
files) this can cause issues. For example, if all the rows in the sample had
integer dtypes, but later on there was a <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, then this would error at
compute time. To fix this, you have a few options:</p>
<ul class="simple">
<li><p>Provide explicit dtypes for the offending columns using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>
keyword. This is the recommended solution.</p></li>
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">assume_missing</span></code> keyword to assume that all columns inferred as
integers contain missing values, and convert them to floats.</p></li>
<li><p>Increase the size of the sample using the <code class="docutils literal notranslate"><span class="pre">sample</span></code> keyword.</p></li>
</ul>
<p>It should also be noted that this function may fail if a fixed-width file
includes quoted strings that contain the line terminator. To get around this
you can specify <code class="docutils literal notranslate"><span class="pre">blocksize=None</span></code> to not split files into multiple partitions,
at the cost of reduced parallelism.</p>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.read_parquet">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">read_parquet</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">filters=None</em>, <em class="sig-param">categories=None</em>, <em class="sig-param">index=None</em>, <em class="sig-param">storage_options=None</em>, <em class="sig-param">engine='auto'</em>, <em class="sig-param">gather_statistics=None</em>, <em class="sig-param">split_row_groups=True</em>, <em class="sig-param">chunksize=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.read_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a Parquet file into a Dask DataFrame</p>
<p>This reads a directory of Parquet data into a Dask.dataframe, one file per
partition.  It selects the index among the sorted columns if any exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>path</strong><span class="classifier">string or list</span></dt><dd><p>Source directory for data, or path(s) to individual parquet files.
Prefix with a protocol like <code class="docutils literal notranslate"><span class="pre">s3://</span></code> to read from alternative
filesystems. To read from multiple files you can pass a globstring or a
list of paths, with the caveat that they must all have the same
protocol.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">string, list or None (default)</span></dt><dd><p>Field name(s) to read in as columns in the output. By default all
non-index fields will be read (as determined by the pandas parquet
metadata, if present). Provide a single field name instead of a list to
read in the data as a Series.</p>
</dd>
<dt><strong>filters</strong><span class="classifier">Union[List[Tuple[str, str, Any]], List[List[Tuple[str, str, Any]]]]</span></dt><dd><p>List of filters to apply, like <code class="docutils literal notranslate"><span class="pre">[[('x',</span> <span class="pre">'=',</span> <span class="pre">0),</span> <span class="pre">...],</span> <span class="pre">...]</span></code>. This
implements partition-level (hive) filtering only, i.e., to prevent the
loading of some row-groups and/or files.</p>
<p>Predicates can be expressed in disjunctive normal form (DNF). This means
that the innermost tuple describes a single column predicate. These
inner predicates are combined with an AND conjunction into a larger
predicate. The outer-most list then combines all of the combined
filters with an OR disjunction.</p>
<p>Predicates can also be expressed as a List[Tuple]. These are evaluated
as an AND conjunction. To express OR in predictates, one must use the
(preferred) List[List[Tuple]] notation.</p>
</dd>
<dt><strong>index</strong><span class="classifier">string, list, False or None (default)</span></dt><dd><p>Field name(s) to use as the output frame index. By default will be
inferred from the pandas parquet file metadata (if present). Use False
to read all fields as columns.</p>
</dd>
<dt><strong>categories</strong><span class="classifier">list, dict or None</span></dt><dd><p>For any fields listed here, if the parquet encoding is Dictionary,
the column will be created with dtype category. Use only if it is
guaranteed that the column is encoded as dictionary in all row-groups.
If a list, assumes up to 2**16-1 labels; if a dict, specify the number
of labels expected; if None, will load categories automatically for
data written by dask/fastparquet, not otherwise.</p>
</dd>
<dt><strong>storage_options</strong><span class="classifier">dict</span></dt><dd><p>Key/value pairs to be passed on to the file-system backend, if any.</p>
</dd>
<dt><strong>engine</strong><span class="classifier">{‘auto’, ‘fastparquet’, ‘pyarrow’}, default ‘auto’</span></dt><dd><p>Parquet reader library to use. If only one library is installed, it
will use that one; if both, it will use ‘fastparquet’</p>
</dd>
<dt><strong>gather_statistics</strong><span class="classifier">bool or None (default).</span></dt><dd><p>Gather the statistics for each dataset partition. By default,
this will only be done if the _metadata file is available. Otherwise,
statistics will only be gathered if True, because the footer of
every file will be parsed (which is very slow on some systems).</p>
</dd>
<dt><strong>split_row_groups</strong><span class="classifier">bool</span></dt><dd><p>If True (default) then output dataframe partitions will correspond
to parquet-file row-groups (when enough row-group metadata is
available). Otherwise, partitions correspond to distinct files.
Only the “pyarrow” engine currently supports this argument.</p>
</dd>
<dt><strong>chunksize</strong><span class="classifier">int, str</span></dt><dd><p>The target task partition size.  If set, consecutive row-groups
from the same file will be aggregated into the same output
partition until the aggregate size reaches this value.</p>
</dd>
<dt><strong>**kwargs: dict (of dicts)</strong></dt><dd><p>Passthrough key-word arguments for read backend.
The top-level keys correspond to the appropriate operation type, and
the second level corresponds to the kwargs that will be passed on to
the underlying <cite>pyarrow</cite> or <cite>fastparquet</cite> function.
Supported top-level keys: ‘dataset’ (for opening a <cite>pyarrow</cite> dataset),
‘file’ (for opening a <cite>fastparquet</cite> <cite>ParquetFile</cite>), and ‘read’ (for the
backend read function)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.to_parquet" title="dask.dataframe.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_parquet</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="s1">&#39;s3://bucket/my-parquet-data&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.read_orc">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">read_orc</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">storage_options=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.read_orc" title="Permalink to this definition">¶</a></dt>
<dd><p>Read dataframe from ORC file(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path: str or list(str)</strong></dt><dd><p>Location of file(s), which can be a full URL with protocol specifier,
and may include glob character if a single string.</p>
</dd>
<dt><strong>columns: None or list(str)</strong></dt><dd><p>Columns to load. If None, loads all.</p>
</dd>
<dt><strong>storage_options: None or dict</strong></dt><dd><p>Further parameters to pass to the bytes backend.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Dask.DataFrame (even if there is only one column)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_orc</span><span class="p">(</span><span class="s1">&#39;https://github.com/apache/orc/raw/&#39;</span>
<span class="gp">... </span>                 <span class="s1">&#39;master/examples/demo-11-zlib.orc&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.read_hdf">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">read_hdf</code><span class="sig-paren">(</span><em class="sig-param">pattern</em>, <em class="sig-param">key</em>, <em class="sig-param">start=0</em>, <em class="sig-param">stop=None</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">chunksize=1000000</em>, <em class="sig-param">sorted_index=False</em>, <em class="sig-param">lock=True</em>, <em class="sig-param">mode='a'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.read_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Read HDF files into a Dask DataFrame</p>
<p>Read hdf files into a dask dataframe. This function is like
<code class="docutils literal notranslate"><span class="pre">pandas.read_hdf</span></code>, except it can read from a single large file, or from
multiple files, or from multiple keys from the same file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pattern</strong><span class="classifier">string, pathlib.Path, list</span></dt><dd><p>File pattern (string), pathlib.Path, buffer to read from, or list of
file paths. Can contain wildcards.</p>
</dd>
<dt><strong>key</strong><span class="classifier">group identifier in the store. Can contain wildcards</span></dt><dd></dd>
<dt><strong>start</strong><span class="classifier">optional, integer (defaults to 0), row number to start at</span></dt><dd></dd>
<dt><strong>stop</strong><span class="classifier">optional, integer (defaults to None, the last row), row number to</span></dt><dd><p>stop at</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of columns, optional</span></dt><dd><p>A list of columns that if not None, will limit the return
columns (default is None)</p>
</dd>
<dt><strong>chunksize</strong><span class="classifier">positive integer, optional</span></dt><dd><p>Maximal number of rows per partition (default is 1000000).</p>
</dd>
<dt><strong>sorted_index</strong><span class="classifier">boolean, optional</span></dt><dd><p>Option to specify whether or not the input hdf files have a sorted
index (default is False).</p>
</dd>
<dt><strong>lock</strong><span class="classifier">boolean, optional</span></dt><dd><p>Option to use a lock to prevent concurrency issues (default is True).</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘a’, ‘r’, ‘r+’}, default ‘a’. Mode to use when opening file(s).</span></dt><dd><dl class="simple">
<dt>‘r’</dt><dd><p>Read-only; no data can be modified.</p>
</dd>
<dt>‘a’</dt><dd><p>Append; an existing file is opened for reading and writing,
and if the file does not exist it is created.</p>
</dd>
<dt>‘r+’</dt><dd><p>It is similar to ‘a’, but the file must already exist.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dask.DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Load single file</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">read_hdf</span><span class="p">(</span><span class="s1">&#39;myfile.1.hdf5&#39;</span><span class="p">,</span> <span class="s1">&#39;/x&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>Load multiple files</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">read_hdf</span><span class="p">(</span><span class="s1">&#39;myfile.*.hdf5&#39;</span><span class="p">,</span> <span class="s1">&#39;/x&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">read_hdf</span><span class="p">([</span><span class="s1">&#39;myfile.1.hdf5&#39;</span><span class="p">,</span> <span class="s1">&#39;myfile.2.hdf5&#39;</span><span class="p">],</span> <span class="s1">&#39;/x&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>Load multiple datasets</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">read_hdf</span><span class="p">(</span><span class="s1">&#39;myfile.1.hdf5&#39;</span><span class="p">,</span> <span class="s1">&#39;/*&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.read_json">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">read_json</code><span class="sig-paren">(</span><em class="sig-param">url_path</em>, <em class="sig-param">orient='records'</em>, <em class="sig-param">lines=None</em>, <em class="sig-param">storage_options=None</em>, <em class="sig-param">blocksize=None</em>, <em class="sig-param">sample=1048576</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='strict'</em>, <em class="sig-param">compression='infer'</em>, <em class="sig-param">meta=None</em>, <em class="sig-param">engine=&lt;function read_json&gt;</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.read_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a dataframe from a set of JSON files</p>
<p>This utilises <code class="docutils literal notranslate"><span class="pre">pandas.read_json()</span></code>, and most parameters are
passed through - see its docstring.</p>
<p>Differences: orient is ‘records’ by default, with lines=True; this
is appropriate for line-delimited “JSON-lines” data, the kind of JSON output
that is most common in big-data scenarios, and which can be chunked when
reading (see <code class="docutils literal notranslate"><span class="pre">read_json()</span></code>). All other options require blocksize=None,
i.e., one partition per input file.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>url_path: str, list of str</strong></dt><dd><p>Location to read from. If a string, can include a glob character to
find a set of file names.
Supports protocol specifications such as <code class="docutils literal notranslate"><span class="pre">&quot;s3://&quot;</span></code>.</p>
</dd>
<dt><strong>encoding, errors:</strong></dt><dd><p>The text encoding to implement, e.g., “utf-8” and how to respond
to errors in the conversion (see <code class="docutils literal notranslate"><span class="pre">str.encode()</span></code>).</p>
</dd>
<dt><strong>orient, lines, kwargs</strong></dt><dd><p>passed to pandas; if not specified, lines=True when orient=’records’,
False otherwise.</p>
</dd>
<dt><strong>storage_options: dict</strong></dt><dd><p>Passed to backend file-system implementation</p>
</dd>
<dt><strong>blocksize: None or int</strong></dt><dd><p>If None, files are not blocked, and you get one partition per input
file. If int, which can only be used for line-delimited JSON files,
each partition will be approximately this size in bytes, to the nearest
newline character.</p>
</dd>
<dt><strong>sample: int</strong></dt><dd><p>Number of bytes to pre-load, to provide an empty dataframe structure
to any blocks without data. Only relevant is using blocksize.</p>
</dd>
<dt><strong>encoding, errors:</strong></dt><dd><p>Text conversion, <code class="docutils literal notranslate"><span class="pre">see</span> <span class="pre">bytes.decode()</span></code></p>
</dd>
<dt><strong>compression</strong><span class="classifier">string or None</span></dt><dd><p>String like ‘gzip’ or ‘xz’.</p>
</dd>
<dt><strong>engine</strong><span class="classifier">function object, default <code class="docutils literal notranslate"><span class="pre">pd.read_json</span></code></span></dt><dd><p>The underlying function that dask will use to read JSON files. By
default, this will be the pandas JSON reader (<code class="docutils literal notranslate"><span class="pre">pd.read_json</span></code>).</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes and
column names of the output. This metadata is necessary for many
algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, a
<code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code> can be
provided (note that the order of the names should match the order of
the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code> can be
used. If not provided, dask will try to infer the metadata. This may
lead to unexpected results, so providing <code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For
more information, see <code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dask.DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Load single file</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="s1">&#39;myfile.1.json&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>Load multiple files</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="s1">&#39;myfile.*.json&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">read_json</span><span class="p">([</span><span class="s1">&#39;myfile.1.json&#39;</span><span class="p">,</span> <span class="s1">&#39;myfile.2.json&#39;</span><span class="p">])</span>  
</pre></div>
</div>
<p>Load large line-delimited JSON files using partitions of approx
256MB size</p>
<p>&gt;&gt; dd.read_json(‘data/file*.csv’, blocksize=2**28)</p>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.read_sql_table">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">read_sql_table</code><span class="sig-paren">(</span><em class="sig-param">table</em>, <em class="sig-param">uri</em>, <em class="sig-param">index_col</em>, <em class="sig-param">divisions=None</em>, <em class="sig-param">npartitions=None</em>, <em class="sig-param">limits=None</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">bytes_per_chunk=268435456</em>, <em class="sig-param">head_rows=5</em>, <em class="sig-param">schema=None</em>, <em class="sig-param">meta=None</em>, <em class="sig-param">engine_kwargs=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.read_sql_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Create dataframe from an SQL table.</p>
<p>If neither divisions or npartitions is given, the memory footprint of the
first few rows will be determined, and partitions of size ~256MB will
be used.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>table</strong><span class="classifier">string or sqlalchemy expression</span></dt><dd><p>Select columns from here.</p>
</dd>
<dt><strong>uri</strong><span class="classifier">string</span></dt><dd><p>Full sqlalchemy URI for the database connection</p>
</dd>
<dt><strong>index_col</strong><span class="classifier">string</span></dt><dd><p>Column which becomes the index, and defines the partitioning. Should
be a indexed column in the SQL server, and any orderable type. If the
type is number or time, then partition boundaries can be inferred from
npartitions or bytes_per_chunk; otherwide must supply explicit
<code class="docutils literal notranslate"><span class="pre">divisions=</span></code>.
<code class="docutils literal notranslate"><span class="pre">index_col</span></code> could be a function to return a value, e.g.,
<code class="docutils literal notranslate"><span class="pre">sql.func.abs(sql.column('value')).label('abs(value)')</span></code>.
<code class="docutils literal notranslate"><span class="pre">index_col=sql.func.abs(sql.column(&quot;value&quot;)).label(&quot;abs(value)&quot;)</span></code>, or
<code class="docutils literal notranslate"><span class="pre">index_col=cast(sql.column(&quot;id&quot;),types.BigInteger).label(&quot;id&quot;)</span></code> to convert
the textfield <code class="docutils literal notranslate"><span class="pre">id</span></code> to <code class="docutils literal notranslate"><span class="pre">BigInteger</span></code>.</p>
<p>Note <code class="docutils literal notranslate"><span class="pre">sql</span></code>, <code class="docutils literal notranslate"><span class="pre">cast</span></code>, <code class="docutils literal notranslate"><span class="pre">types</span></code> methods comes frome <code class="docutils literal notranslate"><span class="pre">sqlalchemy</span></code> module.</p>
<p>Labeling columns created by functions or arithmetic operations is
required.</p>
</dd>
<dt><strong>divisions: sequence</strong></dt><dd><p>Values of the index column to split the table by. If given, this will
override npartitions and bytes_per_chunk. The divisions are the value
boundaries of the index column used to define the partitions. For
example, <code class="docutils literal notranslate"><span class="pre">divisions=list('acegikmoqsuwz')</span></code> could be used to partition
a string column lexographically into 12 partitions, with the implicit
assumption that each partition contains similar numbers of records.</p>
</dd>
<dt><strong>npartitions</strong><span class="classifier">int</span></dt><dd><p>Number of partitions, if divisions is not given. Will split the values
of the index column linearly between limits, if given, or the column
max/min. The index column must be numeric or time for this to work</p>
</dd>
<dt><strong>limits: 2-tuple or None</strong></dt><dd><p>Manually give upper and lower range of values for use with npartitions;
if None, first fetches max/min from the DB. Upper limit, if
given, is inclusive.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of strings or None</span></dt><dd><p>Which columns to select; if None, gets all; can include sqlalchemy
functions, e.g.,
<code class="docutils literal notranslate"><span class="pre">sql.func.abs(sql.column('value')).label('abs(value)')</span></code>.
Labeling columns created by functions or arithmetic operations is
recommended.</p>
</dd>
<dt><strong>bytes_per_chunk</strong><span class="classifier">int</span></dt><dd><p>If both divisions and npartitions is None, this is the target size of
each partition, in bytes</p>
</dd>
<dt><strong>head_rows</strong><span class="classifier">int</span></dt><dd><p>How many rows to load for inferring the data-types, unless passing meta</p>
</dd>
<dt><strong>meta</strong><span class="classifier">empty DataFrame or None</span></dt><dd><p>If provided, do not attempt to infer dtypes, but use these, coercing
all chunks on load</p>
</dd>
<dt><strong>schema</strong><span class="classifier">str or None</span></dt><dd><p>If using a table name, pass this to sqlalchemy to select which DB
schema to use within the URI connection</p>
</dd>
<dt><strong>engine_kwargs</strong><span class="classifier">dict or None</span></dt><dd><p>Specific db engine parameters for sqlalchemy</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional parameters to pass to <cite>pd.read_sql()</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dask.dataframe</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_sql_table</span><span class="p">(</span><span class="s1">&#39;accounts&#39;</span><span class="p">,</span> <span class="s1">&#39;sqlite:///path/to/bank.db&#39;</span><span class="p">,</span>
<span class="gp">... </span>                 <span class="n">npartitions</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.from_array">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">from_array</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">chunksize=50000</em>, <em class="sig-param">columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.from_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Read any slicable array into a Dask Dataframe</p>
<p>Uses getitem syntax to pull slices out of the array.  The array need not be
a NumPy array but must support slicing syntax</p>
<blockquote>
<div><p>x[50000:100000]</p>
</div></blockquote>
<p>and have 2 dimensions:</p>
<blockquote>
<div><p>x.ndim == 2</p>
</div></blockquote>
<p>or have a record dtype:</p>
<blockquote>
<div><p>x.dtype == [(‘name’, ‘O’), (‘balance’, ‘i8’)]</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.from_pandas">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">from_pandas</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">npartitions=None</em>, <em class="sig-param">chunksize=None</em>, <em class="sig-param">sort=True</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.from_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a Dask DataFrame from a Pandas DataFrame</p>
<p>This splits an in-memory Pandas dataframe into several parts and constructs
a dask.dataframe from those parts on which Dask.dataframe can operate in
parallel.</p>
<p>Note that, despite parallelism, Dask.dataframe may not always be faster
than Pandas.  We recommend that you stay with Pandas for as long as
possible before switching to Dask.dataframe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">pandas.DataFrame or pandas.Series</span></dt><dd><p>The DataFrame/Series with which to construct a Dask DataFrame/Series</p>
</dd>
<dt><strong>npartitions</strong><span class="classifier">int, optional</span></dt><dd><p>The number of partitions of the index to create. Note that depending on
the size and index of the dataframe, the output may have fewer
partitions than requested.</p>
</dd>
<dt><strong>chunksize</strong><span class="classifier">int, optional</span></dt><dd><p>The number of rows per index partition to use.</p>
</dd>
<dt><strong>sort: bool</strong></dt><dd><p>Sort input first to obtain cleanly divided partitions or don’t sort and
don’t get cleanly divided partitions</p>
</dd>
<dt><strong>name: string, optional</strong></dt><dd><p>An optional keyname for the dataframe.  Defaults to hashing the input</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dask.DataFrame or dask.Series</strong></dt><dd><p>A dask DataFrame/Series partitioned along the index</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>TypeError</strong></dt><dd><p>If something other than a <code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pandas.Series</span></code> is
passed in.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.from_array" title="dask.dataframe.from_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_array</span></code></a></dt><dd><p>Construct a dask.DataFrame from an array that has record dtype</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.read_csv" title="dask.dataframe.read_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_csv</span></code></a></dt><dd><p>Construct a dask.DataFrame from a CSV file</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;aabbcc&#39;</span><span class="p">),</span> <span class="n">b</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))),</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="s1">&#39;20100101&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span><span class="o">.</span><span class="n">divisions</span>  
<span class="go">(Timestamp(&#39;2010-01-01 00:00:00&#39;, freq=&#39;D&#39;),</span>
<span class="go"> Timestamp(&#39;2010-01-03 00:00:00&#39;, freq=&#39;D&#39;),</span>
<span class="go"> Timestamp(&#39;2010-01-05 00:00:00&#39;, freq=&#39;D&#39;),</span>
<span class="go"> Timestamp(&#39;2010-01-06 00:00:00&#39;, freq=&#39;D&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Works with Series too!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span><span class="o">.</span><span class="n">divisions</span>  
<span class="go">(Timestamp(&#39;2010-01-01 00:00:00&#39;, freq=&#39;D&#39;),</span>
<span class="go"> Timestamp(&#39;2010-01-03 00:00:00&#39;, freq=&#39;D&#39;),</span>
<span class="go"> Timestamp(&#39;2010-01-05 00:00:00&#39;, freq=&#39;D&#39;),</span>
<span class="go"> Timestamp(&#39;2010-01-06 00:00:00&#39;, freq=&#39;D&#39;))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.from_bcolz">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">from_bcolz</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">chunksize=None</em>, <em class="sig-param">categorize=True</em>, <em class="sig-param">index=None</em>, <em class="sig-param">lock=&lt;unlocked _thread.lock object&gt;</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.from_bcolz" title="Permalink to this definition">¶</a></dt>
<dd><p>Read BColz CTable into a Dask Dataframe</p>
<p>BColz is a fast on-disk compressed column store with careful attention
given to compression.  <a class="reference external" href="https://bcolz.readthedocs.io/en/latest/">https://bcolz.readthedocs.io/en/latest/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">bcolz.ctable</span></dt><dd></dd>
<dt><strong>chunksize</strong><span class="classifier">int, optional</span></dt><dd><p>The size(rows) of blocks to pull out from ctable.</p>
</dd>
<dt><strong>categorize</strong><span class="classifier">bool, defaults to True</span></dt><dd><p>Automatically categorize all string dtypes</p>
</dd>
<dt><strong>index</strong><span class="classifier">string, optional</span></dt><dd><p>Column to make the index</p>
</dd>
<dt><strong>lock: bool or Lock</strong></dt><dd><p>Lock to use when reading or False for no lock (not-thread-safe)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.from_array" title="dask.dataframe.from_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_array</span></code></a></dt><dd><p>more generic function not optimized for bcolz</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.from_dask_array">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">from_dask_array</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.from_dask_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Dask DataFrame from a Dask Array.</p>
<p>Converts a 2d array into a DataFrame and a 1d array into a Series.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">da.Array</span></dt><dd></dd>
<dt><strong>columns</strong><span class="classifier">list or string</span></dt><dd><p>list of column names if DataFrame, single string if Series</p>
</dd>
<dt><strong>index</strong><span class="classifier">dask.dataframe.Index, optional</span></dt><dd><p>An optional <em>dask</em> Index to use for the output Series or DataFrame.</p>
<p>The default output index depends on whether <cite>x</cite> has any unknown
chunks. If there are any unknown chunks, the output has <code class="docutils literal notranslate"><span class="pre">None</span></code>
for all the divisions (one per chunk). If all the chunks are known,
a default index with known divsions is created.</p>
<p>Specifying <cite>index</cite> can be useful if you’re conforming a Dask Array
to an existing dask Series or DataFrame, and you would like the
indices to match.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.bag.to_dataframe</span></code></dt><dd><p>from dask.bag</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.dataframe._Frame.values</span></code></dt><dd><p>Reverse conversion</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.dataframe._Frame.to_records</span></code></dt><dd><p>Reverse conversion</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">from_dask_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">     a    b</span>
<span class="go">0  1.0  1.0</span>
<span class="go">1  1.0  1.0</span>
<span class="go">2  1.0  1.0</span>
<span class="go">3  1.0  1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.from_delayed">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">from_delayed</code><span class="sig-paren">(</span><em class="sig-param">dfs</em>, <em class="sig-param">meta=None</em>, <em class="sig-param">divisions=None</em>, <em class="sig-param">prefix='from-delayed'</em>, <em class="sig-param">verify_meta=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.from_delayed" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Dask DataFrame from many Dask Delayed objects</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dfs</strong><span class="classifier">list of Delayed</span></dt><dd><p>An iterable of <code class="docutils literal notranslate"><span class="pre">dask.delayed.Delayed</span></code> objects, such as come from
<code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> These comprise the individual partitions of the
resulting dataframe.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes and
column names of the output. This metadata is necessary for many
algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, a
<code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code> can be
provided (note that the order of the names should match the order of
the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code> can be
used. If not provided, dask will try to infer the metadata. This may
lead to unexpected results, so providing <code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For
more information, see <code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
<dt><strong>divisions</strong><span class="classifier">tuple, str, optional</span></dt><dd><p>Partition boundaries along the index.
For tuple, see <a class="reference external" href="https://docs.dask.org/en/latest/dataframe-design.html#partitions">https://docs.dask.org/en/latest/dataframe-design.html#partitions</a>
For string ‘sorted’ will compute the delayed values to find index
values.  Assumes that the indexes are mutually sorted.
If None, then won’t use index information</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">str, optional</span></dt><dd><p>Prefix to prepend to the keys.</p>
</dd>
<dt><strong>verify_meta</strong><span class="classifier">bool, optional</span></dt><dd><p>If True check that the partitions have consistent metadata, defaults to True.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.to_records">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">to_records</code><span class="sig-paren">(</span><em class="sig-param">df</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.to_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Dask Array from a Dask Dataframe</p>
<p>Warning: This creates a dask.array without precise shape information.
Operations that depend on shape information, like slicing or reshaping,
will not work.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.dataframe._Frame.values</span></code>, <a class="reference internal" href="#dask.dataframe.from_dask_array" title="dask.dataframe.from_dask_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.dataframe.from_dask_array</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_records</span><span class="p">()</span>  
<span class="go">dask.array&lt;to_records, shape=(nan,), dtype=(numpy.record, [(&#39;ind&#39;, &#39;&lt;f8&#39;), (&#39;x&#39;, &#39;O&#39;), (&#39;y&#39;, &#39;&lt;i8&#39;)]), chunksize=(nan,), chunktype=numpy.ndarray&gt;  # noqa: E501</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.to_csv">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">to_csv</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">filename</em>, <em class="sig-param">single_file=False</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">mode='wt'</em>, <em class="sig-param">name_function=None</em>, <em class="sig-param">compression=None</em>, <em class="sig-param">compute=True</em>, <em class="sig-param">scheduler=None</em>, <em class="sig-param">storage_options=None</em>, <em class="sig-param">header_first_partition_only=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.to_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Store Dask DataFrame to CSV files</p>
<p>One filename per partition will be created. You can specify the
filenames in a variety of ways.</p>
<p>Use a globstring:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;/path/to/data/export-*.csv&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>The * will be replaced by the increasing sequence 0, 1, 2, …</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">export</span><span class="o">-</span><span class="mf">0.</span><span class="n">csv</span>
<span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">export</span><span class="o">-</span><span class="mf">1.</span><span class="n">csv</span>
</pre></div>
</div>
<p>Use a globstring and a <code class="docutils literal notranslate"><span class="pre">name_function=</span></code> keyword argument.  The
name_function function should expect an integer and produce a string.
Strings produced by name_function must preserve the order of their
respective partition indices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">date</span><span class="p">(</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;2015-01-01&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="go">&#39;2015-01-16&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;/path/to/data/export-*.csv&#39;</span><span class="p">,</span> <span class="n">name_function</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>  
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">export</span><span class="o">-</span><span class="mi">2015</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mf">01.</span><span class="n">csv</span>
<span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">export</span><span class="o">-</span><span class="mi">2015</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mf">02.</span><span class="n">csv</span>
<span class="o">...</span>
</pre></div>
</div>
<p>You can also provide an explicit list of paths:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;/path/to/data/alice.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;/path/to/data/bob.csv&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> 
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">string</span></dt><dd><p>Path glob indicating the naming scheme for the output files</p>
</dd>
<dt><strong>name_function</strong><span class="classifier">callable, default None</span></dt><dd><p>Function accepting an integer (partition index) and producing a
string to replace the asterisk in the given filename globstring.
Should preserve the lexicographic order of partitions. Not
supported when <cite>single_file</cite> is <cite>True</cite>.</p>
</dd>
<dt><strong>single_file</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether to save everything into a single CSV file. Under the
single file mode, each partition is appended at the end of the
specified CSV file. Note that not all filesystems support the
append mode and thus the single file mode, especially on cloud
storage systems such as S3 or GCS. A warning will be issued when
writing to a file that is not backed by a local filesystem.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">string or None</span></dt><dd><p>String like ‘gzip’ or ‘xz’.  Must support efficient random access.
Filenames with extensions corresponding to known compression
algorithms (gz, bz2) will be compressed accordingly automatically</p>
</dd>
<dt><strong>sep</strong><span class="classifier">character, default ‘,’</span></dt><dd><p>Field delimiter for the output file</p>
</dd>
<dt><strong>na_rep</strong><span class="classifier">string, default ‘’</span></dt><dd><p>Missing data representation</p>
</dd>
<dt><strong>float_format</strong><span class="classifier">string, default None</span></dt><dd><p>Format string for floating point numbers</p>
</dd>
<dt><strong>columns</strong><span class="classifier">sequence, optional</span></dt><dd><p>Columns to write</p>
</dd>
<dt><strong>header</strong><span class="classifier">boolean or list of string, default True</span></dt><dd><p>Write out column names. If a list of string is given it is assumed
to be aliases for the column names</p>
</dd>
<dt><strong>header_first_partition_only</strong><span class="classifier">boolean, default None</span></dt><dd><p>If set to <cite>True</cite>, only write the header row in the first output
file. By default, headers are written to all partitions under
the multiple file mode (<cite>single_file</cite> is <cite>False</cite>) and written
only once under the single file mode (<cite>single_file</cite> is <cite>True</cite>).
It must not be <cite>False</cite> under the single file mode.</p>
</dd>
<dt><strong>index</strong><span class="classifier">boolean, default True</span></dt><dd><p>Write row names (index)</p>
</dd>
<dt><strong>index_label</strong><span class="classifier">string or sequence, or False, default None</span></dt><dd><p>Column label for index column(s) if desired. If None is given, and
<cite>header</cite> and <cite>index</cite> are True, then the index names are used. A
sequence should be given if the DataFrame uses MultiIndex.  If
False do not print fields for index names. Use index_label=False
for easier importing in R</p>
</dd>
<dt><strong>nanRep</strong><span class="classifier">None</span></dt><dd><p>deprecated, use na_rep</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str</span></dt><dd><p>Python write mode, default ‘w’</p>
</dd>
<dt><strong>encoding</strong><span class="classifier">string, optional</span></dt><dd><p>A string representing the encoding to use in the output file,
defaults to ‘ascii’ on Python 2 and ‘utf-8’ on Python 3.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">string, optional</span></dt><dd><p>a string representing the compression to use in the output file,
allowed values are ‘gzip’, ‘bz2’, ‘xz’,
only used when the first argument is a filename</p>
</dd>
<dt><strong>line_terminator</strong><span class="classifier">string, default ‘n’</span></dt><dd><p>The newline character or character sequence to use in the output
file</p>
</dd>
<dt><strong>quoting</strong><span class="classifier">optional constant from csv module</span></dt><dd><p>defaults to csv.QUOTE_MINIMAL</p>
</dd>
<dt><strong>quotechar</strong><span class="classifier">string (length 1), default ‘”’</span></dt><dd><p>character used to quote fields</p>
</dd>
<dt><strong>doublequote</strong><span class="classifier">boolean, default True</span></dt><dd><p>Control quoting of <cite>quotechar</cite> inside a field</p>
</dd>
<dt><strong>escapechar</strong><span class="classifier">string (length 1), default None</span></dt><dd><p>character used to escape <cite>sep</cite> and <cite>quotechar</cite> when appropriate</p>
</dd>
<dt><strong>chunksize</strong><span class="classifier">int or None</span></dt><dd><p>rows to write at a time</p>
</dd>
<dt><strong>tupleize_cols</strong><span class="classifier">boolean, default False</span></dt><dd><p>write multi_index columns as a list of tuples (if True)
or new (expanded format) if False)</p>
</dd>
<dt><strong>date_format</strong><span class="classifier">string, default None</span></dt><dd><p>Format string for datetime objects</p>
</dd>
<dt><strong>decimal: string, default ‘.’</strong></dt><dd><p>Character recognized as decimal separator. E.g. use ‘,’ for
European data</p>
</dd>
<dt><strong>storage_options: dict</strong></dt><dd><p>Parameters passed on to the backend filesystem class.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>The names of the file written if they were computed right away</strong></dt><dd></dd>
<dt><strong>If not, the delayed tasks associated to the writing of the files</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If <cite>header_first_partition_only</cite> is set to <cite>False</cite> or
<cite>name_function</cite> is specified when <cite>single_file</cite> is <cite>True</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.to_bag">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">to_bag</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.to_bag" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Dask Bag from a Dask DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the elements are tuples of <code class="docutils literal notranslate"><span class="pre">(index,</span> <span class="pre">value)</span></code>, otherwise
they’re just the <code class="docutils literal notranslate"><span class="pre">value</span></code>.  Default is False.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bag</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_bag</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.to_hdf">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">to_hdf</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">path</em>, <em class="sig-param">key</em>, <em class="sig-param">mode='a'</em>, <em class="sig-param">append=False</em>, <em class="sig-param">scheduler=None</em>, <em class="sig-param">name_function=None</em>, <em class="sig-param">compute=True</em>, <em class="sig-param">lock=None</em>, <em class="sig-param">dask_kwargs={}</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Store Dask Dataframe to Hierarchical Data Format (HDF) files</p>
<p>This is a parallel version of the Pandas function of the same name.  Please
see the Pandas docstring for more detailed information about shared keyword
arguments.</p>
<p>This function differs from the Pandas version by saving the many partitions
of a Dask DataFrame in parallel, either to many files, or to many datasets
within the same file.  You may specify this parallelism with an asterix
<code class="docutils literal notranslate"><span class="pre">*</span></code> within the filename or datapath, and an optional <code class="docutils literal notranslate"><span class="pre">name_function</span></code>.
The asterix will be replaced with an increasing sequence of integers
starting from <code class="docutils literal notranslate"><span class="pre">0</span></code> or with the result of calling <code class="docutils literal notranslate"><span class="pre">name_function</span></code> on each
of those integers.</p>
<p>This function only supports the Pandas <code class="docutils literal notranslate"><span class="pre">'table'</span></code> format, not the more
specialized <code class="docutils literal notranslate"><span class="pre">'fixed'</span></code> format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">string, pathlib.Path</span></dt><dd><p>Path to a target filename. Supports strings, <code class="docutils literal notranslate"><span class="pre">pathlib.Path</span></code>, or any
object implementing the <code class="docutils literal notranslate"><span class="pre">__fspath__</span></code> protocol. May contain a <code class="docutils literal notranslate"><span class="pre">*</span></code> to
denote many filenames.</p>
</dd>
<dt><strong>key</strong><span class="classifier">string</span></dt><dd><p>Datapath within the files.  May contain a <code class="docutils literal notranslate"><span class="pre">*</span></code> to denote many locations</p>
</dd>
<dt><strong>name_function</strong><span class="classifier">function</span></dt><dd><p>A function to convert the <code class="docutils literal notranslate"><span class="pre">*</span></code> in the above options to a string.
Should take in a number from 0 to the number of partitions and return a
string. (see examples below)</p>
</dd>
<dt><strong>compute</strong><span class="classifier">bool</span></dt><dd><p>Whether or not to execute immediately.  If False then this returns a
<code class="docutils literal notranslate"><span class="pre">dask.Delayed</span></code> value.</p>
</dd>
<dt><strong>lock</strong><span class="classifier">Lock, optional</span></dt><dd><p>Lock to use to prevent concurrency issues.  By default a
<code class="docutils literal notranslate"><span class="pre">threading.Lock</span></code>, <code class="docutils literal notranslate"><span class="pre">multiprocessing.Lock</span></code> or <code class="docutils literal notranslate"><span class="pre">SerializableLock</span></code>
will be used depending on your scheduler if a lock is required. See
dask.utils.get_scheduler_lock for more information about lock
selection.</p>
</dd>
<dt><strong>scheduler</strong><span class="classifier">string</span></dt><dd><p>The scheduler to use, like “threads” or “processes”</p>
</dd>
<dt><strong>**other:</strong></dt><dd><p>See pandas.to_hdf for more information</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filenames</strong><span class="classifier">list</span></dt><dd><p>Returned if <code class="docutils literal notranslate"><span class="pre">compute</span></code> is True. List of file names that each partition
is saved to.</p>
</dd>
<dt><strong>delayed</strong><span class="classifier">dask.Delayed</span></dt><dd><p>Returned if <code class="docutils literal notranslate"><span class="pre">compute</span></code> is False. Delayed object to execute <code class="docutils literal notranslate"><span class="pre">to_hdf</span></code>
when computed.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.read_hdf" title="dask.dataframe.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_hdf</span></code></a>, <a class="reference internal" href="#dask.dataframe.to_parquet" title="dask.dataframe.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_parquet</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Save Data to a single file</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;output.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data&#39;</span><span class="p">)</span>            
</pre></div>
</div>
<p>Save data to multiple datapaths within the same file:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;output.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data-*&#39;</span><span class="p">)</span>          
</pre></div>
</div>
<p>Save data to multiple files:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;output-*.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data&#39;</span><span class="p">)</span>          
</pre></div>
</div>
<p>Save data to multiple files, using the multiprocessing scheduler:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;output-*.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data&#39;</span><span class="p">,</span> <span class="n">scheduler</span><span class="o">=</span><span class="s1">&#39;processes&#39;</span><span class="p">)</span> 
</pre></div>
</div>
<p>Specify custom naming scheme.  This writes files as
‘2000-01-01.hdf’, ‘2000-01-02.hdf’, ‘2000-01-03.hdf’, etc..</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">base</span> <span class="o">=</span> <span class="n">date</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">name_function</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&#39;&#39;&#39; Convert integer 0 to n to a string &#39;&#39;&#39;</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">base</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;*.hdf&#39;</span><span class="p">,</span> <span class="s1">&#39;/data&#39;</span><span class="p">,</span> <span class="n">name_function</span><span class="o">=</span><span class="n">name_function</span><span class="p">)</span> 
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.to_parquet">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">to_parquet</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">path</em>, <em class="sig-param">engine='auto'</em>, <em class="sig-param">compression='default'</em>, <em class="sig-param">write_index=True</em>, <em class="sig-param">append=False</em>, <em class="sig-param">ignore_divisions=False</em>, <em class="sig-param">partition_on=None</em>, <em class="sig-param">storage_options=None</em>, <em class="sig-param">write_metadata_file=True</em>, <em class="sig-param">compute=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.to_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Store Dask.dataframe to Parquet files</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">dask.dataframe.DataFrame</span></dt><dd></dd>
<dt><strong>path</strong><span class="classifier">string or pathlib.Path</span></dt><dd><p>Destination directory for data.  Prepend with protocol like <code class="docutils literal notranslate"><span class="pre">s3://</span></code>
or <code class="docutils literal notranslate"><span class="pre">hdfs://</span></code> for remote data.</p>
</dd>
<dt><strong>engine</strong><span class="classifier">{‘auto’, ‘fastparquet’, ‘pyarrow’}, default ‘auto’</span></dt><dd><p>Parquet library to use. If only one library is installed, it will use
that one; if both, it will use ‘fastparquet’.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">string or dict, optional</span></dt><dd><p>Either a string like <code class="docutils literal notranslate"><span class="pre">&quot;snappy&quot;</span></code> or a dictionary mapping column names
to compressors like <code class="docutils literal notranslate"><span class="pre">{&quot;name&quot;:</span> <span class="pre">&quot;gzip&quot;,</span> <span class="pre">&quot;values&quot;:</span> <span class="pre">&quot;snappy&quot;}</span></code>. The
default is <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code>, which uses the default compression for
whichever engine is selected.</p>
</dd>
<dt><strong>write_index</strong><span class="classifier">boolean, optional</span></dt><dd><p>Whether or not to write the index. Defaults to True.</p>
</dd>
<dt><strong>append</strong><span class="classifier">bool, optional</span></dt><dd><p>If False (default), construct data-set from scratch. If True, add new
row-group(s) to an existing data-set. In the latter case, the data-set
must exist, and the schema must match the input data.</p>
</dd>
<dt><strong>ignore_divisions</strong><span class="classifier">bool, optional</span></dt><dd><p>If False (default) raises error when previous divisions overlap with
the new appended divisions. Ignored if append=False.</p>
</dd>
<dt><strong>partition_on</strong><span class="classifier">list, optional</span></dt><dd><p>Construct directory-based partitioning by splitting on these fields’
values. Each dask partition will result in one or more datafiles,
there will be no global groupby.</p>
</dd>
<dt><strong>storage_options</strong><span class="classifier">dict, optional</span></dt><dd><p>Key/value pairs to be passed on to the file-system backend, if any.</p>
</dd>
<dt><strong>write_metadata_file</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to write the special “_metadata” file.</p>
</dd>
<dt><strong>compute</strong><span class="classifier">bool, optional</span></dt><dd><p>If True (default) then the result is computed immediately. If False
then a <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> object is returned for future computation.</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Extra options to be passed on to the specific backend.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.read_parquet" title="dask.dataframe.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_parquet</span></code></a></dt><dd><p>Read parquet data to dask.dataframe</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Each partition will be written to a separate file.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s1">&#39;/path/to/output/&#39;</span><span class="p">,</span><span class="o">...</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.to_json">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">to_json</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">url_path</em>, <em class="sig-param">orient='records'</em>, <em class="sig-param">lines=None</em>, <em class="sig-param">storage_options=None</em>, <em class="sig-param">compute=True</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='strict'</em>, <em class="sig-param">compression=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Write dataframe into JSON text files</p>
<p>This utilises <code class="docutils literal notranslate"><span class="pre">pandas.DataFrame.to_json()</span></code>, and most parameters are
passed through - see its docstring.</p>
<p>Differences: orient is ‘records’ by default, with lines=True; this
produces the kind of JSON output that is most common in big-data
applications, and which can be chunked when reading (see <code class="docutils literal notranslate"><span class="pre">read_json()</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: dask.DataFrame</strong></dt><dd><p>Data to save</p>
</dd>
<dt><strong>url_path: str, list of str</strong></dt><dd><p>Location to write to. If a string, and there are more than one
partitions in df, should include a glob character to expand into a
set of file names, or provide a <code class="docutils literal notranslate"><span class="pre">name_function=</span></code> parameter.
Supports protocol specifications such as <code class="docutils literal notranslate"><span class="pre">&quot;s3://&quot;</span></code>.</p>
</dd>
<dt><strong>encoding, errors:</strong></dt><dd><p>The text encoding to implement, e.g., “utf-8” and how to respond
to errors in the conversion (see <code class="docutils literal notranslate"><span class="pre">str.encode()</span></code>).</p>
</dd>
<dt><strong>orient, lines, kwargs</strong></dt><dd><p>passed to pandas; if not specified, lines=True when orient=’records’,
False otherwise.</p>
</dd>
<dt><strong>storage_options: dict</strong></dt><dd><p>Passed to backend file-system implementation</p>
</dd>
<dt><strong>compute: bool</strong></dt><dd><p>If true, immediately executes. If False, returns a set of delayed
objects, which can be computed at a later time.</p>
</dd>
<dt><strong>encoding, errors:</strong></dt><dd><p>Text conversion, <code class="docutils literal notranslate"><span class="pre">see</span> <span class="pre">str.encode()</span></code></p>
</dd>
<dt><strong>compression</strong><span class="classifier">string or None</span></dt><dd><p>String like ‘gzip’ or ‘xz’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.to_sql">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">to_sql</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">name: str</em>, <em class="sig-param">con</em>, <em class="sig-param">schema=None</em>, <em class="sig-param">if_exists: str = 'fail'</em>, <em class="sig-param">index: bool = True</em>, <em class="sig-param">index_label=None</em>, <em class="sig-param">chunksize=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">method=None</em>, <em class="sig-param">compute=True</em>, <em class="sig-param">parallel=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.to_sql" title="Permalink to this definition">¶</a></dt>
<dd><p>Store Dask Dataframe to a SQL table</p>
<p>An empty table is created based on the “meta” DataFrame (and conforming to the caller’s “if_exists” preference), and
then each block calls pd.DataFrame.to_sql (with <cite>if_exists=”append”</cite>).</p>
<p>Databases supported by SQLAlchemy <a class="reference internal" href="#r62277b28829f-1" id="id4">[1]</a> are supported. Tables can be
newly created, appended to, or overwritten.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of SQL table.</p>
</dd>
<dt><strong>con</strong><span class="classifier">sqlalchemy.engine.Engine or sqlite3.Connection</span></dt><dd><p>Using SQLAlchemy makes it possible to use any DB supported by that
library. Legacy support is provided for sqlite3.Connection objects. The user
is responsible for engine disposal and connection closure for the SQLAlchemy
connectable See <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/connections.html">here</a>.</p>
</dd>
<dt><strong>schema</strong><span class="classifier">str, optional</span></dt><dd><p>Specify the schema (if database flavor supports this). If None, use
default schema.</p>
</dd>
<dt><strong>if_exists</strong><span class="classifier">{‘fail’, ‘replace’, ‘append’}, default ‘fail’</span></dt><dd><p>How to behave if the table already exists.</p>
<ul class="simple">
<li><p>fail: Raise a ValueError.</p></li>
<li><p>replace: Drop the table before inserting new values.</p></li>
<li><p>append: Insert new values to the existing table.</p></li>
</ul>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Write DataFrame index as a column. Uses <cite>index_label</cite> as the column
name in the table.</p>
</dd>
<dt><strong>index_label</strong><span class="classifier">str or sequence, default None</span></dt><dd><p>Column label for index column(s). If None is given (default) and
<cite>index</cite> is True, then the index names are used.
A sequence should be given if the DataFrame uses MultiIndex.</p>
</dd>
<dt><strong>chunksize</strong><span class="classifier">int, optional</span></dt><dd><p>Specify the number of rows in each batch to be written at a time.
By default, all rows will be written at once.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dict or scalar, optional</span></dt><dd><p>Specifying the datatype for columns. If a dictionary is used, the
keys should be the column names and the values should be the
SQLAlchemy types or strings for the sqlite3 legacy mode. If a
scalar is provided, it will be applied to all columns.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{None, ‘multi’, callable}, optional</span></dt><dd><p>Controls the SQL insertion clause used:</p>
<ul class="simple">
<li><p>None : Uses standard SQL <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> clause (one per row).</p></li>
<li><p>‘multi’: Pass multiple values in a single <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> clause.</p></li>
<li><p>callable with signature <code class="docutils literal notranslate"><span class="pre">(pd_table,</span> <span class="pre">conn,</span> <span class="pre">keys,</span> <span class="pre">data_iter)</span></code>.</p></li>
</ul>
<p>Details and a sample callable implementation can be found in the
section <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-sql-method" title="(in pandas v1.0.3)"><span class="xref std std-ref">insert method</span></a>.</p>
</dd>
<dt><strong>compute</strong><span class="classifier">bool, default True</span></dt><dd><p>When true, call dask.compute and perform the load into SQL; otherwise, return a Dask object (or array of
per-block objects when parallel=True)</p>
</dd>
<dt><strong>parallel</strong><span class="classifier">bool, default False</span></dt><dd><p>When true, have each block append itself to the DB table concurrently. This can result in DB rows being in a
different order than the source DataFrame’s corresponding rows. When false, load each block into the SQL DB in
sequence.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>When the table already exists and <cite>if_exists</cite> is ‘fail’ (the
default).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_sql</span></code></dt><dd><p>Read a DataFrame from a table.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Timezone aware datetime columns will be written as
<code class="docutils literal notranslate"><span class="pre">Timestamp</span> <span class="pre">with</span> <span class="pre">timezone</span></code> type with SQLAlchemy if supported by the
database. Otherwise, the datetimes will be stored as timezone unaware
timestamps local to the original timezone.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0.</span></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r62277b28829f-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id5">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://docs.sqlalchemy.org">https://docs.sqlalchemy.org</a></p>
</dd>
<dt class="label" id="r62277b28829f-2"><span class="brackets"><a class="fn-backref" href="#id6">2</a></span></dt>
<dd><p><a class="reference external" href="https://www.python.org/dev/peps/pep-0249/">https://www.python.org/dev/peps/pep-0249/</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Create an in-memory SQLite database.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite://&#39;</span><span class="p">,</span> <span class="n">echo</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a table from scratch with 3 rows.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;User 1&#39;</span><span class="p">,</span> <span class="s1">&#39;User 2&#39;</span><span class="p">,</span> <span class="s1">&#39;User 3&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">     name</span>
<span class="go">0  User 1</span>
<span class="go">1  User 2</span>
<span class="go">2  User 3</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,</span> <span class="n">con</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM users&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class="go">[(0, &#39;User 1&#39;), (1, &#39;User 2&#39;), (2, &#39;User 3&#39;)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;User 4&#39;</span><span class="p">,</span> <span class="s1">&#39;User 5&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,</span> <span class="n">con</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM users&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class="go">[(0, &#39;User 1&#39;), (1, &#39;User 2&#39;), (2, &#39;User 3&#39;),</span>
<span class="go"> (0, &#39;User 4&#39;), (1, &#39;User 5&#39;)]</span>
</pre></div>
</div>
<p>Overwrite the table with just <code class="docutils literal notranslate"><span class="pre">df1</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,</span> <span class="n">con</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">index_label</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM users&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class="go">[(0, &#39;User 4&#39;), (1, &#39;User 5&#39;)]</span>
</pre></div>
</div>
<p>Specify the dtype (especially useful for integers with missing values).
Notice that while pandas is forced to store the data as floating point,
the database supports nullable integers. When fetching the data with
Python, we get back integer scalars.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">     A</span>
<span class="go">0  1.0</span>
<span class="go">1  NaN</span>
<span class="go">2  2.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.types</span> <span class="kn">import</span> <span class="n">Integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="s1">&#39;integers&#39;</span><span class="p">,</span> <span class="n">con</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="gp">... </span>          <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="n">Integer</span><span class="p">()})</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM integers&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class="go">[(1,), (None,), (2,)]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="rolling">
<h2>Rolling<a class="headerlink" href="#rolling" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="dask.dataframe.rolling.map_overlap">
<code class="sig-prename descclassname">dask.dataframe.rolling.</code><code class="sig-name descname">map_overlap</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">df</em>, <em class="sig-param">before</em>, <em class="sig-param">after</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.rolling.map_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to each partition, sharing rows with adjacent partitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function applied to each partition.</p>
</dd>
<dt><strong>df</strong><span class="classifier">dd.DataFrame, dd.Series</span></dt><dd></dd>
<dt><strong>before</strong><span class="classifier">int or timedelta</span></dt><dd><p>The rows to prepend to partition <code class="docutils literal notranslate"><span class="pre">i</span></code> from the end of
partition <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>after</strong><span class="classifier">int or timedelta</span></dt><dd><p>The rows to append to partition <code class="docutils literal notranslate"><span class="pre">i</span></code> from the beginning
of partition <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>args, kwargs :</strong></dt><dd><p>Arguments and keywords to pass to the function. The partition will
be the first argument, and these will be passed <em>after</em>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dd.DataFrame.map_overlap</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="resampling">
<h2>Resampling<a class="headerlink" href="#resampling" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dask.dataframe.tseries.resample.Resampler">
<em class="property">class </em><code class="sig-prename descclassname">dask.dataframe.tseries.resample.</code><code class="sig-name descname">Resampler</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">rule</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for resampling timeseries data.</p>
<p>This class is commonly encountered when using <code class="docutils literal notranslate"><span class="pre">obj.resample(...)</span></code> which
return <code class="docutils literal notranslate"><span class="pre">Resampler</span></code> objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">Dask DataFrame or Series</span></dt><dd><p>Data to be resampled.</p>
</dd>
<dt><strong>rule</strong><span class="classifier">str, tuple, datetime.timedelta, DateOffset or None</span></dt><dd><p>The offset string or object representing the target conversion.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">optional</span></dt><dd><p>Keyword arguments passed to underlying pandas resampling function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Resampler instance of the appropriate type</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.agg">
<code class="sig-name descname">agg</code><span class="sig-paren">(</span><em class="sig-param">agg_funcs</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.agg" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate using one or more operations over the specified axis.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.agg.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>func</strong><span class="classifier">function, str, list or dict  (Not supported in Dask)</span></dt><dd><p>Function to use for aggregating the data. If a function, must either
work when passed a DataFrame or when passed to DataFrame.apply.</p>
<p>Accepted combinations are:</p>
<ul class="simple">
<li><p>function</p></li>
<li><p>string function name</p></li>
<li><p>list of functions and/or function names, e.g. <code class="docutils literal notranslate"><span class="pre">[np.sum,</span> <span class="pre">'mean']</span></code></p></li>
<li><p>dict of axis labels -&gt; functions, function names or list of such.</p></li>
</ul>
</dd>
<dt><strong>*args</strong></dt><dd><p>Positional arguments to pass to <cite>func</cite>.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Keyword arguments to pass to <cite>func</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>scalar, Series or DataFrame</strong></dt><dd><p>The return can be:</p>
<ul class="simple">
<li><p>scalar : when Series.agg is called with single function</p></li>
<li><p>Series : when DataFrame.agg is called with a single function</p></li>
<li><p>DataFrame : when DataFrame.agg is called with several functions</p></li>
</ul>
<p>Return scalar, Series or DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby.aggregate</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.resample.transform</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.aggregate</span></code></p>
</div>
<p class="rubric">Notes</p>
<p><cite>agg</cite> is an alias for <cite>aggregate</cite>. Use the alias.</p>
<p>A passed user-defined-function will be passed a Series for evaluation.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>  
<span class="go">                  index=pd.date_range(&#39;20130101&#39;, periods=5,freq=&#39;s&#39;))</span>
<span class="go">2013-01-01 00:00:00    1</span>
<span class="go">2013-01-01 00:00:01    2</span>
<span class="go">2013-01-01 00:00:02    3</span>
<span class="go">2013-01-01 00:00:03    4</span>
<span class="go">2013-01-01 00:00:04    5</span>
<span class="go">Freq: S, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;2s&#39;</span><span class="p">)</span>  
<span class="go">DatetimeIndexResampler [freq=&lt;2 * Seconds&gt;, axis=0, closed=left,</span>
<span class="go">                        label=left, convention=start, base=0]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">)</span>  
<span class="go">2013-01-01 00:00:00    3</span>
<span class="go">2013-01-01 00:00:02    7</span>
<span class="go">2013-01-01 00:00:04    5</span>
<span class="go">Freq: 2S, dtype: int64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span><span class="s1">&#39;max&#39;</span><span class="p">])</span>  
<span class="go">                     sum  mean  max</span>
<span class="go">2013-01-01 00:00:00    3   1.5    2</span>
<span class="go">2013-01-01 00:00:02    7   3.5    4</span>
<span class="go">2013-01-01 00:00:04    5   5.0    5</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">&#39;result&#39;</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">(),</span>  
<span class="go">           &#39;total&#39; : np.sum})</span>
<span class="go">                     total    result</span>
<span class="go">2013-01-01 00:00:00      3  2.121320</span>
<span class="go">2013-01-01 00:00:02      7  4.949747</span>
<span class="go">2013-01-01 00:00:04      5       NaN</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute count of group, excluding missing values.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.count.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Count of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.first">
<code class="sig-name descname">first</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.first" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute first of group values.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.first.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed first of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.last">
<code class="sig-name descname">last</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.last" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute last of group values.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.last.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed last of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute max of group values.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.max.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed max of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mean of groups, excluding missing values.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.mean.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pandas.Series or pandas.DataFrame</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>  
<span class="gp">... </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Groupby one column and return the mean of the remaining columns in
each group.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">     B         C</span>
<span class="go">A</span>
<span class="go">1  3.0  1.333333</span>
<span class="go">2  4.0  1.500000</span>
</pre></div>
</div>
<p>Groupby two columns and return the mean of the remaining column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">       C</span>
<span class="go">A B</span>
<span class="go">1 2.0  2</span>
<span class="go">  4.0  1</span>
<span class="go">2 3.0  1</span>
<span class="go">  5.0  2</span>
</pre></div>
</div>
<p>Groupby one column and return the mean of only particular column in
the group.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
<span class="go">A</span>
<span class="go">1    3.0</span>
<span class="go">2    4.0</span>
<span class="go">Name: B, dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.median">
<code class="sig-name descname">median</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute median of groups, excluding missing values.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.median.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>For multiple groupings, the result index will be a MultiIndex</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Median of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute min of group values.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.min.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed min of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.nunique">
<code class="sig-name descname">nunique</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.nunique" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of unique elements in the group.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.nunique.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Number of unique values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.ohlc">
<code class="sig-name descname">ohlc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute sum of values, excluding missing values.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.ohlc.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>For multiple groupings, the result index will be a MultiIndex</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Open, high, low and close values within each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.prod">
<code class="sig-name descname">prod</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute prod of group values.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.prod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed prod of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.quantile">
<code class="sig-name descname">quantile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value at the given quantile.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.quantile.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q</strong><span class="classifier">float or array-like, default 0.5 (50% quantile)  (Not supported in Dask)</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame or Series</strong></dt><dd><p>Quantile of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.quantile</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.quantile</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrameGroupBy.quantile</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.sem">
<code class="sig-name descname">sem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.sem" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute standard error of the mean of groups, excluding missing values.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.sem.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>For multiple groupings, the result index will be a MultiIndex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ddof</strong><span class="classifier">int, default 1</span></dt><dd><p>Degrees of freedom.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Standard error of the mean of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.size">
<code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute group sizes.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.size.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series</strong></dt><dd><p>Number of rows in each group.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.groupby</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.groupby</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute standard deviation of groups, excluding missing values.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.std.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ddof</strong><span class="classifier">int, default 1  (Not supported in Dask)</span></dt><dd><p>Degrees of freedom.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame or Series</strong></dt><dd><p>Standard deviation of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute sum of group values.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.sum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Series or DataFrame</strong></dt><dd><p>Computed sum of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.dataframe.tseries.resample.Resampler.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.tseries.resample.Resampler.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute variance of groups, excluding missing values.</p>
<p>This docstring was copied from pandas.core.resample.Resampler.var.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ddof</strong><span class="classifier">int, default 1  (Not supported in Dask)</span></dt><dd><p>Degrees of freedom.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame or Series</strong></dt><dd><p>Variance of values within each group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="dask-metadata">
<h2>Dask Metadata<a class="headerlink" href="#dask-metadata" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="dask.dataframe.utils.make_meta">
<code class="sig-prename descclassname">dask.dataframe.utils.</code><code class="sig-name descname">make_meta</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.utils.make_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an empty pandas object containing the desired metadata.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">dict, tuple, list, pd.Series, pd.DataFrame, pd.Index, dtype, scalar</span></dt><dd><p>To create a DataFrame, provide a <cite>dict</cite> mapping of <cite>{name: dtype}</cite>, or
an iterable of <cite>(name, dtype)</cite> tuples. To create a <cite>Series</cite>, provide a
tuple of <cite>(name, dtype)</cite>. If a pandas object, names, dtypes, and index
should match the desired output. If a dtype or scalar, a scalar of the
same dtype is returned.</p>
</dd>
<dt><strong>index</strong><span class="classifier">pd.Index, optional</span></dt><dd><p>Any pandas index to use in the metadata. If none provided, a
<cite>RangeIndex</cite> will be used.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">make_meta</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;i8&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">)])</span>
<span class="go">Empty DataFrame</span>
<span class="go">Columns: [a, b]</span>
<span class="go">Index: []</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">make_meta</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;f8&#39;</span><span class="p">))</span>
<span class="go">Series([], Name: a, dtype: float64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">make_meta</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="other-functions">
<h2>Other functions<a class="headerlink" href="#other-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="dask.dataframe.compute">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">compute</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute several dask collections at once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">object</span></dt><dd><p>Any number of objects. If it is a dask object, it’s computed and the
result is returned. By default, python builtin collections are also
traversed to look for dask objects (for more information see the
<code class="docutils literal notranslate"><span class="pre">traverse</span></code> keyword). Non-dask arguments are passed through unchanged.</p>
</dd>
<dt><strong>traverse</strong><span class="classifier">bool, optional</span></dt><dd><p>By default dask traverses builtin python collections looking for dask
objects passed to <code class="docutils literal notranslate"><span class="pre">compute</span></code>. For large collections this can be
expensive. If none of the arguments contain any dask objects, set
<code class="docutils literal notranslate"><span class="pre">traverse=False</span></code> to avoid doing this traversal.</p>
</dd>
<dt><strong>scheduler</strong><span class="classifier">string, optional</span></dt><dd><p>Which scheduler to use like “threads”, “synchronous” or “processes”.
If not provided, the default is to check the global settings first,
and then fall back to the collection defaults.</p>
</dd>
<dt><strong>optimize_graph</strong><span class="classifier">bool, optional</span></dt><dd><p>If True [default], the optimizations for each collection are applied
before computation. Otherwise the graph is run as is. This can be
useful for debugging.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Extra keywords to forward to the scheduler function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compute</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">(45, 4.5)</span>
</pre></div>
</div>
<p>By default, dask objects inside python collections will also be computed:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">compute</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>  
<span class="go">({&#39;a&#39;: 45, &#39;b&#39;: 4.5, &#39;c&#39;: 1},)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.map_partitions">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">map_partitions</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">meta='__no_default__'</em>, <em class="sig-param">enforce_metadata=True</em>, <em class="sig-param">transform_divisions=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.map_partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Python function on each DataFrame partition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function applied to each partition.</p>
</dd>
<dt><strong>args, kwargs :</strong></dt><dd><p>Arguments and keywords to pass to the function.  At least one of the
args should be a Dask.dataframe. Arguments and keywords may contain
<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>, <code class="docutils literal notranslate"><span class="pre">Delayed</span></code> or regular python objects. DataFrame-like args
(both dask and pandas) will be repartitioned to align (if necessary)
before applying the function.</p>
</dd>
<dt><strong>enforce_metadata</strong><span class="classifier">bool</span></dt><dd><p>Whether or not to enforce the structure of the metadata at runtime.
This will rename and reorder columns for each partition,
and will raise an error if this doesn’t work or types don’t match.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">pd.DataFrame, pd.Series, dict, iterable, tuple, optional</span></dt><dd><p>An empty <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.Series</span></code> that matches the dtypes and
column names of the output. This metadata is necessary for many
algorithms in dask dataframe to work.  For ease of use, some
alternative inputs are also available. Instead of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, a
<code class="docutils literal notranslate"><span class="pre">dict</span></code> of <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">dtype}</span></code> or iterable of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code> can be
provided (note that the order of the names should match the order of
the columns). Instead of a series, a tuple of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">dtype)</span></code> can be
used. If not provided, dask will try to infer the metadata. This may
lead to unexpected results, so providing <code class="docutils literal notranslate"><span class="pre">meta</span></code> is recommended. For
more information, see <code class="docutils literal notranslate"><span class="pre">dask.dataframe.utils.make_meta</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.to_datetime">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">to_datetime</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">errors='raise'</em>, <em class="sig-param">dayfirst=False</em>, <em class="sig-param">yearfirst=False</em>, <em class="sig-param">utc=None</em>, <em class="sig-param">format=None</em>, <em class="sig-param">exact=True</em>, <em class="sig-param">unit=None</em>, <em class="sig-param">infer_datetime_format=False</em>, <em class="sig-param">origin='unix'</em>, <em class="sig-param">cache=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.to_datetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert argument to datetime.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>arg</strong><span class="classifier">int, float, str, datetime, list, tuple, 1-d array, Series DataFrame/dict-like</span></dt><dd><p>The object to convert to a datetime.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">{‘ignore’, ‘raise’, ‘coerce’}, default ‘raise’</span></dt><dd><ul class="simple">
<li><p>If ‘raise’, then invalid parsing will raise an exception.</p></li>
<li><p>If ‘coerce’, then invalid parsing will be set as NaT.</p></li>
<li><p>If ‘ignore’, then invalid parsing will return the input.</p></li>
</ul>
</dd>
<dt><strong>dayfirst</strong><span class="classifier">bool, default False</span></dt><dd><p>Specify a date parse order if <cite>arg</cite> is str or its list-likes.
If True, parses dates with the day first, eg 10/11/12 is parsed as
2012-11-10.
Warning: dayfirst=True is not strict, but will prefer to parse
with day first (this is a known bug, based on dateutil behavior).</p>
</dd>
<dt><strong>yearfirst</strong><span class="classifier">bool, default False</span></dt><dd><p>Specify a date parse order if <cite>arg</cite> is str or its list-likes.</p>
<ul class="simple">
<li><p>If True parses dates with the year first, eg 10/11/12 is parsed as
2010-11-12.</p></li>
<li><p>If both dayfirst and yearfirst are True, yearfirst is preceded (same
as dateutil).</p></li>
</ul>
<p>Warning: yearfirst=True is not strict, but will prefer to parse
with year first (this is a known bug, based on dateutil behavior).</p>
</dd>
<dt><strong>utc</strong><span class="classifier">bool, default None</span></dt><dd><p>Return UTC DatetimeIndex if True (converting any tz-aware
datetime.datetime objects as well).</p>
</dd>
<dt><strong>format</strong><span class="classifier">str, default None</span></dt><dd><p>The strftime to parse time, eg “%d/%m/%Y”, note that “%f” will parse
all the way up to nanoseconds.
See strftime documentation for more information on choices:
<a class="reference external" href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior</a>.</p>
</dd>
<dt><strong>exact</strong><span class="classifier">bool, True by default</span></dt><dd><p>Behaves as:
- If True, require an exact format match.
- If False, allow the format to match anywhere in the target string.</p>
</dd>
<dt><strong>unit</strong><span class="classifier">str, default ‘ns’</span></dt><dd><p>The unit of the arg (D,s,ms,us,ns) denote the unit, which is an
integer or float number. This will be based off the origin.
Example, with unit=’ms’ and origin=’unix’ (the default), this
would calculate the number of milliseconds to the unix epoch start.</p>
</dd>
<dt><strong>infer_datetime_format</strong><span class="classifier">bool, default False</span></dt><dd><p>If True and no <cite>format</cite> is given, attempt to infer the format of the
datetime strings, and if it can be inferred, switch to a faster
method of parsing them. In some cases this can increase the parsing
speed by ~5-10x.</p>
</dd>
<dt><strong>origin</strong><span class="classifier">scalar, default ‘unix’</span></dt><dd><p>Define the reference date. The numeric values would be parsed as number
of units (defined by <cite>unit</cite>) since this reference date.</p>
<ul class="simple">
<li><p>If ‘unix’ (or POSIX) time; origin is set to 1970-01-01.</p></li>
<li><p>If ‘julian’, unit must be ‘D’, and origin is set to beginning of
Julian Calendar. Julian day number 0 is assigned to the day starting
at noon on January 1, 4713 BC.</p></li>
<li><p>If Timestamp convertible, origin is set to Timestamp identified by
origin.</p></li>
</ul>
</dd>
<dt><strong>cache</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, use a cache of unique, converted dates to apply the datetime
conversion. May produce significant speed-up when parsing duplicate
date strings, especially ones with timezone offsets. The cache is only
used when there are at least 50 values. The presence of out-of-bounds
values will render the cache unusable and may slow down parsing.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.23.0.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.25.0: </span>- changed default value from False to True.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>datetime</strong></dt><dd><p>If parsing succeeded.
Return type depends on input:</p>
<ul class="simple">
<li><p>list-like: DatetimeIndex</p></li>
<li><p>Series: Series of datetime64 dtype</p></li>
<li><p>scalar: Timestamp</p></li>
</ul>
<p>In case when it is not possible to return designated types (e.g. when
any element of input is before Timestamp.min or after Timestamp.max)
return will have datetime.datetime type (or corresponding
array/Series).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.astype" title="dask.dataframe.DataFrame.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.astype</span></code></a></dt><dd><p>Cast argument to a specified dtype.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_timedelta</span></code></dt><dd><p>Convert argument to timedelta.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_dtypes</span></code></dt><dd><p>Convert dtypes.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Assembling a datetime from multiple columns of a DataFrame. The keys can be
common abbreviations like [‘year’, ‘month’, ‘day’, ‘minute’, ‘second’,
‘ms’, ‘us’, ‘ns’]) or plurals of the same</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;year&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">2016</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;month&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">&#39;day&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">0   2015-02-04</span>
<span class="go">1   2016-03-05</span>
<span class="go">dtype: datetime64[ns]</span>
</pre></div>
</div>
<p>If a date does not meet the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits">timestamp limitations</a>, passing errors=’ignore’
will return the original input instead of raising any exception.</p>
<p>Passing errors=’coerce’ will force an out-of-bounds date to NaT,
in addition to forcing non-dates (or non-parseable dates) to NaT.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="s1">&#39;13000101&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="go">datetime.datetime(1300, 1, 1, 0, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="s1">&#39;13000101&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span>
<span class="go">NaT</span>
</pre></div>
</div>
<p>Passing infer_datetime_format=True can often-times speedup a parsing
if its not an ISO8601 format exactly, but in a regular format.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">&#39;3/11/2000&#39;</span><span class="p">,</span> <span class="s1">&#39;3/12/2000&#39;</span><span class="p">,</span> <span class="s1">&#39;3/13/2000&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="go">0    3/11/2000</span>
<span class="go">1    3/12/2000</span>
<span class="go">2    3/13/2000</span>
<span class="go">3    3/11/2000</span>
<span class="go">4    3/12/2000</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">%</span><span class="n">timeit</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">infer_datetime_format</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">100 loops, best of 3: 10.4 ms per loop</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">%</span><span class="n">timeit</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">infer_datetime_format</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">1 loop, best of 3: 471 ms per loop</span>
</pre></div>
</div>
<p>Using a unix epoch time</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="mi">1490195805</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
<span class="go">Timestamp(&#39;2017-03-22 15:16:45&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="mi">1490195805433502912</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;ns&#39;</span><span class="p">)</span>
<span class="go">Timestamp(&#39;2017-03-22 15:16:45.433502912&#39;)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For float arg, precision rounding might happen. To prevent
unexpected behavior use a fixed-width exact type.</p>
</div>
<p>Using a non-unix epoch origin</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">origin</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1960-01-01&#39;</span><span class="p">))</span>
<span class="go">DatetimeIndex([&#39;1960-01-02&#39;, &#39;1960-01-03&#39;, &#39;1960-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.to_numeric">
<code class="sig-prename descclassname">dask.dataframe.</code><code class="sig-name descname">to_numeric</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">errors='raise'</em>, <em class="sig-param">meta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.to_numeric" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert argument to a numeric type.</p>
<p>This docstring was copied from pandas.to_numeric.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return type depends on input. Delayed if scalar, otherwise same as input.
For errors, only “raise” and “coerce” are allowed.</p>
<p>The default return dtype is <cite>float64</cite> or <cite>int64</cite>
depending on the data supplied. Use the <cite>downcast</cite> parameter
to obtain other dtypes.</p>
<p>Please note that precision loss may occur if really large numbers
are passed in. Due to the internal limitations of <cite>ndarray</cite>, if
numbers smaller than <cite>-9223372036854775808</cite> (np.iinfo(np.int64).min)
or larger than <cite>18446744073709551615</cite> (np.iinfo(np.uint64).max) are
passed in, it is very likely they will be converted to float so that
they can stored in an <cite>ndarray</cite>. These warnings apply similarly to
<cite>Series</cite> since it internally leverages <cite>ndarray</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>arg</strong><span class="classifier">scalar, list, tuple, 1-d array, or Series</span></dt><dd></dd>
<dt><strong>errors</strong><span class="classifier">{‘ignore’, ‘raise’, ‘coerce’}, default ‘raise’</span></dt><dd><ul class="simple">
<li><p>If ‘raise’, then invalid parsing will raise an exception.</p></li>
<li><p>If ‘coerce’, then invalid parsing will be set as NaN.</p></li>
<li><p>If ‘ignore’, then invalid parsing will return the input.</p></li>
</ul>
</dd>
<dt><strong>downcast</strong><span class="classifier">{‘integer’, ‘signed’, ‘unsigned’, ‘float’}, default None  (Not supported in Dask)  (Not supported in Dask)</span></dt><dd><p>If not None, and if the data has been successfully cast to a
numerical dtype (or if the data was numeric to begin with),
downcast that resulting data to the smallest numerical dtype
possible according to the following rules:</p>
<ul class="simple">
<li><p>‘integer’ or ‘signed’: smallest signed int dtype (min.: np.int8)</p></li>
<li><p>‘unsigned’: smallest unsigned int dtype (min.: np.uint8)</p></li>
<li><p>‘float’: smallest float dtype (min.: np.float32)</p></li>
</ul>
<p>As this behaviour is separate from the core conversion to
numeric values, any errors raised during the downcasting
will be surfaced regardless of the value of the ‘errors’ input.</p>
<p>In addition, downcasting will only occur if the size
of the resulting data’s dtype is strictly larger than
the dtype it is to be cast to, so if none of the dtypes
checked satisfy that specification, no downcasting will be
performed on the data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ret</strong><span class="classifier">numeric if parsing succeeded.</span></dt><dd><p>Return type depends on input.  Series if Series, otherwise ndarray.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.dataframe.DataFrame.astype" title="dask.dataframe.DataFrame.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.astype</span></code></a></dt><dd><p>Cast argument to a specified dtype.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.to_datetime" title="dask.dataframe.to_datetime"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_datetime</span></code></a></dt><dd><p>Convert argument to datetime.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_timedelta</span></code></dt><dd><p>Convert argument to timedelta.</p>
</dd>
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray.astype</span></code></a></dt><dd><p>Cast a numpy array to a specified type.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_dtypes</span></code></dt><dd><p>Convert dtypes.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Take separate series and convert to numeric, coercing when told to</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">&#39;1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  
<span class="go">0    1.0</span>
<span class="go">1    2.0</span>
<span class="go">2   -3.0</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>  
<span class="go">0    1.0</span>
<span class="go">1    2.0</span>
<span class="go">2   -3.0</span>
<span class="go">dtype: float32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="s1">&#39;signed&#39;</span><span class="p">)</span>  
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2   -3</span>
<span class="go">dtype: int8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">&#39;apple&#39;</span><span class="p">,</span> <span class="s1">&#39;1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>  
<span class="go">0    apple</span>
<span class="go">1      1.0</span>
<span class="go">2        2</span>
<span class="go">3       -3</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span>  
<span class="go">0    NaN</span>
<span class="go">1    1.0</span>
<span class="go">2    2.0</span>
<span class="go">3   -3.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.multi.concat">
<code class="sig-prename descclassname">dask.dataframe.multi.</code><code class="sig-name descname">concat</code><span class="sig-paren">(</span><em class="sig-param">dfs</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">join='outer'</em>, <em class="sig-param">interleave_partitions=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.multi.concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate DataFrames along rows.</p>
<ul class="simple">
<li><p>When axis=0 (default), concatenate DataFrames row-wise:</p>
<ul>
<li><p>If all divisions are known and ordered, concatenate DataFrames keeping
divisions. When divisions are not ordered, specifying
interleave_partition=True allows concatenate divisions each by each.</p></li>
<li><p>If any of division is unknown, concatenate DataFrames resetting its
division to unknown (None)</p></li>
</ul>
</li>
<li><p>When axis=1, concatenate DataFrames column-wise:</p>
<ul>
<li><p>Allowed if all divisions are known.</p></li>
<li><p>If any of division is unknown, it raises ValueError.</p></li>
</ul>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dfs</strong><span class="classifier">list</span></dt><dd><p>List of dask.DataFrames to be concatenated</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0, 1, ‘index’, ‘columns’}, default 0</span></dt><dd><p>The axis to concatenate along</p>
</dd>
<dt><strong>join</strong><span class="classifier">{‘inner’, ‘outer’}, default ‘outer’</span></dt><dd><p>How to handle indexes on other axis</p>
</dd>
<dt><strong>interleave_partitions</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether to concatenate DataFrames ignoring its order. If True, every
divisions are concatenated each by each.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This differs in from <code class="docutils literal notranslate"><span class="pre">pd.concat</span></code> in the when concatenating Categoricals
with different categories. Pandas currently coerces those to objects
before concatenating. Coercing to objects is very expensive for large
arrays, so dask preserves the Categoricals by taking the union of
the categories.</p>
<p class="rubric">Examples</p>
<p>If all divisions are known and ordered, divisions are kept.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>                                               
<span class="go">dd.DataFrame&lt;x, divisions=(1, 3, 5)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>                                               
<span class="go">dd.DataFrame&lt;y, divisions=(6, 8, 10)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>                               
<span class="go">dd.DataFrame&lt;concat-..., divisions=(1, 3, 6, 8, 10)&gt;</span>
</pre></div>
</div>
<p>Unable to concatenate if divisions are not ordered.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>                                               
<span class="go">dd.DataFrame&lt;x, divisions=(1, 3, 5)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>                                               
<span class="go">dd.DataFrame&lt;y, divisions=(2, 3, 6)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>                               
<span class="go">ValueError: All inputs have known divisions which cannot be concatenated</span>
<span class="go">in order. Specify interleave_partitions=True to ignore order</span>
</pre></div>
</div>
<p>Specify interleave_partitions=True to ignore the division order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">interleave_partitions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>   
<span class="go">dd.DataFrame&lt;concat-..., divisions=(1, 2, 3, 5, 6)&gt;</span>
</pre></div>
</div>
<p>If any of division is unknown, the result division will be unknown</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>                                               
<span class="go">dd.DataFrame&lt;x, divisions=(None, None)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>                                               
<span class="go">dd.DataFrame&lt;y, divisions=(1, 4, 10)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>                               
<span class="go">dd.DataFrame&lt;concat-..., divisions=(None, None, None, None)&gt;</span>
</pre></div>
</div>
<p>Different categoricals are unioned</p>
<p>&gt;&gt; dd.concat([                                     # doctest: +SKIP
…     dd.from_pandas(pd.Series([‘a’, ‘b’], dtype=’category’), 1),
…     dd.from_pandas(pd.Series([‘a’, ‘c’], dtype=’category’), 1),
… ], interleave_partitions=True).dtype
CategoricalDtype(categories=[‘a’, ‘b’, ‘c’], ordered=False)</p>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.multi.merge">
<code class="sig-prename descclassname">dask.dataframe.multi.</code><code class="sig-name descname">merge</code><span class="sig-paren">(</span><em class="sig-param">left</em>, <em class="sig-param">right</em>, <em class="sig-param">how: str = 'inner'</em>, <em class="sig-param">on=None</em>, <em class="sig-param">left_on=None</em>, <em class="sig-param">right_on=None</em>, <em class="sig-param">left_index: bool = False</em>, <em class="sig-param">right_index: bool = False</em>, <em class="sig-param">sort: bool = False</em>, <em class="sig-param">suffixes=('_x'</em>, <em class="sig-param">'_y')</em>, <em class="sig-param">copy: bool = True</em>, <em class="sig-param">indicator: bool = False</em>, <em class="sig-param">validate=None</em><span class="sig-paren">)</span> &#x2192; DataFrame<a class="headerlink" href="#dask.dataframe.multi.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge DataFrame or named Series objects with a database-style join.</p>
<p>The join is done on columns or indexes. If joining columns on
columns, the DataFrame indexes <em>will be ignored</em>. Otherwise if joining indexes
on indexes or indexes on a column or columns, the index will be passed on.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>left</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>right</strong><span class="classifier">DataFrame or named Series</span></dt><dd><p>Object to merge with.</p>
</dd>
<dt><strong>how</strong><span class="classifier">{‘left’, ‘right’, ‘outer’, ‘inner’}, default ‘inner’</span></dt><dd><p>Type of merge to be performed.</p>
<ul class="simple">
<li><p>left: use only keys from left frame, similar to a SQL left outer join;
preserve key order.</p></li>
<li><p>right: use only keys from right frame, similar to a SQL right outer join;
preserve key order.</p></li>
<li><p>outer: use union of keys from both frames, similar to a SQL full outer
join; sort keys lexicographically.</p></li>
<li><p>inner: use intersection of keys from both frames, similar to a SQL inner
join; preserve the order of the left keys.</p></li>
</ul>
</dd>
<dt><strong>on</strong><span class="classifier">label or list</span></dt><dd><p>Column or index level names to join on. These must be found in both
DataFrames. If <cite>on</cite> is None and not merging on indexes then this defaults
to the intersection of the columns in both DataFrames.</p>
</dd>
<dt><strong>left_on</strong><span class="classifier">label or list, or array-like</span></dt><dd><p>Column or index level names to join on in the left DataFrame. Can also
be an array or list of arrays of the length of the left DataFrame.
These arrays are treated as if they are columns.</p>
</dd>
<dt><strong>right_on</strong><span class="classifier">label or list, or array-like</span></dt><dd><p>Column or index level names to join on in the right DataFrame. Can also
be an array or list of arrays of the length of the right DataFrame.
These arrays are treated as if they are columns.</p>
</dd>
<dt><strong>left_index</strong><span class="classifier">bool, default False</span></dt><dd><p>Use the index from the left DataFrame as the join key(s). If it is a
MultiIndex, the number of keys in the other DataFrame (either the index
or a number of columns) must match the number of levels.</p>
</dd>
<dt><strong>right_index</strong><span class="classifier">bool, default False</span></dt><dd><p>Use the index from the right DataFrame as the join key. Same caveats as
left_index.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool, default False</span></dt><dd><p>Sort the join keys lexicographically in the result DataFrame. If False,
the order of the join keys depends on the join type (how keyword).</p>
</dd>
<dt><strong>suffixes</strong><span class="classifier">tuple of (str, str), default (‘_x’, ‘_y’)</span></dt><dd><p>Suffix to apply to overlapping column names in the left and right
side, respectively. To raise an exception on overlapping columns use
(False, False).</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default True</span></dt><dd><p>If False, avoid copy if possible.</p>
</dd>
<dt><strong>indicator</strong><span class="classifier">bool or str, default False</span></dt><dd><p>If True, adds a column to output DataFrame called “_merge” with
information on the source of each row.
If string, column with information on source of each row will be added to
output DataFrame, and column will be named value of string.
Information column is Categorical-type and takes on a value of “left_only”
for observations whose merge key only appears in ‘left’ DataFrame,
“right_only” for observations whose merge key only appears in ‘right’
DataFrame, and “both” if the observation’s merge key is found in both.</p>
</dd>
<dt><strong>validate</strong><span class="classifier">str, optional</span></dt><dd><p>If specified, checks if merge is of specified type.</p>
<ul class="simple">
<li><p>“one_to_one” or “1:1”: check if merge keys are unique in both
left and right datasets.</p></li>
<li><p>“one_to_many” or “1:m”: check if merge keys are unique in left
dataset.</p></li>
<li><p>“many_to_one” or “m:1”: check if merge keys are unique in right
dataset.</p></li>
<li><p>“many_to_many” or “m:m”: allowed, but does not result in checks.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.21.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>A DataFrame of the two merged objects.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_ordered</span></code></dt><dd><p>Merge with optional filling/interpolation.</p>
</dd>
<dt><a class="reference internal" href="#dask.dataframe.multi.merge_asof" title="dask.dataframe.multi.merge_asof"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_asof</span></code></a></dt><dd><p>Merge on nearest keys.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.join</span></code></dt><dd><p>Similar method using indices.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Support for specifying index levels as the <cite>on</cite>, <cite>left_on</cite>, and
<cite>right_on</cite> parameters was added in version 0.23.0
Support for merging named Series objects was added in version 0.24.0</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;lkey&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;rkey&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span>
<span class="go">    lkey value</span>
<span class="go">0   foo      1</span>
<span class="go">1   bar      2</span>
<span class="go">2   baz      3</span>
<span class="go">3   foo      5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span>
<span class="go">    rkey value</span>
<span class="go">0   foo      5</span>
<span class="go">1   bar      6</span>
<span class="go">2   baz      7</span>
<span class="go">3   foo      8</span>
</pre></div>
</div>
<p>Merge df1 and df2 on the lkey and rkey columns. The value columns have
the default suffixes, _x and _y, appended.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s1">&#39;lkey&#39;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s1">&#39;rkey&#39;</span><span class="p">)</span>
<span class="go">  lkey  value_x rkey  value_y</span>
<span class="go">0  foo        1  foo        5</span>
<span class="go">1  foo        1  foo        8</span>
<span class="go">2  foo        5  foo        5</span>
<span class="go">3  foo        5  foo        8</span>
<span class="go">4  bar        2  bar        6</span>
<span class="go">5  baz        3  baz        7</span>
</pre></div>
</div>
<p>Merge DataFrames df1 and df2 with specified left and right suffixes
appended to any overlapping columns.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s1">&#39;lkey&#39;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s1">&#39;rkey&#39;</span><span class="p">,</span>
<span class="gp">... </span>          <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;_left&#39;</span><span class="p">,</span> <span class="s1">&#39;_right&#39;</span><span class="p">))</span>
<span class="go">  lkey  value_left rkey  value_right</span>
<span class="go">0  foo           1  foo            5</span>
<span class="go">1  foo           1  foo            8</span>
<span class="go">2  foo           5  foo            5</span>
<span class="go">3  foo           5  foo            8</span>
<span class="go">4  bar           2  bar            6</span>
<span class="go">5  baz           3  baz            7</span>
</pre></div>
</div>
<p>Merge DataFrames df1 and df2, but raise an exception if the DataFrames have
any overlapping columns.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df1</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s1">&#39;lkey&#39;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s1">&#39;rkey&#39;</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">columns overlap but no suffix specified:</span>
<span class="go">    Index([&#39;value&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.multi.merge_asof">
<code class="sig-prename descclassname">dask.dataframe.multi.</code><code class="sig-name descname">merge_asof</code><span class="sig-paren">(</span><em class="sig-param">left</em>, <em class="sig-param">right</em>, <em class="sig-param">on=None</em>, <em class="sig-param">left_on=None</em>, <em class="sig-param">right_on=None</em>, <em class="sig-param">left_index: bool = False</em>, <em class="sig-param">right_index: bool = False</em>, <em class="sig-param">by=None</em>, <em class="sig-param">left_by=None</em>, <em class="sig-param">right_by=None</em>, <em class="sig-param">suffixes=('_x'</em>, <em class="sig-param">'_y')</em>, <em class="sig-param">tolerance=None</em>, <em class="sig-param">allow_exact_matches: bool = True</em>, <em class="sig-param">direction: str = 'backward'</em><span class="sig-paren">)</span> &#x2192; DataFrame<a class="headerlink" href="#dask.dataframe.multi.merge_asof" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an asof merge. This is similar to a left-join except that we
match on nearest key rather than equal keys.</p>
<p>Both DataFrames must be sorted by the key.</p>
<p>For each row in the left DataFrame:</p>
<blockquote>
<div><ul class="simple">
<li><p>A “backward” search selects the last row in the right DataFrame whose
‘on’ key is less than or equal to the left’s key.</p></li>
<li><p>A “forward” search selects the first row in the right DataFrame whose
‘on’ key is greater than or equal to the left’s key.</p></li>
<li><p>A “nearest” search selects the row in the right DataFrame whose ‘on’
key is closest in absolute distance to the left’s key.</p></li>
</ul>
</div></blockquote>
<p>The default is “backward” and is compatible in versions below 0.20.0.
The direction parameter was added in version 0.20.0 and introduces
“forward” and “nearest”.</p>
<p>Optionally match on equivalent keys with ‘by’ before searching with ‘on’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>left</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>right</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>on</strong><span class="classifier">label</span></dt><dd><p>Field name to join on. Must be found in both DataFrames.
The data MUST be ordered. Furthermore this must be a numeric column,
such as datetimelike, integer, or float. On or left_on/right_on
must be given.</p>
</dd>
<dt><strong>left_on</strong><span class="classifier">label</span></dt><dd><p>Field name to join on in left DataFrame.</p>
</dd>
<dt><strong>right_on</strong><span class="classifier">label</span></dt><dd><p>Field name to join on in right DataFrame.</p>
</dd>
<dt><strong>left_index</strong><span class="classifier">bool</span></dt><dd><p>Use the index of the left DataFrame as the join key.</p>
</dd>
<dt><strong>right_index</strong><span class="classifier">bool</span></dt><dd><p>Use the index of the right DataFrame as the join key.</p>
</dd>
<dt><strong>by</strong><span class="classifier">column name or list of column names</span></dt><dd><p>Match on these columns before performing merge operation.</p>
</dd>
<dt><strong>left_by</strong><span class="classifier">column name</span></dt><dd><p>Field names to match on in the left DataFrame.</p>
</dd>
<dt><strong>right_by</strong><span class="classifier">column name</span></dt><dd><p>Field names to match on in the right DataFrame.</p>
</dd>
<dt><strong>suffixes</strong><span class="classifier">2-length sequence (tuple, list, …)</span></dt><dd><p>Suffix to apply to overlapping column names in the left and right
side, respectively.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">int or Timedelta, optional, default None</span></dt><dd><p>Select asof tolerance within this range; must be compatible
with the merge index.</p>
</dd>
<dt><strong>allow_exact_matches</strong><span class="classifier">bool, default True</span></dt><dd><ul class="simple">
<li><p>If True, allow matching with the same ‘on’ value
(i.e. less-than-or-equal-to / greater-than-or-equal-to)</p></li>
<li><p>If False, don’t match the same ‘on’ value
(i.e., strictly less-than / strictly greater-than).</p></li>
</ul>
</dd>
<dt><strong>direction</strong><span class="classifier">‘backward’ (default), ‘forward’, or ‘nearest’</span></dt><dd><p>Whether to search for prior, subsequent, or closest matches.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>merged</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.dataframe.multi.merge" title="dask.dataframe.multi.merge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_ordered</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">left</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="s1">&#39;left_val&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">left</span>
<span class="go">    a left_val</span>
<span class="go">0   1        a</span>
<span class="go">1   5        b</span>
<span class="go">2  10        c</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">right</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="s1">&#39;right_val&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">right</span>
<span class="go">   a  right_val</span>
<span class="go">0  1          1</span>
<span class="go">1  2          2</span>
<span class="go">2  3          3</span>
<span class="go">3  6          6</span>
<span class="go">4  7          7</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">merge_asof</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">    a left_val  right_val</span>
<span class="go">0   1        a          1</span>
<span class="go">1   5        b          3</span>
<span class="go">2  10        c          7</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">merge_asof</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">allow_exact_matches</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">    a left_val  right_val</span>
<span class="go">0   1        a        NaN</span>
<span class="go">1   5        b        3.0</span>
<span class="go">2  10        c        7.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">merge_asof</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">)</span>
<span class="go">    a left_val  right_val</span>
<span class="go">0   1        a        1.0</span>
<span class="go">1   5        b        6.0</span>
<span class="go">2  10        c        NaN</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">merge_asof</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
<span class="go">    a left_val  right_val</span>
<span class="go">0   1        a          1</span>
<span class="go">1   5        b          6</span>
<span class="go">2  10        c          7</span>
</pre></div>
</div>
<p>We can use indexed DataFrames as well.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">left</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;left_val&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]},</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">left</span>
<span class="go">   left_val</span>
<span class="go">1         a</span>
<span class="go">5         b</span>
<span class="go">10        c</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">right</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;right_val&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]},</span>
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">right</span>
<span class="go">   right_val</span>
<span class="go">1          1</span>
<span class="go">2          2</span>
<span class="go">3          3</span>
<span class="go">6          6</span>
<span class="go">7          7</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">merge_asof</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">   left_val  right_val</span>
<span class="go">1         a          1</span>
<span class="go">5         b          3</span>
<span class="go">10        c          7</span>
</pre></div>
</div>
<p>Here is a real-world times-series example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">quotes</span>
<span class="go">                     time ticker     bid     ask</span>
<span class="go">0 2016-05-25 13:30:00.023   GOOG  720.50  720.93</span>
<span class="go">1 2016-05-25 13:30:00.023   MSFT   51.95   51.96</span>
<span class="go">2 2016-05-25 13:30:00.030   MSFT   51.97   51.98</span>
<span class="go">3 2016-05-25 13:30:00.041   MSFT   51.99   52.00</span>
<span class="go">4 2016-05-25 13:30:00.048   GOOG  720.50  720.93</span>
<span class="go">5 2016-05-25 13:30:00.049   AAPL   97.99   98.01</span>
<span class="go">6 2016-05-25 13:30:00.072   GOOG  720.50  720.88</span>
<span class="go">7 2016-05-25 13:30:00.075   MSFT   52.01   52.03</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">trades</span>
<span class="go">                     time ticker   price  quantity</span>
<span class="go">0 2016-05-25 13:30:00.023   MSFT   51.95        75</span>
<span class="go">1 2016-05-25 13:30:00.038   MSFT   51.95       155</span>
<span class="go">2 2016-05-25 13:30:00.048   GOOG  720.77       100</span>
<span class="go">3 2016-05-25 13:30:00.048   GOOG  720.92       100</span>
<span class="go">4 2016-05-25 13:30:00.048   AAPL   98.00       100</span>
</pre></div>
</div>
<p>By default we are taking the asof of the quotes</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">merge_asof</span><span class="p">(</span><span class="n">trades</span><span class="p">,</span> <span class="n">quotes</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">on</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">by</span><span class="o">=</span><span class="s1">&#39;ticker&#39;</span><span class="p">)</span>
<span class="go">                     time ticker   price  quantity     bid     ask</span>
<span class="go">0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96</span>
<span class="go">1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98</span>
<span class="go">2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93</span>
<span class="go">3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93</span>
<span class="go">4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN</span>
</pre></div>
</div>
<p>We only asof within 2ms between the quote time and the trade time</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">merge_asof</span><span class="p">(</span><span class="n">trades</span><span class="p">,</span> <span class="n">quotes</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">on</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">by</span><span class="o">=</span><span class="s1">&#39;ticker&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">tolerance</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="s1">&#39;2ms&#39;</span><span class="p">))</span>
<span class="go">                     time ticker   price  quantity     bid     ask</span>
<span class="go">0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96</span>
<span class="go">1 2016-05-25 13:30:00.038   MSFT   51.95       155     NaN     NaN</span>
<span class="go">2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93</span>
<span class="go">3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93</span>
<span class="go">4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN</span>
</pre></div>
</div>
<p>We only asof within 10ms between the quote time and the trade time
and we exclude exact matches on time. However <em>prior</em> data will
propagate forward</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">merge_asof</span><span class="p">(</span><span class="n">trades</span><span class="p">,</span> <span class="n">quotes</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">on</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">by</span><span class="o">=</span><span class="s1">&#39;ticker&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">tolerance</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="s1">&#39;10ms&#39;</span><span class="p">),</span>
<span class="gp">... </span>                      <span class="n">allow_exact_matches</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">                     time ticker   price  quantity     bid     ask</span>
<span class="go">0 2016-05-25 13:30:00.023   MSFT   51.95        75     NaN     NaN</span>
<span class="go">1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98</span>
<span class="go">2 2016-05-25 13:30:00.048   GOOG  720.77       100     NaN     NaN</span>
<span class="go">3 2016-05-25 13:30:00.048   GOOG  720.92       100     NaN     NaN</span>
<span class="go">4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.reshape.get_dummies">
<code class="sig-prename descclassname">dask.dataframe.reshape.</code><code class="sig-name descname">get_dummies</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">prefix=None</em>, <em class="sig-param">prefix_sep='_'</em>, <em class="sig-param">dummy_na=False</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">sparse=False</em>, <em class="sig-param">drop_first=False</em>, <em class="sig-param">dtype=&lt;class 'numpy.uint8'&gt;</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.reshape.get_dummies" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert categorical variable into dummy/indicator variables.</p>
<p>Data must have category dtype to infer result’s <code class="docutils literal notranslate"><span class="pre">columns</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">Series, or DataFrame</span></dt><dd><p>For Series, the dtype must be categorical.
For DataFrame, at least one column must be categorical.</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">string, list of strings, or dict of strings, default None</span></dt><dd><p>String to append DataFrame column names.
Pass a list with length equal to the number of columns
when calling get_dummies on a DataFrame. Alternatively, <cite>prefix</cite>
can be a dictionary mapping column names to prefixes.</p>
</dd>
<dt><strong>prefix_sep</strong><span class="classifier">string, default ‘_’</span></dt><dd><p>If appending prefix, separator/delimiter to use. Or pass a
list or dictionary as with <cite>prefix.</cite></p>
</dd>
<dt><strong>dummy_na</strong><span class="classifier">bool, default False</span></dt><dd><p>Add a column to indicate NaNs, if False NaNs are ignored.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list-like, default None</span></dt><dd><p>Column names in the DataFrame to be encoded.
If <cite>columns</cite> is None then all the columns with
<cite>category</cite> dtype will be converted.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether the dummy columns should be sparse or not.  Returns
SparseDataFrame if <cite>data</cite> is a Series or if all columns are included.
Otherwise returns a DataFrame with some SparseBlocks.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.2.</span></p>
</div>
</dd>
<dt><strong>drop_first</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether to get k-1 dummies out of k categorical levels by removing the
first level.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, default np.uint8</span></dt><dd><p>Data type for new columns. Only a single dtype is allowed.
Only valid if pandas is 0.23.0 or newer.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.2.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dummies</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.get_dummies.html#pandas.get_dummies" title="(in pandas v1.0.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.get_dummies</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Dask’s version only works with Categorical data, as this is the only way to
know the output shape without computing all the data.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abca&#39;</span><span class="p">)),</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">`get_dummies` with non-categorical dtypes is not supported...</span>
</pre></div>
</div>
<p>With categorical data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abca&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;category&#39;</span><span class="p">),</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  
<span class="go">Dask DataFrame Structure:</span>
<span class="go">                   a      b      c</span>
<span class="go">npartitions=2</span>
<span class="go">0              uint8  uint8  uint8</span>
<span class="go">2                ...    ...    ...</span>
<span class="go">3                ...    ...    ...</span>
<span class="go">Dask Name: get_dummies, 4 tasks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>  
<span class="go">   a  b  c</span>
<span class="go">0  1  0  0</span>
<span class="go">1  0  1  0</span>
<span class="go">2  0  0  1</span>
<span class="go">3  1  0  0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.reshape.pivot_table">
<code class="sig-prename descclassname">dask.dataframe.reshape.</code><code class="sig-name descname">pivot_table</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">index=None</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">values=None</em>, <em class="sig-param">aggfunc='mean'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.reshape.pivot_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a spreadsheet-style pivot table as a DataFrame. Target <code class="docutils literal notranslate"><span class="pre">columns</span></code>
must have category dtype to infer result’s <code class="docutils literal notranslate"><span class="pre">columns</span></code>.
<code class="docutils literal notranslate"><span class="pre">index</span></code>, <code class="docutils literal notranslate"><span class="pre">columns</span></code>, <code class="docutils literal notranslate"><span class="pre">values</span></code> and <code class="docutils literal notranslate"><span class="pre">aggfunc</span></code> must be all scalar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>index</strong><span class="classifier">scalar</span></dt><dd><p>column to be index</p>
</dd>
<dt><strong>columns</strong><span class="classifier">scalar</span></dt><dd><p>column to be columns</p>
</dd>
<dt><strong>values</strong><span class="classifier">scalar</span></dt><dd><p>column to aggregate</p>
</dd>
<dt><strong>aggfunc</strong><span class="classifier">{‘mean’, ‘sum’, ‘count’}, default ‘mean’</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>table</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pivot_table.html#pandas.DataFrame.pivot_table" title="(in pandas v1.0.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame.pivot_table</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.dataframe.reshape.melt">
<code class="sig-prename descclassname">dask.dataframe.reshape.</code><code class="sig-name descname">melt</code><span class="sig-paren">(</span><em class="sig-param">frame</em>, <em class="sig-param">id_vars=None</em>, <em class="sig-param">value_vars=None</em>, <em class="sig-param">var_name=None</em>, <em class="sig-param">value_name='value'</em>, <em class="sig-param">col_level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.dataframe.reshape.melt" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpivots a DataFrame from wide format to long format, optionally leaving identifier variables set.</p>
<p>This function is useful to massage a DataFrame into a format where one or more columns are identifier variables
(<code class="docutils literal notranslate"><span class="pre">id_vars</span></code>), while all other columns, considered measured variables (<code class="docutils literal notranslate"><span class="pre">value_vars</span></code>), are “unpivoted” to the row
axis, leaving just two non-identifier columns, ‘variable’ and ‘value’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frame</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>id_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to use as identifier variables.</p>
</dd>
<dt><strong>value_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to unpivot. If not specified, uses all columns that
are not set as <cite>id_vars</cite>.</p>
</dd>
<dt><strong>var_name</strong><span class="classifier">scalar</span></dt><dd><p>Name to use for the ‘variable’ column. If None it uses
<code class="docutils literal notranslate"><span class="pre">frame.columns.name</span></code> or ‘variable’.</p>
</dd>
<dt><strong>value_name</strong><span class="classifier">scalar, default ‘value’</span></dt><dd><p>Name to use for the ‘value’ column.</p>
</dd>
<dt><strong>col_level</strong><span class="classifier">int or string, optional</span></dt><dd><p>If columns are a MultiIndex then use this level to melt.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DataFrame</strong></dt><dd><p>Unpivoted DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.melt.html#pandas.DataFrame.melt" title="(in pandas v1.0.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame.melt</span></code></a></p>
</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dataframe-create.html" class="btn btn-neutral float-right" title="Create and Store Dask DataFrames" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dataframe.html" class="btn btn-neutral float-left" title="DataFrame" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014-2018, Anaconda, Inc. and contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>