








<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Custom Collections &mdash; Dask 2.13.0+4.gf26bb993.dirty documentation</title>
  

  
  
  
  

  
  <link rel="stylesheet" href="_static/css/style.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  <link rel="stylesheet" href="_static/style.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/explore.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/nbsphinx.css" type="text/css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="_static/js/custom.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="High Level Graphs" href="high-level-graphs.html" />
    <link rel="prev" title="Optimization" href="optimize.html" />
    <link rel="shortcut icon" href="_static/images/favicon.ico"/>
  
</head>

<body class="wy-body-for-nav">

  
    <nav id="explore-links">
        <a href="https://docs.dask.org/">
        <img class="caption" src="_static/images/dask-horizontal-white.svg"/>
        </a>

        <ul>
        <li>
            <a>Get Started</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/install.html"> Install </a></li>
            <li><a href="https://examples.dask.org"> Examples </a></li>
            <li><a href="https://github.com/dask/dask-tutorial"> Tutorial </a></li>
            <li><a href="https://docs.dask.org/en/latest/why.html"> Why Dask? </a></li>
            <li><a href="https://stories.dask.org/en/latest"> Use Cases </a></li>
            <li><a href="https://www.youtube.com/watch?v=RA_2qdipVng&list=PLRtz5iA93T4PQvWuoMnIyEIz1fXiJ5Pri"> Talks </a></li>
            <li><a href="https://mybinder.org/v2/gh/dask/dask-examples/master?urlpath=lab"> Try Online </a></li>
            <li><a href="https://dask.org/slides"> Slides </a></li>
            </ul>
        </li>

        <li>
            <a href="">Algorithms</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/array.html">Arrays</a></li>
            <li><a href="https://docs.dask.org/en/latest/dataframe.html">Dataframes</a></li>
            <li><a href="https://docs.dask.org/en/latest/bag.html">Bags</a></li>
            <li><a href="https://docs.dask.org/en/latest/delayed.html">Delayed (custom)</a></li>
            <li><a href="https://docs.dask.org/en/latest/futures.html">Futures (real-time)</a></li>
            <li><a href="http://ml.dask.org">Machine Learning</a></li>
            <li><a href="https://xarray.pydata.org/en/latest/">XArray</a></li>
            </ul>
        </li>

        <li>
            <a href="https://docs.dask.org/en/latest/setup.html">Setup</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/setup/single-machine.html"> Local </a></li>
            <li><a href="https://docs.dask.org/en/latest/setup/cloud.html"> Cloud </a></li>
            <li><a href="https://docs.dask.org/en/latest/setup/hpc.html"> HPC </a></li>
            <li><a href="https://kubernetes.dask.org/en/latest/"> Kubernetes </a></li>
            <li><a href="https://yarn.dask.org/en/latest/"> Hadoop / Yarn </a></li>
            </ul>
        </li>

        <li>
            <a>Community</a>
            <ul>
            <li><a href="http://docs.dask.org/en/latest/support.html">Ask for Help</a></li>
            <li><a href="https://github.com/dask">Github</a></li>
            <li><a href="https://stackoverflow.com/questions/tagged/dask">Stack Overflow</a></li>
            <li><a href="https://twitter.com/dask_dev">Twitter</a></li>
            <li><a href="https://blog.dask.org/"> Developer Blog </a></li>
            </ul>
        </li>
        </ul>

    </nav>
  
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Dask
          

          
          </a>

          
            
            
              <div class="version">
                2.13.0+4.gf26bb993.dirty
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Install Dask</a></li>
<li class="toctree-l1"><a class="reference internal" href="setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference external" href="https://stories.dask.org">Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="support.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="why.html">Why Dask?</a></li>
<li class="toctree-l1"><a class="reference internal" href="institutional-faq.html">Institutional FAQ</a></li>
</ul>
<p class="caption"><span class="caption-text">User Interface</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="user-interfaces.html">User Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="array.html">Array</a></li>
<li class="toctree-l1"><a class="reference internal" href="bag.html">Bag</a></li>
<li class="toctree-l1"><a class="reference internal" href="dataframe.html">DataFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="delayed.html">Delayed</a></li>
<li class="toctree-l1"><a class="reference internal" href="futures.html">Futures</a></li>
<li class="toctree-l1"><a class="reference external" href="https://ml.dask.org">Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="best-practices.html">Best Practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
</ul>
<p class="caption"><span class="caption-text">Scheduling</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="scheduling.html">Scheduling</a></li>
<li class="toctree-l1"><a class="reference external" href="https://distributed.dask.org/">Distributed Scheduling</a></li>
</ul>
<p class="caption"><span class="caption-text">Diagnostics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="understanding-performance.html">Understanding Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphviz.html">Visualize task graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics-local.html">Diagnostics (local)</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics-distributed.html">Diagnostics (distributed)</a></li>
<li class="toctree-l1"><a class="reference internal" href="debugging.html">Debugging</a></li>
</ul>
<p class="caption"><span class="caption-text">Help &amp; reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="develop.html">Development Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="educational-resources.html">Educational Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="presentations.html">Presentations On Dask</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheatsheet.html">Dask Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="spark.html">Comparison to Spark</a></li>
<li class="toctree-l1"><a class="reference internal" href="caching.html">Opportunistic Caching</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="graphs.html">Task Graphs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="spec.html">Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="custom-graphs.html">Custom Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimize.html">Optimization</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Custom Collections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-dask-collection-interface">The Dask Collection Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#internals-of-the-core-dask-methods">Internals of the Core Dask Methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#compute">Compute</a></li>
<li class="toctree-l4"><a class="reference internal" href="#persist">Persist</a></li>
<li class="toctree-l4"><a class="reference internal" href="#optimize">Optimize</a></li>
<li class="toctree-l4"><a class="reference internal" href="#visualize">Visualize</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#adding-the-core-dask-methods-to-your-class">Adding the Core Dask Methods to Your Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-dask-collection">Example Dask Collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#checking-if-an-object-is-a-dask-collection">Checking if an object is a Dask collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementing-deterministic-hashing">Implementing Deterministic Hashing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="high-level-graphs.html">High Level Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphs.html#motivation">Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphs.html#example">Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphs.html#schedulers">Schedulers</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphs.html#task-expectations">Task Expectations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="remote-data-services.html">Remote Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpu.html">GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="cite.html">Citations</a></li>
<li class="toctree-l1"><a class="reference internal" href="funding.html">Funding</a></li>
<li class="toctree-l1"><a class="reference internal" href="logos.html">Images and Logos</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Dask</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="graphs.html">Task Graphs</a> &raquo;</li>
        
      <li>Custom Collections</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/custom-collections.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="custom-collections">
<h1>Custom Collections<a class="headerlink" href="#custom-collections" title="Permalink to this headline">¶</a></h1>
<p>For many problems, the built-in Dask collections (<code class="docutils literal notranslate"><span class="pre">dask.array</span></code>,
<code class="docutils literal notranslate"><span class="pre">dask.dataframe</span></code>, <code class="docutils literal notranslate"><span class="pre">dask.bag</span></code>, and <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code>) are sufficient. For
cases where they aren’t, it’s possible to create your own Dask collections. Here
we describe the required methods to fulfill the Dask collection interface.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is considered an advanced feature. For most cases the built-in
collections are probably sufficient.</p>
</div>
<p>Before reading this you should read and understand:</p>
<ul class="simple">
<li><p><a class="reference internal" href="graphs.html"><span class="doc">overview</span></a></p></li>
<li><p><a class="reference internal" href="spec.html"><span class="doc">graph specification</span></a></p></li>
<li><p><a class="reference internal" href="custom-graphs.html"><span class="doc">custom graphs</span></a></p></li>
</ul>
<p><strong>Contents</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="#collection-interface"><span class="std std-ref">Description of the Dask collection interface</span></a></p></li>
<li><p><a class="reference internal" href="#core-method-internals"><span class="std std-ref">How this interface is used to implement the core Dask
methods</span></a></p></li>
<li><p><a class="reference internal" href="#adding-methods-to-class"><span class="std std-ref">How to add the core methods to your class</span></a></p></li>
<li><p><a class="reference internal" href="#example-dask-collection"><span class="std std-ref">Example Dask Collection</span></a></p></li>
<li><p><a class="reference internal" href="#is-dask-collection"><span class="std std-ref">How to check if something is a Dask collection</span></a></p></li>
<li><p><a class="reference internal" href="#deterministic-hashing"><span class="std std-ref">How to make tokenize work with your collection</span></a></p></li>
</ul>
<div class="section" id="the-dask-collection-interface">
<span id="collection-interface"></span><h2>The Dask Collection Interface<a class="headerlink" href="#the-dask-collection-interface" title="Permalink to this headline">¶</a></h2>
<p>To create your own Dask collection, you need to fulfill the following
interface. Note that there is no required base class.</p>
<p>It is recommended to also read <a class="reference internal" href="#core-method-internals"><span class="std std-ref">Internals of the Core Dask Methods</span></a> to see how this
interface is used inside Dask.</p>
<dl class="method">
<dt id="__dask_graph__">
<code class="sig-name descname">__dask_graph__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#__dask_graph__" title="Permalink to this definition">¶</a></dt>
<dd><p>The Dask graph.</p>
<dl class="simple">
<dt>dsk<span class="classifier">MutableMapping, None</span></dt><dd><p>The Dask graph.  If <code class="docutils literal notranslate"><span class="pre">None</span></code>, this instance will not be interpreted as a
Dask collection, and none of the remaining interface methods will be
called.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="__dask_keys__">
<code class="sig-name descname">__dask_keys__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#__dask_keys__" title="Permalink to this definition">¶</a></dt>
<dd><p>The output keys for the Dask graph.</p>
<dl class="simple">
<dt>keys<span class="classifier">list</span></dt><dd><p>A possibly nested list of keys that represent the outputs of the graph.
After computation, the results will be returned in the same layout,
with the keys replaced with their corresponding outputs.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="__dask_optimize__">
<em class="property">static </em><code class="sig-name descname">__dask_optimize__</code><span class="sig-paren">(</span><em class="sig-param">dsk</em>, <em class="sig-param">keys</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#__dask_optimize__" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a graph and keys, return a new optimized graph.</p>
<p>This method can be either a <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> or a <code class="docutils literal notranslate"><span class="pre">classmethod</span></code>, but not
an <code class="docutils literal notranslate"><span class="pre">instancemethod</span></code>.</p>
<p>Note that graphs and keys are merged before calling <code class="docutils literal notranslate"><span class="pre">__dask_optimize__</span></code>;
as such, the graph and keys passed to this method may represent more than
one collection sharing the same optimize method.</p>
<p>If not implemented, defaults to returning the graph unchanged.</p>
<dl class="simple">
<dt>dsk<span class="classifier">MutableMapping</span></dt><dd><p>The merged graphs from all collections sharing the same
<code class="docutils literal notranslate"><span class="pre">__dask_optimize__</span></code> method.</p>
</dd>
<dt>keys<span class="classifier">list</span></dt><dd><p>A list of the outputs from <code class="docutils literal notranslate"><span class="pre">__dask_keys__</span></code> from all collections
sharing the same <code class="docutils literal notranslate"><span class="pre">__dask_optimize__</span></code> method.</p>
</dd>
<dt>**kwargs</dt><dd><p>Extra keyword arguments forwarded from the call to <code class="docutils literal notranslate"><span class="pre">compute</span></code> or
<code class="docutils literal notranslate"><span class="pre">persist</span></code>. Can be used or ignored as needed.</p>
</dd>
</dl>
<dl class="simple">
<dt>optimized_dsk<span class="classifier">MutableMapping</span></dt><dd><p>The optimized Dask graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="__dask_scheduler__">
<em class="property">static </em><code class="sig-name descname">__dask_scheduler__</code><span class="sig-paren">(</span><em class="sig-param">dsk</em>, <em class="sig-param">keys</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#__dask_scheduler__" title="Permalink to this definition">¶</a></dt>
<dd><p>The default scheduler <code class="docutils literal notranslate"><span class="pre">get</span></code> to use for this object.</p>
<p>Usually attached to the class as a staticmethod, e.g.:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.threaded</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyCollection</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Use the threaded scheduler by default</span>
<span class="gp">... </span>    <span class="n">__dask_scheduler__</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">dask</span><span class="o">.</span><span class="n">threaded</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="__dask_postcompute__">
<code class="sig-name descname">__dask_postcompute__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#__dask_postcompute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the finalizer and (optional) extra arguments to convert the computed
results into their in-memory representation.</p>
<p>Used to implement <code class="docutils literal notranslate"><span class="pre">dask.compute</span></code>.</p>
<dl class="simple">
<dt>finalize<span class="classifier">callable</span></dt><dd><p>A function with the signature <code class="docutils literal notranslate"><span class="pre">finalize(results,</span> <span class="pre">*extra_args)</span></code>.
Called with the computed results in the same structure as the
corresponding keys from <code class="docutils literal notranslate"><span class="pre">__dask_keys__</span></code>, as well as any extra
arguments as specified in <code class="docutils literal notranslate"><span class="pre">extra_args</span></code>. Should perform any necessary
finalization before returning the corresponding in-memory collection
from <code class="docutils literal notranslate"><span class="pre">compute</span></code>. For example, the <code class="docutils literal notranslate"><span class="pre">finalize</span></code> function for
<code class="docutils literal notranslate"><span class="pre">dask.array.Array</span></code> concatenates all the individual array chunks into
one large numpy array, which is then the result of <code class="docutils literal notranslate"><span class="pre">compute</span></code>.</p>
</dd>
<dt>extra_args<span class="classifier">tuple</span></dt><dd><p>Any extra arguments to pass to <code class="docutils literal notranslate"><span class="pre">finalize</span></code> after <code class="docutils literal notranslate"><span class="pre">results</span></code>. If no
extra arguments should be an empty tuple.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="__dask_postpersist__">
<code class="sig-name descname">__dask_postpersist__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#__dask_postpersist__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rebuilder and (optional) extra arguments to rebuild an equivalent
Dask collection from a persisted graph.</p>
<p>Used to implement <code class="docutils literal notranslate"><span class="pre">dask.persist</span></code>.</p>
<dl class="simple">
<dt>rebuild<span class="classifier">callable</span></dt><dd><p>A function with the signature <code class="docutils literal notranslate"><span class="pre">rebuild(dsk,</span> <span class="pre">*extra_args)</span></code>. Called
with a persisted graph containing only the keys and results from
<code class="docutils literal notranslate"><span class="pre">__dask_keys__</span></code>, as well as any extra arguments as specified in
<code class="docutils literal notranslate"><span class="pre">extra_args</span></code>. Should return an equivalent Dask collection with the
same keys as <code class="docutils literal notranslate"><span class="pre">self</span></code>, but with the results already computed. For
example, the <code class="docutils literal notranslate"><span class="pre">rebuild</span></code> function for <code class="docutils literal notranslate"><span class="pre">dask.array.Array</span></code> is just the
<code class="docutils literal notranslate"><span class="pre">__init__</span></code> method called with the new graph but the same metadata.</p>
</dd>
<dt>extra_args<span class="classifier">tuple</span></dt><dd><p>Any extra arguments to pass to <code class="docutils literal notranslate"><span class="pre">rebuild</span></code> after <code class="docutils literal notranslate"><span class="pre">dsk</span></code>. If no extra
arguments should be an empty tuple.</p>
</dd>
</dl>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It’s also recommended to define <code class="docutils literal notranslate"><span class="pre">__dask_tokenize__</span></code>,
see <a class="reference internal" href="#deterministic-hashing"><span class="std std-ref">Implementing Deterministic Hashing</span></a>.</p>
</div>
</div>
<div class="section" id="internals-of-the-core-dask-methods">
<span id="core-method-internals"></span><h2>Internals of the Core Dask Methods<a class="headerlink" href="#internals-of-the-core-dask-methods" title="Permalink to this headline">¶</a></h2>
<p>Dask has a few <em>core</em> functions (and corresponding methods) that implement
common operations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">compute</span></code>: Convert one or more Dask collections into their in-memory
counterparts</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">persist</span></code>: Convert one or more Dask collections into equivalent Dask
collections with their results already computed and cached in memory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">optimize</span></code>: Convert one or more Dask collections into equivalent Dask
collections sharing one large optimized graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">visualize</span></code>: Given one or more Dask collections, draw out the graph that
would be passed to the scheduler during a call to <code class="docutils literal notranslate"><span class="pre">compute</span></code> or <code class="docutils literal notranslate"><span class="pre">persist</span></code></p></li>
</ul>
<p>Here we briefly describe the internals of these functions to illustrate how
they relate to the above interface.</p>
<div class="section" id="compute">
<h3>Compute<a class="headerlink" href="#compute" title="Permalink to this headline">¶</a></h3>
<p>The operation of <code class="docutils literal notranslate"><span class="pre">compute</span></code> can be broken into three stages:</p>
<ol class="arabic">
<li><p><strong>Graph Merging &amp; Optimization</strong></p>
<p>First, the individual collections are converted to a single large graph and
nested list of keys. How this happens depends on the value of the
<code class="docutils literal notranslate"><span class="pre">optimize_graph</span></code> keyword, which each function takes:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">optimize_graph</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (default), then the collections are first
grouped by their <code class="docutils literal notranslate"><span class="pre">__dask_optimize__</span></code> methods.  All collections with the
same <code class="docutils literal notranslate"><span class="pre">__dask_optimize__</span></code> method have their graphs merged and keys
concatenated, and then a single call to each respective
<code class="docutils literal notranslate"><span class="pre">__dask_optimize__</span></code> is made with the merged graphs and keys.  The
resulting graphs are then merged.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">optimize_graph</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, then all the graphs are merged and all
the keys concatenated.</p></li>
</ul>
<p>After this stage there is a single large graph and nested list of keys which
represents all the collections.</p>
</li>
<li><p><strong>Computation</strong></p>
<p>After the graphs are merged and any optimizations performed, the resulting
large graph and nested list of keys are passed on to the scheduler.  The
scheduler to use is chosen as follows:</p>
<ul class="simple">
<li><p>If a <code class="docutils literal notranslate"><span class="pre">get</span></code> function is specified directly as a keyword, use that</p></li>
<li><p>Otherwise, if a global scheduler is set, use that</p></li>
<li><p>Otherwise fall back to the default scheduler for the given collections.
Note that if all collections don’t share the same <code class="docutils literal notranslate"><span class="pre">__dask_scheduler__</span></code>
then an error will be raised.</p></li>
</ul>
<p>Once the appropriate scheduler <code class="docutils literal notranslate"><span class="pre">get</span></code> function is determined, it is called
with the merged graph, keys, and extra keyword arguments.  After this stage,
<code class="docutils literal notranslate"><span class="pre">results</span></code> is a nested list of values. The structure of this list mirrors
that of <code class="docutils literal notranslate"><span class="pre">keys</span></code>, with each key substituted with its corresponding result.</p>
</li>
<li><p><strong>Postcompute</strong></p>
<p>After the results are generated, the output values of <code class="docutils literal notranslate"><span class="pre">compute</span></code> need to be
built. This is what the <code class="docutils literal notranslate"><span class="pre">__dask_postcompute__</span></code> method is for.
<code class="docutils literal notranslate"><span class="pre">__dask_postcompute__</span></code> returns two things:</p>
<ul class="simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">finalize</span></code> function, which takes in the results for the corresponding
keys</p></li>
<li><p>A tuple of extra arguments to pass to <code class="docutils literal notranslate"><span class="pre">finalize</span></code> after the results</p></li>
</ul>
<p>To build the outputs, the list of collections and results is iterated over,
and the finalizer for each collection is called on its respective results.</p>
</li>
</ol>
<p>In pseudocode, this process looks like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="o">*</span><span class="n">collections</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># 1. Graph Merging &amp; Optimization</span>
    <span class="c1"># -------------------------------</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;optimize_graph&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
        <span class="c1"># If optimization is turned on, group the collections by</span>
        <span class="c1"># optimization method, and apply each method only once to the merged</span>
        <span class="c1"># sub-graphs.</span>
        <span class="n">optimization_groups</span> <span class="o">=</span> <span class="n">groupby_optimization_methods</span><span class="p">(</span><span class="n">collections</span><span class="p">)</span>
        <span class="n">graphs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">optimize_method</span><span class="p">,</span> <span class="n">cols</span> <span class="ow">in</span> <span class="n">optimization_groups</span><span class="p">:</span>
            <span class="c1"># Merge the graphs and keys for the subset of collections that</span>
            <span class="c1"># share this optimization method</span>
            <span class="n">sub_graph</span> <span class="o">=</span> <span class="n">merge_graphs</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">])</span>
            <span class="n">sub_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">]</span>
            <span class="c1"># kwargs are forwarded to ``__dask_optimize__`` from compute</span>
            <span class="n">optimized_graph</span> <span class="o">=</span> <span class="n">optimize_method</span><span class="p">(</span><span class="n">sub_graph</span><span class="p">,</span> <span class="n">sub_keys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">optimized_graph</span><span class="p">)</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">merge_graphs</span><span class="p">(</span><span class="n">graphs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">merge_graphs</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">collections</span><span class="p">])</span>
    <span class="c1"># Keys are always the same</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">collections</span><span class="p">]</span>

    <span class="c1"># 2. Computation</span>
    <span class="c1"># --------------</span>
    <span class="c1"># Determine appropriate get function based on collections, global</span>
    <span class="c1"># settings, and keyword arguments</span>
    <span class="n">get</span> <span class="o">=</span> <span class="n">determine_get_function</span><span class="p">(</span><span class="n">collections</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># Pass the merged graph, keys, and kwargs to ``get``</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># 3. Postcompute</span>
    <span class="c1"># --------------</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Iterate over the results and collections</span>
    <span class="k">for</span> <span class="n">res</span><span class="p">,</span> <span class="n">collection</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">collections</span><span class="p">):</span>
        <span class="n">finalize</span><span class="p">,</span> <span class="n">extra_args</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">__dask_postcompute__</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">finalize</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_args</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="c1"># `dask.compute` always returns tuples</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="persist">
<h3>Persist<a class="headerlink" href="#persist" title="Permalink to this headline">¶</a></h3>
<p>Persist is very similar to <code class="docutils literal notranslate"><span class="pre">compute</span></code>, except for how the return values are
created. It too has three stages:</p>
<ol class="arabic">
<li><p><strong>Graph Merging &amp; Optimization</strong></p>
<p>Same as in <code class="docutils literal notranslate"><span class="pre">compute</span></code>.</p>
</li>
<li><p><strong>Computation</strong></p>
<p>Same as in <code class="docutils literal notranslate"><span class="pre">compute</span></code>, except in the case of the distributed scheduler,
where the values in <code class="docutils literal notranslate"><span class="pre">results</span></code> are futures instead of values.</p>
</li>
<li><p><strong>Postpersist</strong></p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">__dask_postcompute__</span></code>, <code class="docutils literal notranslate"><span class="pre">__dask_postpersist__</span></code> is used to
rebuild values in a call to <code class="docutils literal notranslate"><span class="pre">persist</span></code>. <code class="docutils literal notranslate"><span class="pre">__dask_postpersist__</span></code> returns
two things:</p>
<ul class="simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">rebuild</span></code> function, which takes in a persisted graph.  The keys of
this graph are the same as <code class="docutils literal notranslate"><span class="pre">__dask_keys__</span></code> for the corresponding
collection, and the values are computed results (for the single machine
scheduler) or futures (for the distributed scheduler).</p></li>
<li><p>A tuple of extra arguments to pass to <code class="docutils literal notranslate"><span class="pre">rebuild</span></code> after the graph</p></li>
</ul>
<p>To build the outputs of <code class="docutils literal notranslate"><span class="pre">persist</span></code>, the list of collections and results is
iterated over, and the rebuilder for each collection is called on the graph
for its respective results.</p>
</li>
</ol>
<p>In pseudocode, this looks like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">persist</span><span class="p">(</span><span class="o">*</span><span class="n">collections</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># 1. Graph Merging &amp; Optimization</span>
    <span class="c1"># -------------------------------</span>
    <span class="c1"># **Same as in compute**</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="o">...</span>

    <span class="c1"># 2. Computation</span>
    <span class="c1"># --------------</span>
    <span class="c1"># **Same as in compute**</span>
    <span class="n">results</span> <span class="o">=</span> <span class="o">...</span>

    <span class="c1"># 3. Postpersist</span>
    <span class="c1"># --------------</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Iterate over the results and collections</span>
    <span class="k">for</span> <span class="n">res</span><span class="p">,</span> <span class="n">collection</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">collections</span><span class="p">):</span>
        <span class="c1"># res has the same structure as keys</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">()</span>
        <span class="c1"># Get the computed graph for this collection.</span>
        <span class="c1"># Here flatten converts a nested list into a single list</span>
        <span class="n">subgraph</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">r</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="n">flatten</span><span class="p">(</span><span class="n">res</span><span class="p">))}</span>

        <span class="c1"># Rebuild the output dask collection with the computed graph</span>
        <span class="n">rebuild</span><span class="p">,</span> <span class="n">extra_args</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">__dask_postpersist__</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">rebuild</span><span class="p">(</span><span class="n">subgraph</span><span class="p">,</span> <span class="o">*</span><span class="n">extra_args</span><span class="p">)</span>

        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="c1"># dask.persist always returns tuples</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="optimize">
<h3>Optimize<a class="headerlink" href="#optimize" title="Permalink to this headline">¶</a></h3>
<p>The operation of <code class="docutils literal notranslate"><span class="pre">optimize</span></code> can be broken into two stages:</p>
<ol class="arabic">
<li><p><strong>Graph Merging &amp; Optimization</strong></p>
<p>Same as in <code class="docutils literal notranslate"><span class="pre">compute</span></code>.</p>
</li>
<li><p><strong>Rebuilding</strong></p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">persist</span></code>, the <code class="docutils literal notranslate"><span class="pre">rebuild</span></code> function and arguments from
<code class="docutils literal notranslate"><span class="pre">__dask_postpersist__</span></code> are used to reconstruct equivalent collections from
the optimized graph.</p>
</li>
</ol>
<p>In pseudocode, this looks like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="o">*</span><span class="n">collections</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># 1. Graph Merging &amp; Optimization</span>
    <span class="c1"># -------------------------------</span>
    <span class="c1"># **Same as in compute**</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

    <span class="c1"># 2. Rebuilding</span>
    <span class="c1"># -------------</span>
    <span class="c1"># Rebuild each dask collection using the same large optimized graph</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">collection</span> <span class="ow">in</span> <span class="n">collections</span><span class="p">:</span>
        <span class="n">rebuild</span><span class="p">,</span> <span class="n">extra_args</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">__dask_postpersist__</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">rebuild</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="o">*</span><span class="n">extra_args</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="c1"># dask.optimize always returns tuples</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="visualize">
<h3>Visualize<a class="headerlink" href="#visualize" title="Permalink to this headline">¶</a></h3>
<p>Visualize is the simplest of the 4 core functions. It only has two stages:</p>
<ol class="arabic">
<li><p><strong>Graph Merging &amp; Optimization</strong></p>
<p>Same as in <code class="docutils literal notranslate"><span class="pre">compute</span></code>.</p>
</li>
<li><p><strong>Graph Drawing</strong></p>
<p>The resulting merged graph is drawn using <code class="docutils literal notranslate"><span class="pre">graphviz</span></code> and outputs to the
specified file.</p>
</li>
</ol>
<p>In pseudocode, this looks like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">visualize</span><span class="p">(</span><span class="o">*</span><span class="n">collections</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># 1. Graph Merging &amp; Optimization</span>
    <span class="c1"># -------------------------------</span>
    <span class="c1"># **Same as in compute**</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="o">...</span>

    <span class="c1"># 2. Graph Drawing</span>
    <span class="c1"># ----------------</span>
    <span class="c1"># Draw the graph with graphviz&#39;s `dot` tool and return the result.</span>
    <span class="k">return</span> <span class="n">dot_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="adding-the-core-dask-methods-to-your-class">
<span id="adding-methods-to-class"></span><h2>Adding the Core Dask Methods to Your Class<a class="headerlink" href="#adding-the-core-dask-methods-to-your-class" title="Permalink to this headline">¶</a></h2>
<p>Defining the above interface will allow your object to used by the core Dask
functions (<code class="docutils literal notranslate"><span class="pre">dask.compute</span></code>, <code class="docutils literal notranslate"><span class="pre">dask.persist</span></code>, <code class="docutils literal notranslate"><span class="pre">dask.visualize</span></code>, etc.). To
add corresponding method versions of these, you can subclass from
<code class="docutils literal notranslate"><span class="pre">dask.base.DaskMethodsMixin</span></code> which adds implementations of <code class="docutils literal notranslate"><span class="pre">compute</span></code>,
<code class="docutils literal notranslate"><span class="pre">persist</span></code>, and <code class="docutils literal notranslate"><span class="pre">visualize</span></code> based on the interface above.</p>
</div>
<div class="section" id="example-dask-collection">
<span id="id1"></span><h2>Example Dask Collection<a class="headerlink" href="#example-dask-collection" title="Permalink to this headline">¶</a></h2>
<p>Here we create a Dask collection representing a tuple.  Every element in the
tuple is represented as a task in the graph.  Note that this is for illustration
purposes only - the same user experience could be done using normal tuples with
elements of <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Saved as dask_tuple.py</span>
<span class="kn">from</span> <span class="nn">dask.base</span> <span class="kn">import</span> <span class="n">DaskMethodsMixin</span>
<span class="kn">from</span> <span class="nn">dask.optimization</span> <span class="kn">import</span> <span class="n">cull</span>

<span class="c1"># We subclass from DaskMethodsMixin to add common dask methods to our</span>
<span class="c1"># class. This is nice but not necessary for creating a dask collection.</span>
<span class="k">class</span> <span class="nc">Tuple</span><span class="p">(</span><span class="n">DaskMethodsMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dsk</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="c1"># The init method takes in a dask graph and a set of keys to use</span>
        <span class="c1"># as outputs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dsk</span> <span class="o">=</span> <span class="n">dsk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span> <span class="o">=</span> <span class="n">keys</span>

    <span class="k">def</span> <span class="nf">__dask_graph__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dsk</span>

    <span class="k">def</span> <span class="nf">__dask_keys__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__dask_optimize__</span><span class="p">(</span><span class="n">dsk</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># We cull unnecessary tasks here. Note that this isn&#39;t necessary,</span>
        <span class="c1"># dask will do this automatically, this just shows one optimization</span>
        <span class="c1"># you could do.</span>
        <span class="n">dsk2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cull</span><span class="p">(</span><span class="n">dsk</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dsk2</span>

    <span class="c1"># Use the threaded scheduler by default.</span>
    <span class="n">__dask_scheduler__</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">dask</span><span class="o">.</span><span class="n">threaded</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__dask_postcompute__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># We want to return the results as a tuple, so our finalize</span>
        <span class="c1"># function is `tuple`. There are no extra arguments, so we also</span>
        <span class="c1"># return an empty tuple.</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">,</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__dask_postpersist__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Since our __init__ takes a graph as its first argument, our</span>
        <span class="c1"># rebuild function can just be the class itself. For extra</span>
        <span class="c1"># arguments we also return a tuple containing just the keys.</span>
        <span class="k">return</span> <span class="n">Tuple</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">__dask_tokenize__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># For tokenize to work we want to return a value that fully</span>
        <span class="c1"># represents this object. In this case it&#39;s the list of keys</span>
        <span class="c1"># to be computed.</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">)</span>
</pre></div>
</div>
<p>Demonstrating this class:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask_tuple</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span><span class="p">,</span> <span class="n">mul</span>

<span class="go"># Define a dask graph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsk</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span>
<span class="gp">... </span>       <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span>       <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)}</span>

<span class="go"># The output keys for this graph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">dsk</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>

<span class="go"># Compute turns Tuple into a tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">(2, 3, 4, 5)</span>

<span class="go"># Persist turns Tuple into a Tuple, with each task already computed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">()</span>
<span class="go">{&#39;b&#39;: 2,</span>
<span class="go"> &#39;c&#39;: 3,</span>
<span class="go"> &#39;d&#39;: 4,</span>
<span class="go"> &#39;e&#39;: 5}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">(2, 3, 4, 5)</span>
</pre></div>
</div>
</div>
<div class="section" id="checking-if-an-object-is-a-dask-collection">
<span id="is-dask-collection"></span><h2>Checking if an object is a Dask collection<a class="headerlink" href="#checking-if-an-object-is-a-dask-collection" title="Permalink to this headline">¶</a></h2>
<p>To check if an object is a Dask collection, use
<code class="docutils literal notranslate"><span class="pre">dask.base.is_dask_collection</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask.base</span> <span class="kn">import</span> <span class="n">is_dask_collection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask</span> <span class="kn">import</span> <span class="n">delayed</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">delayed</span><span class="p">(</span><span class="nb">sum</span><span class="p">)([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_dask_collection</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_dask_collection</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
<div class="section" id="implementing-deterministic-hashing">
<span id="deterministic-hashing"></span><h2>Implementing Deterministic Hashing<a class="headerlink" href="#implementing-deterministic-hashing" title="Permalink to this headline">¶</a></h2>
<p>Dask implements its own deterministic hash function to generate keys based on
the value of arguments.  This function is available as <code class="docutils literal notranslate"><span class="pre">dask.base.tokenize</span></code>.
Many common types already have implementations of <code class="docutils literal notranslate"><span class="pre">tokenize</span></code>, which can be
found in <code class="docutils literal notranslate"><span class="pre">dask/base.py</span></code>.</p>
<p>When creating your own custom classes, you may need to register a <code class="docutils literal notranslate"><span class="pre">tokenize</span></code>
implementation. There are two ways to do this:</p>
<ol class="arabic">
<li><p>The <code class="docutils literal notranslate"><span class="pre">__dask_tokenize__</span></code> method</p>
<p>Where possible, it is recommended to define the <code class="docutils literal notranslate"><span class="pre">__dask_tokenize__</span></code> method.
This method takes no arguments and should return a value fully
representative of the object.</p>
</li>
<li><p>Register a function with <code class="docutils literal notranslate"><span class="pre">dask.base.normalize_token</span></code></p>
<p>If defining a method on the class isn’t possible or you need to
customize the tokenize function for a class whose super-class is
already registered (for example if you need to sub-class built-ins),
you can register a tokenize function with the <code class="docutils literal notranslate"><span class="pre">normalize_token</span></code>
dispatch.  The function should have the same signature as described
above.</p>
</li>
</ol>
<p>In both cases the implementation should be the same, where only the location of the
definition is different.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both Dask collections and normal Python objects can have
implementations of <code class="docutils literal notranslate"><span class="pre">tokenize</span></code> using either of the methods
described above.</p>
</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask.base</span> <span class="kn">import</span> <span class="n">tokenize</span><span class="p">,</span> <span class="n">normalize_token</span>

<span class="go"># Define a tokenize implementation using a method.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__dask_tokenize__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># This tuple fully represents self</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokenize</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&#39;5988362b6e07087db2bc8e7c1c8cc560&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokenize</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># token is deterministic</span>
<span class="go">True</span>

<span class="go"># Register an implementation with normalize_token</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nd">@normalize_token</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Bar</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">tokenize_bar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">Bar</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokenize</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">&#39;5a7e9c3645aa44cf13d021c14452152e&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokenize</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokenize</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># tokens for different objects aren&#39;t equal</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For more examples, see <code class="docutils literal notranslate"><span class="pre">dask/base.py</span></code> or any of the built-in Dask collections.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="high-level-graphs.html" class="btn btn-neutral float-right" title="High Level Graphs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="optimize.html" class="btn btn-neutral float-left" title="Optimization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014-2018, Anaconda, Inc. and contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>