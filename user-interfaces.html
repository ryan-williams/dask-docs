








<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>User Interfaces &mdash; Dask 2.13.0+4.gf26bb993.dirty documentation</title>
  

  
  
  
  

  
  <link rel="stylesheet" href="_static/css/style.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  <link rel="stylesheet" href="_static/style.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/explore.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/nbsphinx.css" type="text/css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="_static/js/custom.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Array" href="array.html" />
    <link rel="prev" title="Institutional FAQ" href="institutional-faq.html" />
    <link rel="shortcut icon" href="_static/images/favicon.ico"/>
  
</head>

<body class="wy-body-for-nav">

  
    <nav id="explore-links">
        <a href="https://docs.dask.org/">
        <img class="caption" src="_static/images/dask-horizontal-white.svg"/>
        </a>

        <ul>
        <li>
            <a>Get Started</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/install.html"> Install </a></li>
            <li><a href="https://examples.dask.org"> Examples </a></li>
            <li><a href="https://github.com/dask/dask-tutorial"> Tutorial </a></li>
            <li><a href="https://docs.dask.org/en/latest/why.html"> Why Dask? </a></li>
            <li><a href="https://stories.dask.org/en/latest"> Use Cases </a></li>
            <li><a href="https://www.youtube.com/watch?v=RA_2qdipVng&list=PLRtz5iA93T4PQvWuoMnIyEIz1fXiJ5Pri"> Talks </a></li>
            <li><a href="https://mybinder.org/v2/gh/dask/dask-examples/master?urlpath=lab"> Try Online </a></li>
            <li><a href="https://dask.org/slides"> Slides </a></li>
            </ul>
        </li>

        <li>
            <a href="">Algorithms</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/array.html">Arrays</a></li>
            <li><a href="https://docs.dask.org/en/latest/dataframe.html">Dataframes</a></li>
            <li><a href="https://docs.dask.org/en/latest/bag.html">Bags</a></li>
            <li><a href="https://docs.dask.org/en/latest/delayed.html">Delayed (custom)</a></li>
            <li><a href="https://docs.dask.org/en/latest/futures.html">Futures (real-time)</a></li>
            <li><a href="http://ml.dask.org">Machine Learning</a></li>
            <li><a href="https://xarray.pydata.org/en/latest/">XArray</a></li>
            </ul>
        </li>

        <li>
            <a href="https://docs.dask.org/en/latest/setup.html">Setup</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/setup/single-machine.html"> Local </a></li>
            <li><a href="https://docs.dask.org/en/latest/setup/cloud.html"> Cloud </a></li>
            <li><a href="https://docs.dask.org/en/latest/setup/hpc.html"> HPC </a></li>
            <li><a href="https://kubernetes.dask.org/en/latest/"> Kubernetes </a></li>
            <li><a href="https://yarn.dask.org/en/latest/"> Hadoop / Yarn </a></li>
            </ul>
        </li>

        <li>
            <a>Community</a>
            <ul>
            <li><a href="http://docs.dask.org/en/latest/support.html">Ask for Help</a></li>
            <li><a href="https://github.com/dask">Github</a></li>
            <li><a href="https://stackoverflow.com/questions/tagged/dask">Stack Overflow</a></li>
            <li><a href="https://twitter.com/dask_dev">Twitter</a></li>
            <li><a href="https://blog.dask.org/"> Developer Blog </a></li>
            </ul>
        </li>
        </ul>

    </nav>
  
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Dask
          

          
          </a>

          
            
            
              <div class="version">
                2.13.0+4.gf26bb993.dirty
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Install Dask</a></li>
<li class="toctree-l1"><a class="reference internal" href="setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference external" href="https://stories.dask.org">Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="support.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="why.html">Why Dask?</a></li>
<li class="toctree-l1"><a class="reference internal" href="institutional-faq.html">Institutional FAQ</a></li>
</ul>
<p class="caption"><span class="caption-text">User Interface</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">User Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#high-level-collections">High-Level Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="#low-level-interfaces">Low-Level Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="#combining-high-and-low-level-interfaces">Combining High- and Low-Level Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="#laziness-and-computing">Laziness and Computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#persist-into-distributed-memory">Persist into Distributed Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lazy-vs-immediate">Lazy vs Immediate</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#delayed-lazy">Delayed: Lazy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#futures-immediate">Futures: Immediate</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#combining-interfaces">Combining Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="array.html">Array</a></li>
<li class="toctree-l1"><a class="reference internal" href="bag.html">Bag</a></li>
<li class="toctree-l1"><a class="reference internal" href="dataframe.html">DataFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="delayed.html">Delayed</a></li>
<li class="toctree-l1"><a class="reference internal" href="futures.html">Futures</a></li>
<li class="toctree-l1"><a class="reference external" href="https://ml.dask.org">Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="best-practices.html">Best Practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
</ul>
<p class="caption"><span class="caption-text">Scheduling</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="scheduling.html">Scheduling</a></li>
<li class="toctree-l1"><a class="reference external" href="https://distributed.dask.org/">Distributed Scheduling</a></li>
</ul>
<p class="caption"><span class="caption-text">Diagnostics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="understanding-performance.html">Understanding Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphviz.html">Visualize task graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics-local.html">Diagnostics (local)</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics-distributed.html">Diagnostics (distributed)</a></li>
<li class="toctree-l1"><a class="reference internal" href="debugging.html">Debugging</a></li>
</ul>
<p class="caption"><span class="caption-text">Help &amp; reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="develop.html">Development Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="educational-resources.html">Educational Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="presentations.html">Presentations On Dask</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheatsheet.html">Dask Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="spark.html">Comparison to Spark</a></li>
<li class="toctree-l1"><a class="reference internal" href="caching.html">Opportunistic Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphs.html">Task Graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="remote-data-services.html">Remote Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpu.html">GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="cite.html">Citations</a></li>
<li class="toctree-l1"><a class="reference internal" href="funding.html">Funding</a></li>
<li class="toctree-l1"><a class="reference internal" href="logos.html">Images and Logos</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Dask</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>User Interfaces</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/user-interfaces.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="user-interfaces">
<h1>User Interfaces<a class="headerlink" href="#user-interfaces" title="Permalink to this headline">¶</a></h1>
<p>Dask supports several user interfaces:</p>
<ul class="simple">
<li><dl class="simple">
<dt>High-Level</dt><dd><ul>
<li><p><a class="reference internal" href="array.html"><span class="doc">Arrays</span></a>: Parallel NumPy</p></li>
<li><p><a class="reference internal" href="bag.html"><span class="doc">Bags</span></a>: Parallel lists</p></li>
<li><p><a class="reference internal" href="dataframe.html"><span class="doc">DataFrames</span></a>: Parallel Pandas</p></li>
<li><p><a class="reference external" href="https://ml.dask.org">Machine Learning</a> : Parallel Scikit-Learn</p></li>
<li><p>Others from external projects, like <a class="reference external" href="https://xarray.pydata.org">XArray</a></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Low-Level</dt><dd><ul>
<li><p><a class="reference internal" href="delayed.html"><span class="doc">Delayed</span></a>: Parallel function evaluation</p></li>
<li><p><a class="reference internal" href="futures.html"><span class="doc">Futures</span></a>: Real-time parallel function evaluation</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Each of these user interfaces employs the same underlying parallel computing
machinery, and so has the same scaling, diagnostics, resilience, and so on, but
each provides a different set of parallel algorithms and programming style.</p>
<p>This document helps you to decide which user interface best suits your needs,
and gives some general information that applies to all interfaces.
The pages linked above give more information about each interface in greater
depth.</p>
<div class="section" id="high-level-collections">
<h2>High-Level Collections<a class="headerlink" href="#high-level-collections" title="Permalink to this headline">¶</a></h2>
<p>Many people who start using Dask are explicitly looking for a scalable version of
NumPy, Pandas, or Scikit-Learn.  For these situations, the starting point within
Dask is usually fairly clear.  If you want scalable NumPy arrays, then start with Dask
array; if you want scalable Pandas DataFrames, then start with Dask DataFrame, and so on.</p>
<p>These high-level interfaces copy the standard interface with slight variations.
These interfaces automatically parallelize over larger datasets for you for a
large subset of the API from the original project.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Arrays</span>
<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">),</span>  <span class="c1"># normal numpy code</span>
                      <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>  <span class="c1"># break into chunks of size 1000x1000</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Use normal syntax for high level algorithms</span>

<span class="c1"># DataFrames</span>
<span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;2018-*-*.csv&#39;</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="s1">&#39;timestamp&#39;</span><span class="p">,</span>  <span class="c1"># normal Pandas code</span>
                 <span class="n">blocksize</span><span class="o">=</span><span class="mi">64000000</span><span class="p">)</span>  <span class="c1"># break text into 64MB chunks</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">balance</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># Use normal syntax for high level algorithms</span>

<span class="c1"># Bags / lists</span>
<span class="kn">import</span> <span class="nn">dask.bag</span> <span class="k">as</span> <span class="nn">db</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">read_text</span><span class="p">(</span><span class="s1">&#39;*.json&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">)</span>
<span class="n">total</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Alice&#39;</span><span class="p">)</span>
          <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;balance&#39;</span><span class="p">])</span>
          <span class="o">.</span><span class="n">sum</span><span class="p">())</span>
</pre></div>
</div>
<p>It is important to remember that, while APIs may be similar, some differences do
exist.  Additionally, the performance of some algorithms may differ from their
in-memory counterparts due to the advantages and disadvantages of parallel
programming.  Some thought and attention is still required when using Dask.</p>
</div>
<div class="section" id="low-level-interfaces">
<h2>Low-Level Interfaces<a class="headerlink" href="#low-level-interfaces" title="Permalink to this headline">¶</a></h2>
<p>Often when parallelizing existing code bases or building custom algorithms, you
run into code that is parallelizable, but isn’t just a big DataFrame or array.
Consider the for-loopy code below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">B</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>There is potential parallelism in this code (the many calls to <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>
can be done in parallel), but it’s not clear how to rewrite it into a big
array or DataFrame so that it can use a higher-level API.  Even if you could
rewrite it into one of these paradigms, it’s not clear that this would be a
good idea.  Much of the meaning would likely be lost in translation, and this
process would become much more difficult for more complex systems.</p>
<p>Instead, Dask’s lower-level APIs let you write parallel code one function call
at a time within the context of your existing for loops.  A common solution
here is to use <a class="reference internal" href="delayed.html"><span class="doc">Dask delayed</span></a> to wrap individual function calls
into a lazily constructed task graph:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dask</span>

<span class="n">lazy_results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">B</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># add lazy task</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">g</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># add lazy task</span>
        <span class="n">lazy_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

<span class="n">results</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="o">*</span><span class="n">lazy_results</span><span class="p">)</span>  <span class="c1"># compute all in parallel</span>
</pre></div>
</div>
</div>
<div class="section" id="combining-high-and-low-level-interfaces">
<h2>Combining High- and Low-Level Interfaces<a class="headerlink" href="#combining-high-and-low-level-interfaces" title="Permalink to this headline">¶</a></h2>
<p>It is common to combine high- and low-level interfaces.
For example, you might use Dask array/bag/dataframe to load in data and do
initial pre-processing, then switch to Dask delayed for a custom algorithm that
is specific to your domain, then switch back to Dask array/dataframe to clean
up and store results.  Understanding both sets of user interfaces, and how
to switch between them, can be a productive combination.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert to a list of delayed Pandas dataframes</span>
<span class="n">delayed_values</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_delayed</span><span class="p">()</span>

<span class="c1"># Manipulate delayed values arbitrarily as you like</span>

<span class="c1"># Convert many delayed Pandas DataFrames back to a single Dask DataFrame</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_delayed</span><span class="p">(</span><span class="n">delayed_values</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="laziness-and-computing">
<h2>Laziness and Computing<a class="headerlink" href="#laziness-and-computing" title="Permalink to this headline">¶</a></h2>
<p>Most Dask user interfaces are <em>lazy</em>, meaning that they do not evaluate until
you explicitly ask for a result using the <code class="docutils literal notranslate"><span class="pre">compute</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># This array syntax doesn&#39;t cause computation</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Trigger computation by explicitly calling the compute method</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
</pre></div>
</div>
<p>If you have multiple results that you want to compute at the same time, use the
<code class="docutils literal notranslate"><span class="pre">dask.compute</span></code> function.  This can share intermediate results and so be more
efficient:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># compute multiple results at the same time with the compute function</span>
<span class="nb">min</span><span class="p">,</span> <span class="nb">max</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">compute()</span></code> function returns in-memory results.  It converts
Dask DataFrames to Pandas DataFrames, Dask arrays to NumPy arrays, and Dask
bags to lists.  <em>You should only call compute on results that will fit
comfortably in memory</em>.  If your result does not fit in memory, then you might
consider writing it to disk instead.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Write larger results out to disk rather than store them in memory</span>
<span class="n">my_dask_dataframe</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="s1">&#39;myfile.parquet&#39;</span><span class="p">)</span>
<span class="n">my_dask_array</span><span class="o">.</span><span class="n">to_hdf5</span><span class="p">(</span><span class="s1">&#39;myfile.hdf5&#39;</span><span class="p">)</span>
<span class="n">my_dask_bag</span><span class="o">.</span><span class="n">to_textfiles</span><span class="p">(</span><span class="s1">&#39;myfile.*.txt&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="persist-into-distributed-memory">
<h2>Persist into Distributed Memory<a class="headerlink" href="#persist-into-distributed-memory" title="Permalink to this headline">¶</a></h2>
<p>Alternatively, if you are on a cluster, then you may want to trigger a
computation and store the results in distributed memory.  In this case you do
not want to call <code class="docutils literal notranslate"><span class="pre">compute</span></code>, which would create a single Pandas, NumPy, or
list result. Instead, you want to call <code class="docutils literal notranslate"><span class="pre">persist</span></code>, which returns a new Dask
object that points to actively computing, or already computed results spread
around your cluster’s memory.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute returns an in-memory non-Dask object</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

<span class="c1"># Persist returns an in-memory Dask object that uses distributed storage if available</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span>
</pre></div>
</div>
<p>This is common to see after data loading an preprocessing steps, but before
rapid iteration, exploration, or complex algorithms.  For example, we might read
in a lot of data, filter down to a more manageable subset, and then persist
data into memory so that we can iterate quickly.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Alice&#39;</span><span class="p">]</span>  <span class="c1"># select important subset of data</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span>  <span class="c1"># trigger computation in the background</span>

<span class="c1"># These are all relatively fast now that the relevant data is in memory</span>
<span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">balance</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>   <span class="c1"># explore data quickly</span>
<span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">balance</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>  <span class="c1"># explore data quickly</span>
<span class="n">df</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span>                             <span class="c1"># explore data quickly</span>
</pre></div>
</div>
</div>
<div class="section" id="lazy-vs-immediate">
<h2>Lazy vs Immediate<a class="headerlink" href="#lazy-vs-immediate" title="Permalink to this headline">¶</a></h2>
<p>As mentioned above, most Dask workloads are lazy, that is, they don’t start any
work until you explicitly trigger them with a call to <code class="docutils literal notranslate"><span class="pre">compute()</span></code>.
However, sometimes you <em>do</em> want to submit work as quickly as possible, track it
over time, submit new work or cancel work depending on partial results, and so
on.  This can be useful when tracking or responding to real-time events,
handling streaming data, or when building complex and adaptive algorithms.</p>
<p>For these situations, people typically turn to the <a class="reference internal" href="futures.html"><span class="doc">futures interface</span></a> which is a low-level interface like Dask delayed, but operates
immediately rather than lazily.</p>
<p>Here is the same example with Dask delayed and Dask futures to illustrate the
difference.</p>
<div class="section" id="delayed-lazy">
<h3>Delayed: Lazy<a class="headerlink" href="#delayed-lazy" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
<span class="k">def</span> <span class="nf">inc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># no work has happened yet</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">inc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>       <span class="c1"># no work has happened yet</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>    <span class="c1"># no work has happened yet</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>  <span class="c1"># This triggers all of the above computations</span>
</pre></div>
</div>
</div>
<div class="section" id="futures-immediate">
<h3>Futures: Immediate<a class="headerlink" href="#futures-immediate" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">inc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>     <span class="c1"># work starts immediately</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>     <span class="c1"># work starts immediately</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># work starts immediately</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>                <span class="c1"># block until work finishes, then gather result</span>
</pre></div>
</div>
<p>You can also trigger work with the high-level collections using the
<code class="docutils literal notranslate"><span class="pre">persist</span></code> function.  This will cause work to happen in the background when
using the distributed scheduler.</p>
</div>
</div>
<div class="section" id="combining-interfaces">
<h2>Combining Interfaces<a class="headerlink" href="#combining-interfaces" title="Permalink to this headline">¶</a></h2>
<p>There are established ways to combine the interfaces above:</p>
<ol class="arabic">
<li><p>The high-level interfaces (array, bag, dataframe) have a <code class="docutils literal notranslate"><span class="pre">to_delayed</span></code>
method that can convert to a sequence (or grid) of Dask delayed objects</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">delayeds</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_delayed</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p>The high-level interfaces (array, bag, dataframe) have a <code class="docutils literal notranslate"><span class="pre">from_delayed</span></code>
method that can convert from either Delayed <em>or</em> Future objects</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_delayed</span><span class="p">(</span><span class="n">delayeds</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_delayed</span><span class="p">(</span><span class="n">futures</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Client.compute</span></code> method converts Delayed objects into Futures</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">futures</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">delayeds</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">dask.distributed.futures_of</span></code> function gathers futures from
persisted collections</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">futures_of</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span>  <span class="c1"># start computation in the background</span>
<span class="n">futures</span> <span class="o">=</span> <span class="n">futures_of</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>The Dask.delayed object converts Futures into delayed objects</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">delayed_value</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
<p>The approaches above should suffice to convert any interface into any other.
We often see some anti-patterns that do not work as well:</p>
<ol class="arabic simple">
<li><p>Calling low-level APIs (delayed or futures) on high-level objects (like
Dask arrays or DataFrames). This downgrades those objects to their NumPy or
Pandas equivalents, which may not be desired.
Often people are looking for APIs like <code class="docutils literal notranslate"><span class="pre">dask.array.map_blocks</span></code> or
<code class="docutils literal notranslate"><span class="pre">dask.dataframe.map_partitions</span></code> instead.</p></li>
<li><p>Calling <code class="docutils literal notranslate"><span class="pre">compute()</span></code> on Future objects.
Often people want the <code class="docutils literal notranslate"><span class="pre">.result()</span></code> method instead.</p></li>
<li><p>Calling NumPy/Pandas functions on high-level Dask objects or
high-level Dask functions on NumPy/Pandas objects</p></li>
</ol>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>Most people who use Dask start with only one of the interfaces above but
eventually learn how to use a few interfaces together.  This helps them
leverage the sophisticated algorithms in the high-level interfaces while also
working around tricky problems with the low-level interfaces.</p>
<p>For more information, see the documentation for the particular user interfaces
below:</p>
<ul class="simple">
<li><dl class="simple">
<dt>High Level</dt><dd><ul>
<li><p><a class="reference internal" href="array.html"><span class="doc">Arrays</span></a>: Parallel NumPy</p></li>
<li><p><a class="reference internal" href="bag.html"><span class="doc">Bags</span></a>: Parallel lists</p></li>
<li><p><a class="reference internal" href="dataframe.html"><span class="doc">DataFrames</span></a>: Parallel Pandas</p></li>
<li><p><a class="reference external" href="https://ml.dask.org">Machine Learning</a> : Parallel Scikit-Learn</p></li>
<li><p>Others from external projects, like <a class="reference external" href="https://xarray.pydata.org">XArray</a></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Low Level</dt><dd><ul>
<li><p><a class="reference internal" href="delayed.html"><span class="doc">Delayed</span></a>: Parallel function evaluation</p></li>
<li><p><a class="reference internal" href="futures.html"><span class="doc">Futures</span></a>: Real-time parallel function evaluation</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="array.html" class="btn btn-neutral float-right" title="Array" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="institutional-faq.html" class="btn btn-neutral float-left" title="Institutional FAQ" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014-2018, Anaconda, Inc. and contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>