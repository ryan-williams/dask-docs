








<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API &mdash; Dask 2.13.0+4.gf26bb993.dirty documentation</title>
  

  
  
  
  

  
  <link rel="stylesheet" href="_static/css/style.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  <link rel="stylesheet" href="_static/style.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/explore.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/nbsphinx.css" type="text/css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="_static/js/custom.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Best Practices" href="array-best-practices.html" />
    <link rel="prev" title="Array" href="array.html" />
    <link rel="shortcut icon" href="_static/images/favicon.ico"/>
  
</head>

<body class="wy-body-for-nav">

  
    <nav id="explore-links">
        <a href="https://docs.dask.org/">
        <img class="caption" src="_static/images/dask-horizontal-white.svg"/>
        </a>

        <ul>
        <li>
            <a>Get Started</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/install.html"> Install </a></li>
            <li><a href="https://examples.dask.org"> Examples </a></li>
            <li><a href="https://github.com/dask/dask-tutorial"> Tutorial </a></li>
            <li><a href="https://docs.dask.org/en/latest/why.html"> Why Dask? </a></li>
            <li><a href="https://stories.dask.org/en/latest"> Use Cases </a></li>
            <li><a href="https://www.youtube.com/watch?v=RA_2qdipVng&list=PLRtz5iA93T4PQvWuoMnIyEIz1fXiJ5Pri"> Talks </a></li>
            <li><a href="https://mybinder.org/v2/gh/dask/dask-examples/master?urlpath=lab"> Try Online </a></li>
            <li><a href="https://dask.org/slides"> Slides </a></li>
            </ul>
        </li>

        <li>
            <a href="">Algorithms</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/array.html">Arrays</a></li>
            <li><a href="https://docs.dask.org/en/latest/dataframe.html">Dataframes</a></li>
            <li><a href="https://docs.dask.org/en/latest/bag.html">Bags</a></li>
            <li><a href="https://docs.dask.org/en/latest/delayed.html">Delayed (custom)</a></li>
            <li><a href="https://docs.dask.org/en/latest/futures.html">Futures (real-time)</a></li>
            <li><a href="http://ml.dask.org">Machine Learning</a></li>
            <li><a href="https://xarray.pydata.org/en/latest/">XArray</a></li>
            </ul>
        </li>

        <li>
            <a href="https://docs.dask.org/en/latest/setup.html">Setup</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/setup/single-machine.html"> Local </a></li>
            <li><a href="https://docs.dask.org/en/latest/setup/cloud.html"> Cloud </a></li>
            <li><a href="https://docs.dask.org/en/latest/setup/hpc.html"> HPC </a></li>
            <li><a href="https://kubernetes.dask.org/en/latest/"> Kubernetes </a></li>
            <li><a href="https://yarn.dask.org/en/latest/"> Hadoop / Yarn </a></li>
            </ul>
        </li>

        <li>
            <a>Community</a>
            <ul>
            <li><a href="http://docs.dask.org/en/latest/support.html">Ask for Help</a></li>
            <li><a href="https://github.com/dask">Github</a></li>
            <li><a href="https://stackoverflow.com/questions/tagged/dask">Stack Overflow</a></li>
            <li><a href="https://twitter.com/dask_dev">Twitter</a></li>
            <li><a href="https://blog.dask.org/"> Developer Blog </a></li>
            </ul>
        </li>
        </ul>

    </nav>
  
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Dask
          

          
          </a>

          
            
            
              <div class="version">
                2.13.0+4.gf26bb993.dirty
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Install Dask</a></li>
<li class="toctree-l1"><a class="reference internal" href="setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference external" href="https://stories.dask.org">Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="support.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="why.html">Why Dask?</a></li>
<li class="toctree-l1"><a class="reference internal" href="institutional-faq.html">Institutional FAQ</a></li>
</ul>
<p class="caption"><span class="caption-text">User Interface</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="user-interfaces.html">User Interfaces</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="array.html">Array</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fast-fourier-transforms">Fast Fourier Transforms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linear-algebra">Linear Algebra</a></li>
<li class="toctree-l3"><a class="reference internal" href="#masked-arrays">Masked Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="#random">Random</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stats">Stats</a></li>
<li class="toctree-l3"><a class="reference internal" href="#image-support">Image Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slightly-overlapping-computations">Slightly Overlapping Computations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#create-and-store-arrays">Create and Store Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generalized-ufuncs">Generalized Ufuncs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#internal-functions">Internal functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-functions">Other functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#array-methods">Array Methods</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="array-best-practices.html">Best Practices</a></li>
<li class="toctree-l2"><a class="reference internal" href="array-chunks.html">Chunks</a></li>
<li class="toctree-l2"><a class="reference internal" href="array-creation.html">Create Dask Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="array-creation.html#store-dask-arrays">Store Dask Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="array-creation.html#plugins">Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="array-overlap.html">Overlapping Computations</a></li>
<li class="toctree-l2"><a class="reference internal" href="array-design.html">Internal Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="array-sparse.html">Sparse Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="array-stats.html">Stats</a></li>
<li class="toctree-l2"><a class="reference internal" href="array-linear-operator.html">LinearOperator</a></li>
<li class="toctree-l2"><a class="reference internal" href="array-slicing.html">Slicing</a></li>
<li class="toctree-l2"><a class="reference internal" href="array-stack.html">Stack, Concatenate, and Block</a></li>
<li class="toctree-l2"><a class="reference internal" href="array-gufunc.html">Generalized Ufuncs</a></li>
<li class="toctree-l2"><a class="reference internal" href="array.html#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="array.html#design">Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="array.html#common-uses">Common Uses</a></li>
<li class="toctree-l2"><a class="reference internal" href="array.html#scope">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="array.html#execution">Execution</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bag.html">Bag</a></li>
<li class="toctree-l1"><a class="reference internal" href="dataframe.html">DataFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="delayed.html">Delayed</a></li>
<li class="toctree-l1"><a class="reference internal" href="futures.html">Futures</a></li>
<li class="toctree-l1"><a class="reference external" href="https://ml.dask.org">Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="best-practices.html">Best Practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
</ul>
<p class="caption"><span class="caption-text">Scheduling</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="scheduling.html">Scheduling</a></li>
<li class="toctree-l1"><a class="reference external" href="https://distributed.dask.org/">Distributed Scheduling</a></li>
</ul>
<p class="caption"><span class="caption-text">Diagnostics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="understanding-performance.html">Understanding Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphviz.html">Visualize task graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics-local.html">Diagnostics (local)</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics-distributed.html">Diagnostics (distributed)</a></li>
<li class="toctree-l1"><a class="reference internal" href="debugging.html">Debugging</a></li>
</ul>
<p class="caption"><span class="caption-text">Help &amp; reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="develop.html">Development Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="educational-resources.html">Educational Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="presentations.html">Presentations On Dask</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheatsheet.html">Dask Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="spark.html">Comparison to Spark</a></li>
<li class="toctree-l1"><a class="reference internal" href="caching.html">Opportunistic Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphs.html">Task Graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="remote-data-services.html">Remote Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpu.html">GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="cite.html">Citations</a></li>
<li class="toctree-l1"><a class="reference internal" href="funding.html">Funding</a></li>
<li class="toctree-l1"><a class="reference internal" href="logos.html">Images and Logos</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Dask</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="array.html">Array</a> &raquo;</li>
        
      <li>API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/array-api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api">
<h1>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h1>
<p>Top level user functions:</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.all" title="dask.array.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code></a>(a[, axis, keepdims, split_every, out])</p></td>
<td><p>Test whether all array elements along a given axis evaluate to True.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.allclose" title="dask.array.allclose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">allclose</span></code></a>(arr1, arr2[, rtol, atol, equal_nan])</p></td>
<td><p>Returns True if two arrays are element-wise equal within a tolerance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.angle" title="dask.array.angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle</span></code></a>(x[, deg])</p></td>
<td><p>Return the angle of the complex argument.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.any" title="dask.array.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code></a>(a[, axis, keepdims, split_every, out])</p></td>
<td><p>Test whether any array element along a given axis evaluates to True.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.apply_along_axis" title="dask.array.apply_along_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_along_axis</span></code></a>(func1d, axis, arr, *args[, …])</p></td>
<td><p>Apply a function to 1-D slices along the given axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.apply_over_axes" title="dask.array.apply_over_axes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_over_axes</span></code></a>(func, a, axes)</p></td>
<td><p>Apply a function repeatedly over multiple axes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.arange" title="dask.array.arange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arange</span></code></a>(*args, **kwargs)</p></td>
<td><p>Return evenly spaced values from <cite>start</cite> to <cite>stop</cite> with step size <cite>step</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.arccos" title="dask.array.arccos"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arccos</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.arccos.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.arccosh" title="dask.array.arccosh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arccosh</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.arccosh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.arcsin" title="dask.array.arcsin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arcsin</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.arcsin.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.arcsinh" title="dask.array.arcsinh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arcsinh</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.arcsinh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.arctan" title="dask.array.arctan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arctan</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.arctan.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.arctan2" title="dask.array.arctan2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arctan2</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.arctan2.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.arctanh" title="dask.array.arctanh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arctanh</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.arctanh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.argmax" title="dask.array.argmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax</span></code></a>(x[, axis, split_every, out])</p></td>
<td><p>Return the maximum of an array or maximum along an axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.argmin" title="dask.array.argmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmin</span></code></a>(x[, axis, split_every, out])</p></td>
<td><p>Return the minimum of an array or minimum along an axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.argtopk" title="dask.array.argtopk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argtopk</span></code></a>(a, k[, axis, split_every])</p></td>
<td><p>Extract the indices of the k largest elements from a on the given axis, and return them sorted from largest to smallest.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.argwhere" title="dask.array.argwhere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argwhere</span></code></a>(a)</p></td>
<td><p>Find the indices of array elements that are non-zero, grouped by element.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.around" title="dask.array.around"><code class="xref py py-obj docutils literal notranslate"><span class="pre">around</span></code></a>(x[, decimals])</p></td>
<td><p>Evenly round to the given number of decimals.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.array" title="dask.array.array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">array</span></code></a>(object[, dtype, copy, order, subok, ndmin])</p></td>
<td><p>This docstring was copied from numpy.array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.asanyarray" title="dask.array.asanyarray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asanyarray</span></code></a>(a)</p></td>
<td><p>Convert the input to a dask array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.asarray" title="dask.array.asarray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asarray</span></code></a>(a, **kwargs)</p></td>
<td><p>Convert the input to a dask array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.atleast_1d" title="dask.array.atleast_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atleast_1d</span></code></a>(*arys)</p></td>
<td><p>Convert inputs to arrays with at least one dimension.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.atleast_2d" title="dask.array.atleast_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atleast_2d</span></code></a>(*arys)</p></td>
<td><p>View inputs as arrays with at least two dimensions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.atleast_3d" title="dask.array.atleast_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atleast_3d</span></code></a>(*arys)</p></td>
<td><p>View inputs as arrays with at least three dimensions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.average" title="dask.array.average"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average</span></code></a>(a[, axis, weights, returned])</p></td>
<td><p>Compute the weighted average along the specified axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.bincount" title="dask.array.bincount"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bincount</span></code></a>(x[, weights, minlength])</p></td>
<td><p>This docstring was copied from numpy.bincount.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.bitwise_and" title="dask.array.bitwise_and"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_and</span></code></a>(x1, x2, /[, out, where, …])</p></td>
<td><p>This docstring was copied from numpy.bitwise_and.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.bitwise_not" title="dask.array.bitwise_not"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_not</span></code></a>(x, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.invert.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.bitwise_or" title="dask.array.bitwise_or"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_or</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.bitwise_or.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.bitwise_xor" title="dask.array.bitwise_xor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_xor</span></code></a>(x1, x2, /[, out, where, …])</p></td>
<td><p>This docstring was copied from numpy.bitwise_xor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.block" title="dask.array.block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">block</span></code></a>(arrays[, allow_unknown_chunksizes])</p></td>
<td><p>Assemble an nd-array from nested lists of blocks.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.blockwise" title="dask.array.blockwise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">blockwise</span></code></a>(func, out_ind, *args[, name, …])</p></td>
<td><p>Tensor operation: Generalized inner and outer products</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.broadcast_arrays" title="dask.array.broadcast_arrays"><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast_arrays</span></code></a>(*args, **kwargs)</p></td>
<td><p>Broadcast any number of arrays against each other.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.broadcast_to" title="dask.array.broadcast_to"><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast_to</span></code></a>(x, shape[, chunks])</p></td>
<td><p>Broadcast an array to a new shape.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.coarsen" title="dask.array.coarsen"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coarsen</span></code></a>(reduction, x, axes[, trim_excess])</p></td>
<td><p>Coarsen array by applying reduction to fixed size neighborhoods</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.ceil" title="dask.array.ceil"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceil</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.ceil.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.choose" title="dask.array.choose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose</span></code></a>(a, choices)</p></td>
<td><p>Construct an array from an index array and a set of arrays to choose from.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.clip" title="dask.array.clip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code></a>(*args, **kwargs)</p></td>
<td><p>Clip (limit) the values in an array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.compress" title="dask.array.compress"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress</span></code></a>(condition, a[, axis])</p></td>
<td><p>Return selected slices of an array along given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.concatenate" title="dask.array.concatenate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concatenate</span></code></a>(seq[, axis, …])</p></td>
<td><p>Concatenate arrays along an existing axis</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.conj" title="dask.array.conj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.conjugate.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.copysign" title="dask.array.copysign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copysign</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.copysign.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.corrcoef" title="dask.array.corrcoef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">corrcoef</span></code></a>(x[, y, rowvar])</p></td>
<td><p>Return Pearson product-moment correlation coefficients.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.cos" title="dask.array.cos"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cos</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.cos.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.cosh" title="dask.array.cosh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cosh</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.cosh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.count_nonzero" title="dask.array.count_nonzero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count_nonzero</span></code></a>(a[, axis])</p></td>
<td><p>Counts the number of non-zero values in the array <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.cov" title="dask.array.cov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cov</span></code></a>(m[, y, rowvar, bias, ddof])</p></td>
<td><p>Estimate a covariance matrix, given data and weights.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.cumprod" title="dask.array.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumprod</span></code></a>(x[, axis, dtype, out])</p></td>
<td><p>Return the cumulative product of elements along a given axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.cumsum" title="dask.array.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code></a>(x[, axis, dtype, out])</p></td>
<td><p>Return the cumulative sum of the elements along a given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.deg2rad" title="dask.array.deg2rad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deg2rad</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.deg2rad.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.degrees" title="dask.array.degrees"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degrees</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.degrees.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.diag" title="dask.array.diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diag</span></code></a>(v)</p></td>
<td><p>Extract a diagonal or construct a diagonal array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.diagonal" title="dask.array.diagonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal</span></code></a>(a[, offset, axis1, axis2])</p></td>
<td><p>Return specified diagonals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.diff" title="dask.array.diff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code></a>(a[, n, axis])</p></td>
<td><p>Calculate the n-th discrete difference along the given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">divmod</span></code>(x1, x2[, out1, out2], / [[, out, …])</p></td>
<td><p>This docstring was copied from numpy.divmod.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.digitize" title="dask.array.digitize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">digitize</span></code></a>(a, bins[, right])</p></td>
<td><p>Return the indices of the bins to which each value in input array belongs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.dot" title="dask.array.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code></a>(a, b[, out])</p></td>
<td><p>This docstring was copied from numpy.dot.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.dstack" title="dask.array.dstack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dstack</span></code></a>(tup[, allow_unknown_chunksizes])</p></td>
<td><p>Stack arrays in sequence depth wise (along third axis).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.ediff1d" title="dask.array.ediff1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ediff1d</span></code></a>(ary[, to_end, to_begin])</p></td>
<td><p>The differences between consecutive elements of an array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.einsum" title="dask.array.einsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">einsum</span></code></a>(subscripts, *operands[, out, dtype, …])</p></td>
<td><p>This docstring was copied from numpy.einsum.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.empty" title="dask.array.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a>(*args, **kwargs)</p></td>
<td><p>Blocked variant of empty</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.empty_like" title="dask.array.empty_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty_like</span></code></a>(a[, dtype, chunks])</p></td>
<td><p>Return a new array with the same shape and type as a given array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.exp" title="dask.array.exp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exp</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.exp.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.expm1" title="dask.array.expm1"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expm1</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.expm1.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.eye" title="dask.array.eye"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eye</span></code></a>(N[, chunks, M, k, dtype])</p></td>
<td><p>Return a 2-D Array with ones on the diagonal and zeros elsewhere.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.fabs" title="dask.array.fabs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fabs</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.fabs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fix" title="dask.array.fix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix</span></code></a>(*args, **kwargs)</p></td>
<td><p>Round to nearest integer towards zero.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.flatnonzero" title="dask.array.flatnonzero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatnonzero</span></code></a>(a)</p></td>
<td><p>Return indices that are non-zero in the flattened version of a.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.flip" title="dask.array.flip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flip</span></code></a>(m, axis)</p></td>
<td><p>Reverse element order along axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.flipud" title="dask.array.flipud"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flipud</span></code></a>(m)</p></td>
<td><p>Flip array in the up/down direction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fliplr" title="dask.array.fliplr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fliplr</span></code></a>(m)</p></td>
<td><p>Flip array in the left/right direction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.floor" title="dask.array.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.floor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fmax" title="dask.array.fmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmax</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.fmax.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.fmin" title="dask.array.fmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmin</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.fmin.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fmod" title="dask.array.fmod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmod</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.fmod.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.frexp" title="dask.array.frexp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frexp</span></code></a>(x[, out1, out2], / [[, out, where, …])</p></td>
<td><p>This docstring was copied from numpy.frexp.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fromfunction" title="dask.array.fromfunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fromfunction</span></code></a>(func[, chunks, shape, dtype])</p></td>
<td><p>Construct an array by executing a function over each coordinate.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.frompyfunc" title="dask.array.frompyfunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frompyfunc</span></code></a>(func, nin, nout)</p></td>
<td><p>This docstring was copied from numpy.frompyfunc.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.full" title="dask.array.full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code></a>(*args, **kwargs)</p></td>
<td><p>Blocked variant of full</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.full_like" title="dask.array.full_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full_like</span></code></a>(a, fill_value[, dtype, chunks])</p></td>
<td><p>Return a full array with the same shape and type as a given array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.gradient" title="dask.array.gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient</span></code></a>(f, *varargs, **kwargs)</p></td>
<td><p>Return the gradient of an N-dimensional array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.histogram" title="dask.array.histogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">histogram</span></code></a>(a[, bins, range, normed, weights, …])</p></td>
<td><p>Blocked variant of <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html#numpy.histogram" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.histogram()</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.hstack" title="dask.array.hstack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hstack</span></code></a>(tup[, allow_unknown_chunksizes])</p></td>
<td><p>Stack arrays in sequence horizontally (column wise).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.hypot" title="dask.array.hypot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hypot</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.hypot.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.imag" title="dask.array.imag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">imag</span></code></a>(*args, **kwargs)</p></td>
<td><p>Return the imaginary part of the complex argument.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.indices" title="dask.array.indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">indices</span></code></a>(dimensions[, dtype, chunks])</p></td>
<td><p>Implements NumPy’s <code class="docutils literal notranslate"><span class="pre">indices</span></code> for Dask Arrays.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.insert" title="dask.array.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a>(arr, obj, values, axis)</p></td>
<td><p>Insert values along the given axis before the given indices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.invert" title="dask.array.invert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.invert.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.isclose" title="dask.array.isclose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isclose</span></code></a>(arr1, arr2[, rtol, atol, equal_nan])</p></td>
<td><p>Returns a boolean array where two arrays are element-wise equal within a tolerance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.iscomplex" title="dask.array.iscomplex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iscomplex</span></code></a>(*args, **kwargs)</p></td>
<td><p>Returns a bool array, where True if input element is complex.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.isfinite" title="dask.array.isfinite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfinite</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.isfinite.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.isin" title="dask.array.isin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isin</span></code></a>(element, test_elements[, …])</p></td>
<td><p>Calculates <cite>element in test_elements</cite>, broadcasting over <cite>element</cite> only.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.isinf" title="dask.array.isinf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinf</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.isinf.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.isneginf" title="dask.array.isneginf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isneginf</span></code></a></p></td>
<td><p>This docstring was copied from numpy.equal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.isnan" title="dask.array.isnan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnan</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.isnan.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.isnull" title="dask.array.isnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnull</span></code></a>(values)</p></td>
<td><p>pandas.isnull for dask arrays</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.isposinf" title="dask.array.isposinf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isposinf</span></code></a></p></td>
<td><p>This docstring was copied from numpy.equal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.isreal" title="dask.array.isreal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isreal</span></code></a>(*args, **kwargs)</p></td>
<td><p>Returns a bool array, where True if input element is real.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.ldexp" title="dask.array.ldexp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ldexp</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.ldexp.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.linspace" title="dask.array.linspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linspace</span></code></a>(start, stop[, num, endpoint, …])</p></td>
<td><p>Return <cite>num</cite> evenly spaced values over the closed interval [<cite>start</cite>, <cite>stop</cite>].</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.log" title="dask.array.log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.log.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.log10" title="dask.array.log10"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log10</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.log10.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.log1p" title="dask.array.log1p"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log1p</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.log1p.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.log2" title="dask.array.log2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log2</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.log2.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.logaddexp" title="dask.array.logaddexp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logaddexp</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.logaddexp.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.logaddexp2" title="dask.array.logaddexp2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logaddexp2</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.logaddexp2.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.logical_and" title="dask.array.logical_and"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_and</span></code></a>(x1, x2, /[, out, where, …])</p></td>
<td><p>This docstring was copied from numpy.logical_and.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.logical_not" title="dask.array.logical_not"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_not</span></code></a>(x, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.logical_not.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.logical_or" title="dask.array.logical_or"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_or</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.logical_or.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.logical_xor" title="dask.array.logical_xor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_xor</span></code></a>(x1, x2, /[, out, where, …])</p></td>
<td><p>This docstring was copied from numpy.logical_xor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="array-overlap.html#dask.array.map_overlap" title="dask.array.map_overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_overlap</span></code></a>(x, func, depth[, boundary, trim])</p></td>
<td><p>Map a function over blocks of the array with some overlap</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.map_blocks" title="dask.array.map_blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_blocks</span></code></a>(func, *args[, name, token, …])</p></td>
<td><p>Map a function across all blocks of a dask array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.matmul" title="dask.array.matmul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matmul</span></code></a>(x1, x2, /[, out, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.matmul.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.max" title="dask.array.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code></a>(a[, axis, keepdims, split_every, out])</p></td>
<td><p>Return the maximum of an array or maximum along an axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.maximum" title="dask.array.maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.maximum.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.mean" title="dask.array.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>(a[, axis, dtype, keepdims, …])</p></td>
<td><p>Compute the arithmetic mean along the specified axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.median" title="dask.array.median"><code class="xref py py-obj docutils literal notranslate"><span class="pre">median</span></code></a>(a[, axis, keepdims, out])</p></td>
<td><p>Compute the median along the specified axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.meshgrid" title="dask.array.meshgrid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">meshgrid</span></code></a>(*xi, **kwargs)</p></td>
<td><p>Return coordinate matrices from coordinate vectors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.min" title="dask.array.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code></a>(a[, axis, keepdims, split_every, out])</p></td>
<td><p>Return the minimum of an array or minimum along an axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.minimum" title="dask.array.minimum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.minimum.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.modf" title="dask.array.modf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">modf</span></code></a>(x[, out1, out2], / [[, out, where, …])</p></td>
<td><p>This docstring was copied from numpy.modf.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.moment" title="dask.array.moment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment</span></code></a>(a, order[, axis, dtype, keepdims, …])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.moveaxis" title="dask.array.moveaxis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moveaxis</span></code></a>(a, source, destination)</p></td>
<td><p>Move axes of an array to new positions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.nanargmax" title="dask.array.nanargmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanargmax</span></code></a>(x[, axis, split_every, out])</p></td>
<td><p>Return the maximum of an array or maximum along an axis, ignoring any NaNs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.nanargmin" title="dask.array.nanargmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanargmin</span></code></a>(x[, axis, split_every, out])</p></td>
<td><p>Return minimum of an array or minimum along an axis, ignoring any NaNs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.nancumprod" title="dask.array.nancumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nancumprod</span></code></a>(x, axis[, dtype, out])</p></td>
<td><p>Return the cumulative product of array elements over a given axis treating Not a Numbers (NaNs) as one.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.nancumsum" title="dask.array.nancumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nancumsum</span></code></a>(x, axis[, dtype, out])</p></td>
<td><p>Return the cumulative sum of array elements over a given axis treating Not a Numbers (NaNs) as zero.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.nanmax" title="dask.array.nanmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmax</span></code></a>(a[, axis, keepdims, split_every, out])</p></td>
<td><p>Return the maximum of an array or maximum along an axis, ignoring any NaNs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.nanmean" title="dask.array.nanmean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmean</span></code></a>(a[, axis, dtype, keepdims, …])</p></td>
<td><p>Compute the arithmetic mean along the specified axis, ignoring NaNs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.nanmedian" title="dask.array.nanmedian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmedian</span></code></a>(a[, axis, keepdims, out])</p></td>
<td><p>Compute the median along the specified axis, while ignoring NaNs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.nanmin" title="dask.array.nanmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmin</span></code></a>(a[, axis, keepdims, split_every, out])</p></td>
<td><p>Return minimum of an array or minimum along an axis, ignoring any NaNs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.nanprod" title="dask.array.nanprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanprod</span></code></a>(a[, axis, dtype, keepdims, …])</p></td>
<td><p>Return the product of array elements over a given axis treating Not a Numbers (NaNs) as ones.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.nanstd" title="dask.array.nanstd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanstd</span></code></a>(a[, axis, dtype, keepdims, ddof, …])</p></td>
<td><p>Compute the standard deviation along the specified axis, while ignoring NaNs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.nansum" title="dask.array.nansum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nansum</span></code></a>(a[, axis, dtype, keepdims, …])</p></td>
<td><p>Return the sum of array elements over a given axis treating Not a Numbers (NaNs) as zero.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.nanvar" title="dask.array.nanvar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanvar</span></code></a>(a[, axis, dtype, keepdims, ddof, …])</p></td>
<td><p>Compute the variance along the specified axis, while ignoring NaNs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.nan_to_num" title="dask.array.nan_to_num"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nan_to_num</span></code></a>(*args, **kwargs)</p></td>
<td><p>Replace NaN with zero and infinity with large finite numbers (default behaviour) or with the numbers defined by the user using the <cite>nan</cite>,  <cite>posinf</cite> and/or <cite>neginf</cite> keywords.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.nextafter" title="dask.array.nextafter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nextafter</span></code></a>(x1, x2, /[, out, where, casting, …])</p></td>
<td><p>This docstring was copied from numpy.nextafter.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.nonzero" title="dask.array.nonzero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code></a>(a)</p></td>
<td><p>Return the indices of the elements that are non-zero.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.notnull" title="dask.array.notnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">notnull</span></code></a>(values)</p></td>
<td><p>pandas.notnull for dask arrays</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.ones" title="dask.array.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a>(*args, **kwargs)</p></td>
<td><p>Blocked variant of ones</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.ones_like" title="dask.array.ones_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones_like</span></code></a>(a[, dtype, chunks])</p></td>
<td><p>Return an array of ones with the same shape and type as a given array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.outer" title="dask.array.outer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">outer</span></code></a>(a, b)</p></td>
<td><p>Compute the outer product of two vectors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.pad" title="dask.array.pad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad</span></code></a>(array, pad_width, mode, **kwargs)</p></td>
<td><p>Pad an array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.percentile" title="dask.array.percentile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">percentile</span></code></a>(a, q[, interpolation, method])</p></td>
<td><p>Approximate percentile of 1-D array</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PerformanceWarning</span></code></p></td>
<td><p>A warning given when bad chunking may cause poor performance</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.piecewise" title="dask.array.piecewise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">piecewise</span></code></a>(x, condlist, funclist, *args, **kw)</p></td>
<td><p>Evaluate a piecewise-defined function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.prod" title="dask.array.prod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code></a>(a[, axis, dtype, keepdims, …])</p></td>
<td><p>Return the product of array elements over a given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.ptp" title="dask.array.ptp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ptp</span></code></a>(a[, axis])</p></td>
<td><p>Range of values (maximum - minimum) along an axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.rad2deg" title="dask.array.rad2deg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rad2deg</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.rad2deg.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.radians" title="dask.array.radians"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radians</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.radians.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.ravel" title="dask.array.ravel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ravel</span></code></a>(array)</p></td>
<td><p>Return a contiguous flattened array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.real" title="dask.array.real"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real</span></code></a>(*args, **kwargs)</p></td>
<td><p>Return the real part of the complex argument.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.rechunk" title="dask.array.rechunk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rechunk</span></code></a>(x[, chunks, threshold, block_size_limit])</p></td>
<td><p>Convert blocks in dask array x for new chunks.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.reduction" title="dask.array.reduction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduction</span></code></a>(x, chunk, aggregate[, axis, …])</p></td>
<td><p>General version of reductions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.repeat" title="dask.array.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a>(a, repeats[, axis])</p></td>
<td><p>Repeat elements of an array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.reshape" title="dask.array.reshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code></a>(x, shape)</p></td>
<td><p>Reshape array to new shape</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.result_type" title="dask.array.result_type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">result_type</span></code></a>(*arrays_and_dtypes)</p></td>
<td><p>This docstring was copied from numpy.result_type.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.rint" title="dask.array.rint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rint</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.rint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.roll" title="dask.array.roll"><code class="xref py py-obj docutils literal notranslate"><span class="pre">roll</span></code></a>(array, shift[, axis])</p></td>
<td><p>Roll array elements along a given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.rollaxis" title="dask.array.rollaxis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rollaxis</span></code></a>(a, axis[, start])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.round" title="dask.array.round"><code class="xref py py-obj docutils literal notranslate"><span class="pre">round</span></code></a>(a[, decimals])</p></td>
<td><p>Round an array to the given number of decimals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.sign" title="dask.array.sign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sign</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.sign.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.signbit" title="dask.array.signbit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signbit</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.signbit.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.sin" title="dask.array.sin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sin</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.sin.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.sinh" title="dask.array.sinh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sinh</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.sinh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.sqrt" title="dask.array.sqrt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sqrt</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.sqrt.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.square" title="dask.array.square"><code class="xref py py-obj docutils literal notranslate"><span class="pre">square</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.square.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.squeeze" title="dask.array.squeeze"><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code></a>(a[, axis])</p></td>
<td><p>Remove single-dimensional entries from the shape of an array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.stack" title="dask.array.stack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack</span></code></a>(seq[, axis])</p></td>
<td><p>Stack arrays along a new axis</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.std" title="dask.array.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>(a[, axis, dtype, keepdims, ddof, …])</p></td>
<td><p>Compute the standard deviation along the specified axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.sum" title="dask.array.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>(a[, axis, dtype, keepdims, split_every, out])</p></td>
<td><p>Sum of array elements over a given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.take" title="dask.array.take"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code></a>(a, indices[, axis])</p></td>
<td><p>Take elements from an array along an axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.tan" title="dask.array.tan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tan</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.tan.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.tanh" title="dask.array.tanh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tanh</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.tanh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.tensordot" title="dask.array.tensordot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensordot</span></code></a>(lhs, rhs[, axes])</p></td>
<td><p>Compute tensor dot product along specified axes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.tile" title="dask.array.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a>(A, reps)</p></td>
<td><p>Construct an array by repeating A the number of times given by reps.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.topk" title="dask.array.topk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">topk</span></code></a>(a, k[, axis, split_every])</p></td>
<td><p>Extract the k largest elements from a on the given axis, and return them sorted from largest to smallest.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>(a[, offset, axis1, axis2, dtype])</p></td>
<td><p>Return the sum along diagonals of the array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.transpose" title="dask.array.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(a[, axes])</p></td>
<td><p>Permute the dimensions of an array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.tril" title="dask.array.tril"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tril</span></code></a>(m[, k])</p></td>
<td><p>Lower triangle of an array with elements above the <cite>k</cite>-th diagonal zeroed.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.triu" title="dask.array.triu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triu</span></code></a>(m[, k])</p></td>
<td><p>Upper triangle of an array with elements below the <cite>k</cite>-th diagonal zeroed.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.trunc" title="dask.array.trunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trunc</span></code></a>(x, /[, out, where, casting, order, …])</p></td>
<td><p>This docstring was copied from numpy.trunc.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unify_chunks</span></code>(*args, **kwargs)</p></td>
<td><p>Unify chunks across a sequence of arrays</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.unique" title="dask.array.unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique</span></code></a>(ar[, return_index, return_inverse, …])</p></td>
<td><p>Find the unique elements of an array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.unravel_index" title="dask.array.unravel_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unravel_index</span></code></a>(indices, shape[, order])</p></td>
<td><p>This docstring was copied from numpy.unravel_index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.var" title="dask.array.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>(a[, axis, dtype, keepdims, ddof, …])</p></td>
<td><p>Compute the variance along the specified axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.vdot" title="dask.array.vdot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vdot</span></code></a>(a, b)</p></td>
<td><p>This docstring was copied from numpy.vdot.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.vstack" title="dask.array.vstack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vstack</span></code></a>(tup[, allow_unknown_chunksizes])</p></td>
<td><p>Stack arrays in sequence vertically (row wise).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.where" title="dask.array.where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">where</span></code></a>(condition, [x, y])</p></td>
<td><p>This docstring was copied from numpy.where.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.zeros" title="dask.array.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a>(*args, **kwargs)</p></td>
<td><p>Blocked variant of zeros</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.zeros_like" title="dask.array.zeros_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros_like</span></code></a>(a[, dtype, chunks])</p></td>
<td><p>Return an array of zeros with the same shape and type as a given array.</p></td>
</tr>
</tbody>
</table>
<div class="section" id="fast-fourier-transforms">
<h2>Fast Fourier Transforms<a class="headerlink" href="#fast-fourier-transforms" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.fft.fft_wrap" title="dask.array.fft.fft_wrap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.fft_wrap</span></code></a>(fft_func[, kind, dtype])</p></td>
<td><p>Wrap 1D, 2D, and ND real and complex FFT functions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fft.fft" title="dask.array.fft.fft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.fft</span></code></a>(a[, n, axis])</p></td>
<td><p>Wrapping of numpy.fft.fft</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.fft.fft2" title="dask.array.fft.fft2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.fft2</span></code></a>(a[, s, axes])</p></td>
<td><p>Wrapping of numpy.fft.fft2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fft.fftn" title="dask.array.fft.fftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.fftn</span></code></a>(a[, s, axes])</p></td>
<td><p>Wrapping of numpy.fft.fftn</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.fft.ifft" title="dask.array.fft.ifft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.ifft</span></code></a>(a[, n, axis])</p></td>
<td><p>Wrapping of numpy.fft.ifft</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fft.ifft2" title="dask.array.fft.ifft2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.ifft2</span></code></a>(a[, s, axes])</p></td>
<td><p>Wrapping of numpy.fft.ifft2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.fft.ifftn" title="dask.array.fft.ifftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.ifftn</span></code></a>(a[, s, axes])</p></td>
<td><p>Wrapping of numpy.fft.ifftn</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fft.rfft" title="dask.array.fft.rfft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.rfft</span></code></a>(a[, n, axis])</p></td>
<td><p>Wrapping of numpy.fft.rfft</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.fft.rfft2" title="dask.array.fft.rfft2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.rfft2</span></code></a>(a[, s, axes])</p></td>
<td><p>Wrapping of numpy.fft.rfft2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fft.rfftn" title="dask.array.fft.rfftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.rfftn</span></code></a>(a[, s, axes])</p></td>
<td><p>Wrapping of numpy.fft.rfftn</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.fft.irfft" title="dask.array.fft.irfft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.irfft</span></code></a>(a[, n, axis])</p></td>
<td><p>Wrapping of numpy.fft.irfft</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fft.irfft2" title="dask.array.fft.irfft2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.irfft2</span></code></a>(a[, s, axes])</p></td>
<td><p>Wrapping of numpy.fft.irfft2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.fft.irfftn" title="dask.array.fft.irfftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.irfftn</span></code></a>(a[, s, axes])</p></td>
<td><p>Wrapping of numpy.fft.irfftn</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fft.hfft" title="dask.array.fft.hfft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.hfft</span></code></a>(a[, n, axis])</p></td>
<td><p>Wrapping of numpy.fft.hfft</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.fft.ihfft" title="dask.array.fft.ihfft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.ihfft</span></code></a>(a[, n, axis])</p></td>
<td><p>Wrapping of numpy.fft.ihfft</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fft.fftfreq" title="dask.array.fft.fftfreq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.fftfreq</span></code></a>(n[, d, chunks])</p></td>
<td><p>Return the Discrete Fourier Transform sample frequencies.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.fft.rfftfreq" title="dask.array.fft.rfftfreq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.rfftfreq</span></code></a>(n[, d, chunks])</p></td>
<td><p>Return the Discrete Fourier Transform sample frequencies (for usage with rfft, irfft).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.fft.fftshift" title="dask.array.fft.fftshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.fftshift</span></code></a>(x[, axes])</p></td>
<td><p>Shift the zero-frequency component to the center of the spectrum.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.fft.ifftshift" title="dask.array.fft.ifftshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft.ifftshift</span></code></a>(x[, axes])</p></td>
<td><p>The inverse of <cite>fftshift</cite>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="linear-algebra">
<h2>Linear Algebra<a class="headerlink" href="#linear-algebra" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.linalg.cholesky" title="dask.array.linalg.cholesky"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.cholesky</span></code></a>(a[, lower])</p></td>
<td><p>Returns the Cholesky decomposition, <span class="math notranslate nohighlight">\(A = L L^*\)</span> or <span class="math notranslate nohighlight">\(A = U^* U\)</span> of a Hermitian positive-definite matrix A.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.linalg.inv" title="dask.array.linalg.inv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.inv</span></code></a>(a)</p></td>
<td><p>Compute the inverse of a matrix with LU decomposition and forward / backward substitutions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.linalg.lstsq" title="dask.array.linalg.lstsq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.lstsq</span></code></a>(a, b)</p></td>
<td><p>Return the least-squares solution to a linear matrix equation using QR decomposition.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.linalg.lu" title="dask.array.linalg.lu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.lu</span></code></a>(a)</p></td>
<td><p>Compute the lu decomposition of a matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.linalg.norm" title="dask.array.linalg.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.norm</span></code></a>(x[, ord, axis, keepdims])</p></td>
<td><p>Matrix or vector norm.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.linalg.qr" title="dask.array.linalg.qr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.qr</span></code></a>(a)</p></td>
<td><p>Compute the qr factorization of a matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.linalg.solve" title="dask.array.linalg.solve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.solve</span></code></a>(a, b[, sym_pos])</p></td>
<td><p>Solve the equation <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></code> for <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.linalg.solve_triangular" title="dask.array.linalg.solve_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.solve_triangular</span></code></a>(a, b[, lower])</p></td>
<td><p>Solve the equation <cite>a x = b</cite> for <cite>x</cite>, assuming a is a triangular matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.linalg.svd" title="dask.array.linalg.svd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.svd</span></code></a>(a)</p></td>
<td><p>Compute the singular value decomposition of a matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.linalg.svd_compressed" title="dask.array.linalg.svd_compressed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.svd_compressed</span></code></a>(a, k[, n_power_iter, …])</p></td>
<td><p>Randomly compressed rank-k thin Singular Value Decomposition.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.linalg.sfqr" title="dask.array.linalg.sfqr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.sfqr</span></code></a>(data[, name])</p></td>
<td><p>Direct Short-and-Fat QR</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.linalg.tsqr" title="dask.array.linalg.tsqr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.tsqr</span></code></a>(data[, compute_svd, …])</p></td>
<td><p>Direct Tall-and-Skinny QR algorithm</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="masked-arrays">
<h2>Masked Arrays<a class="headerlink" href="#masked-arrays" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.ma.average" title="dask.array.ma.average"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.average</span></code></a>(a[, axis, weights, returned])</p></td>
<td><p>Return the weighted average of array over the given axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.ma.filled" title="dask.array.ma.filled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.filled</span></code></a>(a[, fill_value])</p></td>
<td><p>Return input as an array with masked data replaced by a fill value.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.ma.fix_invalid" title="dask.array.ma.fix_invalid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.fix_invalid</span></code></a>(a[, fill_value])</p></td>
<td><p>Return input with invalid data masked and replaced by a fill value.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.ma.getdata" title="dask.array.ma.getdata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.getdata</span></code></a>(a)</p></td>
<td><p>Return the data of a masked array as an ndarray.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.ma.getmaskarray" title="dask.array.ma.getmaskarray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.getmaskarray</span></code></a>(a)</p></td>
<td><p>Return the mask of a masked array, or full boolean array of False.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.ma.masked_array" title="dask.array.ma.masked_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.masked_array</span></code></a>(data[, mask, fill_value])</p></td>
<td><p>An array class with possibly masked values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.ma.masked_equal" title="dask.array.ma.masked_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.masked_equal</span></code></a>(a, value)</p></td>
<td><p>Mask an array where equal to a given value.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.ma.masked_greater" title="dask.array.ma.masked_greater"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.masked_greater</span></code></a>(x, value[, copy])</p></td>
<td><p>Mask an array where greater than a given value.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.ma.masked_greater_equal" title="dask.array.ma.masked_greater_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.masked_greater_equal</span></code></a>(x, value[, copy])</p></td>
<td><p>Mask an array where greater than or equal to a given value.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.ma.masked_inside" title="dask.array.ma.masked_inside"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.masked_inside</span></code></a>(x, v1, v2)</p></td>
<td><p>Mask an array inside a given interval.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.ma.masked_invalid" title="dask.array.ma.masked_invalid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.masked_invalid</span></code></a>(a)</p></td>
<td><p>Mask an array where invalid values occur (NaNs or infs).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.ma.masked_less" title="dask.array.ma.masked_less"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.masked_less</span></code></a>(x, value[, copy])</p></td>
<td><p>Mask an array where less than a given value.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.ma.masked_less_equal" title="dask.array.ma.masked_less_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.masked_less_equal</span></code></a>(x, value[, copy])</p></td>
<td><p>Mask an array where less than or equal to a given value.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.ma.masked_not_equal" title="dask.array.ma.masked_not_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.masked_not_equal</span></code></a>(x, value[, copy])</p></td>
<td><p>Mask an array where <cite>not</cite> equal to a given value.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.ma.masked_outside" title="dask.array.ma.masked_outside"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.masked_outside</span></code></a>(x, v1, v2)</p></td>
<td><p>Mask an array outside a given interval.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.ma.masked_values" title="dask.array.ma.masked_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.masked_values</span></code></a>(x, value[, rtol, atol, shrink])</p></td>
<td><p>Mask using floating point equality.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.ma.masked_where" title="dask.array.ma.masked_where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.masked_where</span></code></a>(condition, a)</p></td>
<td><p>Mask an array where a condition is met.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.ma.set_fill_value" title="dask.array.ma.set_fill_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.set_fill_value</span></code></a>(a, fill_value)</p></td>
<td><p>Set the filling value of a, if a is a masked array.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="random">
<h2>Random<a class="headerlink" href="#random" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.beta" title="dask.array.random.beta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.beta</span></code></a>(a, b[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.beta.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.binomial" title="dask.array.random.binomial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.binomial</span></code></a>(n, p[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.binomial.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.chisquare" title="dask.array.random.chisquare"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.chisquare</span></code></a>(df[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.chisquare.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.choice" title="dask.array.random.choice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.choice</span></code></a>(a[, size, replace, p])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.choice.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.exponential" title="dask.array.random.exponential"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.exponential</span></code></a>([scale, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.exponential.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.f" title="dask.array.random.f"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.f</span></code></a>(dfnum, dfden[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.f.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.gamma" title="dask.array.random.gamma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.gamma</span></code></a>(shape[, scale, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.gamma.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.geometric" title="dask.array.random.geometric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.geometric</span></code></a>(p[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.geometric.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.gumbel" title="dask.array.random.gumbel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.gumbel</span></code></a>([loc, scale, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.gumbel.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.hypergeometric" title="dask.array.random.hypergeometric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.hypergeometric</span></code></a>(ngood, nbad, nsample)</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.hypergeometric.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.laplace" title="dask.array.random.laplace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.laplace</span></code></a>([loc, scale, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.laplace.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.logistic" title="dask.array.random.logistic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.logistic</span></code></a>([loc, scale, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.logistic.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.lognormal" title="dask.array.random.lognormal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.lognormal</span></code></a>([mean, sigma, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.lognormal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.logseries" title="dask.array.random.logseries"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.logseries</span></code></a>(p[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.logseries.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.negative_binomial" title="dask.array.random.negative_binomial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.negative_binomial</span></code></a>(n, p[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.negative_binomial.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.noncentral_chisquare" title="dask.array.random.noncentral_chisquare"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.noncentral_chisquare</span></code></a>(df, nonc[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.noncentral_chisquare.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.noncentral_f" title="dask.array.random.noncentral_f"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.noncentral_f</span></code></a>(dfnum, dfden, nonc[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.noncentral_f.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.normal" title="dask.array.random.normal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.normal</span></code></a>([loc, scale, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.normal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.pareto" title="dask.array.random.pareto"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.pareto</span></code></a>(a[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.pareto.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.permutation</span></code>(x)</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.permutation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.poisson" title="dask.array.random.poisson"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.poisson</span></code></a>([lam, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.poisson.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.power" title="dask.array.random.power"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.power</span></code></a>(a[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.power.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.randint" title="dask.array.random.randint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.randint</span></code></a>(low[, high, size, dtype])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.randint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.random" title="dask.array.random.random"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.random</span></code></a>([size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.random_sample.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.random_sample" title="dask.array.random.random_sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.random_sample</span></code></a>([size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.random_sample.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.rayleigh" title="dask.array.random.rayleigh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.rayleigh</span></code></a>([scale, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.rayleigh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.standard_cauchy" title="dask.array.random.standard_cauchy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.standard_cauchy</span></code></a>([size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.standard_cauchy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.standard_exponential" title="dask.array.random.standard_exponential"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.standard_exponential</span></code></a>([size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.standard_exponential.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.standard_gamma" title="dask.array.random.standard_gamma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.standard_gamma</span></code></a>(shape[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.standard_gamma.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.standard_normal" title="dask.array.random.standard_normal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.standard_normal</span></code></a>([size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.standard_normal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.standard_t" title="dask.array.random.standard_t"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.standard_t</span></code></a>(df[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.standard_t.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.triangular" title="dask.array.random.triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.triangular</span></code></a>(left, mode, right[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.triangular.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.uniform" title="dask.array.random.uniform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.uniform</span></code></a>([low, high, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.uniform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.vonmises" title="dask.array.random.vonmises"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.vonmises</span></code></a>(mu, kappa[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.vonmises.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.wald" title="dask.array.random.wald"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.wald</span></code></a>(mean, scale[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.wald.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.random.weibull" title="dask.array.random.weibull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.weibull</span></code></a>(a[, size])</p></td>
<td><p>This docstring was copied from numpy.random.mtrand.RandomState.weibull.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.random.zipf" title="dask.array.random.zipf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.zipf</span></code></a>(a[, size])</p></td>
<td><p>Standard distributions</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="stats">
<h2>Stats<a class="headerlink" href="#stats" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.stats.ttest_ind" title="dask.array.stats.ttest_ind"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats.ttest_ind</span></code></a>(a, b[, axis, equal_var])</p></td>
<td><p>Calculate the T-test for the means of <em>two independent</em> samples of scores.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.stats.ttest_1samp" title="dask.array.stats.ttest_1samp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats.ttest_1samp</span></code></a>(a, popmean[, axis, nan_policy])</p></td>
<td><p>Calculate the T-test for the mean of ONE group of scores.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.stats.ttest_rel" title="dask.array.stats.ttest_rel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats.ttest_rel</span></code></a>(a, b[, axis, nan_policy])</p></td>
<td><p>Calculate the t-test on TWO RELATED samples of scores, a and b.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.stats.chisquare" title="dask.array.stats.chisquare"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats.chisquare</span></code></a>(f_obs[, f_exp, ddof, axis])</p></td>
<td><p>Calculate a one-way chi-square test.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.stats.power_divergence" title="dask.array.stats.power_divergence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats.power_divergence</span></code></a>(f_obs[, f_exp, ddof, …])</p></td>
<td><p>Cressie-Read power divergence statistic and goodness of fit test.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.stats.skew" title="dask.array.stats.skew"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats.skew</span></code></a>(a[, axis, bias, nan_policy])</p></td>
<td><p>Compute the sample skewness of a data set.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.stats.skewtest" title="dask.array.stats.skewtest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats.skewtest</span></code></a>(a[, axis, nan_policy])</p></td>
<td><p>Test whether the skew is different from the normal distribution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.stats.kurtosis" title="dask.array.stats.kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats.kurtosis</span></code></a>(a[, axis, fisher, bias, …])</p></td>
<td><p>Compute the kurtosis (Fisher or Pearson) of a dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.stats.kurtosistest" title="dask.array.stats.kurtosistest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats.kurtosistest</span></code></a>(a[, axis, nan_policy])</p></td>
<td><p>Test whether a dataset has normal kurtosis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.stats.normaltest" title="dask.array.stats.normaltest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats.normaltest</span></code></a>(a[, axis, nan_policy])</p></td>
<td><p>Test whether a sample differs from a normal distribution.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.stats.f_oneway" title="dask.array.stats.f_oneway"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats.f_oneway</span></code></a>(*args)</p></td>
<td><p>Perform one-way ANOVA.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.stats.moment" title="dask.array.stats.moment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats.moment</span></code></a>(a[, moment, axis, nan_policy])</p></td>
<td><p>Calculate the nth moment about the mean for a sample.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="image-support">
<h2>Image Support<a class="headerlink" href="#image-support" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.image.imread" title="dask.array.image.imread"><code class="xref py py-obj docutils literal notranslate"><span class="pre">image.imread</span></code></a>(filename[, imread, preprocess])</p></td>
<td><p>Read a stack of images into a dask array</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="slightly-overlapping-computations">
<h2>Slightly Overlapping Computations<a class="headerlink" href="#slightly-overlapping-computations" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.overlap.overlap" title="dask.array.overlap.overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap.overlap</span></code></a>(x, depth, boundary)</p></td>
<td><p>Share boundaries between neighboring blocks</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.overlap.map_overlap" title="dask.array.overlap.map_overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap.map_overlap</span></code></a>(x, func, depth[, …])</p></td>
<td><p>Map a function over blocks of the array with some overlap</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.overlap.trim_internal" title="dask.array.overlap.trim_internal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap.trim_internal</span></code></a>(x, axes[, boundary])</p></td>
<td><p>Trim sides from each block</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.overlap.trim_overlap" title="dask.array.overlap.trim_overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap.trim_overlap</span></code></a>(x, depth[, boundary])</p></td>
<td><p>Trim sides from each block.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="create-and-store-arrays">
<h2>Create and Store Arrays<a class="headerlink" href="#create-and-store-arrays" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.from_array" title="dask.array.from_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_array</span></code></a>(x[, chunks, name, lock, asarray, …])</p></td>
<td><p>Create dask array from something that looks like an array</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.from_delayed" title="dask.array.from_delayed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_delayed</span></code></a>(value, shape[, dtype, meta, name])</p></td>
<td><p>Create a dask array from a dask delayed value</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.from_npy_stack" title="dask.array.from_npy_stack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_npy_stack</span></code></a>(dirname[, mmap_mode])</p></td>
<td><p>Load dask array from stack of npy files</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.from_zarr" title="dask.array.from_zarr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_zarr</span></code></a>(url[, component, storage_options, …])</p></td>
<td><p>Load array from the zarr storage format</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.from_tiledb" title="dask.array.from_tiledb"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_tiledb</span></code></a>(uri[, attribute, chunks, …])</p></td>
<td><p>Load array from the TileDB storage format</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.store" title="dask.array.store"><code class="xref py py-obj docutils literal notranslate"><span class="pre">store</span></code></a>(sources, targets[, lock, regions, …])</p></td>
<td><p>Store dask arrays in array-like objects, overwrite data in target</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.to_hdf5" title="dask.array.to_hdf5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_hdf5</span></code></a>(filename, *args, **kwargs)</p></td>
<td><p>Store arrays in HDF5 file</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.to_zarr" title="dask.array.to_zarr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_zarr</span></code></a>(arr, url[, component, …])</p></td>
<td><p>Save array to the zarr storage format</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.to_npy_stack" title="dask.array.to_npy_stack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_npy_stack</span></code></a>(dirname, x[, axis])</p></td>
<td><p>Write dask array to a stack of .npy files</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.to_tiledb" title="dask.array.to_tiledb"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_tiledb</span></code></a>(darray, uri[, compute, …])</p></td>
<td><p>Save array to the TileDB storage format</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="generalized-ufuncs">
<h2>Generalized Ufuncs<a class="headerlink" href="#generalized-ufuncs" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.gufunc.apply_gufunc" title="dask.array.gufunc.apply_gufunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_gufunc</span></code></a>(func, signature, *args, **kwargs)</p></td>
<td><p>Apply a generalized ufunc or similar python function to arrays.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.gufunc.as_gufunc" title="dask.array.gufunc.as_gufunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_gufunc</span></code></a>([signature])</p></td>
<td><p>Decorator for <code class="docutils literal notranslate"><span class="pre">dask.array.gufunc</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.gufunc.gufunc" title="dask.array.gufunc.gufunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gufunc</span></code></a>(pyfunc, **kwargs)</p></td>
<td><p>Binds <cite>pyfunc</cite> into <code class="docutils literal notranslate"><span class="pre">dask.array.apply_gufunc</span></code> when called.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="internal-functions">
<h2>Internal functions<a class="headerlink" href="#internal-functions" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dask.array.core.blockwise" title="dask.array.core.blockwise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">blockwise</span></code></a>(func, out_ind, *args[, name, …])</p></td>
<td><p>Tensor operation: Generalized inner and outer products</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dask.array.core.normalize_chunks" title="dask.array.core.normalize_chunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_chunks</span></code></a>(chunks[, shape, limit, …])</p></td>
<td><p>Normalize chunks to tuple of tuples</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="other-functions">
<h2>Other functions<a class="headerlink" href="#other-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="dask.array.from_array">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">from_array</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">chunks='auto'</em>, <em class="sig-param">name=None</em>, <em class="sig-param">lock=False</em>, <em class="sig-param">asarray=None</em>, <em class="sig-param">fancy=True</em>, <em class="sig-param">getitem=None</em>, <em class="sig-param">meta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.from_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create dask array from something that looks like an array</p>
<p>Input must have a <code class="docutils literal notranslate"><span class="pre">.shape</span></code>, <code class="docutils literal notranslate"><span class="pre">.ndim</span></code>, <code class="docutils literal notranslate"><span class="pre">.dtype</span></code> and support numpy-style slicing.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>chunks</strong><span class="classifier">int, tuple</span></dt><dd><p>How to chunk the array. Must be one of the following forms:</p>
<ul class="simple">
<li><p>A blocksize like 1000.</p></li>
<li><p>A blockshape like (1000, 1000).</p></li>
<li><p>Explicit sizes of all blocks along all dimensions like
((1000, 1000, 500), (400, 400)).</p></li>
<li><p>A size in bytes, like “100 MiB” which will choose a uniform
block-like shape</p></li>
<li><p>The word “auto” which acts like the above, but uses a configuration
value <code class="docutils literal notranslate"><span class="pre">array.chunk-size</span></code> for the chunk size</p></li>
</ul>
<p>-1 or None as a blocksize indicate the size of the corresponding
dimension.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>The key name to use for the array. Defaults to a hash of <code class="docutils literal notranslate"><span class="pre">x</span></code>.
By default, hash uses python’s standard sha1. This behaviour can be
changed by installing cityhash, xxhash or murmurhash. If installed,
a large-factor speedup can be obtained in the tokenisation step.
Use <code class="docutils literal notranslate"><span class="pre">name=False</span></code> to generate a random name instead of hashing (fast)</p>
</dd>
<dt><strong>lock</strong><span class="classifier">bool or Lock, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> doesn’t support concurrent reads then provide a lock here, or
pass in True to have dask.array create one for you.</p>
</dd>
<dt><strong>asarray</strong><span class="classifier">bool, optional</span></dt><dd><p>If True then call np.asarray on chunks to convert them to numpy arrays.
If False then chunks are passed through unchanged.
If None (default) then we use True if the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> method
is undefined.</p>
</dd>
<dt><strong>fancy</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> doesn’t support fancy indexing (e.g. indexing with lists or
arrays) then set to False. Default is True.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">Array-like, optional</span></dt><dd><p>The metadata for the resulting dask array.  This is the kind of array
that will result from slicing the input array.
Defaults to the input array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)[</span><span class="s1">&#39;/data/path&#39;</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>  
</pre></div>
</div>
<p>If your underlying datastore does not support concurrent reads then include
the <code class="docutils literal notranslate"><span class="pre">lock=True</span></code> keyword argument or <code class="docutils literal notranslate"><span class="pre">lock=mylock</span></code> if you want multiple
arrays to coordinate around the same lock.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="n">lock</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
</pre></div>
</div>
<p>If your underlying datastore has a <code class="docutils literal notranslate"><span class="pre">.chunks</span></code> attribute (as h5py and zarr
datasets do) then a multiple of that chunk shape will be used if you
do not provide a chunk shape.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="s1">&#39;100 MiB&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.from_delayed">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">from_delayed</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">shape</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">meta=None</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.from_delayed" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a dask array from a dask delayed value</p>
<p>This routine is useful for constructing dask arrays in an ad-hoc fashion
using dask delayed, particularly when combined with stack and concatenate.</p>
<p>The dask array will consist of a single chunk.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">)(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_delayed</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span>
<span class="go">dask.array&lt;from-value, shape=(5,), dtype=float64, chunksize=(5,), chunktype=numpy.ndarray&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([1., 1., 1., 1., 1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.store">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">store</code><span class="sig-paren">(</span><em class="sig-param">sources</em>, <em class="sig-param">targets</em>, <em class="sig-param">lock=True</em>, <em class="sig-param">regions=None</em>, <em class="sig-param">compute=True</em>, <em class="sig-param">return_stored=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.store" title="Permalink to this definition">¶</a></dt>
<dd><p>Store dask arrays in array-like objects, overwrite data in target</p>
<p>This stores dask arrays into object that supports numpy-style setitem
indexing.  It stores values chunk by chunk so that it does not have to
fill up memory.  For best performance you can align the block size of
the storage target with the block size of your array.</p>
<p>If your data fits in memory then you may prefer calling
<code class="docutils literal notranslate"><span class="pre">np.array(myarray)</span></code> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sources: Array or iterable of Arrays</strong></dt><dd></dd>
<dt><strong>targets: array-like or Delayed or iterable of array-likes and/or Delayeds</strong></dt><dd><p>These should support setitem syntax <code class="docutils literal notranslate"><span class="pre">target[10:20]</span> <span class="pre">=</span> <span class="pre">...</span></code></p>
</dd>
<dt><strong>lock: boolean or threading.Lock, optional</strong></dt><dd><p>Whether or not to lock the data stores while storing.
Pass True (lock each file individually), False (don’t lock) or a
particular <code class="docutils literal notranslate"><span class="pre">threading.Lock</span></code> object to be shared among all writes.</p>
</dd>
<dt><strong>regions: tuple of slices or list of tuples of slices</strong></dt><dd><p>Each <code class="docutils literal notranslate"><span class="pre">region</span></code> tuple in <code class="docutils literal notranslate"><span class="pre">regions</span></code> should be such that
<code class="docutils literal notranslate"><span class="pre">target[region].shape</span> <span class="pre">=</span> <span class="pre">source.shape</span></code>
for the corresponding source and target in sources and targets,
respectively. If this is a tuple, the contents will be assumed to be
slices, so do not provide a tuple of tuples.</p>
</dd>
<dt><strong>compute: boolean, optional</strong></dt><dd><p>If true compute immediately, return <code class="docutils literal notranslate"><span class="pre">dask.delayed.Delayed</span></code> otherwise</p>
</dd>
<dt><strong>return_stored: boolean, optional</strong></dt><dd><p>Optionally return the stored result (default False).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="o">...</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">h5py</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;myfile.hdf5&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">dset</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;/data&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">chunks</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">store</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dset</span><span class="p">)</span>  
</pre></div>
</div>
<p>Alternatively store many arrays at the same time</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">store</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="p">[</span><span class="n">dset1</span><span class="p">,</span> <span class="n">dset2</span><span class="p">,</span> <span class="n">dset3</span><span class="p">])</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.coarsen">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">coarsen</code><span class="sig-paren">(</span><em class="sig-param">reduction</em>, <em class="sig-param">x</em>, <em class="sig-param">axes</em>, <em class="sig-param">trim_excess=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.coarsen" title="Permalink to this definition">¶</a></dt>
<dd><p>Coarsen array by applying reduction to fixed size neighborhoods</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reduction: function</strong></dt><dd><p>Function like np.sum, np.mean, etc…</p>
</dd>
<dt><strong>x: np.ndarray</strong></dt><dd><p>Array to be coarsened</p>
</dd>
<dt><strong>axes: dict</strong></dt><dd><p>Mapping of axis to coarsening factor</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coarsen</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">array([ 3,  7, 11])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coarsen</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
<span class="go">array([3, 6])</span>
</pre></div>
</div>
<p>Provide dictionary of scale per dimension</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">       [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coarsen</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
<span class="go">array([[ 0,  3],</span>
<span class="go">       [12, 15]])</span>
</pre></div>
</div>
<p>You must avoid excess elements explicitly</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coarsen</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="n">trim_excess</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([1, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.stack">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">stack</code><span class="sig-paren">(</span><em class="sig-param">seq</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays along a new axis</p>
<p>Given a sequence of dask arrays, form a new dask array by stacking them
along a new dimension (axis=0 by default)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.concatenate" title="dask.array.concatenate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concatenate</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Create slices</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">from_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 4, 4)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 3, 4)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 4, 3)</span>
</pre></div>
</div>
<p>Result is a new dask Array</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.concatenate">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">concatenate</code><span class="sig-paren">(</span><em class="sig-param">seq</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">allow_unknown_chunksizes=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate arrays along an existing axis</p>
<p>Given a sequence of dask Arrays form a new dask Array by stacking them
along an existing dimension (axis=0 by default)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seq: list of dask.arrays</strong></dt><dd></dd>
<dt><strong>axis: int</strong></dt><dd><p>Dimension along which to align all of the arrays</p>
</dd>
<dt><strong>allow_unknown_chunksizes: bool</strong></dt><dd><p>Allow unknown chunksizes, such as come from converting from dask
dataframes.  Dask.array is unable to verify that chunks line up.  If
data comes from differently aligned sources then this can cause
unexpected results.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.stack" title="dask.array.stack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Create slices</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">from_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(12, 4)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 12)</span>
</pre></div>
</div>
<p>Result is a new dask Array</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.all">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">all</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether all array elements along a given axis evaluate to True.</p>
<p>This docstring was copied from numpy.all.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which a logical AND reduction is performed.
The default (<code class="docutils literal notranslate"><span class="pre">axis=None</span></code>) is to perform a logical AND over all
the dimensions of the input array. <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.
It must have the same shape as the expected output and its
type is preserved (e.g., if <code class="docutils literal notranslate"><span class="pre">dtype(out)</span></code> is float, the result
will consist of 0.0’s and 1.0’s). See <cite>ufuncs-output-type</cite> for more
details.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>all</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>all</strong><span class="classifier">ndarray, bool</span></dt><dd><p>A new boolean or array is returned unless <cite>out</cite> is specified,
in which case a reference to <cite>out</cite> is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.all</span></code></dt><dd><p>equivalent method</p>
</dd>
<dt><a class="reference internal" href="#dask.array.any" title="dask.array.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code></a></dt><dd><p>Test whether any element along a given axis evaluates to True.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Not a Number (NaN), positive infinity and negative infinity
evaluate to <cite>True</cite> because these are not equal to zero.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">]])</span>  
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>  
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">o</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">z</span>  
<span class="go">(28293632, 28293632, array(True)) # may vary</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.allclose">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">allclose</code><span class="sig-paren">(</span><em class="sig-param">arr1</em>, <em class="sig-param">arr2</em>, <em class="sig-param">rtol=1e-05</em>, <em class="sig-param">atol=1e-08</em>, <em class="sig-param">equal_nan=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.allclose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if two arrays are element-wise equal within a tolerance.</p>
<p>This docstring was copied from numpy.allclose.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The tolerance values are positive, typically very small numbers.  The
relative difference (<cite>rtol</cite> * abs(<cite>b</cite>)) and the absolute difference
<cite>atol</cite> are added together to compare against the absolute difference
between <cite>a</cite> and <cite>b</cite>.</p>
<p>NaNs are treated as equal if they are in the same place and if
<code class="docutils literal notranslate"><span class="pre">equal_nan=True</span></code>.  Infs are treated as equal if they are in the same
place and of the same sign in both arrays.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a, b</strong><span class="classifier">array_like</span></dt><dd><p>Input arrays to compare.</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">float</span></dt><dd><p>The relative tolerance parameter (see Notes).</p>
</dd>
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>The absolute tolerance parameter (see Notes).</p>
</dd>
<dt><strong>equal_nan</strong><span class="classifier">bool</span></dt><dd><p>Whether to compare NaN’s as equal.  If True, NaN’s in <cite>a</cite> will be
considered equal to NaN’s in <cite>b</cite> in the output array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>allclose</strong><span class="classifier">bool</span></dt><dd><p>Returns True if the two arrays are equal within the given
tolerance; False otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.isclose" title="dask.array.isclose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isclose</span></code></a>, <a class="reference internal" href="#dask.array.all" title="dask.array.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code></a>, <a class="reference internal" href="#dask.array.any" title="dask.array.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">equal</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>If the following equation is element-wise True, then allclose returns
True.</p>
<blockquote>
<div><p>absolute(<cite>a</cite> - <cite>b</cite>) &lt;= (<cite>atol</cite> + <cite>rtol</cite> * absolute(<cite>b</cite>))</p>
</div></blockquote>
<p>The above equation is not symmetric in <cite>a</cite> and <cite>b</cite>, so that
<code class="docutils literal notranslate"><span class="pre">allclose(a,</span> <span class="pre">b)</span></code> might be different from <code class="docutils literal notranslate"><span class="pre">allclose(b,</span> <span class="pre">a)</span></code> in
some rare cases.</p>
<p>The comparison of <cite>a</cite> and <cite>b</cite> uses standard broadcasting, which
means that <cite>a</cite> and <cite>b</cite> need not have the same shape in order for
<code class="docutils literal notranslate"><span class="pre">allclose(a,</span> <span class="pre">b)</span></code> to evaluate to True.  The same is true for
<cite>equal</cite> but not <cite>array_equal</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">])</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.angle">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">angle</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">deg=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angle of the complex argument.</p>
<p>This docstring was copied from numpy.angle.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>A complex number or sequence of complex numbers.</p>
</dd>
<dt><strong>deg</strong><span class="classifier">bool, optional</span></dt><dd><p>Return angle in degrees if True, radians if False (default).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>angle</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The counterclockwise angle from the positive real axis on the complex
plane in the range <code class="docutils literal notranslate"><span class="pre">(-pi,</span> <span class="pre">pi]</span></code>, with dtype as numpy.float64.</p>
<dl class="simple">
<dt>..versionchanged:: 1.16.0</dt><dd><p>This function works on subclasses of ndarray like <cite>ma.array</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.arctan2" title="dask.array.arctan2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arctan2</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">absolute</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">])</span>               <span class="c1"># in radians  </span>
<span class="go">array([ 0.        ,  1.57079633,  0.78539816]) # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>                  <span class="c1"># in degrees  </span>
<span class="go">45.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.any">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">any</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any array element along a given axis evaluates to True.</p>
<p>This docstring was copied from numpy.any.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns single boolean unless <cite>axis</cite> is not <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which a logical OR reduction is performed.
The default (<code class="docutils literal notranslate"><span class="pre">axis=None</span></code>) is to perform a logical OR over all
the dimensions of the input array. <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  It must have
the same shape as the expected output and its type is preserved
(e.g., if it is of type float, then it will remain so, returning
1.0 for True and 0.0 for False, regardless of the type of <cite>a</cite>).
See <cite>ufuncs-output-type</cite> for more details.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>any</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>any</strong><span class="classifier">bool or ndarray</span></dt><dd><p>A new boolean or <cite>ndarray</cite> is returned unless <cite>out</cite> is specified,
in which case a reference to <cite>out</cite> is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.any</span></code></dt><dd><p>equivalent method</p>
</dd>
<dt><a class="reference internal" href="#dask.array.all" title="dask.array.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code></a></dt><dd><p>Test whether all elements along a given axis evaluate to True.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Not a Number (NaN), positive infinity and negative infinity evaluate
to <cite>True</cite> because these are not equal to zero.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]])</span>  
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>  
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>  
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">o</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">,</span> <span class="n">o</span>  
<span class="go">(array(True), array(True))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check now that z is a reference to o</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="ow">is</span> <span class="n">o</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="c1"># identity of z and o              </span>
<span class="go">(191614240, 191614240)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.apply_along_axis">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">apply_along_axis</code><span class="sig-paren">(</span><em class="sig-param">func1d</em>, <em class="sig-param">axis</em>, <em class="sig-param">arr</em>, <em class="sig-param">*args</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">shape=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.apply_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to 1-D slices along the given axis.</p>
<p>This docstring was copied from numpy.apply_along_axis.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Apply a function to 1-D slices along the given axis. This is
a blocked variant of <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.apply_along_axis.html#numpy.apply_along_axis" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.apply_along_axis()</span></code></a> implemented via
<a class="reference internal" href="#dask.array.map_blocks" title="dask.array.map_blocks"><code class="xref py py-func docutils literal notranslate"><span class="pre">dask.array.map_blocks()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func1d</strong><span class="classifier">callable</span></dt><dd><p>Function to apply to 1-D slices of the array along the given axis</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>Axis along which func1d will be applied</p>
</dd>
<dt><strong>arr</strong><span class="classifier">dask array</span></dt><dd><p>Dask array to which <code class="docutils literal notranslate"><span class="pre">func1d</span></code> will be applied</p>
</dd>
<dt><strong>args</strong><span class="classifier">any</span></dt><dd><p>Additional arguments to <code class="docutils literal notranslate"><span class="pre">func1d</span></code>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">str or dtype, optional</span></dt><dd><p>The dtype of the output of <code class="docutils literal notranslate"><span class="pre">func1d</span></code>.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple, optional</span></dt><dd><p>The shape of the output of <code class="docutils literal notranslate"><span class="pre">func1d</span></code>.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">any</span></dt><dd><p>Additional keyword arguments for <code class="docutils literal notranslate"><span class="pre">func1d</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray  (Ni…, Nj…, Nk…)</span></dt><dd><p>The output array. The shape of <cite>out</cite> is identical to the shape of
<cite>arr</cite>, except along the <cite>axis</cite> dimension. This axis is removed, and
replaced with new dimensions equal to the shape of the return value
of <cite>func1d</cite>. So if <cite>func1d</cite> returns a scalar <cite>out</cite> will have one
fewer dimensions than <cite>arr</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.apply_over_axes" title="dask.array.apply_over_axes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_over_axes</span></code></a></dt><dd><p>Apply a function repeatedly over multiple axes.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If either of <cite>dtype</cite> or <cite>shape</cite> are not provided, Dask attempts to
determine them by calling <cite>func1d</cite> on a dummy array. This may produce
incorrect values for <cite>dtype</cite> or <cite>shape</cite>, so we recommend providing them.</p>
<p>Execute <cite>func1d(a, *args)</cite> where <cite>func1d</cite> operates on 1-D arrays and <cite>a</cite>
is a 1-D slice of <cite>arr</cite> along <cite>axis</cite>.</p>
<p>This is equivalent to (but faster than) the following use of <cite>ndindex</cite> and
<cite>s_</cite>, which sets each of <code class="docutils literal notranslate"><span class="pre">ii</span></code>, <code class="docutils literal notranslate"><span class="pre">jj</span></code>, and <code class="docutils literal notranslate"><span class="pre">kk</span></code> to a tuple of indices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">func1d</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">])</span>
        <span class="n">Nj</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nj</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">jj</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
</pre></div>
</div>
<p>Equivalently, eliminating the inner loop, this can be expressed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[</span><span class="o">...</span><span class="p">,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">func1d</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_func</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;Average first and last element of a 1-D array&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">my_func</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([4., 5., 6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">my_func</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([2.,  5.,  8.])</span>
</pre></div>
</div>
<p>For a function that returns a 1D array, the number of dimensions in
<cite>outarr</cite> is the same as <cite>arr</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="nb">sorted</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([[1, 7, 8],</span>
<span class="go">       [3, 4, 9],</span>
<span class="go">       [2, 5, 6]])</span>
</pre></div>
</div>
<p>For a function that returns a higher dimensional array, those dimensions
are inserted in place of the <cite>axis</cite> dimension.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([[[1, 0, 0],</span>
<span class="go">        [0, 2, 0],</span>
<span class="go">        [0, 0, 3]],</span>
<span class="go">       [[4, 0, 0],</span>
<span class="go">        [0, 5, 0],</span>
<span class="go">        [0, 0, 6]],</span>
<span class="go">       [[7, 0, 0],</span>
<span class="go">        [0, 8, 0],</span>
<span class="go">        [0, 0, 9]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.apply_over_axes">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">apply_over_axes</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">a</em>, <em class="sig-param">axes</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.apply_over_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function repeatedly over multiple axes.</p>
<p>This docstring was copied from numpy.apply_over_axes.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p><cite>func</cite> is called as <cite>res = func(a, axis)</cite>, where <cite>axis</cite> is the first
element of <cite>axes</cite>.  The result <cite>res</cite> of the function call must have
either the same dimensions as <cite>a</cite> or one less dimension.  If <cite>res</cite>
has one less dimension than <cite>a</cite>, a dimension is inserted before
<cite>axis</cite>.  The call to <cite>func</cite> is then repeated for each axis in <cite>axes</cite>,
with <cite>res</cite> as the first argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>This function must take two arguments, <cite>func(a, axis)</cite>.</p>
</dd>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">array_like</span></dt><dd><p>Axes over which <cite>func</cite> is applied; the elements must be integers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>apply_over_axis</strong><span class="classifier">ndarray</span></dt><dd><p>The output array.  The number of dimensions is the same as <cite>a</cite>,
but the shape can be different.  This depends on whether <cite>func</cite>
changes the shape of its output with respect to its input.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.apply_along_axis" title="dask.array.apply_along_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_along_axis</span></code></a></dt><dd><p>Apply a function to 1-D slices of an array along the given axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function is equivalent to tuple axis arguments to reorderable ufuncs
with keepdims=True. Tuple axis arguments to ufuncs have been available since
version 1.7.0.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>
<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]]])</span>
</pre></div>
</div>
<p>Sum over axes 0 and 2. The result has same number of dimensions
as the original array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_over_axes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>  
<span class="go">array([[[ 60],</span>
<span class="go">        [ 92],</span>
<span class="go">        [124]]])</span>
</pre></div>
</div>
<p>Tuple axis arguments to ufuncs are equivalent:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">array([[[ 60],</span>
<span class="go">        [ 92],</span>
<span class="go">        [124]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.arange">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">arange</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Return evenly spaced values from <cite>start</cite> to <cite>stop</cite> with step size <cite>step</cite>.</p>
<p>The values are half-open [start, stop), so including start and excluding
stop. This is basically the same as python’s range function but for dask
arrays.</p>
<p>When using a non-integer step, such as 0.1, the results will often not be
consistent. It is better to use linspace for these cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start</strong><span class="classifier">int, optional</span></dt><dd><p>The starting value of the sequence. The default is 0.</p>
</dd>
<dt><strong>stop</strong><span class="classifier">int</span></dt><dd><p>The end of the interval, this value is excluded from the interval.</p>
</dd>
<dt><strong>step</strong><span class="classifier">int, optional</span></dt><dd><p>The spacing between the values. The default is 1 when not specified.
The last value of the sequence.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">int</span></dt><dd><p>The number of samples on each block. Note that the last block will have
fewer samples if <code class="docutils literal notranslate"><span class="pre">len(array)</span> <span class="pre">%</span> <span class="pre">chunks</span> <span class="pre">!=</span> <span class="pre">0</span></code>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">numpy.dtype</span></dt><dd><p>Output dtype. Omit to infer it from start, stop, step</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">dask array</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.linspace" title="dask.array.linspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.linspace</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.arccos">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">arccos</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.arccos" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.arccos.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Trigonometric inverse cosine, element-wise.</p>
<p>The inverse of <cite>cos</cite> so that, if <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">cos(x)</span></code>, then <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">arccos(y)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p><cite>x</cite>-coordinate on the unit circle.
For real arguments, the domain is [-1, 1].</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>angle</strong><span class="classifier">ndarray</span></dt><dd><p>The angle of the ray intersecting the unit circle at the given
<cite>x</cite>-coordinate in radians [0, pi].
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.cos" title="dask.array.cos"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cos</span></code></a>, <a class="reference internal" href="#dask.array.arctan" title="dask.array.arctan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arctan</span></code></a>, <a class="reference internal" href="#dask.array.arcsin" title="dask.array.arcsin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arcsin</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">emath.arccos</span></code></p>
</div>
<p class="rubric">Notes</p>
<p><cite>arccos</cite> is a multivalued function: for each <cite>x</cite> there are infinitely
many numbers <cite>z</cite> such that <cite>cos(z) = x</cite>. The convention is to return
the angle <cite>z</cite> whose real part lies in <cite>[0, pi]</cite>.</p>
<p>For real-valued input data types, <cite>arccos</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>arccos</cite> is a complex analytic function that
has branch cuts <cite>[-inf, -1]</cite> and <cite>[1, inf]</cite> and is continuous from
above on the former and from below on the latter.</p>
<p>The inverse <cite>cos</cite> is also known as <cite>acos</cite> or cos^-1.</p>
<p class="rubric">References</p>
<p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 79. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
<p class="rubric">Examples</p>
<p>We expect the arccos of 1 to be 0, and of -1 to be pi:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>  
<span class="go">array([ 0.        ,  3.14159265])</span>
</pre></div>
</div>
<p>Plot arccos:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.arccosh">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">arccosh</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.arccosh" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.arccosh.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Inverse hyperbolic cosine, element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>arccosh</strong><span class="classifier">ndarray</span></dt><dd><p>Array of the same shape as <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.cosh" title="dask.array.cosh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cosh</span></code></a>, <a class="reference internal" href="#dask.array.arcsinh" title="dask.array.arcsinh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arcsinh</span></code></a>, <a class="reference internal" href="#dask.array.sinh" title="dask.array.sinh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sinh</span></code></a>, <a class="reference internal" href="#dask.array.arctanh" title="dask.array.arctanh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arctanh</span></code></a>, <a class="reference internal" href="#dask.array.tanh" title="dask.array.tanh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tanh</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p><cite>arccosh</cite> is a multivalued function: for each <cite>x</cite> there are infinitely
many numbers <cite>z</cite> such that <cite>cosh(z) = x</cite>. The convention is to return the
<cite>z</cite> whose imaginary part lies in <cite>[-pi, pi]</cite> and the real part in
<code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">inf]</span></code>.</p>
<p>For real-valued input data types, <cite>arccosh</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity, it
yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>arccosh</cite> is a complex analytical function that
has a branch cut <cite>[-inf, 1]</cite> and is continuous from above on it.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r2dde872b1e94-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 86. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="r2dde872b1e94-2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Wikipedia, “Inverse hyperbolic function”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Arccosh">https://en.wikipedia.org/wiki/Arccosh</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arccosh</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">])</span>  
<span class="go">array([ 1.65745445,  2.99322285])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arccosh</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.arcsin">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">arcsin</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.arcsin" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.arcsin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Inverse sine, element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p><cite>y</cite>-coordinate on the unit circle.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>angle</strong><span class="classifier">ndarray</span></dt><dd><p>The inverse sine of each element in <cite>x</cite>, in radians and in the
closed interval <code class="docutils literal notranslate"><span class="pre">[-pi/2,</span> <span class="pre">pi/2]</span></code>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.sin" title="dask.array.sin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sin</span></code></a>, <a class="reference internal" href="#dask.array.cos" title="dask.array.cos"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cos</span></code></a>, <a class="reference internal" href="#dask.array.arccos" title="dask.array.arccos"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arccos</span></code></a>, <a class="reference internal" href="#dask.array.tan" title="dask.array.tan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tan</span></code></a>, <a class="reference internal" href="#dask.array.arctan" title="dask.array.arctan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arctan</span></code></a>, <a class="reference internal" href="#dask.array.arctan2" title="dask.array.arctan2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arctan2</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">emath.arcsin</span></code></p>
</div>
<p class="rubric">Notes</p>
<p><cite>arcsin</cite> is a multivalued function: for each <cite>x</cite> there are infinitely
many numbers <cite>z</cite> such that <span class="math notranslate nohighlight">\(sin(z) = x\)</span>.  The convention is to
return the angle <cite>z</cite> whose real part lies in [-pi/2, pi/2].</p>
<p>For real-valued input data types, <em>arcsin</em> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>arcsin</cite> is a complex analytic function that
has, by convention, the branch cuts [-inf, -1] and [1, inf]  and is
continuous from above on the former and from below on the latter.</p>
<p>The inverse sine is also known as <cite>asin</cite> or sin^{-1}.</p>
<p class="rubric">References</p>
<p>Abramowitz, M. and Stegun, I. A., <em>Handbook of Mathematical Functions</em>,
10th printing, New York: Dover, 1964, pp. 79ff.
<a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>     <span class="c1"># pi/2  </span>
<span class="go">1.5707963267948966</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># -pi/2  </span>
<span class="go">-1.5707963267948966</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.arcsinh">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">arcsinh</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.arcsinh" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.arcsinh.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Inverse hyperbolic sine element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Array of the same shape as <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><cite>arcsinh</cite> is a multivalued function: for each <cite>x</cite> there are infinitely
many numbers <cite>z</cite> such that <cite>sinh(z) = x</cite>. The convention is to return the
<cite>z</cite> whose imaginary part lies in <cite>[-pi/2, pi/2]</cite>.</p>
<p>For real-valued input data types, <cite>arcsinh</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity, it
returns <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>arccos</cite> is a complex analytical function that
has branch cuts <cite>[1j, infj]</cite> and <cite>[-1j, -infj]</cite> and is continuous from
the right on the former and from the left on the latter.</p>
<p>The inverse hyperbolic sine is also known as <cite>asinh</cite> or <code class="docutils literal notranslate"><span class="pre">sinh^-1</span></code>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc62edf9e095e-1"><span class="brackets"><a class="fn-backref" href="#id3">1</a></span></dt>
<dd><p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 86. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="rc62edf9e095e-2"><span class="brackets"><a class="fn-backref" href="#id4">2</a></span></dt>
<dd><p>Wikipedia, “Inverse hyperbolic function”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Arcsinh">https://en.wikipedia.org/wiki/Arcsinh</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arcsinh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]))</span>  
<span class="go">array([ 1.72538256,  2.99822295])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.arctan">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">arctan</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.arctan" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.arctan.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Trigonometric inverse tangent, element-wise.</p>
<p>The inverse of tan, so that if <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">tan(x)</span></code> then <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">arctan(y)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Out has the same shape as <cite>x</cite>.  Its real part is in
<code class="docutils literal notranslate"><span class="pre">[-pi/2,</span> <span class="pre">pi/2]</span></code> (<code class="docutils literal notranslate"><span class="pre">arctan(+/-inf)</span></code> returns <code class="docutils literal notranslate"><span class="pre">+/-pi/2</span></code>).
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.arctan2" title="dask.array.arctan2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arctan2</span></code></a></dt><dd><p>The “four quadrant” arctan of the angle formed by (<cite>x</cite>, <cite>y</cite>) and the positive <cite>x</cite>-axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.angle" title="dask.array.angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle</span></code></a></dt><dd><p>Argument of complex values.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><cite>arctan</cite> is a multi-valued function: for each <cite>x</cite> there are infinitely
many numbers <cite>z</cite> such that tan(<cite>z</cite>) = <cite>x</cite>.  The convention is to return
the angle <cite>z</cite> whose real part lies in [-pi/2, pi/2].</p>
<p>For real-valued input data types, <cite>arctan</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>arctan</cite> is a complex analytic function that
has [<cite>1j, infj</cite>] and [<cite>-1j, -infj</cite>] as branch cuts, and is continuous
from the left on the former and from the right on the latter.</p>
<p>The inverse tangent is also known as <cite>atan</cite> or tan^{-1}.</p>
<p class="rubric">References</p>
<p>Abramowitz, M. and Stegun, I. A., <em>Handbook of Mathematical Functions</em>,
10th printing, New York: Dover, 1964, pp. 79.
<a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
<p class="rubric">Examples</p>
<p>We expect the arctan of 0 to be 0, and of 1 to be pi/4:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  
<span class="go">array([ 0.        ,  0.78539816])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span>  
<span class="go">0.78539816339744828</span>
</pre></div>
</div>
<p>Plot arctan:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.arctan2">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">arctan2</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.arctan2" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.arctan2.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Element-wise arc tangent of <code class="docutils literal notranslate"><span class="pre">x1/x2</span></code> choosing the quadrant correctly.</p>
<p>The quadrant (i.e., branch) is chosen so that <code class="docutils literal notranslate"><span class="pre">arctan2(x1,</span> <span class="pre">x2)</span></code> is
the signed angle in radians between the ray ending at the origin and
passing through the point (1,0), and the ray ending at the origin and
passing through the point (<cite>x2</cite>, <cite>x1</cite>).  (Note the role reversal: the
“<cite>y</cite>-coordinate” is the first function parameter, the “<cite>x</cite>-coordinate”
is the second.)  By IEEE convention, this function is defined for
<cite>x2</cite> = +/-0 and for either or both of <cite>x1</cite> and <cite>x2</cite> = +/-inf (see
Notes for specific values).</p>
<p>This function is not defined for complex-valued arguments; for the
so-called argument of complex values, use <cite>angle</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1</strong><span class="classifier">array_like, real-valued</span></dt><dd><p><cite>y</cite>-coordinates.</p>
</dd>
<dt><strong>x2</strong><span class="classifier">array_like, real-valued</span></dt><dd><p><cite>x</cite>-coordinates. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>angle</strong><span class="classifier">ndarray</span></dt><dd><p>Array of angles in radians, in the range <code class="docutils literal notranslate"><span class="pre">[-pi,</span> <span class="pre">pi]</span></code>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.arctan" title="dask.array.arctan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arctan</span></code></a>, <a class="reference internal" href="#dask.array.tan" title="dask.array.tan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tan</span></code></a>, <a class="reference internal" href="#dask.array.angle" title="dask.array.angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p><em>arctan2</em> is identical to the <cite>atan2</cite> function of the underlying
C library.  The following special values are defined in the C
standard: <a class="reference internal" href="#r347210aad557-1" id="id5">[1]</a></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><cite>x1</cite></p></th>
<th class="head"><p><cite>x2</cite></p></th>
<th class="head"><p><cite>arctan2(x1,x2)</cite></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>+/- 0</p></td>
<td><p>+0</p></td>
<td><p>+/- 0</p></td>
</tr>
<tr class="row-odd"><td><p>+/- 0</p></td>
<td><p>-0</p></td>
<td><p>+/- pi</p></td>
</tr>
<tr class="row-even"><td><p>&gt; 0</p></td>
<td><p>+/-inf</p></td>
<td><p>+0 / +pi</p></td>
</tr>
<tr class="row-odd"><td><p>&lt; 0</p></td>
<td><p>+/-inf</p></td>
<td><p>-0 / -pi</p></td>
</tr>
<tr class="row-even"><td><p>+/-inf</p></td>
<td><p>+inf</p></td>
<td><p>+/- (pi/4)</p></td>
</tr>
<tr class="row-odd"><td><p>+/-inf</p></td>
<td><p>-inf</p></td>
<td><p>+/- (3*pi/4)</p></td>
</tr>
</tbody>
</table>
<p>Note that +0 and -0 are distinct floating point numbers, as are +inf
and -inf.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r347210aad557-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id5">1</a>,<a href="#id6">2</a>)</span></dt>
<dd><p>ISO/IEC standard 9899:1999, “Programming language C.”</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Consider four points in different quadrants:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>  
<span class="go">array([-135.,  -45.,   45.,  135.])</span>
</pre></div>
</div>
<p>Note the order of the parameters. <cite>arctan2</cite> is defined also when <cite>x2</cite> = 0
and at several other special points, obtaining values in
the range <code class="docutils literal notranslate"><span class="pre">[-pi,</span> <span class="pre">pi]</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>  
<span class="go">array([ 1.57079633, -1.57079633])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="o">+</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>  
<span class="go">array([ 0.        ,  3.14159265,  0.78539816])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.arctanh">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">arctanh</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.arctanh" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.arctanh.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Inverse hyperbolic tangent element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Array of the same shape as <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">emath.arctanh</span></code></p>
</div>
<p class="rubric">Notes</p>
<p><cite>arctanh</cite> is a multivalued function: for each <cite>x</cite> there are infinitely
many numbers <cite>z</cite> such that <cite>tanh(z) = x</cite>. The convention is to return
the <cite>z</cite> whose imaginary part lies in <cite>[-pi/2, pi/2]</cite>.</p>
<p>For real-valued input data types, <cite>arctanh</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>arctanh</cite> is a complex analytical function
that has branch cuts <cite>[-1, -inf]</cite> and <cite>[1, inf]</cite> and is continuous from
above on the former and from below on the latter.</p>
<p>The inverse hyperbolic tangent is also known as <cite>atanh</cite> or <code class="docutils literal notranslate"><span class="pre">tanh^-1</span></code>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8e19d9ba4634-1"><span class="brackets"><a class="fn-backref" href="#id7">1</a></span></dt>
<dd><p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 86. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="r8e19d9ba4634-2"><span class="brackets"><a class="fn-backref" href="#id8">2</a></span></dt>
<dd><p>Wikipedia, “Inverse hyperbolic function”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Arctanh">https://en.wikipedia.org/wiki/Arctanh</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arctanh</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">])</span>  
<span class="go">array([ 0.        , -0.54930614])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.argmax">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">argmax</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of an array or maximum along an axis.</p>
<p>This docstring was copied from numpy.amax.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to operate.  By default, flattened input is
used.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <cite>ufuncs-output-type</cite> for more details.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>amax</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt><strong>initial</strong><span class="classifier">scalar, optional  (Not supported in Dask)</span></dt><dd><p>The minimum value of an output element. Must be present to allow
computation on empty slice. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</dd>
<dt><strong>where</strong><span class="classifier">array_like of bool, optional  (Not supported in Dask)</span></dt><dd><p>Elements to compare for the maximum. See <cite>~numpy.ufunc.reduce</cite>
for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>amax</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Maximum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">amin</span></code></dt><dd><p>The minimum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.nanmax" title="dask.array.nanmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmax</span></code></a></dt><dd><p>The maximum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.maximum" title="dask.array.maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum</span></code></a></dt><dd><p>Element-wise maximum of two arrays, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fmax" title="dask.array.fmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmax</span></code></a></dt><dd><p>Element-wise maximum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.argmax" title="dask.array.argmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax</span></code></a></dt><dd><p>Return the indices of the maximum values.</p>
</dd>
</dl>
<p><a class="reference internal" href="#dask.array.nanmin" title="dask.array.nanmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmin</span></code></a>, <a class="reference internal" href="#dask.array.minimum" title="dask.array.minimum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum</span></code></a>, <a class="reference internal" href="#dask.array.fmin" title="dask.array.fmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmin</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.</p>
<p>Don’t use <cite>amax</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal notranslate"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal notranslate"><span class="pre">maximum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal notranslate"><span class="pre">amax(a,</span> <span class="pre">axis=0)</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Maximum of the flattened array  </span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Maxima along the first axis  </span>
<span class="go">array([2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Maxima along the second axis  </span>
<span class="go">array([1, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">initial</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([-1,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">initial</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="go">4.0</span>
</pre></div>
</div>
<p>You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([ 0, 10])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>  
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>  
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.argmin">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">argmin</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum of an array or minimum along an axis.</p>
<p>This docstring was copied from numpy.amin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to operate.  By default, flattened input is
used.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, the minimum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <cite>ufuncs-output-type</cite> for more details.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>amin</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt><strong>initial</strong><span class="classifier">scalar, optional  (Not supported in Dask)</span></dt><dd><p>The maximum value of an output element. Must be present to allow
computation on empty slice. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</dd>
<dt><strong>where</strong><span class="classifier">array_like of bool, optional  (Not supported in Dask)</span></dt><dd><p>Elements to compare for the minimum. See <cite>~numpy.ufunc.reduce</cite>
for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>amin</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Minimum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">amax</span></code></dt><dd><p>The maximum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.nanmin" title="dask.array.nanmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmin</span></code></a></dt><dd><p>The minimum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.minimum" title="dask.array.minimum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum</span></code></a></dt><dd><p>Element-wise minimum of two arrays, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fmin" title="dask.array.fmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmin</span></code></a></dt><dd><p>Element-wise minimum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.argmin" title="dask.array.argmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmin</span></code></a></dt><dd><p>Return the indices of the minimum values.</p>
</dd>
</dl>
<p><a class="reference internal" href="#dask.array.nanmax" title="dask.array.nanmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmax</span></code></a>, <a class="reference internal" href="#dask.array.maximum" title="dask.array.maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum</span></code></a>, <a class="reference internal" href="#dask.array.fmax" title="dask.array.fmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmax</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.</p>
<p>Don’t use <cite>amin</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal notranslate"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal notranslate"><span class="pre">minimum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal notranslate"><span class="pre">amin(a,</span> <span class="pre">axis=0)</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Minimum of the flattened array  </span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Minima along the first axis  </span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Minima along the second axis  </span>
<span class="go">array([0, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([10,  1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">initial</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="go">0.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([-50,   0])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
minimum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<p>Notice that this isn’t the same as Python’s <code class="docutils literal notranslate"><span class="pre">default</span></code> argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.argtopk">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">argtopk</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">k</em>, <em class="sig-param">axis=-1</em>, <em class="sig-param">split_every=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.argtopk" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the indices of the k largest elements from a on the given axis,
and return them sorted from largest to smallest. If k is negative, extract
the indices of the -k smallest elements instead, and return them sorted
from smallest to largest.</p>
<p>This performs best when <code class="docutils literal notranslate"><span class="pre">k</span></code> is much smaller than the chunk size. All
results will be returned in a single chunk along the given axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x: Array</strong></dt><dd><p>Data being sorted</p>
</dd>
<dt><strong>k: int</strong></dt><dd></dd>
<dt><strong>axis: int, optional</strong></dt><dd></dd>
<dt><strong>split_every: int &gt;=2, optional</strong></dt><dd><p>See <a class="reference internal" href="#dask.array.topk" title="dask.array.topk"><code class="xref py py-func docutils literal notranslate"><span class="pre">topk()</span></code></a>. The performance considerations for topk also apply
here.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Selection of np.intp indices of x with size abs(k) along the given axis.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">argtopk</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([3, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">argtopk</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.argwhere">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">argwhere</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.argwhere" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the indices of array elements that are non-zero, grouped by element.</p>
<p>This docstring was copied from numpy.argwhere.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>index_array</strong><span class="classifier">(N, a.ndim) ndarray</span></dt><dd><p>Indices of elements that are non-zero. Indices are grouped by element.
This array will have shape <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">a.ndim)</span></code> where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the number of
non-zero items.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.where" title="dask.array.where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">where</span></code></a>, <a class="reference internal" href="#dask.array.nonzero" title="dask.array.nonzero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">np.argwhere(a)</span></code> is almost the same as <code class="docutils literal notranslate"><span class="pre">np.transpose(np.nonzero(a))</span></code>,
but produces a result of the correct shape for a 0D array.</p>
<p>The output of <code class="docutils literal notranslate"><span class="pre">argwhere</span></code> is not suitable for indexing arrays.
For this purpose use <code class="docutils literal notranslate"><span class="pre">nonzero(a)</span></code> instead.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[0, 2],</span>
<span class="go">       [1, 0],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [1, 2]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.around">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">around</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">decimals=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.around" title="Permalink to this definition">¶</a></dt>
<dd><p>Evenly round to the given number of decimals.</p>
<p>This docstring was copied from numpy.around.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>decimals</strong><span class="classifier">int, optional</span></dt><dd><p>Number of decimal places to round to (default: 0).  If
decimals is negative, it specifies the number of positions to
the left of the decimal point.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional  (Not supported in Dask)</span></dt><dd><p>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary. See <cite>ufuncs-output-type</cite> for more
details.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>rounded_array</strong><span class="classifier">ndarray</span></dt><dd><p>An array of the same type as <cite>a</cite>, containing the rounded values.
Unless <cite>out</cite> was specified, a new array is created.  A reference to
the result is returned.</p>
<p>The real and imaginary parts of complex numbers are rounded
separately.  The result of rounding a float is a float.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.round</span></code></dt><dd><p>equivalent method</p>
</dd>
</dl>
<p><a class="reference internal" href="#dask.array.ceil" title="dask.array.ceil"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceil</span></code></a>, <a class="reference internal" href="#dask.array.fix" title="dask.array.fix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix</span></code></a>, <a class="reference internal" href="#dask.array.floor" title="dask.array.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a>, <a class="reference internal" href="#dask.array.rint" title="dask.array.rint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rint</span></code></a>, <a class="reference internal" href="#dask.array.trunc" title="dask.array.trunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trunc</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>For values exactly halfway between rounded decimal values, NumPy
rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
-0.5 and 0.5 round to 0.0, etc.</p>
<p><code class="docutils literal notranslate"><span class="pre">np.around</span></code> uses a fast but sometimes inexact algorithm to round
floating-point datatypes. For positive <cite>decimals</cite> it is equivalent to
<code class="docutils literal notranslate"><span class="pre">np.true_divide(np.rint(a</span> <span class="pre">*</span> <span class="pre">10**decimals),</span> <span class="pre">10**decimals)</span></code>, which has
error due to the inexact representation of decimal fractions in the IEEE
floating point standard <a class="reference internal" href="#rebb500653d2a-1" id="id9">[1]</a> and errors introduced when scaling by powers
of ten. For instance, note the extra “1” in the following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">56294995342131.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  
<span class="go">56294995342131.51</span>
</pre></div>
</div>
<p>If your goal is to print such values with a fixed number of decimals, it is
preferable to use numpy’s float printing routines to limit the number of
printed decimals:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_positional</span><span class="p">(</span><span class="mf">56294995342131.5</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  
<span class="go">&#39;56294995342131.5&#39;</span>
</pre></div>
</div>
<p>The float printing routines use an accurate but much more computationally
demanding algorithm to compute the number of digits after the decimal
point.</p>
<p>Alternatively, Python’s builtin <cite>round</cite> function uses a more accurate
but slower algorithm for 64-bit floating point values:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="mf">56294995342131.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  
<span class="go">56294995342131.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">16.055</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="mf">16.055</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># equals 16.0549999999999997  </span>
<span class="go">(16.06, 16.05)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rebb500653d2a-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id9">1</a>,<a href="#id10">2</a>)</span></dt>
<dd><p>“Lecture Notes on the Status of IEEE 754”, William Kahan,
<a class="reference external" href="https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF</a></p>
</dd>
<dt class="label" id="rebb500653d2a-2"><span class="brackets"><a class="fn-backref" href="#id11">2</a></span></dt>
<dd><p>“How Futile are Mindless Assessments of
Roundoff in Floating-Point Computation?”, William Kahan,
<a class="reference external" href="https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf">https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mf">0.37</span><span class="p">,</span> <span class="mf">1.64</span><span class="p">])</span>  
<span class="go">array([0.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mf">0.37</span><span class="p">,</span> <span class="mf">1.64</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([0.4,  1.6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">])</span> <span class="c1"># rounds to nearest even value  </span>
<span class="go">array([0.,  2.,  2.,  4.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># ndarray of ints is returned  </span>
<span class="go">array([ 1,  2,  3, 11])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([ 0,  0,  0, 10])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.array">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">array</code><span class="sig-paren">(</span><em class="sig-param">object</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">copy=True</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">subok=False</em>, <em class="sig-param">ndmin=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.array" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.array.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Create an array.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>object</strong><span class="classifier">array_like</span></dt><dd><p>An array, any object exposing the array interface, an object whose
__array__ method returns an array, or any (nested) sequence.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional</span></dt><dd><p>If true (default), then the object is copied.  Otherwise, a copy will
only be made if __array__ returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<cite>dtype</cite>, <cite>order</cite>, etc.).</p>
</dd>
<dt><strong>order</strong><span class="classifier">{‘K’, ‘A’, ‘C’, ‘F’}, optional</span></dt><dd><p>Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless ‘F’ is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 14%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>order</p></th>
<th class="head"><p>no copy</p></th>
<th class="head"><p>copy=True</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘K’</p></td>
<td><p>unchanged</p></td>
<td><p>F &amp; C order preserved, otherwise most similar order</p></td>
</tr>
<tr class="row-odd"><td><p>‘A’</p></td>
<td><p>unchanged</p></td>
<td><p>F order if input is F and not C, otherwise C order</p></td>
</tr>
<tr class="row-even"><td><p>‘C’</p></td>
<td><p>C order</p></td>
<td><p>C order</p></td>
</tr>
<tr class="row-odd"><td><p>‘F’</p></td>
<td><p>F order</p></td>
<td><p>F order</p></td>
</tr>
</tbody>
</table>
<p>When <code class="docutils literal notranslate"><span class="pre">copy=False</span></code> and a copy is made for other reasons, the result is
the same as if <code class="docutils literal notranslate"><span class="pre">copy=True</span></code>, with some exceptions for <cite>A</cite>, see the
Notes section. The default order is ‘K’.</p>
</dd>
<dt><strong>subok</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).</p>
</dd>
<dt><strong>ndmin</strong><span class="classifier">int, optional</span></dt><dd><p>Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>An array object satisfying the specified requirements.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.empty_like" title="dask.array.empty_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty_like</span></code></a></dt><dd><p>Return an empty array with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ones_like" title="dask.array.ones_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones_like</span></code></a></dt><dd><p>Return an array of ones with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.zeros_like" title="dask.array.zeros_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros_like</span></code></a></dt><dd><p>Return an array of zeros with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.full_like" title="dask.array.full_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full_like</span></code></a></dt><dd><p>Return a new array with shape of input filled with value.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.empty" title="dask.array.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a></dt><dd><p>Return a new uninitialized array.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ones" title="dask.array.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a></dt><dd><p>Return a new array setting values to one.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.zeros" title="dask.array.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a></dt><dd><p>Return a new array setting values to zero.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.full" title="dask.array.full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code></a></dt><dd><p>Return a new array of given shape filled with value.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When order is ‘A’ and <cite>object</cite> is an array in neither ‘C’ nor ‘F’ order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily ‘C’ as expected. This is likely a bug.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<p>Upcasting:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>  
<span class="go">array([ 1.,  2.,  3.])</span>
</pre></div>
</div>
<p>More than one dimension:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>  
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>Minimum dimensions 2:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">array([[1, 2, 3]])</span>
</pre></div>
</div>
<p>Type provided:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>  
<span class="go">array([ 1.+0.j,  2.+0.j,  3.+0.j])</span>
</pre></div>
</div>
<p>Data-type consisting of more than one element:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">),(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>  
<span class="go">array([1, 3])</span>
</pre></div>
</div>
<p>Creating an array from sub-classes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">))</span>  
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">),</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.asanyarray">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">asanyarray</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.asanyarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input to a dask array.</p>
<p>Subclasses of <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> will be passed through as chunks unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array-like</span></dt><dd><p>Input data, in any form that can be converted to a dask array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">dask array</span></dt><dd><p>Dask array interpretation of a.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">dask.array&lt;array, shape=(3,), dtype=int64, chunksize=(3,), chunktype=numpy.ndarray&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">dask.array&lt;array, shape=(2, 3), dtype=int64, chunksize=(2, 3), chunktype=numpy.ndarray&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.asarray">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">asarray</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.asarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input to a dask array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array-like</span></dt><dd><p>Input data, in any form that can be converted to a dask array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">dask array</span></dt><dd><p>Dask array interpretation of a.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">dask.array&lt;array, shape=(3,), dtype=int64, chunksize=(3,), chunktype=numpy.ndarray&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">dask.array&lt;array, shape=(2, 3), dtype=int64, chunksize=(2, 3), chunktype=numpy.ndarray&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.atleast_1d">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">atleast_1d</code><span class="sig-paren">(</span><em class="sig-param">*arys</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.atleast_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert inputs to arrays with at least one dimension.</p>
<p>This docstring was copied from numpy.atleast_1d.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arys1, arys2, …</strong><span class="classifier">array_like</span></dt><dd><p>One or more input arrays.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ret</strong><span class="classifier">ndarray</span></dt><dd><p>An array, or list of arrays, each with <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">1</span></code>.
Copies are made only if necessary.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.atleast_2d" title="dask.array.atleast_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atleast_2d</span></code></a>, <a class="reference internal" href="#dask.array.atleast_3d" title="dask.array.atleast_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atleast_3d</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>  
<span class="go">array([1.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([[0., 1., 2.],</span>
<span class="go">       [3., 4., 5.],</span>
<span class="go">       [6., 7., 8.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span>  
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>  
<span class="go">[array([1]), array([3, 4])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.atleast_2d">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">atleast_2d</code><span class="sig-paren">(</span><em class="sig-param">*arys</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.atleast_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>View inputs as arrays with at least two dimensions.</p>
<p>This docstring was copied from numpy.atleast_2d.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arys1, arys2, …</strong><span class="classifier">array_like</span></dt><dd><p>One or more array-like sequences.  Non-array inputs are converted
to arrays.  Arrays that already have two or more dimensions are
preserved.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>res, res2, …</strong><span class="classifier">ndarray</span></dt><dd><p>An array, or list of arrays, each with <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code>.
Copies are avoided where possible, and views with two or more
dimensions are returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.atleast_1d" title="dask.array.atleast_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atleast_1d</span></code></a>, <a class="reference internal" href="#dask.array.atleast_3d" title="dask.array.atleast_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atleast_3d</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>  
<span class="go">array([[3.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([[0., 1., 2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span>  
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>  
<span class="go">[array([[1]]), array([[1, 2]]), array([[1, 2]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.atleast_3d">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">atleast_3d</code><span class="sig-paren">(</span><em class="sig-param">*arys</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.atleast_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>View inputs as arrays with at least three dimensions.</p>
<p>This docstring was copied from numpy.atleast_3d.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arys1, arys2, …</strong><span class="classifier">array_like</span></dt><dd><p>One or more array-like sequences.  Non-array inputs are converted to
arrays.  Arrays that already have three or more dimensions are
preserved.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>res1, res2, …</strong><span class="classifier">ndarray</span></dt><dd><p>An array, or list of arrays, each with <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">3</span></code>.  Copies are
avoided where possible, and views with three or more dimensions are
returned.  For example, a 1-D array of shape <code class="docutils literal notranslate"><span class="pre">(N,)</span></code> becomes a view
of shape <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">N,</span> <span class="pre">1)</span></code>, and a 2-D array of shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">N)</span></code> becomes a
view of shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">N,</span> <span class="pre">1)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.atleast_1d" title="dask.array.atleast_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atleast_1d</span></code></a>, <a class="reference internal" href="#dask.array.atleast_2d" title="dask.array.atleast_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atleast_2d</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>  
<span class="go">array([[[3.]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(1, 3, 1)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">12.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(4, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span><span class="o">.</span><span class="n">base</span>  <span class="c1"># x is a reshape, so not base itself  </span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]]):</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> 
<span class="gp">...</span>
<span class="go">[[[1]</span>
<span class="go">  [2]]] (1, 2, 1)</span>
<span class="go">[[[1]</span>
<span class="go">  [2]]] (1, 2, 1)</span>
<span class="go">[[[1 2]]] (1, 1, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.average">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">average</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">weights=None</em>, <em class="sig-param">returned=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted average along the specified axis.</p>
<p>This docstring was copied from numpy.average.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Array containing data to be averaged. If <cite>a</cite> is not an array, a
conversion is attempted.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to average <cite>a</cite>.  The default,
axis=None, will average over all of the elements of the input array.
If axis is negative it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If axis is a tuple of ints, averaging is performed on all of the axes
specified in the tuple instead of a single axis or all the axes as
before.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">array_like, optional</span></dt><dd><p>An array of weights associated with the values in <cite>a</cite>. Each value in
<cite>a</cite> contributes to the average according to its associated weight.
The weights array can either be 1-D (in which case its length must be
the size of <cite>a</cite> along the given axis) or of the same shape as <cite>a</cite>.
If <cite>weights=None</cite>, then all data in <cite>a</cite> are assumed to have a
weight equal to one.  The 1-D calculation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">avg</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
<p>The only constraint on <cite>weights</cite> is that <cite>sum(weights)</cite> must not be 0.</p>
</dd>
<dt><strong>returned</strong><span class="classifier">bool, optional</span></dt><dd><p>Default is <cite>False</cite>. If <cite>True</cite>, the tuple (<cite>average</cite>, <cite>sum_of_weights</cite>)
is returned, otherwise only the average is returned.
If <cite>weights=None</cite>, <cite>sum_of_weights</cite> is equivalent to the number of
elements over which the average is taken.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>retval, [sum_of_weights]</strong><span class="classifier">array_type or double</span></dt><dd><p>Return the average along the specified axis. When <cite>returned</cite> is <cite>True</cite>,
return a tuple with the average as the first element and the sum
of the weights as the second element. <cite>sum_of_weights</cite> is of the
same type as <cite>retval</cite>. The result dtype follows a genereal pattern.
If <cite>weights</cite> is None, the result dtype will be that of <cite>a</cite> , or <code class="docutils literal notranslate"><span class="pre">float64</span></code>
if <cite>a</cite> is integral. Otherwise, if <cite>weights</cite> is not None and <cite>a</cite> is non-
integral, the result type will be the type of lowest precision capable of
representing values of both <cite>a</cite> and <cite>weights</cite>. If <cite>a</cite> happens to be
integral, the previous rules still applies but the result dtype will
at least be <code class="docutils literal notranslate"><span class="pre">float64</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ZeroDivisionError</strong></dt><dd><p>When all weights along axis are zero. See <cite>numpy.ma.average</cite> for a
version robust to this type of error.</p>
</dd>
<dt><strong>TypeError</strong></dt><dd><p>When the length of 1D <cite>weights</cite> is not the same as the shape of <cite>a</cite>
along axis.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.mean" title="dask.array.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a></p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ma.average" title="dask.array.ma.average"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.average</span></code></a></dt><dd><p>average for masked arrays – useful if your data contains “missing” values</p>
</dd>
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.result_type.html#numpy.result_type" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.result_type</span></code></a></dt><dd><p>Returns the type that results from applying the numpy type promotion rules to the arguments.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>  
<span class="go">array([1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  
<span class="go">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>  
<span class="go">4.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>  
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mf">3.</span><span class="o">/</span><span class="mi">4</span><span class="p">])</span>  
<span class="go">array([0.75, 2.75, 4.75])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mf">3.</span><span class="o">/</span><span class="mi">4</span><span class="p">])</span>  
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TypeError</span>: <span class="n">Axis must be specified when shapes of a and weights differ.</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float128</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">avg</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  
<span class="go">complex256</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.bincount">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">bincount</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">weights=None</em>, <em class="sig-param">minlength=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.bincount" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.bincount.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Count number of occurrences of each value in array of non-negative ints.</p>
<p>The number of bins (of size 1) is one larger than the largest value in
<cite>x</cite>. If <cite>minlength</cite> is specified, there will be at least this number
of bins in the output array (though it will be longer if necessary,
depending on the contents of <cite>x</cite>).
Each bin gives the number of occurrences of its index value in <cite>x</cite>.
If <cite>weights</cite> is specified the input array is weighted by it, i.e. if a
value <code class="docutils literal notranslate"><span class="pre">n</span></code> is found at position <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">out[n]</span> <span class="pre">+=</span> <span class="pre">weight[i]</span></code> instead
of <code class="docutils literal notranslate"><span class="pre">out[n]</span> <span class="pre">+=</span> <span class="pre">1</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like, 1 dimension, nonnegative ints</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">array_like, optional</span></dt><dd><p>Weights, array of the same shape as <cite>x</cite>.</p>
</dd>
<dt><strong>minlength</strong><span class="classifier">int, optional</span></dt><dd><p>A minimum number of bins for the output array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of ints</span></dt><dd><p>The result of binning the input array.
The length of <cite>out</cite> is equal to <code class="docutils literal notranslate"><span class="pre">np.amax(x)+1</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If the input is not 1-dimensional, or contains elements with negative
values, or if <cite>minlength</cite> is negative.</p>
</dd>
<dt><strong>TypeError</strong></dt><dd><p>If the type of the input is float or complex.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.histogram" title="dask.array.histogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">histogram</span></code></a>, <a class="reference internal" href="#dask.array.digitize" title="dask.array.digitize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">digitize</span></code></a>, <a class="reference internal" href="#dask.array.unique" title="dask.array.unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>  
<span class="go">array([1, 1, 1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>  
<span class="go">array([1, 3, 1, 1, 0, 0, 0, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">23</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>  
<span class="go">True</span>
</pre></div>
</div>
<p>The input array needs to be of integer dtype, otherwise a
TypeError is raised:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">array cannot be safely cast to required type</span>
</pre></div>
</div>
<p>A possible use of <code class="docutils literal notranslate"><span class="pre">bincount</span></code> is to perform sums over
variable-size chunks of an array, using the <code class="docutils literal notranslate"><span class="pre">weights</span></code> keyword.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6</span><span class="p">])</span> <span class="c1"># weights  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>  <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>  
<span class="go">array([ 0.3,  0.7,  1.1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.bitwise_and">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">bitwise_and</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.bitwise_and" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.bitwise_and.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute the bit-wise AND of two arrays element-wise.</p>
<p>Computes the bit-wise AND of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>Only integer and boolean types are handled. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Result.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.logical_and" title="dask.array.logical_and"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_and</span></code></a>, <a class="reference internal" href="#dask.array.bitwise_or" title="dask.array.bitwise_or"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_or</span></code></a>, <a class="reference internal" href="#dask.array.bitwise_xor" title="dask.array.bitwise_xor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_xor</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_repr</span></code></dt><dd><p>Return the binary representation of the input number as a string.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>The number 13 is represented by <code class="docutils literal notranslate"><span class="pre">00001101</span></code>.  Likewise, 17 is
represented by <code class="docutils literal notranslate"><span class="pre">00010001</span></code>.  The bit-wise AND of 13 and 17 is
therefore <code class="docutils literal notranslate"><span class="pre">000000001</span></code>, or 1:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>  
<span class="go">1</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>  
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>  
<span class="go">&#39;1100&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">([</span><span class="mi">14</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">13</span><span class="p">)</span>  
<span class="go">array([12,  1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">25</span><span class="p">])</span>  
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">255</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">]))</span>  
<span class="go">array([ 2,  4, 16])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>  
<span class="go">array([False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.bitwise_not">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">bitwise_not</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.bitwise_not" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.invert.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute bit-wise inversion, or bit-wise NOT, element-wise.</p>
<p>Computes the bit-wise NOT of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator <code class="docutils literal notranslate"><span class="pre">~</span></code>.</p>
<p>For signed integer inputs, the two’s complement is returned.  In a
two’s-complement system negative numbers are represented by the two’s
complement of the absolute value. This is the most common method of
representing signed integers on computers <a class="reference internal" href="#r4546e276892f-1" id="id12">[1]</a>. A N-bit
two’s-complement system can represent every integer in the range
<span class="math notranslate nohighlight">\(-2^{N-1}\)</span> to <span class="math notranslate nohighlight">\(+2^{N-1}-1\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Only integer and boolean types are handled.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Result.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.bitwise_and" title="dask.array.bitwise_and"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_and</span></code></a>, <a class="reference internal" href="#dask.array.bitwise_or" title="dask.array.bitwise_or"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_or</span></code></a>, <a class="reference internal" href="#dask.array.bitwise_xor" title="dask.array.bitwise_xor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_xor</span></code></a>, <a class="reference internal" href="#dask.array.logical_not" title="dask.array.logical_not"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_not</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_repr</span></code></dt><dd><p>Return the binary representation of the input number as a string.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><cite>bitwise_not</cite> is an alias for <cite>invert</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span>  
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4546e276892f-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id12">1</a>,<a href="#id13">2</a>)</span></dt>
<dd><p>Wikipedia, “Two’s complement”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Two's_complement">https://en.wikipedia.org/wiki/Two’s_complement</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We’ve seen that 13 is represented by <code class="docutils literal notranslate"><span class="pre">00001101</span></code>.
The invert or bit-wise NOT of 13 is then:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">242</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>  
<span class="go">&#39;11110010&#39;</span>
</pre></div>
</div>
<p>The result depends on the bit-width:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">65522</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>  
<span class="go">&#39;1111111111110010&#39;</span>
</pre></div>
</div>
<p>When using signed integer types the result is the two’s complement of
the result for the unsigned type:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">13</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">))</span>  
<span class="go">array([-14], dtype=int8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="o">-</span><span class="mi">14</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>  
<span class="go">&#39;11110010&#39;</span>
</pre></div>
</div>
<p>Booleans are accepted as well:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]))</span>  
<span class="go">array([False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.bitwise_or">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">bitwise_or</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.bitwise_or" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.bitwise_or.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute the bit-wise OR of two arrays element-wise.</p>
<p>Computes the bit-wise OR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator <code class="docutils literal notranslate"><span class="pre">|</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>Only integer and boolean types are handled. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Result.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.logical_or" title="dask.array.logical_or"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_or</span></code></a>, <a class="reference internal" href="#dask.array.bitwise_and" title="dask.array.bitwise_and"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_and</span></code></a>, <a class="reference internal" href="#dask.array.bitwise_xor" title="dask.array.bitwise_xor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_xor</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_repr</span></code></dt><dd><p>Return the binary representation of the input number as a string.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>The number 13 has the binaray representation <code class="docutils literal notranslate"><span class="pre">00001101</span></code>. Likewise,
16 is represented by <code class="docutils literal notranslate"><span class="pre">00010000</span></code>.  The bit-wise OR of 13 and 16 is
then <code class="docutils literal notranslate"><span class="pre">000111011</span></code>, or 29:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>  
<span class="go">29</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span>  
<span class="go">&#39;11101&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">([</span><span class="mi">33</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>  
<span class="go">array([33,  5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">([</span><span class="mi">33</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="go">array([33,  6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">255</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>  
<span class="go">array([  6,   5, 255])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">255</span><span class="p">])</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>  
<span class="go">array([  6,   5, 255])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">2147483647</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>  
<span class="gp">... </span>              <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2147483647</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
<span class="go">array([         6,          5,        255, 2147483647])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>  
<span class="go">array([ True,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.bitwise_xor">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">bitwise_xor</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.bitwise_xor" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.bitwise_xor.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute the bit-wise XOR of two arrays element-wise.</p>
<p>Computes the bit-wise XOR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator <code class="docutils literal notranslate"><span class="pre">^</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>Only integer and boolean types are handled. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Result.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.logical_xor" title="dask.array.logical_xor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_xor</span></code></a>, <a class="reference internal" href="#dask.array.bitwise_and" title="dask.array.bitwise_and"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_and</span></code></a>, <a class="reference internal" href="#dask.array.bitwise_or" title="dask.array.bitwise_or"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_or</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_repr</span></code></dt><dd><p>Return the binary representation of the input number as a string.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>The number 13 is represented by <code class="docutils literal notranslate"><span class="pre">00001101</span></code>. Likewise, 17 is
represented by <code class="docutils literal notranslate"><span class="pre">00010001</span></code>.  The bit-wise XOR of 13 and 17 is
therefore <code class="docutils literal notranslate"><span class="pre">00011100</span></code>, or 28:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>  
<span class="go">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">28</span><span class="p">)</span>  
<span class="go">&#39;11100&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  
<span class="go">26</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">([</span><span class="mi">31</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>  
<span class="go">array([26,  6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">([</span><span class="mi">31</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>  
<span class="go">array([26,  5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>  
<span class="go">array([ True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.block">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">block</code><span class="sig-paren">(</span><em class="sig-param">arrays</em>, <em class="sig-param">allow_unknown_chunksizes=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.block" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble an nd-array from nested lists of blocks.</p>
<p>Blocks in the innermost lists are concatenated along the last
dimension (-1), then these are concatenated along the second-last
dimension (-2), and so on until the outermost list is reached</p>
<p>Blocks can be of any dimension, but will not be broadcasted using the normal
rules. Instead, leading axes of size 1 are inserted, to make <code class="docutils literal notranslate"><span class="pre">block.ndim</span></code>
the same for all blocks. This is primarily useful for working with scalars,
and means that code like <code class="docutils literal notranslate"><span class="pre">block([v,</span> <span class="pre">1])</span></code> is valid, where
<code class="docutils literal notranslate"><span class="pre">v.ndim</span> <span class="pre">==</span> <span class="pre">1</span></code>.</p>
<p>When the nested list is two levels deep, this allows block matrices to be
constructed from their components.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>arrays</strong><span class="classifier">nested list of array_like or scalars (but not tuples)</span></dt><dd><p>If passed a single ndarray or scalar (a nested list of depth 0), this
is returned unmodified (and not copied).</p>
<p>Elements shapes must match along the appropriate axes (without
broadcasting), but leading 1s will be prepended to the shape as
necessary to make the dimensions match.</p>
</dd>
<dt><strong>allow_unknown_chunksizes: bool</strong></dt><dd><p>Allow unknown chunksizes, such as come from converting from dask
dataframes.  Dask.array is unable to verify that chunks line up.  If
data comes from differently aligned sources then this can cause
unexpected results.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>block_array</strong><span class="classifier">ndarray</span></dt><dd><p>The array assembled from the given blocks.</p>
<p>The dimensionality of the output is equal to the greatest of:
* the dimensionality of all the inputs
* the depth to which the input list is nested</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><ul class="simple">
<li><p>If list depths are mismatched - for instance, <code class="docutils literal notranslate"><span class="pre">[[a,</span> <span class="pre">b],</span> <span class="pre">c]</span></code> is
illegal, and should be spelt <code class="docutils literal notranslate"><span class="pre">[[a,</span> <span class="pre">b],</span> <span class="pre">[c]]</span></code></p></li>
<li><p>If lists are empty - for instance, <code class="docutils literal notranslate"><span class="pre">[[a,</span> <span class="pre">b],</span> <span class="pre">[]]</span></code></p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.concatenate" title="dask.array.concatenate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concatenate</span></code></a></dt><dd><p>Join a sequence of arrays together.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.stack" title="dask.array.stack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack</span></code></a></dt><dd><p>Stack arrays in sequence along a new dimension.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.hstack" title="dask.array.hstack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hstack</span></code></a></dt><dd><p>Stack arrays in sequence horizontally (column wise).</p>
</dd>
<dt><a class="reference internal" href="#dask.array.vstack" title="dask.array.vstack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vstack</span></code></a></dt><dd><p>Stack arrays in sequence vertically (row wise).</p>
</dd>
<dt><a class="reference internal" href="#dask.array.dstack" title="dask.array.dstack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dstack</span></code></a></dt><dd><p>Stack arrays in sequence depth wise (along third dimension).</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vsplit</span></code></dt><dd><p>Split array into a list of multiple sub-arrays vertically.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When called with only scalars, <code class="docutils literal notranslate"><span class="pre">block</span></code> is equivalent to an ndarray
call. So <code class="docutils literal notranslate"><span class="pre">block([[1,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">4]])</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">array([[1,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">4]])</span></code>.</p>
<p>This function does not enforce that the blocks lie on a fixed grid.
<code class="docutils literal notranslate"><span class="pre">block([[a,</span> <span class="pre">b],</span> <span class="pre">[c,</span> <span class="pre">d]])</span></code> is not restricted to arrays of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AAAbb</span>
<span class="n">AAAbb</span>
<span class="n">cccDD</span>
</pre></div>
</div>
<p>But is also allowed to produce, for some <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AAAbb</span>
<span class="n">AAAbb</span>
<span class="n">cDDDD</span>
</pre></div>
</div>
<p>Since concatenation happens along the last axis first, <cite>block</cite> is _not_
capable of producing the following directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AAAbb</span>
<span class="n">cccbb</span>
<span class="n">cccDD</span>
</pre></div>
</div>
<p>Matlab’s “square bracket stacking”, <code class="docutils literal notranslate"><span class="pre">[A,</span> <span class="pre">B,</span> <span class="pre">...;</span> <span class="pre">p,</span> <span class="pre">q,</span> <span class="pre">...]</span></code>, is
equivalent to <code class="docutils literal notranslate"><span class="pre">block([[A,</span> <span class="pre">B,</span> <span class="pre">...],</span> <span class="pre">[p,</span> <span class="pre">q,</span> <span class="pre">...]])</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.blockwise">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">blockwise</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">out_ind</em>, <em class="sig-param">*args</em>, <em class="sig-param">name=None</em>, <em class="sig-param">token=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">adjust_chunks=None</em>, <em class="sig-param">new_axes=None</em>, <em class="sig-param">align_arrays=True</em>, <em class="sig-param">concatenate=None</em>, <em class="sig-param">meta=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.blockwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Tensor operation: Generalized inner and outer products</p>
<p>A broad class of blocked algorithms and patterns can be specified with a
concise multi-index notation.  The <code class="docutils literal notranslate"><span class="pre">blockwise</span></code> function applies an in-memory
function across multiple blocks of multiple inputs in a variety of ways.
Many dask.array operations are special cases of blockwise including
elementwise, broadcasting, reductions, tensordot, and transpose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>Function to apply to individual tuples of blocks</p>
</dd>
<dt><strong>out_ind</strong><span class="classifier">iterable</span></dt><dd><p>Block pattern of the output, something like ‘ijk’ or (1, 2, 3)</p>
</dd>
<dt><strong>*args</strong><span class="classifier">sequence of Array, index pairs</span></dt><dd><p>Sequence like (x, ‘ij’, y, ‘jk’, z, ‘i’)</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>Extra keyword arguments to pass to function</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">np.dtype</span></dt><dd><p>Datatype of resulting array.</p>
</dd>
<dt><strong>concatenate</strong><span class="classifier">bool, keyword only</span></dt><dd><p>If true concatenate arrays along dummy indices, else provide lists</p>
</dd>
<dt><strong>adjust_chunks</strong><span class="classifier">dict</span></dt><dd><p>Dictionary mapping index to function to be applied to chunk sizes</p>
</dd>
<dt><strong>new_axes</strong><span class="classifier">dict, keyword only</span></dt><dd><p>New indexes and their dimension lengths</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>2D embarrassingly parallel operation from two arrays, x, and y.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>  <span class="c1"># z = x + y  </span>
</pre></div>
</div>
<p>Outer product multiplying x by y, two 1-d vectors</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>z = x.T</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">,</span> <span class="s1">&#39;ji&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  
</pre></div>
</div>
<p>The transpose case above is illustrative because it does same transposition
both on each in-memory block by calling <code class="docutils literal notranslate"><span class="pre">np.transpose</span></code> and on the order
of the blocks themselves, by switching the order of the index <code class="docutils literal notranslate"><span class="pre">ij</span> <span class="pre">-&gt;</span> <span class="pre">ji</span></code>.</p>
<p>We can compose these same patterns with more variables and more complex
in-memory functions</p>
<p>z = X + Y.T</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ji&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>Any index, like <code class="docutils literal notranslate"><span class="pre">i</span></code> missing from the output index is interpreted as a
contraction (note that this differs from Einstein convention; repeated
indices do not imply contraction.)  In the case of a contraction the passed
function should expect an iterable of blocks on any array that holds that
index.  To receive arrays concatenated along contracted dimensions instead
pass <code class="docutils literal notranslate"><span class="pre">concatenate=True</span></code>.</p>
<p>Inner product multiplying x by y, two 1-d vectors</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sequence_dot</span><span class="p">(</span><span class="n">x_blocks</span><span class="p">,</span> <span class="n">y_blocks</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_blocks</span><span class="p">,</span> <span class="n">y_blocks</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">sequence_dot</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>Add new single-chunk dimensions with the <code class="docutils literal notranslate"><span class="pre">new_axes=</span></code> keyword, including
the length of the new dimension.  New dimensions will always be in a single
chunk.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;az&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  
</pre></div>
</div>
<p>New dimensions can also be multi-chunk by specifying a tuple of chunk
sizes.  This has limited utility as is (because the chunks are all the
same), but the resulting graph can be modified to achieve more useful
results (see <code class="docutils literal notranslate"><span class="pre">da.map_blocks</span></code>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;az&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)},</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  
</pre></div>
</div>
<p>If the applied function changes the size of each chunk you can specify this
with a <code class="docutils literal notranslate"><span class="pre">adjust_chunks={...}</span></code> dictionary holding a function for each index
that modifies the dimension size in that index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">double</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">adjust_chunks</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">},</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  
</pre></div>
</div>
<p>Include literals by indexing with None</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.broadcast_arrays">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">broadcast_arrays</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.broadcast_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcast any number of arrays against each other.</p>
<p>This docstring was copied from numpy.broadcast_arrays.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>`*args`</strong><span class="classifier">array_likes</span></dt><dd><p>The arrays to broadcast.</p>
</dd>
<dt><strong>subok</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, then sub-classes will be passed-through, otherwise
the returned arrays will be forced to be a base-class array (default).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>broadcasted</strong><span class="classifier">list of arrays</span></dt><dd><p>These arrays are views on the original arrays.  They are typically
not contiguous.  Furthermore, more than one element of a
broadcasted array may refer to a single memory location. If you need
to write to the arrays, make copies first. While you can set the
<code class="docutils literal notranslate"><span class="pre">writable</span></code> flag True, writing to a single output value may end up
changing more than one location in the output array.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.17: </span>The output is currently marked so that if written to, a deprecation
warning will be emitted. A future version will set the
<code class="docutils literal notranslate"><span class="pre">writable</span></code> flag False so writing to it will raise an error.</p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  
<span class="go">[array([[1, 2, 3],</span>
<span class="go">       [1, 2, 3]]), array([[4, 4, 4],</span>
<span class="go">       [5, 5, 5]])]</span>
</pre></div>
</div>
<p>Here is a useful idiom for getting contiguous copies instead of
non-contiguous views.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>  
<span class="go">[array([[1, 2, 3],</span>
<span class="go">       [1, 2, 3]]), array([[4, 4, 4],</span>
<span class="go">       [5, 5, 5]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.broadcast_to">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">broadcast_to</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">shape</em>, <em class="sig-param">chunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.broadcast_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcast an array to a new shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>The array to broadcast.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the desired array.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">tuple, optional</span></dt><dd><p>If provided, then the result will use these chunks instead of the same
chunks as the source array. Setting chunks explicitly as part of
broadcast_to is more efficient than rechunking afterwards. Chunks are
only allowed to differ from the original shape along dimensions that
are new on the result or have size 1 the input array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>broadcast</strong><span class="classifier">dask array</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast_to.html#numpy.broadcast_to" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.broadcast_to()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">coarsen</code><span class="sig-paren">(</span><em class="sig-param">reduction</em>, <em class="sig-param">x</em>, <em class="sig-param">axes</em>, <em class="sig-param">trim_excess=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Coarsen array by applying reduction to fixed size neighborhoods</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reduction: function</strong></dt><dd><p>Function like np.sum, np.mean, etc…</p>
</dd>
<dt><strong>x: np.ndarray</strong></dt><dd><p>Array to be coarsened</p>
</dd>
<dt><strong>axes: dict</strong></dt><dd><p>Mapping of axis to coarsening factor</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coarsen</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">array([ 3,  7, 11])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coarsen</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
<span class="go">array([3, 6])</span>
</pre></div>
</div>
<p>Provide dictionary of scale per dimension</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">       [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coarsen</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
<span class="go">array([[ 0,  3],</span>
<span class="go">       [12, 15]])</span>
</pre></div>
</div>
<p>You must avoid excess elements explicitly</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coarsen</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="n">trim_excess</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([1, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ceil">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">ceil</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ceil.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the ceiling of the input, element-wise.</p>
<p>The ceil of the scalar <cite>x</cite> is the smallest integer <cite>i</cite>, such that
<cite>i &gt;= x</cite>.  It is often denoted as <span class="math notranslate nohighlight">\(\lceil x \rceil\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The ceiling of each element in <cite>x</cite>, with <cite>float</cite> dtype.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.floor" title="dask.array.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a>, <a class="reference internal" href="#dask.array.trunc" title="dask.array.trunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trunc</span></code></a>, <a class="reference internal" href="#dask.array.rint" title="dask.array.rint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rint</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">array([-1., -1., -0.,  1.,  2.,  2.,  2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.choose">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">choose</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">choices</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.choose" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array from an index array and a set of arrays to choose from.</p>
<p>This docstring was copied from numpy.choose.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>First of all, if confused or uncertain, definitely look at the Examples -
in its full generality, this function is less simple than it might
seem from the following code description (below ndi =
<cite>numpy.lib.index_tricks</cite>):</p>
<p><code class="docutils literal notranslate"><span class="pre">np.choose(a,c)</span> <span class="pre">==</span> <span class="pre">np.array([c[a[I]][I]</span> <span class="pre">for</span> <span class="pre">I</span> <span class="pre">in</span> <span class="pre">ndi.ndindex(a.shape)])</span></code>.</p>
<p>But this omits some subtleties.  Here is a fully general summary:</p>
<p>Given an “index” array (<cite>a</cite>) of integers and a sequence of <cite>n</cite> arrays
(<cite>choices</cite>), <cite>a</cite> and each choice array are first broadcast, as necessary,
to arrays of a common shape; calling these <em>Ba</em> and <em>Bchoices[i], i =
0,…,n-1</em> we have that, necessarily, <code class="docutils literal notranslate"><span class="pre">Ba.shape</span> <span class="pre">==</span> <span class="pre">Bchoices[i].shape</span></code>
for each <cite>i</cite>.  Then, a new array with shape <code class="docutils literal notranslate"><span class="pre">Ba.shape</span></code> is created as
follows:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">mode=raise</span></code> (the default), then, first of all, each element of
<cite>a</cite> (and thus <cite>Ba</cite>) must be in the range <cite>[0, n-1]</cite>; now, suppose that
<cite>i</cite> (in that range) is the value at the <cite>(j0, j1, …, jm)</cite> position
in <cite>Ba</cite> - then the value at the same position in the new array is the
value in <cite>Bchoices[i]</cite> at that same position;</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">mode=wrap</span></code>, values in <cite>a</cite> (and thus <cite>Ba</cite>) may be any (signed)
integer; modular arithmetic is used to map integers outside the range
<cite>[0, n-1]</cite> back into that range; and then the new array is constructed
as above;</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">mode=clip</span></code>, values in <cite>a</cite> (and thus <cite>Ba</cite>) may be any (signed)
integer; negative integers are mapped to 0; values greater than <cite>n-1</cite>
are mapped to <cite>n-1</cite>; and then the new array is constructed as above.</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">int array</span></dt><dd><p>This array must contain integers in <cite>[0, n-1]</cite>, where <cite>n</cite> is the number
of choices, unless <code class="docutils literal notranslate"><span class="pre">mode=wrap</span></code> or <code class="docutils literal notranslate"><span class="pre">mode=clip</span></code>, in which cases any
integers are permissible.</p>
</dd>
<dt><strong>choices</strong><span class="classifier">sequence of arrays</span></dt><dd><p>Choice arrays. <cite>a</cite> and all of the choices must be broadcastable to the
same shape.  If <cite>choices</cite> is itself an array (not recommended), then
its outermost dimension (i.e., the one corresponding to
<code class="docutils literal notranslate"><span class="pre">choices.shape[0]</span></code>) is taken as defining the “sequence”.</p>
</dd>
<dt><strong>out</strong><span class="classifier">array, optional  (Not supported in Dask)</span></dt><dd><p>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype. Note that <cite>out</cite> is always
buffered if <cite>mode=’raise’</cite>; use other modes for better performance.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘raise’ (default), ‘wrap’, ‘clip’}, optional  (Not supported in Dask)</span></dt><dd><p>Specifies how indices outside <cite>[0, n-1]</cite> will be treated:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘raise’ : an exception is raised</p></li>
<li><p>‘wrap’ : value becomes value mod <cite>n</cite></p></li>
<li><p>‘clip’ : values &lt; 0 are mapped to 0, values &gt; n-1 are mapped to n-1</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>merged_array</strong><span class="classifier">array</span></dt><dd><p>The merged result.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError: shape mismatch</strong></dt><dd><p>If <cite>a</cite> and each choice array are not all broadcastable to the same
shape.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.choose</span></code></dt><dd><p>equivalent method</p>
</dd>
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.take_along_axis.html#numpy.take_along_axis" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.take_along_axis</span></code></a></dt><dd><p>Preferable if <cite>choices</cite> is an array</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>To reduce the chance of misinterpretation, even though the following
“abuse” is nominally supported, <cite>choices</cite> should neither be, nor be
thought of as, a single array, i.e., the outermost sequence-like container
should be either a list or a tuple.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">choices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span>  
<span class="gp">... </span>  <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">33</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">choices</span>  
<span class="gp">... </span><span class="c1"># the first element of the result will be the first element of the</span>
<span class="gp">... </span><span class="c1"># third (2+1) &quot;array&quot; in choices, namely, 20; the second element</span>
<span class="gp">... </span><span class="c1"># will be the second element of the fourth (3+1) choice array, i.e.,</span>
<span class="gp">... </span><span class="c1"># 31, etc.</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([20, 31, 12,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">choices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span> <span class="c1"># 4 goes to 3 (4-1)  </span>
<span class="go">array([20, 31, 12,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># because there are 4 choice arrays</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">choices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span> <span class="c1"># 4 goes to (4 mod 4)  </span>
<span class="go">array([20,  1, 12,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># i.e., 0</span>
</pre></div>
</div>
<p>A couple examples illustrating how choose broadcasts:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">choices</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">choices</span><span class="p">)</span>  
<span class="go">array([[ 10, -10,  10],</span>
<span class="go">       [-10,  10, -10],</span>
<span class="go">       [ 10, -10,  10]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># With thanks to Anne Archibald</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span> <span class="c1"># result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2  </span>
<span class="go">array([[[ 1,  1,  1,  1,  1],</span>
<span class="go">        [ 2,  2,  2,  2,  2],</span>
<span class="go">        [ 3,  3,  3,  3,  3]],</span>
<span class="go">       [[-1, -2, -3, -4, -5],</span>
<span class="go">        [-1, -2, -3, -4, -5],</span>
<span class="go">        [-1, -2, -3, -4, -5]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.clip">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">clip</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip (limit) the values in an array.</p>
<p>This docstring was copied from numpy.clip.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.</p>
<p>Equivalent to but faster than <code class="docutils literal notranslate"><span class="pre">np.maximum(a_min,</span> <span class="pre">np.minimum(a,</span> <span class="pre">a_max))</span></code>.
No check is performed to ensure <code class="docutils literal notranslate"><span class="pre">a_min</span> <span class="pre">&lt;</span> <span class="pre">a_max</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Array containing elements to clip.</p>
</dd>
<dt><strong>a_min</strong><span class="classifier">scalar or array_like or None  (Not supported in Dask)</span></dt><dd><p>Minimum value. If None, clipping is not performed on lower
interval edge. Not more than one of <cite>a_min</cite> and <cite>a_max</cite> may be
None.</p>
</dd>
<dt><strong>a_max</strong><span class="classifier">scalar or array_like or None  (Not supported in Dask)</span></dt><dd><p>Maximum value. If None, clipping is not performed on upper
interval edge. Not more than one of <cite>a_min</cite> and <cite>a_max</cite> may be
None. If <cite>a_min</cite> or <cite>a_max</cite> are array_like, then the three
arrays will be broadcasted to match their shapes.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional  (Not supported in Dask)</span></dt><dd><p>The results will be placed in this array. It may be the input
array for in-place clipping.  <cite>out</cite> must be of the right shape
to hold the output.  Its type is preserved.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clipped_array</strong><span class="classifier">ndarray</span></dt><dd><p>An array with the elements of <cite>a</cite>, but where values
&lt; <cite>a_min</cite> are replaced with <cite>a_min</cite>, and those &gt; <cite>a_max</cite>
with <cite>a_max</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ufuncs-output-type</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>  
<span class="go">array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>  
<span class="go">array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>  
<span class="go">array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.compress">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">compress</code><span class="sig-paren">(</span><em class="sig-param">condition</em>, <em class="sig-param">a</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Return selected slices of an array along given axis.</p>
<p>This docstring was copied from numpy.compress.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>When working along a given axis, a slice along that axis is returned in
<cite>output</cite> for each index where <cite>condition</cite> evaluates to True. When
working on a 1-D array, <cite>compress</cite> is equivalent to <cite>extract</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>condition</strong><span class="classifier">1-D array of bools</span></dt><dd><p>Array that selects which entries to return. If len(condition)
is less than the size of <cite>a</cite> along the given axis, then output is
truncated to the length of the condition array.</p>
</dd>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Array from which to extract a part.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which to take slices. If None (default), work on the
flattened array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional  (Not supported in Dask)</span></dt><dd><p>Output array.  Its type is preserved and it must be of the right
shape to hold the output.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>compressed_array</strong><span class="classifier">ndarray</span></dt><dd><p>A copy of <cite>a</cite> without the slices along axis for which <cite>condition</cite>
is false.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.take" title="dask.array.take"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code></a>, <a class="reference internal" href="#dask.array.choose" title="dask.array.choose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose</span></code></a>, <a class="reference internal" href="#dask.array.diag" title="dask.array.diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diag</span></code></a>, <a class="reference internal" href="#dask.array.diagonal" title="dask.array.diagonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">select</span></code></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.compress</span></code></dt><dd><p>Equivalent method in ndarray</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.extract</span></code></dt><dd><p>Equivalent method when working on 1-D arrays</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ufuncs-output-type</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([[3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([[3, 4],</span>
<span class="go">       [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[2],</span>
<span class="go">       [4],</span>
<span class="go">       [6]])</span>
</pre></div>
</div>
<p>Working on the flattened array does not return slices along an axis but
selects elements.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>  
<span class="go">array([2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">concatenate</code><span class="sig-paren">(</span><em class="sig-param">seq</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">allow_unknown_chunksizes=False</em><span class="sig-paren">)</span></dt>
<dd><p>Concatenate arrays along an existing axis</p>
<p>Given a sequence of dask Arrays form a new dask Array by stacking them
along an existing dimension (axis=0 by default)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seq: list of dask.arrays</strong></dt><dd></dd>
<dt><strong>axis: int</strong></dt><dd><p>Dimension along which to align all of the arrays</p>
</dd>
<dt><strong>allow_unknown_chunksizes: bool</strong></dt><dd><p>Allow unknown chunksizes, such as come from converting from dask
dataframes.  Dask.array is unable to verify that chunks line up.  If
data comes from differently aligned sources then this can cause
unexpected results.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.stack" title="dask.array.stack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Create slices</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">from_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(12, 4)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 12)</span>
</pre></div>
</div>
<p>Result is a new dask Array</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.conj">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">conj</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.conjugate.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the complex conjugate, element-wise.</p>
<p>The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input value.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The complex conjugate of <cite>x</cite>, with same dtype as <cite>y</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><cite>conj</cite> is an alias for <cite>conjugate</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">conj</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span>  
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">)</span>  
<span class="go">(1-2j)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([[ 1.-1.j,  0.-0.j],</span>
<span class="go">       [ 0.-0.j,  1.-1.j]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.copysign">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">copysign</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.copysign" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.copysign.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Change the sign of x1 to that of x2, element-wise.</p>
<p>If <cite>x2</cite> is a scalar, its sign will be copied to all elements of <cite>x1</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1</strong><span class="classifier">array_like</span></dt><dd><p>Values to change the sign of.</p>
</dd>
<dt><strong>x2</strong><span class="classifier">array_like</span></dt><dd><p>The sign of <cite>x2</cite> is copied to <cite>x1</cite>. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The values of <cite>x1</cite> with the sign of <cite>x2</cite>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">-1.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  
<span class="go">inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">-inf</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">copysign</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mf">1.1</span><span class="p">)</span>  
<span class="go">array([-1., -0., -1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">copysign</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([-1.,  0.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.corrcoef">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">corrcoef</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y=None</em>, <em class="sig-param">rowvar=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.corrcoef" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Pearson product-moment correlation coefficients.</p>
<p>This docstring was copied from numpy.corrcoef.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Please refer to the documentation for <cite>cov</cite> for more detail.  The
relationship between the correlation coefficient matrix, <cite>R</cite>, and the
covariance matrix, <cite>C</cite>, is</p>
<div class="math notranslate nohighlight">
\[R_{ij} = \frac{ C_{ij} } { \sqrt{ C_{ii} * C_{jj} } }\]</div>
<p>The values of <cite>R</cite> are between -1 and 1, inclusive.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>A 1-D or 2-D array containing multiple variables and observations.
Each row of <cite>x</cite> represents a variable, and each column a single
observation of all those variables. Also see <cite>rowvar</cite> below.</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like, optional</span></dt><dd><p>An additional set of variables and observations. <cite>y</cite> has the same
shape as <cite>x</cite>.</p>
</dd>
<dt><strong>rowvar</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>rowvar</cite> is True (default), then each row represents a
variable, with observations in the columns. Otherwise, the relationship
is transposed: each column represents a variable, while the rows
contain observations.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">_NoValue, optional  (Not supported in Dask)</span></dt><dd><p>Has no effect, do not use.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.10.0.</span></p>
</div>
</dd>
<dt><strong>ddof</strong><span class="classifier">_NoValue, optional  (Not supported in Dask)</span></dt><dd><p>Has no effect, do not use.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.10.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">ndarray</span></dt><dd><p>The correlation coefficient matrix of the variables.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.cov" title="dask.array.cov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cov</span></code></a></dt><dd><p>Covariance matrix</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Due to floating point rounding the resulting array may not be Hermitian,
the diagonal elements may not be 1, and the elements may not satisfy the
inequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the
interval [-1,  1] in an attempt to improve on that situation but is not
much help in the complex case.</p>
<p>This function accepts but discards arguments <cite>bias</cite> and <cite>ddof</cite>.  This is
for backwards compatibility with previous versions of this function.  These
arguments had no effect on the return values of the function and can be
safely ignored in this and previous versions of numpy.</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.cos">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">cos</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.cos.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Cosine element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array in radians.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The corresponding cosine values.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <cite>out</cite> is provided, the function writes the result into it,
and returns a reference to <cite>out</cite>.  (See Examples)</p>
<p class="rubric">References</p>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]))</span>  
<span class="go">array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of providing the optional output parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">([</span><span class="mf">0.1</span><span class="p">],</span> <span class="n">out1</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="ow">is</span> <span class="n">out1</span>  
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of ValueError due to provision of shape mis-matched `out`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operands could not be broadcast together with shapes (3,3) (2,2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.cosh">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">cosh</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.cosh" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.cosh.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Hyperbolic cosine, element-wise.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">1/2</span> <span class="pre">*</span> <span class="pre">(np.exp(x)</span> <span class="pre">+</span> <span class="pre">np.exp(-x))</span></code> and <code class="docutils literal notranslate"><span class="pre">np.cos(1j*x)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Output array of same shape as <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">1.0</span>
</pre></div>
</div>
<p>The hyperbolic cosine describes the shape of a hanging cable:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.count_nonzero">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">count_nonzero</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.count_nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the number of non-zero values in the array <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>This docstring was copied from numpy.count_nonzero.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The word “non-zero” is in reference to the Python 2.x
built-in method <code class="docutils literal notranslate"><span class="pre">__nonzero__()</span></code> (renamed <code class="docutils literal notranslate"><span class="pre">__bool__()</span></code>
in Python 3.x) of Python objects that tests an object’s
“truthfulness”. For example, any number is considered
truthful if it is nonzero, whereas any string is considered
truthful if it is not the empty string. Thus, this function
(recursively) counts how many elements in <code class="docutils literal notranslate"><span class="pre">a</span></code> (and in
sub-arrays thereof) have their <code class="docutils literal notranslate"><span class="pre">__nonzero__()</span></code> or <code class="docutils literal notranslate"><span class="pre">__bool__()</span></code>
method evaluated to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>The array for which to count non-zeros.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or tuple, optional</span></dt><dd><p>Axis or tuple of axes along which to count non-zeros.
Default is None, meaning that non-zeros will be counted
along a flattened version of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>count</strong><span class="classifier">int or array of int</span></dt><dd><p>Number of non-zero values in the array along a given axis.
Otherwise, the total number of non-zero values in the array
is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.nonzero" title="dask.array.nonzero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code></a></dt><dd><p>Return the coordinates of all the non-zero values.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>  
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">19</span><span class="p">]])</span>  
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">19</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([1, 1, 1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">19</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.cov">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">cov</code><span class="sig-paren">(</span><em class="sig-param">m</em>, <em class="sig-param">y=None</em>, <em class="sig-param">rowvar=1</em>, <em class="sig-param">bias=0</em>, <em class="sig-param">ddof=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate a covariance matrix, given data and weights.</p>
<p>This docstring was copied from numpy.cov.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Covariance indicates the level to which two variables vary together.
If we examine N-dimensional samples, <span class="math notranslate nohighlight">\(X = [x_1, x_2, ... x_N]^T\)</span>,
then the covariance matrix element <span class="math notranslate nohighlight">\(C_{ij}\)</span> is the covariance of
<span class="math notranslate nohighlight">\(x_i\)</span> and <span class="math notranslate nohighlight">\(x_j\)</span>. The element <span class="math notranslate nohighlight">\(C_{ii}\)</span> is the variance
of <span class="math notranslate nohighlight">\(x_i\)</span>.</p>
<p>See the notes for an outline of the algorithm.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>m</strong><span class="classifier">array_like</span></dt><dd><p>A 1-D or 2-D array containing multiple variables and observations.
Each row of <cite>m</cite> represents a variable, and each column a single
observation of all those variables. Also see <cite>rowvar</cite> below.</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like, optional</span></dt><dd><p>An additional set of variables and observations. <cite>y</cite> has the same form
as that of <cite>m</cite>.</p>
</dd>
<dt><strong>rowvar</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>rowvar</cite> is True (default), then each row represents a
variable, with observations in the columns. Otherwise, the relationship
is transposed: each column represents a variable, while the rows
contain observations.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">bool, optional</span></dt><dd><p>Default normalization (False) is by <code class="docutils literal notranslate"><span class="pre">(N</span> <span class="pre">-</span> <span class="pre">1)</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the
number of observations given (unbiased estimate). If <cite>bias</cite> is True,
then normalization is by <code class="docutils literal notranslate"><span class="pre">N</span></code>. These values can be overridden by using
the keyword <code class="docutils literal notranslate"><span class="pre">ddof</span></code> in numpy versions &gt;= 1.5.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, optional</span></dt><dd><p>If not <code class="docutils literal notranslate"><span class="pre">None</span></code> the default value implied by <cite>bias</cite> is overridden.
Note that <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code> will return the unbiased estimate, even if both
<cite>fweights</cite> and <cite>aweights</cite> are specified, and <code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> will return
the simple average. See the notes for the details. The default value
is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.5.</span></p>
</div>
</dd>
<dt><strong>fweights</strong><span class="classifier">array_like, int, optional  (Not supported in Dask)</span></dt><dd><p>1-D array of integer frequency weights; the number of times each
observation vector should be repeated.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.</span></p>
</div>
</dd>
<dt><strong>aweights</strong><span class="classifier">array_like, optional  (Not supported in Dask)</span></dt><dd><p>1-D array of observation vector weights. These relative weights are
typically large for observations considered “important” and smaller for
observations considered less “important”. If <code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> the array of
weights can be used to assign probabilities to observation vectors.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>The covariance matrix of the variables.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.corrcoef" title="dask.array.corrcoef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">corrcoef</span></code></a></dt><dd><p>Normalized covariance matrix</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Assume that the observations are in the columns of the observation
array <cite>m</cite> and let <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">fweights</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">aweights</span></code> for brevity. The
steps to compute the weighted covariance are as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">a</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">/</span> <span class="n">v1</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">/</span> <span class="p">(</span><span class="n">v1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">ddof</span> <span class="o">*</span> <span class="n">v2</span><span class="p">)</span>  
</pre></div>
</div>
<p>Note that when <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">1</span></code>, the normalization factor
<code class="docutils literal notranslate"><span class="pre">v1</span> <span class="pre">/</span> <span class="pre">(v1**2</span> <span class="pre">-</span> <span class="pre">ddof</span> <span class="pre">*</span> <span class="pre">v2)</span></code> goes over to <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">(np.sum(f)</span> <span class="pre">-</span> <span class="pre">ddof)</span></code>
as it should.</p>
<p class="rubric">Examples</p>
<p>Consider two variables, <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x_1\)</span>, which
correlate perfectly, but in opposite directions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [2, 1, 0]])</span>
</pre></div>
</div>
<p>Note how <span class="math notranslate nohighlight">\(x_0\)</span> increases while <span class="math notranslate nohighlight">\(x_1\)</span> decreases. The covariance
matrix shows this clearly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([[ 1., -1.],</span>
<span class="go">       [-1.,  1.]])</span>
</pre></div>
</div>
<p>Note that element <span class="math notranslate nohighlight">\(C_{0,1}\)</span>, which shows the correlation between
<span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x_1\)</span>, is negative.</p>
<p>Further, note how <cite>x</cite> and <cite>y</cite> are combined:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mf">4.3</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span>  <span class="mf">1.1</span><span class="p">,</span>  <span class="mf">0.12</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  
<span class="go">array([[11.71      , -4.286     ], # may vary</span>
<span class="go">       [-4.286     ,  2.144133]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  
<span class="go">array([[11.71      , -4.286     ], # may vary</span>
<span class="go">       [-4.286     ,  2.144133]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array(11.71)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.cumprod">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">cumprod</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product of elements along a given axis.</p>
<p>This docstring was copied from numpy.cumprod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which the cumulative product is computed.  By default
the input is flattened.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Type of the returned array, as well as of the accumulator in which
the elements are multiplied.  If <em>dtype</em> is not specified, it
defaults to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with
a precision less than that of the default platform integer.  In
that case, the default platform integer is used instead.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type of the resulting values will be cast if necessary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cumprod</strong><span class="classifier">ndarray</span></dt><dd><p>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case a reference to out is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ufuncs-output-type</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># intermediate results 1, 1*2  </span>
<span class="gp">... </span>              <span class="c1"># total product 1*2*3 = 6</span>
<span class="go">array([1, 2, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># specify type of output  </span>
<span class="go">array([   1.,    2.,    6.,   24.,  120.,  720.])</span>
</pre></div>
</div>
<p>The cumulative product for each column (i.e., over the rows) of <cite>a</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([[ 1,  2,  3],</span>
<span class="go">       [ 4, 10, 18]])</span>
</pre></div>
</div>
<p>The cumulative product for each row (i.e. over the columns) of <cite>a</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[  1,   2,   6],</span>
<span class="go">       [  4,  20, 120]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.cumsum">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">cumsum</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative sum of the elements along a given axis.</p>
<p>This docstring was copied from numpy.cumsum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which the cumulative sum is computed. The default
(None) is to compute the cumsum over the flattened array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Type of the returned array and of the accumulator in which the
elements are summed.  If <cite>dtype</cite> is not specified, it defaults
to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with a
precision less than that of the default platform integer.  In
that case, the default platform integer is used.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type will be cast if necessary. See <cite>ufuncs-output-type</cite> for
more details.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cumsum_along_axis</strong><span class="classifier">ndarray.</span></dt><dd><p>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case a reference to <cite>out</cite> is returned. The
result has the same size as <cite>a</cite>, and the same shape as <cite>a</cite> if
<cite>axis</cite> is not None or <cite>a</cite> is a 1-d array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.sum" title="dask.array.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a></dt><dd><p>Sum array elements.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">trapz</span></code></dt><dd><p>Integration of array values using the composite trapezoidal rule.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.diff" title="dask.array.diff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code></a></dt><dd><p>Calculate the n-th discrete difference along given axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">array([ 1,  3,  6, 10, 15, 21])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>     <span class="c1"># specifies type of output value(s)  </span>
<span class="go">array([  1.,   3.,   6.,  10.,  15.,  21.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>      <span class="c1"># sum over rows for each of the 3 columns  </span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [5, 7, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>      <span class="c1"># sum over columns for each of the 2 rows  </span>
<span class="go">array([[ 1,  3,  6],</span>
<span class="go">       [ 4,  9, 15]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.deg2rad">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">deg2rad</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.deg2rad" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.deg2rad.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Convert angles from degrees to radians.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Angles in degrees.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The corresponding angle in radians.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.rad2deg" title="dask.array.rad2deg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rad2deg</span></code></a></dt><dd><p>Convert angles from radians to degrees.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">unwrap</span></code></dt><dd><p>Remove large jumps in angle by wrapping.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">deg2rad(x)</span></code> is <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">pi</span> <span class="pre">/</span> <span class="pre">180</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">180</span><span class="p">)</span>  
<span class="go">3.1415926535897931</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.degrees">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">degrees</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.degrees.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Convert angles from radians to degrees.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array in radians.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray of floats</span></dt><dd><p>The corresponding degree values; if <cite>out</cite> was supplied this is a
reference to it.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.rad2deg" title="dask.array.rad2deg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rad2deg</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Convert a radian array to degrees</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">12.</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span>  
<span class="go">array([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,</span>
<span class="go">        270.,  300.,  330.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rad</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">rad</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">out</span><span class="p">)</span>  
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.diag">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">diag</code><span class="sig-paren">(</span><em class="sig-param">v</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a diagonal or construct a diagonal array.</p>
<p>This docstring was copied from numpy.diag.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>See the more detailed documentation for <code class="docutils literal notranslate"><span class="pre">numpy.diagonal</span></code> if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">array_like</span></dt><dd><p>If <cite>v</cite> is a 2-D array, return a copy of its <cite>k</cite>-th diagonal.
If <cite>v</cite> is a 1-D array, return a 2-D array with <cite>v</cite> on the <cite>k</cite>-th
diagonal.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>Diagonal in question. The default is 0. Use <cite>k&gt;0</cite> for diagonals
above the main diagonal, and <cite>k&lt;0</cite> for diagonals below the main
diagonal.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>The extracted diagonal or constructed diagonal array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.diagonal" title="dask.array.diagonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal</span></code></a></dt><dd><p>Return specified diagonals.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagflat</span></code></dt><dd><p>Create a 2-D array with the flattened input as a diagonal.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code></dt><dd><p>Sum along diagonals.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.triu" title="dask.array.triu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triu</span></code></a></dt><dd><p>Upper triangle of an array.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.tril" title="dask.array.tril"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tril</span></code></a></dt><dd><p>Lower triangle of an array.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([0, 4, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([1, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([3, 7])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 8]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.diagonal">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">diagonal</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">offset=0</em>, <em class="sig-param">axis1=0</em>, <em class="sig-param">axis2=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return specified diagonals.</p>
<p>This docstring was copied from numpy.diagonal.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>If <cite>a</cite> is 2-D, returns the diagonal of <cite>a</cite> with the given offset,
i.e., the collection of elements of the form <code class="docutils literal notranslate"><span class="pre">a[i,</span> <span class="pre">i+offset]</span></code>.  If
<cite>a</cite> has more than two dimensions, then the axes specified by <cite>axis1</cite>
and <cite>axis2</cite> are used to determine the 2-D sub-array whose diagonal is
returned.  The shape of the resulting array can be determined by
removing <cite>axis1</cite> and <cite>axis2</cite> and appending an index to the right equal
to the size of the resulting diagonals.</p>
<p>In versions of NumPy prior to 1.7, this function always returned a new,
independent array containing a copy of the values in the diagonal.</p>
<p>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,
but depending on this fact is deprecated. Writing to the resulting
array continues to work as it used to, but a FutureWarning is issued.</p>
<p>Starting in NumPy 1.9 it returns a read-only view on the original array.
Attempting to write to the resulting array will produce an error.</p>
<p>In some future release, it will return a read/write view and writing to
the returned array will alter your original array.  The returned array
will have the same type as the input array.</p>
<p>If you don’t write to the array returned by this function, then you can
just ignore all of the above.</p>
<p>If you depend on the current behavior, then we suggest copying the
returned array explicitly, i.e., use <code class="docutils literal notranslate"><span class="pre">np.diagonal(a).copy()</span></code> instead
of just <code class="docutils literal notranslate"><span class="pre">np.diagonal(a)</span></code>. This will work with both past and future
versions of NumPy.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Array from which the diagonals are taken.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int, optional</span></dt><dd><p>Offset of the diagonal from the main diagonal.  Can be positive or
negative.  Defaults to main diagonal (0).</p>
</dd>
<dt><strong>axis1</strong><span class="classifier">int, optional</span></dt><dd><p>Axis to be used as the first axis of the 2-D sub-arrays from which
the diagonals should be taken.  Defaults to first axis (0).</p>
</dd>
<dt><strong>axis2</strong><span class="classifier">int, optional</span></dt><dd><p>Axis to be used as the second axis of the 2-D sub-arrays from
which the diagonals should be taken. Defaults to second axis (1).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>array_of_diagonals</strong><span class="classifier">ndarray</span></dt><dd><p>If <cite>a</cite> is 2-D, then a 1-D array containing the diagonal and of the
same type as <cite>a</cite> is returned unless <cite>a</cite> is a <cite>matrix</cite>, in which case
a 1-D array rather than a (2-D) <cite>matrix</cite> is returned in order to
maintain backward compatibility.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;</span> <span class="pre">2</span></code>, then the dimensions specified by <cite>axis1</cite> and <cite>axis2</cite>
are removed, and a new axis inserted at the end corresponding to the
diagonal.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If the dimension of <cite>a</cite> is less than 2.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.diag" title="dask.array.diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diag</span></code></a></dt><dd><p>MATLAB work-a-like for 1-D and 2-D arrays.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagflat</span></code></dt><dd><p>Create diagonal arrays.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code></dt><dd><p>Sum along diagonals.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>  
<span class="go">array([0, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([1])</span>
</pre></div>
</div>
<p>A 3-D example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span>  
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># Main diagonals of two arrays created by skipping  </span>
<span class="gp">... </span>           <span class="mi">0</span><span class="p">,</span>  <span class="c1"># across the outer(left)-most axis last and</span>
<span class="gp">... </span>           <span class="mi">1</span><span class="p">)</span>  <span class="c1"># the &quot;middle&quot; (row) axis first.</span>
<span class="go">array([[0, 6],</span>
<span class="go">       [1, 7]])</span>
</pre></div>
</div>
<p>The sub-arrays whose main diagonals we just obtained; note that each
corresponds to fixing the right-most (column) axis, and that the
diagonals are “packed” in rows.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># main diagonal is [0 6]  </span>
<span class="go">array([[0, 2],</span>
<span class="go">       [4, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># main diagonal is [1 7]  </span>
<span class="go">array([[1, 3],</span>
<span class="go">       [5, 7]])</span>
</pre></div>
</div>
<p>The anti-diagonal can be obtained by reversing the order of elements
using either <cite>numpy.flipud</cite> or <cite>numpy.fliplr</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>  <span class="c1"># Horizontal flip  </span>
<span class="go">array([2, 4, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>  <span class="c1"># Vertical flip  </span>
<span class="go">array([6, 4, 2])</span>
</pre></div>
</div>
<p>Note that the order in which the diagonal is retrieved varies depending
on the flip function.</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.diff">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">diff</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">n=1</em>, <em class="sig-param">axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the n-th discrete difference along the given axis.</p>
<p>This docstring was copied from numpy.diff.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The first difference is given by <code class="docutils literal notranslate"><span class="pre">out[i]</span> <span class="pre">=</span> <span class="pre">a[i+1]</span> <span class="pre">-</span> <span class="pre">a[i]</span></code> along
the given axis, higher differences are calculated by using <cite>diff</cite>
recursively.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>The number of times values are differenced. If zero, the input
is returned as-is.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>The axis along which the difference is taken, default is the
last axis.</p>
</dd>
<dt><strong>prepend, append</strong><span class="classifier">array_like, optional</span></dt><dd><p>Values to prepend or append to <cite>a</cite> along axis prior to
performing the difference.  Scalar values are expanded to
arrays with length 1 in the direction of axis and the shape
of the input array in along all other axes.  Otherwise the
dimension and shape must match <cite>a</cite> except along axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.16.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>diff</strong><span class="classifier">ndarray</span></dt><dd><p>The n-th differences. The shape of the output is the same as <cite>a</cite>
except along <cite>axis</cite> where the dimension is smaller by <cite>n</cite>. The
type of the output is the same as the type of the difference
between any two elements of <cite>a</cite>. This is the same as the type of
<cite>a</cite> in most cases. A notable exception is <cite>datetime64</cite>, which
results in a <cite>timedelta64</cite> output array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.gradient" title="dask.array.gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient</span></code></a>, <a class="reference internal" href="#dask.array.ediff1d" title="dask.array.ediff1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ediff1d</span></code></a>, <a class="reference internal" href="#dask.array.cumsum" title="dask.array.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Type is preserved for boolean arrays, so the result will contain
<cite>False</cite> when consecutive elements are the same and <cite>True</cite> when they
differ.</p>
<p>For unsigned integer arrays, the results will also be unsigned. This
should not be surprising, as the result is consistent with
calculating the difference directly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u8_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u8_arr</span><span class="p">)</span>  
<span class="go">array([255], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u8_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">-</span> <span class="n">u8_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>  
<span class="go">255</span>
</pre></div>
</div>
<p>If this is not desirable, then the array should be cast to a larger
integer type first:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i16_arr</span> <span class="o">=</span> <span class="n">u8_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">i16_arr</span><span class="p">)</span>  
<span class="go">array([-1], dtype=int16)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([ 1,  2,  3, -7])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">array([  1,   1, -10])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([[2, 3, 4],</span>
<span class="go">       [5, 1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([[-1,  2,  0, -2]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="s1">&#39;1066-10-13&#39;</span><span class="p">,</span> <span class="s1">&#39;1066-10-16&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([1, 1], dtype=&#39;timedelta64[D]&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.digitize">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">digitize</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">bins</em>, <em class="sig-param">right=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.digitize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the bins to which each value in input array belongs.</p>
<p>This docstring was copied from numpy.digitize.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 26%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><cite>right</cite></p></th>
<th class="head"><p>order of bins</p></th>
<th class="head"><p>returned index <cite>i</cite> satisfies</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
<td><p>increasing</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bins[i-1]</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">bins[i]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
<td><p>increasing</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bins[i-1]</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">bins[i]</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
<td><p>decreasing</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bins[i-1]</span> <span class="pre">&gt;</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">bins[i]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
<td><p>decreasing</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bins[i-1]</span> <span class="pre">&gt;=</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">bins[i]</span></code></p></td>
</tr>
</tbody>
</table>
<p>If values in <cite>x</cite> are beyond the bounds of <cite>bins</cite>, 0 or <code class="docutils literal notranslate"><span class="pre">len(bins)</span></code> is
returned as appropriate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input array to be binned. Prior to NumPy 1.10.0, this array had to
be 1-dimensional, but can now have any shape.</p>
</dd>
<dt><strong>bins</strong><span class="classifier">array_like</span></dt><dd><p>Array of bins. It has to be 1-dimensional and monotonic.</p>
</dd>
<dt><strong>right</strong><span class="classifier">bool, optional</span></dt><dd><p>Indicating whether the intervals include the right or the left bin
edge. Default behavior is (right==False) indicating that the interval
does not include the right edge. The left bin end is open in this
case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for
monotonically increasing bins.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>indices</strong><span class="classifier">ndarray of ints</span></dt><dd><p>Output array of indices, of same shape as <cite>x</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If <cite>bins</cite> is not monotonic.</p>
</dd>
<dt><strong>TypeError</strong></dt><dd><p>If the type of the input is complex.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.bincount" title="dask.array.bincount"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bincount</span></code></a>, <a class="reference internal" href="#dask.array.histogram" title="dask.array.histogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">histogram</span></code></a>, <a class="reference internal" href="#dask.array.unique" title="dask.array.unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">searchsorted</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>If values in <cite>x</cite> are such that they fall outside the bin range,
attempting to index <cite>bins</cite> with the indices that <cite>digitize</cite> returns
will result in an IndexError.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p><cite>np.digitize</cite> is  implemented in terms of <cite>np.searchsorted</cite>. This means
that a binary search is used to bin the values, which scales much better
for larger number of bins than the previous linear search. It also removes
the requirement for the input array to be 1-dimensional.</p>
<p>For monotonically _increasing_ <cite>bins</cite>, the following are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that as the order of the arguments are reversed, the side must be too.
The <cite>searchsorted</cite> call is marginally faster, as it does not do any
monotonicity checks. Perhaps more importantly, it supports all dtypes.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">6.4</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span>  
<span class="go">array([1, 4, 3, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>  
<span class="gp">... </span>  <span class="nb">print</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">bins</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">n</span><span class="p">]])</span>
<span class="gp">...</span>
<span class="go">0.0 &lt;= 0.2 &lt; 1.0</span>
<span class="go">4.0 &lt;= 6.4 &lt; 10.0</span>
<span class="go">2.5 &lt;= 3.0 &lt; 4.0</span>
<span class="go">1.0 &lt;= 1.6 &lt; 2.5</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">12.4</span><span class="p">,</span> <span class="mf">15.5</span><span class="p">,</span> <span class="mf">20.</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">bins</span><span class="p">,</span><span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">array([1, 2, 3, 4, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">bins</span><span class="p">,</span><span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">array([1, 3, 3, 4, 5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.dot">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">dot</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.dot.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Dot product of two arrays. Specifically,</p>
<ul>
<li><p>If both <cite>a</cite> and <cite>b</cite> are 1-D arrays, it is inner product of vectors
(without complex conjugation).</p></li>
<li><p>If both <cite>a</cite> and <cite>b</cite> are 2-D arrays, it is matrix multiplication,
but using <a class="reference internal" href="#dask.array.matmul" title="dask.array.matmul"><code class="xref py py-func docutils literal notranslate"><span class="pre">matmul()</span></code></a> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#64;</span> <span class="pre">b</span></code> is preferred.</p></li>
<li><p>If either <cite>a</cite> or <cite>b</cite> is 0-D (scalar), it is equivalent to <code class="xref py py-func docutils literal notranslate"><span class="pre">multiply()</span></code>
and using <code class="docutils literal notranslate"><span class="pre">numpy.multiply(a,</span> <span class="pre">b)</span></code> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span></code> is preferred.</p></li>
<li><p>If <cite>a</cite> is an N-D array and <cite>b</cite> is a 1-D array, it is a sum product over
the last axis of <cite>a</cite> and <cite>b</cite>.</p></li>
<li><p>If <cite>a</cite> is an N-D array and <cite>b</cite> is an M-D array (where <code class="docutils literal notranslate"><span class="pre">M&gt;=2</span></code>), it is a
sum product over the last axis of <cite>a</cite> and the second-to-last axis of <cite>b</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">,:,</span><span class="n">m</span><span class="p">])</span>
</pre></div>
</div>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>First argument.</p>
</dd>
<dt><strong>b</strong><span class="classifier">array_like</span></dt><dd><p>Second argument.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <cite>dot(a,b)</cite>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>Returns the dot product of <cite>a</cite> and <cite>b</cite>.  If <cite>a</cite> and <cite>b</cite> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If <cite>out</cite> is given, then it is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If the last dimension of <cite>a</cite> is not the same size as
the second-to-last dimension of <cite>b</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.vdot" title="dask.array.vdot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vdot</span></code></a></dt><dd><p>Complex-conjugating dot product.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.tensordot" title="dask.array.tensordot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensordot</span></code></a></dt><dd><p>Sum products over arbitrary axes.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.einsum" title="dask.array.einsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">einsum</span></code></a></dt><dd><p>Einstein summation convention.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.matmul" title="dask.array.matmul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matmul</span></code></a></dt><dd><p>‘&#64;’ operator as method with out parameter.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  
<span class="go">12</span>
</pre></div>
</div>
<p>Neither argument is complex-conjugated:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">([</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">])</span>  
<span class="go">(-13+0j)</span>
</pre></div>
</div>
<p>For 2-D arrays it is the matrix product:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([[4, 1],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>  
<span class="go">499128</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">2</span><span class="p">])</span>  
<span class="go">499128</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.dstack">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">dstack</code><span class="sig-paren">(</span><em class="sig-param">tup</em>, <em class="sig-param">allow_unknown_chunksizes=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.dstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence depth wise (along third axis).</p>
<p>This docstring was copied from numpy.dstack.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This is equivalent to concatenation along the third axis after 2-D arrays
of shape <cite>(M,N)</cite> have been reshaped to <cite>(M,N,1)</cite> and 1-D arrays of shape
<cite>(N,)</cite> have been reshaped to <cite>(1,N,1)</cite>. Rebuilds arrays divided by
<cite>dsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tup</strong><span class="classifier">sequence of arrays</span></dt><dd><p>The arrays must have the same shape along all but the third axis.
1-D or 2-D arrays must have the same shape.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stacked</strong><span class="classifier">ndarray</span></dt><dd><p>The array formed by stacking the given arrays, will be at least 3-D.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.stack" title="dask.array.stack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack</span></code></a></dt><dd><p>Join a sequence of arrays along a new axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.vstack" title="dask.array.vstack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vstack</span></code></a></dt><dd><p>Stack along first axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.hstack" title="dask.array.hstack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hstack</span></code></a></dt><dd><p>Stack along second axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.concatenate" title="dask.array.concatenate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concatenate</span></code></a></dt><dd><p>Join a sequence of arrays along an existing axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dsplit</span></code></dt><dd><p>Split array along third axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>  
<span class="go">array([[[1, 2],</span>
<span class="go">        [2, 3],</span>
<span class="go">        [3, 4]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>  
<span class="go">array([[[1, 2]],</span>
<span class="go">       [[2, 3]],</span>
<span class="go">       [[3, 4]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ediff1d">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">ediff1d</code><span class="sig-paren">(</span><em class="sig-param">ary</em>, <em class="sig-param">to_end=None</em>, <em class="sig-param">to_begin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ediff1d" title="Permalink to this definition">¶</a></dt>
<dd><p>The differences between consecutive elements of an array.</p>
<p>This docstring was copied from numpy.ediff1d.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ary</strong><span class="classifier">array_like</span></dt><dd><p>If necessary, will be flattened before the differences are taken.</p>
</dd>
<dt><strong>to_end</strong><span class="classifier">array_like, optional</span></dt><dd><p>Number(s) to append at the end of the returned differences.</p>
</dd>
<dt><strong>to_begin</strong><span class="classifier">array_like, optional</span></dt><dd><p>Number(s) to prepend at the beginning of the returned differences.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ediff1d</strong><span class="classifier">ndarray</span></dt><dd><p>The differences. Loosely, this is <code class="docutils literal notranslate"><span class="pre">ary.flat[1:]</span> <span class="pre">-</span> <span class="pre">ary.flat[:-1]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.diff" title="dask.array.diff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code></a>, <a class="reference internal" href="#dask.array.gradient" title="dask.array.gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>When applied to masked arrays, this function drops the mask information
if the <cite>to_begin</cite> and/or <cite>to_end</cite> parameters are used.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([ 1,  2,  3, -7])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">to_begin</span><span class="o">=-</span><span class="mi">99</span><span class="p">,</span> <span class="n">to_end</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">88</span><span class="p">,</span> <span class="mi">99</span><span class="p">]))</span>  
<span class="go">array([-99,   1,   2, ...,  -7,  88,  99])</span>
</pre></div>
</div>
<p>The returned array is always 1D.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">24</span><span class="p">]]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  
<span class="go">array([ 1,  2, -3,  5, 18])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.empty">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">empty</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocked variant of empty</p>
<p>Follows the signature of empty exactly except that it also requires a
keyword argument chunks=(…)</p>
<p>Original signature follows below.
empty(shape, dtype=float, order=’C’)</p>
<p>Return a new array of given shape and type, without initializing entries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">int or tuple of int</span></dt><dd><p>Shape of the empty array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Desired output data-type for the array, e.g, <cite>numpy.int8</cite>. Default is
<cite>numpy.float64</cite>.</p>
</dd>
<dt><strong>order</strong><span class="classifier">{‘C’, ‘F’}, optional, default: ‘C’</span></dt><dd><p>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of uninitialized (arbitrary) data of the given shape, dtype, and
order.  Object arrays will be initialized to None.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.empty_like" title="dask.array.empty_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty_like</span></code></a></dt><dd><p>Return an empty array with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ones" title="dask.array.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a></dt><dd><p>Return a new array setting values to one.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.zeros" title="dask.array.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a></dt><dd><p>Return a new array setting values to zero.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.full" title="dask.array.full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code></a></dt><dd><p>Return a new array of given shape filled with value.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><cite>empty</cite>, unlike <cite>zeros</cite>, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([[ -9.74499359e+001,   6.69583040e-309],</span>
<span class="go">       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[-1073741821, -1067949133],</span>
<span class="go">       [  496041986,    19249760]])                     #uninitialized</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.empty_like">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">empty_like</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">chunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.empty_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array with the same shape and type as a given array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>The shape and data-type of <cite>a</cite> define these same attributes of the
returned array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Overrides the data type of the result.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">sequence of ints</span></dt><dd><p>The number of samples on each block. Note that the last block will have
fewer samples if <code class="docutils literal notranslate"><span class="pre">len(array)</span> <span class="pre">%</span> <span class="pre">chunks</span> <span class="pre">!=</span> <span class="pre">0</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of uninitialized (arbitrary) data with the same
shape and type as <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ones_like" title="dask.array.ones_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones_like</span></code></a></dt><dd><p>Return an array of ones with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.zeros_like" title="dask.array.zeros_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros_like</span></code></a></dt><dd><p>Return an array of zeros with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.empty" title="dask.array.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a></dt><dd><p>Return a new uninitialized array.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ones" title="dask.array.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a></dt><dd><p>Return a new array setting values to one.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.zeros" title="dask.array.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a></dt><dd><p>Return a new array setting values to zero.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function does <em>not</em> initialize the returned array; to do that use
<cite>zeros_like</cite> or <cite>ones_like</cite> instead.  It may be marginally faster than
the functions that do set the array values.</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.einsum">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">einsum</code><span class="sig-paren">(</span><em class="sig-param">subscripts</em>, <em class="sig-param">*operands</em>, <em class="sig-param">out=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">casting='safe'</em>, <em class="sig-param">optimize=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.einsum" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.einsum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Evaluates the Einstein summation convention on the operands.</p>
<p>Using the Einstein summation convention, many common multi-dimensional,
linear algebraic array operations can be represented in a simple fashion.
In <em>implicit</em> mode <cite>einsum</cite> computes these values.</p>
<p>In <em>explicit</em> mode, <cite>einsum</cite> provides further flexibility to compute
other array operations that might not be considered classical Einstein
summation operations, by disabling, or forcing summation over specified
subscript labels.</p>
<p>See the notes and examples for clarification.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>subscripts</strong><span class="classifier">str</span></dt><dd><p>Specifies the subscripts for summation as comma separated list of
subscript labels. An implicit (classical Einstein summation)
calculation is performed unless the explicit indicator ‘-&gt;’ is
included as well as subscript labels of the precise output form.</p>
</dd>
<dt><strong>operands</strong><span class="classifier">list of array_like</span></dt><dd><p>These are the arrays for the operation.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>If provided, the calculation is done into this array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">{data-type, None}, optional</span></dt><dd><p>If provided, forces the calculation to use the data type specified.
Note that you may have to also give a more liberal <cite>casting</cite>
parameter to allow the conversions. Default is None.</p>
</dd>
<dt><strong>order</strong><span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt><dd><p>Controls the memory layout of the output. ‘C’ means it should
be C contiguous. ‘F’ means it should be Fortran contiguous,
‘A’ means it should be ‘F’ if the inputs are all ‘F’, ‘C’ otherwise.
‘K’ means it should be as close to the layout as the inputs as
is possible, including arbitrarily permuted axes.
Default is ‘K’.</p>
</dd>
<dt><strong>casting</strong><span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt><dd><p>Controls what kind of data casting may occur.  Setting this to
‘unsafe’ is not recommended, as it can adversely affect accumulations.</p>
<blockquote>
<div><ul class="simple">
<li><p>‘no’ means the data types should not be cast at all.</p></li>
<li><p>‘equiv’ means only byte-order changes are allowed.</p></li>
<li><p>‘safe’ means only casts which can preserve values are allowed.</p></li>
<li><p>‘same_kind’ means only safe casts or casts within a kind,
like float64 to float32, are allowed.</p></li>
<li><p>‘unsafe’ means any data conversions may be done.</p></li>
</ul>
</div></blockquote>
<p>Default is ‘safe’.</p>
</dd>
<dt><strong>optimize</strong><span class="classifier">{False, True, ‘greedy’, ‘optimal’}, optional</span></dt><dd><p>Controls if intermediate optimization should occur. No optimization
will occur if False and True will default to the ‘greedy’ algorithm.
Also accepts an explicit contraction list from the <code class="docutils literal notranslate"><span class="pre">np.einsum_path</span></code>
function. See <code class="docutils literal notranslate"><span class="pre">np.einsum_path</span></code> for more details. Defaults to False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>The calculation based on the Einstein summation convention.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">einsum_path</span></code>, <a class="reference internal" href="#dask.array.dot" title="dask.array.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">inner</span></code>, <a class="reference internal" href="#dask.array.outer" title="dask.array.outer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">outer</span></code></a>, <a class="reference internal" href="#dask.array.tensordot" title="dask.array.tensordot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensordot</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.multi_dot</span></code></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
<p>The Einstein summation convention can be used to compute
many multi-dimensional, linear algebraic array operations. <cite>einsum</cite>
provides a succinct way of representing these.</p>
<p>A non-exhaustive list of these operations,
which can be computed by <cite>einsum</cite>, is shown below along with examples:</p>
<ul class="simple">
<li><p>Trace of an array, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.trace.html#numpy.trace" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.trace()</span></code></a>.</p></li>
<li><p>Return a diagonal, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.diag.html#numpy.diag" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.diag()</span></code></a>.</p></li>
<li><p>Array axis summations, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html#numpy.sum" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.sum()</span></code></a>.</p></li>
<li><p>Transpositions and permutations, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.transpose.html#numpy.transpose" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.transpose()</span></code></a>.</p></li>
<li><p>Matrix multiplication and dot product, <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.matmul()</span></code> <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html#numpy.dot" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.dot()</span></code></a>.</p></li>
<li><p>Vector inner and outer products, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.inner.html#numpy.inner" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.inner()</span></code></a> <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.outer.html#numpy.outer" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.outer()</span></code></a>.</p></li>
<li><p>Broadcasting, element-wise and scalar multiplication, <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.multiply()</span></code>.</p></li>
<li><p>Tensor contractions, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.tensordot.html#numpy.tensordot" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.tensordot()</span></code></a>.</p></li>
<li><p>Chained array operations, in efficient calculation order, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.einsum_path.html#numpy.einsum_path" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.einsum_path()</span></code></a>.</p></li>
</ul>
<p>The subscripts string is a comma-separated list of subscript labels,
where each label refers to a dimension of the corresponding operand.
Whenever a label is repeated it is summed, so <code class="docutils literal notranslate"><span class="pre">np.einsum('i,i',</span> <span class="pre">a,</span> <span class="pre">b)</span></code>
is equivalent to <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.inner.html#numpy.inner" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">np.inner(a,b)</span></code></a>. If a label
appears only once, it is not summed, so <code class="docutils literal notranslate"><span class="pre">np.einsum('i',</span> <span class="pre">a)</span></code> produces a
view of <code class="docutils literal notranslate"><span class="pre">a</span></code> with no changes. A further example <code class="docutils literal notranslate"><span class="pre">np.einsum('ij,jk',</span> <span class="pre">a,</span> <span class="pre">b)</span></code>
describes traditional matrix multiplication and is equivalent to
<code class="xref py py-func docutils literal notranslate"><span class="pre">np.matmul(a,b)</span></code>. Repeated subscript labels in one
operand take the diagonal. For example, <code class="docutils literal notranslate"><span class="pre">np.einsum('ii',</span> <span class="pre">a)</span></code> is equivalent
to <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.trace.html#numpy.trace" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">np.trace(a)</span></code></a>.</p>
<p>In <em>implicit mode</em>, the chosen subscripts are important
since the axes of the output are reordered alphabetically.  This
means that <code class="docutils literal notranslate"><span class="pre">np.einsum('ij',</span> <span class="pre">a)</span></code> doesn’t affect a 2D array, while
<code class="docutils literal notranslate"><span class="pre">np.einsum('ji',</span> <span class="pre">a)</span></code> takes its transpose. Additionally,
<code class="docutils literal notranslate"><span class="pre">np.einsum('ij,jk',</span> <span class="pre">a,</span> <span class="pre">b)</span></code> returns a matrix multiplication, while,
<code class="docutils literal notranslate"><span class="pre">np.einsum('ij,jh',</span> <span class="pre">a,</span> <span class="pre">b)</span></code> returns the transpose of the
multiplication since subscript ‘h’ precedes subscript ‘i’.</p>
<p>In <em>explicit mode</em> the output can be directly controlled by
specifying output subscript labels.  This requires the
identifier ‘-&gt;’ as well as the list of output subscript labels.
This feature increases the flexibility of the function since
summing can be disabled or forced when required. The call
<code class="docutils literal notranslate"><span class="pre">np.einsum('i-&gt;',</span> <span class="pre">a)</span></code> is like <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html#numpy.sum" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">np.sum(a,</span> <span class="pre">axis=-1)</span></code></a>,
and <code class="docutils literal notranslate"><span class="pre">np.einsum('ii-&gt;i',</span> <span class="pre">a)</span></code> is like <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.diag.html#numpy.diag" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">np.diag(a)</span></code></a>.
The difference is that <cite>einsum</cite> does not allow broadcasting by default.
Additionally <code class="docutils literal notranslate"><span class="pre">np.einsum('ij,jh-&gt;ih',</span> <span class="pre">a,</span> <span class="pre">b)</span></code> directly specifies the
order of the output subscript labels and therefore returns matrix
multiplication, unlike the example above in implicit mode.</p>
<p>To enable and control broadcasting, use an ellipsis.  Default
NumPy-style broadcasting is done by adding an ellipsis
to the left of each term, like <code class="docutils literal notranslate"><span class="pre">np.einsum('...ii-&gt;...i',</span> <span class="pre">a)</span></code>.
To take the trace along the first and last axes,
you can do <code class="docutils literal notranslate"><span class="pre">np.einsum('i...i',</span> <span class="pre">a)</span></code>, or to do a matrix-matrix
product with the left-most indices instead of rightmost, one can do
<code class="docutils literal notranslate"><span class="pre">np.einsum('ij...,jk...-&gt;ik...',</span> <span class="pre">a,</span> <span class="pre">b)</span></code>.</p>
<p>When there is only one operand, no axes are summed, and no output
parameter is provided, a view into the operand is returned instead
of a new array.  Thus, taking the diagonal as <code class="docutils literal notranslate"><span class="pre">np.einsum('ii-&gt;i',</span> <span class="pre">a)</span></code>
produces a view (changed in version 1.10.0).</p>
<p><cite>einsum</cite> also provides an alternative way to provide the subscripts
and operands as <code class="docutils literal notranslate"><span class="pre">einsum(op0,</span> <span class="pre">sublist0,</span> <span class="pre">op1,</span> <span class="pre">sublist1,</span> <span class="pre">...,</span> <span class="pre">[sublistout])</span></code>.
If the output shape is not provided in this format <cite>einsum</cite> will be
calculated in implicit mode, otherwise it will be performed explicitly.
The examples below have corresponding <cite>einsum</cite> calls with the two
parameter methods.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Views returned from einsum are now writeable whenever the input array
is writeable. For example, <code class="docutils literal notranslate"><span class="pre">np.einsum('ijk...-&gt;kji...',</span> <span class="pre">a)</span></code> will now
have the same effect as <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.swapaxes.html#numpy.swapaxes" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">np.swapaxes(a,</span> <span class="pre">0,</span> <span class="pre">2)</span></code></a>
and <code class="docutils literal notranslate"><span class="pre">np.einsum('ii-&gt;i',</span> <span class="pre">a)</span></code> will return a writeable view of the diagonal
of a 2D array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<p>Added the <code class="docutils literal notranslate"><span class="pre">optimize</span></code> argument which will optimize the contraction order
of an einsum expression. For a contraction with three or more operands this
can greatly increase the computational efficiency at the cost of a larger
memory footprint during computation.</p>
<p>Typically a ‘greedy’ algorithm is applied which empirical tests have shown
returns the optimal path in the majority of cases. In some cases ‘optimal’
will return the superlative path through a more expensive, exhaustive search.
For iterative calculations it may be advisable to calculate the optimal path
once and reuse that path by supplying it as an argument. An example is given
below.</p>
<p>See <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.einsum_path.html#numpy.einsum_path" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.einsum_path()</span></code></a> for more details.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>  
</pre></div>
</div>
<p>Trace of a matrix:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  
<span class="go">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>  
<span class="go">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">60</span>
</pre></div>
</div>
<p>Extract the diagonal (requires explicit form):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii-&gt;i&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  
<span class="go">array([ 0,  6, 12, 18, 24])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
<span class="go">array([ 0,  6, 12, 18, 24])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">array([ 0,  6, 12, 18, 24])</span>
</pre></div>
</div>
<p>Sum over an axis (requires explicit form):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  
<span class="go">array([ 10,  35,  60,  85, 110])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
<span class="go">array([ 10,  35,  60,  85, 110])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([ 10,  35,  60,  85, 110])</span>
</pre></div>
</div>
<p>For higher dimensional arrays summing a single axis can be done with ellipsis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...j-&gt;...&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  
<span class="go">array([ 10,  35,  60,  85, 110])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">])</span>  
<span class="go">array([ 10,  35,  60,  85, 110])</span>
</pre></div>
</div>
<p>Compute a matrix transpose, or reorder any number of axes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji&#39;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>  
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij-&gt;ji&#39;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>  
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>  
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
</pre></div>
</div>
<p>Vector inner products:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,i&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>  
<span class="go">30</span>
</pre></div>
</div>
<p>Matrix vector multiplication:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,j&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([ 30,  80, 130, 180, 230])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>  
<span class="go">array([ 30,  80, 130, 180, 230])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([ 30,  80, 130, 180, 230])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...j,j&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([ 30,  80, 130, 180, 230])</span>
</pre></div>
</div>
<p>Broadcasting and scalar multiplication:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;..., ...&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>  
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;,ij&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>  
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">])</span>  
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>  
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
</pre></div>
</div>
<p>Vector outer product:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,j&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 2, 4, 6, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>  
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 2, 4, 6, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 2, 4, 6, 8]])</span>
</pre></div>
</div>
<p>Tensor contraction:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">60.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">24.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,jil-&gt;kl&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([[4400., 4730.],</span>
<span class="go">       [4532., 4874.],</span>
<span class="go">       [4664., 5018.],</span>
<span class="go">       [4796., 5162.],</span>
<span class="go">       [4928., 5306.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>  
<span class="go">array([[4400., 4730.],</span>
<span class="go">       [4532., 4874.],</span>
<span class="go">       [4664., 5018.],</span>
<span class="go">       [4796., 5162.],</span>
<span class="go">       [4928., 5306.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>  
<span class="go">array([[4400., 4730.],</span>
<span class="go">       [4532., 4874.],</span>
<span class="go">       [4664., 5018.],</span>
<span class="go">       [4796., 5162.],</span>
<span class="go">       [4928., 5306.]])</span>
</pre></div>
</div>
<p>Writeable returned arrays (since version 1.10.0):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii-&gt;i&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)[:]</span> <span class="o">=</span> <span class="mi">1</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[1., 0., 0.],</span>
<span class="go">       [0., 1., 0.],</span>
<span class="go">       [0., 0., 1.]])</span>
</pre></div>
</div>
<p>Example of ellipsis use:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ki,jk-&gt;ij&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([[10, 28, 46, 64],</span>
<span class="go">       [13, 40, 67, 94]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ki,...k-&gt;i...&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([[10, 28, 46, 64],</span>
<span class="go">       [13, 40, 67, 94]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;k...,jk&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([[10, 28, 46, 64],</span>
<span class="go">       [13, 40, 67, 94]])</span>
</pre></div>
</div>
<p>Chained array operations. For more complicated contractions, speed ups
might be achieved by repeatedly computing a ‘greedy’ path or pre-computing the
‘optimal’ path and repeatedly applying it, using an
<cite>einsum_path</cite> insertion (since version 1.12.0). Performance improvements can be
particularly significant with larger arrays:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>  
</pre></div>
</div>
<p>Basic <cite>einsum</cite>: ~1520ms  (benchmarked on 3.1GHz Intel i5.)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Sub-optimal <cite>einsum</cite> (due to repeated path calculation time): ~330ms</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;optimal&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Greedy <cite>einsum</cite> (faster optimal path approximation): ~160ms</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Optimal <cite>einsum</cite> (best usage pattern in some use cases): ~110ms</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum_path</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;optimal&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.exp">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.exp.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Calculate the exponential of all elements in the input array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input values.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Output array, element-wise exponential of <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.expm1" title="dask.array.expm1"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expm1</span></code></a></dt><dd><p>Calculate <code class="docutils literal notranslate"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code> for all elements in the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">exp2</span></code></dt><dd><p>Calculate <code class="docutils literal notranslate"><span class="pre">2**x</span></code> for all elements in the array.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The irrational number <code class="docutils literal notranslate"><span class="pre">e</span></code> is also known as Euler’s number.  It is
approximately 2.718281, and is the base of the natural logarithm,
<code class="docutils literal notranslate"><span class="pre">ln</span></code> (this means that, if <span class="math notranslate nohighlight">\(x = \ln y = \log_e y\)</span>,
then <span class="math notranslate nohighlight">\(e^x = y\)</span>. For real input, <code class="docutils literal notranslate"><span class="pre">exp(x)</span></code> is always positive.</p>
<p>For complex arguments, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">ib</span></code>, we can write
<span class="math notranslate nohighlight">\(e^x = e^a e^{ib}\)</span>.  The first term, <span class="math notranslate nohighlight">\(e^a\)</span>, is already
known (it is the real argument, described above).  The second term,
<span class="math notranslate nohighlight">\(e^{ib}\)</span>, is <span class="math notranslate nohighlight">\(\cos b + i \sin b\)</span>, a function with
magnitude 1 and a periodic phase.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra05a861d2a84-1"><span class="brackets"><a class="fn-backref" href="#id14">1</a></span></dt>
<dd><p>Wikipedia, “Exponential function”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Exponential_function">https://en.wikipedia.org/wiki/Exponential_function</a></p>
</dd>
<dt class="label" id="ra05a861d2a84-2"><span class="brackets"><a class="fn-backref" href="#id15">2</a></span></dt>
<dd><p>M. Abramovitz and I. A. Stegun, “Handbook of Mathematical Functions
with Formulas, Graphs, and Mathematical Tables,” Dover, 1964, p. 69,
<a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/page_69.htm">http://www.math.sfu.ca/~cbm/aands/page_69.htm</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the magnitude and phase of <code class="docutils literal notranslate"><span class="pre">exp(x)</span></code> in the complex plane:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="c1"># a + ib over complex plane  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">out</span><span class="p">),</span>  
<span class="gp">... </span>           <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Magnitude of exp(x)&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">out</span><span class="p">),</span>  
<span class="gp">... </span>           <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;hsv&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase (angle) of exp(x)&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.expm1">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">expm1</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.expm1" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.expm1.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Calculate <code class="docutils literal notranslate"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code> for all elements in the array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input values.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Element-wise exponential minus one: <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.log1p" title="dask.array.log1p"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log1p</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">log(1</span> <span class="pre">+</span> <span class="pre">x)</span></code>, the inverse of expm1.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function provides greater precision than <code class="docutils literal notranslate"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code>
for small values of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p class="rubric">Examples</p>
<p>The true value of <code class="docutils literal notranslate"><span class="pre">exp(1e-10)</span> <span class="pre">-</span> <span class="pre">1</span></code> is <code class="docutils literal notranslate"><span class="pre">1.00000000005e-10</span></code> to
about 32 significant digits. This example shows the superiority of
expm1 in this case.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">)</span>  
<span class="go">1.00000000005e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  
<span class="go">1.000000082740371e-10</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.eye">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">eye</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">chunks='auto'</em>, <em class="sig-param">M=None</em>, <em class="sig-param">k=0</em>, <em class="sig-param">dtype=&lt;class 'float'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.eye" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2-D Array with ones on the diagonal and zeros elsewhere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of rows in the output.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">int, str</span></dt><dd><p>How to chunk the array. Must be one of the following forms:</p>
<ul class="simple">
<li><p>A blocksize like 1000.</p></li>
<li><p>A size in bytes, like “100 MiB” which will choose a uniform
block-like shape</p></li>
<li><p>The word “auto” which acts like the above, but uses a configuration
value <code class="docutils literal notranslate"><span class="pre">array.chunk-size</span></code> for the chunk size</p></li>
</ul>
</dd>
<dt><strong>M</strong><span class="classifier">int, optional</span></dt><dd><p>Number of columns in the output. If None, defaults to <cite>N</cite>.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int, optional</span></dt><dd><p>Index of the diagonal: 0 (the default) refers to the main diagonal,
a positive value refers to an upper diagonal, and a negative value
to a lower diagonal.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Data-type of the returned array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>I</strong><span class="classifier">Array of shape (N,M)</span></dt><dd><p>An array where all elements are equal to zero, except for the <cite>k</cite>-th
diagonal, whose values are equal to one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.array.fabs">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">fabs</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fabs" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.fabs.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute the absolute values element-wise.</p>
<p>This function returns the absolute values (positive magnitude) of the
data in <cite>x</cite>. Complex values are not handled, use <cite>absolute</cite> to find the
absolute values of complex data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>The array of numbers for which the absolute values are required. If
<cite>x</cite> is a scalar, the result <cite>y</cite> will also be a scalar.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The absolute values of <cite>x</cite>, the returned values are always floats.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">absolute</span></code></dt><dd><p>Absolute values including <cite>complex</cite> types.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">([</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">])</span>  
<span class="go">array([ 1.2,  1.2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fix">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">fix</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fix" title="Permalink to this definition">¶</a></dt>
<dd><p>Round to nearest integer towards zero.</p>
<p>This docstring was copied from numpy.fix.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Round an array of floats element-wise to nearest integer towards zero.
The rounded values are returned as floats.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>An array of floats to be rounded</p>
</dd>
<dt><strong>y</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Output array</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of floats  (Not supported in Dask)</span></dt><dd><p>The array of rounded numbers</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.trunc" title="dask.array.trunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trunc</span></code></a>, <a class="reference internal" href="#dask.array.floor" title="dask.array.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a>, <a class="reference internal" href="#dask.array.ceil" title="dask.array.ceil"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceil</span></code></a></p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.around" title="dask.array.around"><code class="xref py py-obj docutils literal notranslate"><span class="pre">around</span></code></a></dt><dd><p>Round to given number of decimals</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>  
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">([</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.9</span><span class="p">])</span>  
<span class="go">array([ 2.,  2., -2., -2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.flatnonzero">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">flatnonzero</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.flatnonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return indices that are non-zero in the flattened version of a.</p>
<p>This docstring was copied from numpy.flatnonzero.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This is equivalent to np.nonzero(np.ravel(a))[0].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>res</strong><span class="classifier">ndarray</span></dt><dd><p>Output array, containing the indices of the elements of <cite>a.ravel()</cite>
that are non-zero.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.nonzero" title="dask.array.nonzero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code></a></dt><dd><p>Return the indices of the non-zero elements of the input array.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ravel" title="dask.array.ravel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ravel</span></code></a></dt><dd><p>Return a 1-D array containing the elements of the input array.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">array([-2, -1,  0,  1,  2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([0, 1, 3, 4])</span>
</pre></div>
</div>
<p>Use the indices of the non-zero elements as an index array to extract
these elements:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>  
<span class="go">array([-2, -1,  1,  2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.flip">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">flip</code><span class="sig-paren">(</span><em class="sig-param">m</em>, <em class="sig-param">axis</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse element order along axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>Axis to reverse element order of.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reversed array</strong><span class="classifier">ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.array.flipud">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">flipud</code><span class="sig-paren">(</span><em class="sig-param">m</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.flipud" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip array in the up/down direction.</p>
<p>This docstring was copied from numpy.flipud.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Flip the entries in each column in the up/down direction.
Rows are preserved, but appear in a different order than before.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>m</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array_like</span></dt><dd><p>A view of <cite>m</cite> with the rows reversed.  Since a view is
returned, this operation is <span class="math notranslate nohighlight">\(\mathcal O(1)\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.fliplr" title="dask.array.fliplr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fliplr</span></code></a></dt><dd><p>Flip array in the left/right direction.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">rot90</span></code></dt><dd><p>Rotate array counterclockwise.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">m[::-1,...]</span></code>.
Does not require the array to be two-dimensional.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>  
<span class="go">array([[1.,  0.,  0.],</span>
<span class="go">       [0.,  2.,  0.],</span>
<span class="go">       [0.,  0.,  3.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  
<span class="go">array([[0.,  0.,  3.],</span>
<span class="go">       [0.,  2.,  0.],</span>
<span class="go">       [1.,  0.,  0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>  
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>  
<span class="go">array([2, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fliplr">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">fliplr</code><span class="sig-paren">(</span><em class="sig-param">m</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fliplr" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip array in the left/right direction.</p>
<p>This docstring was copied from numpy.fliplr.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Flip the entries in each row in the left/right direction.
Columns are preserved, but appear in a different order than before.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>m</strong><span class="classifier">array_like</span></dt><dd><p>Input array, must be at least 2-D.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">ndarray</span></dt><dd><p>A view of <cite>m</cite> with the columns reversed.  Since a view
is returned, this operation is <span class="math notranslate nohighlight">\(\mathcal O(1)\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.flipud" title="dask.array.flipud"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flipud</span></code></a></dt><dd><p>Flip array in the up/down direction.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">rot90</span></code></dt><dd><p>Rotate array counterclockwise.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Equivalent to m[:,::-1]. Requires the array to be at least 2-D.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>  
<span class="go">array([[1.,  0.,  0.],</span>
<span class="go">       [0.,  2.,  0.],</span>
<span class="go">       [0.,  0.,  3.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  
<span class="go">array([[0.,  0.,  1.],</span>
<span class="go">       [0.,  2.,  0.],</span>
<span class="go">       [3.,  0.,  0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span><span class="p">[:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>  
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.floor">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">floor</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.floor.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the floor of the input, element-wise.</p>
<p>The floor of the scalar <cite>x</cite> is the largest integer <cite>i</cite>, such that
<cite>i &lt;= x</cite>.  It is often denoted as <span class="math notranslate nohighlight">\(\lfloor x \rfloor\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The floor of each element in <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.ceil" title="dask.array.ceil"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceil</span></code></a>, <a class="reference internal" href="#dask.array.trunc" title="dask.array.trunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trunc</span></code></a>, <a class="reference internal" href="#dask.array.rint" title="dask.array.rint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rint</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Some spreadsheet programs calculate the “floor-towards-zero”, in other
words <code class="docutils literal notranslate"><span class="pre">floor(-2.5)</span> <span class="pre">==</span> <span class="pre">-2</span></code>.  NumPy instead uses the definition of
<cite>floor</cite> where <cite>floor(-2.5) == -3</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">array([-2., -2., -1.,  0.,  1.,  1.,  2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fmax">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">fmax</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fmax" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.fmax.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Element-wise maximum of array elements.</p>
<p>Compare two arrays and returns a new array containing the element-wise
maxima. If one of the elements being compared is a NaN, then the
non-nan element is returned. If both elements are NaNs then the first
is returned.  The latter distinction is important for complex NaNs,
which are defined as at least one of the real or imaginary parts being
a NaN. The net effect is that NaNs are ignored when possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>The arrays holding the elements to be compared. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The maximum of <cite>x1</cite> and <cite>x2</cite>, element-wise.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.fmin" title="dask.array.fmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmin</span></code></a></dt><dd><p>Element-wise minimum of two arrays, ignores NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.maximum" title="dask.array.maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum</span></code></a></dt><dd><p>Element-wise maximum of two arrays, propagates NaNs.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">amax</span></code></dt><dd><p>The maximum value of an array along a given axis, propagates NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.nanmax" title="dask.array.nanmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmax</span></code></a></dt><dd><p>The maximum value of an array along a given axis, ignores NaNs.</p>
</dd>
</dl>
<p><a class="reference internal" href="#dask.array.minimum" title="dask.array.minimum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">amin</span></code>, <a class="reference internal" href="#dask.array.nanmin" title="dask.array.nanmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmin</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p>The fmax is equivalent to <code class="docutils literal notranslate"><span class="pre">np.where(x1</span> <span class="pre">&gt;=</span> <span class="pre">x2,</span> <span class="pre">x1,</span> <span class="pre">x2)</span></code> when neither
x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="go">array([ 2.,  5.,  4.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="go">array([[ 1. ,  2. ],</span>
<span class="go">       [ 0.5,  2. ]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="go">array([ 0.,  0., nan])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fmin">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">fmin</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fmin" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.fmin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Element-wise minimum of array elements.</p>
<p>Compare two arrays and returns a new array containing the element-wise
minima. If one of the elements being compared is a NaN, then the
non-nan element is returned. If both elements are NaNs then the first
is returned.  The latter distinction is important for complex NaNs,
which are defined as at least one of the real or imaginary parts being
a NaN. The net effect is that NaNs are ignored when possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>The arrays holding the elements to be compared. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The minimum of <cite>x1</cite> and <cite>x2</cite>, element-wise.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.fmax" title="dask.array.fmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmax</span></code></a></dt><dd><p>Element-wise maximum of two arrays, ignores NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.minimum" title="dask.array.minimum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum</span></code></a></dt><dd><p>Element-wise minimum of two arrays, propagates NaNs.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">amin</span></code></dt><dd><p>The minimum value of an array along a given axis, propagates NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.nanmin" title="dask.array.nanmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmin</span></code></a></dt><dd><p>The minimum value of an array along a given axis, ignores NaNs.</p>
</dd>
</dl>
<p><a class="reference internal" href="#dask.array.maximum" title="dask.array.maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">amax</span></code>, <a class="reference internal" href="#dask.array.nanmax" title="dask.array.nanmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmax</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p>The fmin is equivalent to <code class="docutils literal notranslate"><span class="pre">np.where(x1</span> <span class="pre">&lt;=</span> <span class="pre">x2,</span> <span class="pre">x1,</span> <span class="pre">x2)</span></code> when neither
x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fmin</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="go">array([1, 3, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="go">array([[ 0.5,  0. ],</span>
<span class="go">       [ 0. ,  1. ]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fmin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="go">array([ 0.,  0., nan])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fmod">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">fmod</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fmod" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.fmod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the element-wise remainder of division.</p>
<p>This is the NumPy implementation of the C library function fmod, the
remainder has the same sign as the dividend <cite>x1</cite>. It is equivalent to
the Matlab(TM) <code class="docutils literal notranslate"><span class="pre">rem</span></code> function and should not be confused with the
Python modulus operator <code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">%</span> <span class="pre">x2</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1</strong><span class="classifier">array_like</span></dt><dd><p>Dividend.</p>
</dd>
<dt><strong>x2</strong><span class="classifier">array_like</span></dt><dd><p>Divisor. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>The remainder of the division of <cite>x1</cite> by <cite>x2</cite>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">remainder</span></code></dt><dd><p>Equivalent to the Python <code class="docutils literal notranslate"><span class="pre">%</span></code> operator.</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">divide</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The result of the modulo operation for negative dividend and divisors
is bound by conventions. For <cite>fmod</cite>, the sign of result is the sign of
the dividend, while for <cite>remainder</cite> the sign of the result is the sign
of the divisor. The <cite>fmod</cite> function is equivalent to the Matlab(TM)
<code class="docutils literal notranslate"><span class="pre">rem</span></code> function.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fmod</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">array([-1,  0, -1,  1,  0,  1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">array([1, 0, 1, 1, 0, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fmod</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span>  
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[-3, -2],</span>
<span class="go">       [-1,  0],</span>
<span class="go">       [ 1,  2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>  
<span class="go">array([[-1,  0],</span>
<span class="go">       [-1,  0],</span>
<span class="go">       [ 1,  0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.frexp">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">frexp</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <span class="optional">[</span><em class="sig-param">out1</em>, <em class="sig-param">out2</em>, <span class="optional">]</span><em class="sig-param">/</em>, <span class="optional">[</span><em class="sig-param">out=(None</em>, <em class="sig-param">None)</em>, <span class="optional">]</span><em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.frexp" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.frexp.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Decompose the elements of x into mantissa and twos exponent.</p>
<p>Returns (<cite>mantissa</cite>, <cite>exponent</cite>), where <cite>x = mantissa * 2**exponent`</cite>.
The mantissa is lies in the open interval(-1, 1), while the twos
exponent is a signed integer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Array of numbers to be decomposed.</p>
</dd>
<dt><strong>out1</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Output array for the mantissa. Must have the same shape as <cite>x</cite>.</p>
</dd>
<dt><strong>out2</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Output array for the exponent. Must have the same shape as <cite>x</cite>.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mantissa</strong><span class="classifier">ndarray</span></dt><dd><p>Floating values between -1 and 1.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt><strong>exponent</strong><span class="classifier">ndarray</span></dt><dd><p>Integer exponents of 2.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ldexp" title="dask.array.ldexp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ldexp</span></code></a></dt><dd><p>Compute <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">x1</span> <span class="pre">*</span> <span class="pre">2**x2</span></code>, the inverse of <cite>frexp</cite>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Complex dtypes are not supported, they will raise a TypeError.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frexp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y1</span>  
<span class="go">array([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,</span>
<span class="go">        0.5  ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y2</span>  
<span class="go">array([0, 1, 2, 2, 3, 3, 3, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y1</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">y2</span>  
<span class="go">array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fromfunction">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">fromfunction</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">chunks='auto'</em>, <em class="sig-param">shape=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fromfunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array by executing a function over each coordinate.</p>
<p>This docstring was copied from numpy.fromfunction.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The resulting array therefore has a value <code class="docutils literal notranslate"><span class="pre">fn(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> at
coordinate <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable  (Not supported in Dask)</span></dt><dd><p>The function is called with N parameters, where N is the rank of
<cite>shape</cite>.  Each parameter represents the coordinates of the array
varying along a specific axis.  For example, if <cite>shape</cite>
were <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">2)</span></code>, then the parameters would be
<code class="docutils literal notranslate"><span class="pre">array([[0,</span> <span class="pre">0],</span> <span class="pre">[1,</span> <span class="pre">1]])</span></code> and <code class="docutils literal notranslate"><span class="pre">array([[0,</span> <span class="pre">1],</span> <span class="pre">[0,</span> <span class="pre">1]])</span></code></p>
</dd>
<dt><strong>shape</strong><span class="classifier">(N,) tuple of ints</span></dt><dd><p>Shape of the output array, which also determines the shape of
the coordinate arrays passed to <cite>function</cite>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Data-type of the coordinate arrays passed to <cite>function</cite>.
By default, <cite>dtype</cite> is float.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fromfunction</strong><span class="classifier">any</span></dt><dd><p>The result of the call to <cite>function</cite> is passed back directly.
Therefore the shape of <cite>fromfunction</cite> is completely determined by
<cite>function</cite>.  If <cite>function</cite> returns a scalar value, the shape of
<cite>fromfunction</cite> would not match the <cite>shape</cite> parameter.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.indices" title="dask.array.indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">indices</span></code></a>, <a class="reference internal" href="#dask.array.meshgrid" title="dask.array.meshgrid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">meshgrid</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Keywords other than <cite>dtype</cite> are passed to <cite>function</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  
<span class="go">array([[ True, False, False],</span>
<span class="go">       [False,  True, False],</span>
<span class="go">       [False, False,  True]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [1, 2, 3],</span>
<span class="go">       [2, 3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.frompyfunc">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">frompyfunc</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">nin</em>, <em class="sig-param">nout</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.frompyfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.frompyfunc.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Takes an arbitrary Python function and returns a NumPy ufunc.</p>
<p>Can be used, for example, to add broadcasting to a built-in Python
function (see Examples section).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">Python function object</span></dt><dd><p>An arbitrary Python function.</p>
</dd>
<dt><strong>nin</strong><span class="classifier">int</span></dt><dd><p>The number of input arguments.</p>
</dd>
<dt><strong>nout</strong><span class="classifier">int</span></dt><dd><p>The number of objects returned by <cite>func</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ufunc</span></dt><dd><p>Returns a NumPy universal function (<code class="docutils literal notranslate"><span class="pre">ufunc</span></code>) object.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vectorize</span></code></dt><dd><p>Evaluates pyfunc over input arrays using broadcasting rules of numpy.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The returned ufunc always returns PyObject arrays.</p>
<p class="rubric">Examples</p>
<p>Use frompyfunc to add broadcasting to the Python function <code class="docutils literal notranslate"><span class="pre">oct</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oct_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span><span class="nb">oct</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">oct_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">100</span><span class="p">)))</span>  
<span class="go">array([&#39;0o12&#39;, &#39;0o36&#39;, &#39;0o144&#39;], dtype=object)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="nb">oct</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="nb">oct</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="nb">oct</span><span class="p">(</span><span class="mi">100</span><span class="p">)))</span> <span class="c1"># for comparison  </span>
<span class="go">array([&#39;0o12&#39;, &#39;0o36&#39;, &#39;0o144&#39;], dtype=&#39;&lt;U5&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.full">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">full</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocked variant of full</p>
<p>Follows the signature of full exactly except that it also requires a
keyword argument chunks=(…)</p>
<p>Original signature follows below.</p>
<p>Return a new array of given shape and type, filled with <cite>fill_value</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">int or sequence of ints</span></dt><dd><p>Shape of the new array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">scalar</span></dt><dd><p>Fill value.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><dl class="simple">
<dt>The desired data-type for the array  The default, None, means</dt><dd><p><cite>np.array(fill_value).dtype</cite>.</p>
</dd>
</dl>
</dd>
<dt><strong>order</strong><span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Whether to store multidimensional data in C- or Fortran-contiguous
(row- or column-wise) order in memory.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of <cite>fill_value</cite> with the given shape, dtype, and order.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.full_like" title="dask.array.full_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full_like</span></code></a></dt><dd><p>Return a new array with shape of input filled with value.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.empty" title="dask.array.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a></dt><dd><p>Return a new uninitialized array.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ones" title="dask.array.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a></dt><dd><p>Return a new array setting values to one.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.zeros" title="dask.array.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a></dt><dd><p>Return a new array setting values to zero.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">array([[inf, inf],</span>
<span class="go">       [inf, inf]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">array([[10, 10],</span>
<span class="go">       [10, 10]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.full_like">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">full_like</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">fill_value</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">chunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.full_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a full array with the same shape and type as a given array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>The shape and data-type of <cite>a</cite> define these same attributes of
the returned array.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">scalar</span></dt><dd><p>Fill value.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Overrides the data type of the result.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">sequence of ints</span></dt><dd><p>The number of samples on each block. Note that the last block will have
fewer samples if <code class="docutils literal notranslate"><span class="pre">len(array)</span> <span class="pre">%</span> <span class="pre">chunks</span> <span class="pre">!=</span> <span class="pre">0</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of <cite>fill_value</cite> with the same shape and type as <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.zeros_like" title="dask.array.zeros_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros_like</span></code></a></dt><dd><p>Return an array of zeros with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ones_like" title="dask.array.ones_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones_like</span></code></a></dt><dd><p>Return an array of ones with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.empty_like" title="dask.array.empty_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty_like</span></code></a></dt><dd><p>Return an empty array with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.zeros" title="dask.array.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a></dt><dd><p>Return a new array setting values to zero.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ones" title="dask.array.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a></dt><dd><p>Return a new array setting values to one.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.empty" title="dask.array.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a></dt><dd><p>Return a new uninitialized array.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.full" title="dask.array.full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code></a></dt><dd><p>Fill a new array.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.gradient">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">f</em>, <em class="sig-param">*varargs</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the gradient of an N-dimensional array.</p>
<p>This docstring was copied from numpy.gradient.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The gradient is computed using second order accurate central differences
in the interior points and either first or second order accurate one-sides
(forward or backwards) differences at the boundaries.
The returned gradient hence has the same shape as the input array.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f</strong><span class="classifier">array_like</span></dt><dd><p>An N-dimensional array containing samples of a scalar function.</p>
</dd>
<dt><strong>varargs</strong><span class="classifier">list of scalar or array, optional</span></dt><dd><p>Spacing between f values. Default unitary spacing for all dimensions.
Spacing can be specified using:</p>
<ol class="arabic simple">
<li><p>single scalar to specify a sample distance for all dimensions.</p></li>
<li><p>N scalars to specify a constant sample distance for each dimension.
i.e. <cite>dx</cite>, <cite>dy</cite>, <cite>dz</cite>, …</p></li>
<li><p>N arrays to specify the coordinates of the values along each
dimension of F. The length of the array must match the size of
the corresponding dimension</p></li>
<li><p>Any combination of N scalars/arrays with the meaning of 2. and 3.</p></li>
</ol>
<p>If <cite>axis</cite> is given, the number of varargs must equal the number of axes.
Default: 1.</p>
</dd>
<dt><strong>edge_order</strong><span class="classifier">{1, 2}, optional</span></dt><dd><p>Gradient is calculated using N-th order accurate differences
at the boundaries. Default: 1.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.1.</span></p>
</div>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Gradient is calculated only along the given axis or axes
The default (axis = None) is to calculate the gradient for all the axes
of the input array. axis may be negative, in which case it counts from
the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.11.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gradient</strong><span class="classifier">ndarray or list of ndarray</span></dt><dd><p>A set of ndarrays (or a single ndarray if there is only one dimension)
corresponding to the derivatives of f with respect to each dimension.
Each derivative has the same shape as f.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Assuming that <span class="math notranslate nohighlight">\(f\in C^{3}\)</span> (i.e., <span class="math notranslate nohighlight">\(f\)</span> has at least 3 continuous
derivatives) and let <span class="math notranslate nohighlight">\(h_{*}\)</span> be a non-homogeneous stepsize, we
minimize the “consistency error” <span class="math notranslate nohighlight">\(\eta_{i}\)</span> between the true gradient
and its estimate from a linear combination of the neighboring grid-points:</p>
<div class="math notranslate nohighlight">
\[\eta_{i} = f_{i}^{\left(1\right)} -
            \left[ \alpha f\left(x_{i}\right) +
                    \beta f\left(x_{i} + h_{d}\right) +
                    \gamma f\left(x_{i}-h_{s}\right)
            \right]\]</div>
<p>By substituting <span class="math notranslate nohighlight">\(f(x_{i} + h_{d})\)</span> and <span class="math notranslate nohighlight">\(f(x_{i} - h_{s})\)</span>
with their Taylor series expansion, this translates into solving
the following the linear system:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left\{
    \begin{array}{r}
        \alpha+\beta+\gamma=0 \\
        \beta h_{d}-\gamma h_{s}=1 \\
        \beta h_{d}^{2}+\gamma h_{s}^{2}=0
    \end{array}
\right.\end{split}\]</div>
<p>The resulting approximation of <span class="math notranslate nohighlight">\(f_{i}^{(1)}\)</span> is the following:</p>
<div class="math notranslate nohighlight">
\[\hat f_{i}^{(1)} =
    \frac{
        h_{s}^{2}f\left(x_{i} + h_{d}\right)
        + \left(h_{d}^{2} - h_{s}^{2}\right)f\left(x_{i}\right)
        - h_{d}^{2}f\left(x_{i}-h_{s}\right)}
        { h_{s}h_{d}\left(h_{d} + h_{s}\right)}
    + \mathcal{O}\left(\frac{h_{d}h_{s}^{2}
                        + h_{s}h_{d}^{2}}{h_{d}
                        + h_{s}}\right)\]</div>
<p>It is worth noting that if <span class="math notranslate nohighlight">\(h_{s}=h_{d}\)</span>
(i.e., data are evenly spaced)
we find the standard second order approximation:</p>
<div class="math notranslate nohighlight">
\[\hat f_{i}^{(1)}=
    \frac{f\left(x_{i+1}\right) - f\left(x_{i-1}\right)}{2h}
    + \mathcal{O}\left(h^{2}\right)\]</div>
<p>With a similar procedure the forward/backward approximations used for
boundaries can be derived.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1caaab30ccb3-1"><span class="brackets"><a class="fn-backref" href="#id16">1</a></span></dt>
<dd><p>Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics
(Texts in Applied Mathematics). New York: Springer.</p>
</dd>
<dt class="label" id="r1caaab30ccb3-2"><span class="brackets"><a class="fn-backref" href="#id17">2</a></span></dt>
<dd><p>Durran D. R. (1999) Numerical Methods for Wave Equations
in Geophysical Fluid Dynamics. New York: Springer.</p>
</dd>
<dt class="label" id="r1caaab30ccb3-3"><span class="brackets"><a class="fn-backref" href="#id18">3</a></span></dt>
<dd><p>Fornberg B. (1988) Generation of Finite Difference Formulas on
Arbitrarily Spaced Grids,
Mathematics of Computation 51, no. 184 : 699-706.
<a class="reference external" href="http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf">PDF</a>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>  
<span class="go">array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])</span>
</pre></div>
</div>
<p>Spacing can be also specified with an array that represents the coordinates
of the values F along the dimensions.
For instance a uniform spacing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>  
<span class="go">array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])</span>
</pre></div>
</div>
<p>Or a non uniform one:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>  
<span class="go">array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])</span>
</pre></div>
</div>
<p>For two dimensional arrays, the return will be two arrays ordered by
axis. In this example the first array stands for the gradient in
rows and the second one in columns direction:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>  
<span class="go">[array([[ 2.,  2., -1.],</span>
<span class="go">       [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],</span>
<span class="go">       [1. , 1. , 1. ]])]</span>
</pre></div>
</div>
<p>In this example the spacing is also specified:
uniform for axis=0 and non uniform for axis=1</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dx</span> <span class="o">=</span> <span class="mf">2.</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  
<span class="go">[array([[ 1. ,  1. , -0.5],</span>
<span class="go">       [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],</span>
<span class="go">       [2. , 1.7, 0.5]])]</span>
</pre></div>
</div>
<p>It is possible to specify how boundaries are treated using <cite>edge_order</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([1.,  2.,  4.,  6.,  7.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">array([0., 2., 4., 6., 8.])</span>
</pre></div>
</div>
<p>The <cite>axis</cite> keyword can be used to specify a subset of axes of which the
gradient is calculated</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([[ 2.,  2., -1.],</span>
<span class="go">       [ 2.,  2., -1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.histogram">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">histogram</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">bins=None</em>, <em class="sig-param">range=None</em>, <em class="sig-param">normed=False</em>, <em class="sig-param">weights=None</em>, <em class="sig-param">density=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocked variant of <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html#numpy.histogram" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.histogram()</span></code></a>.</p>
<p>Follows the signature of <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html#numpy.histogram" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.histogram()</span></code></a> exactly with the following
exceptions:</p>
<ul class="simple">
<li><p>Either an iterable specifying the <code class="docutils literal notranslate"><span class="pre">bins</span></code> or the number of <code class="docutils literal notranslate"><span class="pre">bins</span></code>
and a <code class="docutils literal notranslate"><span class="pre">range</span></code> argument is required as computing <code class="docutils literal notranslate"><span class="pre">min</span></code> and <code class="docutils literal notranslate"><span class="pre">max</span></code>
over blocked arrays is an expensive operation that must be performed
explicitly.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weights</span></code> must be a dask.array.Array with the same block structure
as <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Using number of bins and range:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10000</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10000</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bins</span>
<span class="go">array([    0.,  1000.,  2000.,  3000.,  4000.,  5000.,  6000.,  7000.,</span>
<span class="go">        8000.,  9000., 10000.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000])</span>
</pre></div>
</div>
<p>Explicitly specifying the bins:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bins</span>
<span class="go">array([    0,  5000, 10000])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([5000, 5000])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.hstack">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">hstack</code><span class="sig-paren">(</span><em class="sig-param">tup</em>, <em class="sig-param">allow_unknown_chunksizes=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.hstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence horizontally (column wise).</p>
<p>This docstring was copied from numpy.hstack.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This is equivalent to concatenation along the second axis, except for 1-D
arrays where it concatenates along the first axis. Rebuilds arrays divided
by <cite>hsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tup</strong><span class="classifier">sequence of ndarrays</span></dt><dd><p>The arrays must have the same shape along all but the second axis,
except 1-D arrays which can be any length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stacked</strong><span class="classifier">ndarray</span></dt><dd><p>The array formed by stacking the given arrays.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.stack" title="dask.array.stack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack</span></code></a></dt><dd><p>Join a sequence of arrays along a new axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.vstack" title="dask.array.vstack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vstack</span></code></a></dt><dd><p>Stack arrays in sequence vertically (row wise).</p>
</dd>
<dt><a class="reference internal" href="#dask.array.dstack" title="dask.array.dstack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dstack</span></code></a></dt><dd><p>Stack arrays in sequence depth wise (along third axis).</p>
</dd>
<dt><a class="reference internal" href="#dask.array.concatenate" title="dask.array.concatenate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concatenate</span></code></a></dt><dd><p>Join a sequence of arrays along an existing axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">hsplit</span></code></dt><dd><p>Split array along second axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.block" title="dask.array.block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">block</span></code></a></dt><dd><p>Assemble arrays from blocks.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>  
<span class="go">array([1, 2, 3, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>  
<span class="go">array([[1, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.hypot">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">hypot</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.hypot" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.hypot.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Given the “legs” of a right triangle, return its hypotenuse.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">sqrt(x1**2</span> <span class="pre">+</span> <span class="pre">x2**2)</span></code>, element-wise.  If <cite>x1</cite> or
<cite>x2</cite> is scalar_like (i.e., unambiguously cast-able to a scalar type),
it is broadcast for use with each element of the other argument.
(See Examples)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>Leg of the triangle(s). If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">ndarray</span></dt><dd><p>The hypotenuse of the triangle(s).
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>  
<span class="go">array([[ 5.,  5.,  5.],</span>
<span class="go">       [ 5.,  5.,  5.],</span>
<span class="go">       [ 5.,  5.,  5.]])</span>
</pre></div>
</div>
<p>Example showing broadcast of scalar_like argument:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="p">[</span><span class="mi">4</span><span class="p">])</span>  
<span class="go">array([[ 5.,  5.,  5.],</span>
<span class="go">       [ 5.,  5.,  5.],</span>
<span class="go">       [ 5.,  5.,  5.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.imag">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">imag</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imaginary part of the complex argument.</p>
<p>This docstring was copied from numpy.imag.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>val</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The imaginary component of the complex argument. If <cite>val</cite> is real,
the type of <cite>val</cite> is used for the output.  If <cite>val</cite> has complex
elements, the returned type is float.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.real" title="dask.array.real"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real</span></code></a>, <a class="reference internal" href="#dask.array.angle" title="dask.array.angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">real_if_close</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">,</span> <span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">imag</span>  
<span class="go">array([2.,  4.,  6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([1. +8.j,  3.+10.j,  5.+12.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>  
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.indices">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">indices</code><span class="sig-paren">(</span><em class="sig-param">dimensions</em>, <em class="sig-param">dtype=&lt;class 'int'&gt;</em>, <em class="sig-param">chunks='auto'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements NumPy’s <code class="docutils literal notranslate"><span class="pre">indices</span></code> for Dask Arrays.</p>
<p>Generates a grid of indices covering the dimensions provided.</p>
<p>The final array has the shape <code class="docutils literal notranslate"><span class="pre">(len(dimensions),</span> <span class="pre">*dimensions)</span></code>. The
chunks are used to specify the chunking for axis 1 up to
<code class="docutils literal notranslate"><span class="pre">len(dimensions)</span></code>. The 0th axis always has chunks of length 1.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>dimensions</strong><span class="classifier">sequence of ints</span></dt><dd><p>The shape of the index grid.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Type to use for the array. Default is <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">sequence of ints, str</span></dt><dd><p>The size of each block.  Must be one of the following forms:</p>
<ul class="simple">
<li><p>A blocksize like (500, 1000)</p></li>
<li><p>A size in bytes, like “100 MiB” which will choose a uniform
block-like shape</p></li>
<li><p>The word “auto” which acts like the above, but uses a configuration
value <code class="docutils literal notranslate"><span class="pre">array.chunk-size</span></code> for the chunk size</p></li>
</ul>
<p>Note that the last block will have fewer samples if <code class="docutils literal notranslate"><span class="pre">len(array)</span> <span class="pre">%</span> <span class="pre">chunks</span> <span class="pre">!=</span> <span class="pre">0</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>grid</strong><span class="classifier">dask array</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.array.insert">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">insert</code><span class="sig-paren">(</span><em class="sig-param">arr</em>, <em class="sig-param">obj</em>, <em class="sig-param">values</em>, <em class="sig-param">axis</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert values along the given axis before the given indices.</p>
<p>This docstring was copied from numpy.insert.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>arr</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>obj</strong><span class="classifier">int, slice or sequence of ints</span></dt><dd><p>Object that defines the index or indices before which <cite>values</cite> is
inserted.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<p>Support for multiple insertions when <cite>obj</cite> is a single scalar or a
sequence with one element (similar to calling insert multiple
times).</p>
</dd>
<dt><strong>values</strong><span class="classifier">array_like</span></dt><dd><p>Values to insert into <cite>arr</cite>. If the type of <cite>values</cite> is different
from that of <cite>arr</cite>, <cite>values</cite> is converted to the type of <cite>arr</cite>.
<cite>values</cite> should be shaped so that <code class="docutils literal notranslate"><span class="pre">arr[...,obj,...]</span> <span class="pre">=</span> <span class="pre">values</span></code>
is legal.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which to insert <cite>values</cite>.  If <cite>axis</cite> is None then <cite>arr</cite>
is flattened first.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>A copy of <cite>arr</cite> with <cite>values</cite> inserted.  Note that <cite>insert</cite>
does not occur in-place: a new array is returned. If
<cite>axis</cite> is None, <cite>out</cite> is a flattened array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></dt><dd><p>Append elements at the end of an array.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.concatenate" title="dask.array.concatenate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concatenate</span></code></a></dt><dd><p>Join a sequence of arrays along an existing axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete</span></code></dt><dd><p>Delete elements from an array.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Note that for higher dimensional inserts <cite>obj=0</cite> behaves very different
from <cite>obj=[0]</cite> just like <cite>arr[:,0,:] = values</cite> is different from
<cite>arr[:,[0],:] = values</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[1, 1],</span>
<span class="go">       [2, 2],</span>
<span class="go">       [3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  
<span class="go">array([1, 5, 1, ..., 2, 3, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[1, 5, 1],</span>
<span class="go">       [2, 5, 2],</span>
<span class="go">       [3, 5, 3]])</span>
</pre></div>
</div>
<p>Difference between sequence and scalars:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[1, 1, 1],</span>
<span class="go">       [2, 2, 2],</span>
<span class="go">       [3, 3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>  
<span class="gp">... </span>               <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">array([1, 1, 2, 2, 3, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>  
<span class="go">array([1, 1, 5, ..., 2, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>  
<span class="go">array([1, 1, 5, ..., 2, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">7.13</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span> <span class="c1"># type casting  </span>
<span class="go">array([1, 1, 7, ..., 2, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[  0, 999,   1,   2, 999,   3],</span>
<span class="go">       [  4, 999,   5,   6, 999,   7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.invert">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">invert</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.invert.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute bit-wise inversion, or bit-wise NOT, element-wise.</p>
<p>Computes the bit-wise NOT of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator <code class="docutils literal notranslate"><span class="pre">~</span></code>.</p>
<p>For signed integer inputs, the two’s complement is returned.  In a
two’s-complement system negative numbers are represented by the two’s
complement of the absolute value. This is the most common method of
representing signed integers on computers <a class="reference internal" href="#r046109bd3458-1" id="id19">[1]</a>. A N-bit
two’s-complement system can represent every integer in the range
<span class="math notranslate nohighlight">\(-2^{N-1}\)</span> to <span class="math notranslate nohighlight">\(+2^{N-1}-1\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Only integer and boolean types are handled.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Result.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.bitwise_and" title="dask.array.bitwise_and"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_and</span></code></a>, <a class="reference internal" href="#dask.array.bitwise_or" title="dask.array.bitwise_or"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_or</span></code></a>, <a class="reference internal" href="#dask.array.bitwise_xor" title="dask.array.bitwise_xor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_xor</span></code></a>, <a class="reference internal" href="#dask.array.logical_not" title="dask.array.logical_not"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_not</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_repr</span></code></dt><dd><p>Return the binary representation of the input number as a string.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><cite>bitwise_not</cite> is an alias for <cite>invert</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span>  
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r046109bd3458-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id19">1</a>,<a href="#id20">2</a>)</span></dt>
<dd><p>Wikipedia, “Two’s complement”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Two's_complement">https://en.wikipedia.org/wiki/Two’s_complement</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We’ve seen that 13 is represented by <code class="docutils literal notranslate"><span class="pre">00001101</span></code>.
The invert or bit-wise NOT of 13 is then:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">242</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>  
<span class="go">&#39;11110010&#39;</span>
</pre></div>
</div>
<p>The result depends on the bit-width:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">65522</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>  
<span class="go">&#39;1111111111110010&#39;</span>
</pre></div>
</div>
<p>When using signed integer types the result is the two’s complement of
the result for the unsigned type:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">13</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">))</span>  
<span class="go">array([-14], dtype=int8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="o">-</span><span class="mi">14</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>  
<span class="go">&#39;11110010&#39;</span>
</pre></div>
</div>
<p>Booleans are accepted as well:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]))</span>  
<span class="go">array([False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.isclose">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">isclose</code><span class="sig-paren">(</span><em class="sig-param">arr1</em>, <em class="sig-param">arr2</em>, <em class="sig-param">rtol=1e-05</em>, <em class="sig-param">atol=1e-08</em>, <em class="sig-param">equal_nan=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.isclose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean array where two arrays are element-wise equal within a
tolerance.</p>
<p>This docstring was copied from numpy.isclose.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The tolerance values are positive, typically very small numbers.  The
relative difference (<cite>rtol</cite> * abs(<cite>b</cite>)) and the absolute difference
<cite>atol</cite> are added together to compare against the absolute difference
between <cite>a</cite> and <cite>b</cite>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The default <cite>atol</cite> is not appropriate for comparing numbers
that are much smaller than one (see Notes).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a, b</strong><span class="classifier">array_like</span></dt><dd><p>Input arrays to compare.</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">float</span></dt><dd><p>The relative tolerance parameter (see Notes).</p>
</dd>
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>The absolute tolerance parameter (see Notes).</p>
</dd>
<dt><strong>equal_nan</strong><span class="classifier">bool</span></dt><dd><p>Whether to compare NaN’s as equal.  If True, NaN’s in <cite>a</cite> will be
considered equal to NaN’s in <cite>b</cite> in the output array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>Returns a boolean array of where <cite>a</cite> and <cite>b</cite> are equal within the
given tolerance. If both <cite>a</cite> and <cite>b</cite> are scalars, returns a single
boolean value.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.allclose" title="dask.array.allclose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">allclose</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>For finite values, isclose uses the following equation to test whether
two floating point values are equivalent.</p>
<blockquote>
<div><p>absolute(<cite>a</cite> - <cite>b</cite>) &lt;= (<cite>atol</cite> + <cite>rtol</cite> * absolute(<cite>b</cite>))</p>
</div></blockquote>
<p>Unlike the built-in <cite>math.isclose</cite>, the above equation is not symmetric
in <cite>a</cite> and <cite>b</cite> – it assumes <cite>b</cite> is the reference value – so that
<cite>isclose(a, b)</cite> might be different from <cite>isclose(b, a)</cite>. Furthermore,
the default value of atol is not zero, and is used to determine what
small values should be considered close to zero. The default value is
appropriate for expected values of order unity: if the expected values
are significantly smaller than one, it can result in false positives.
<cite>atol</cite> should be carefully selected for the use case at hand. A zero value
for <cite>atol</cite> will result in <cite>False</cite> if either <cite>a</cite> or <cite>b</cite> is zero.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">])</span>  
<span class="go">array([ True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>  
<span class="go">array([ True, True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>  
<span class="go">array([False,  True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="go">array([ True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">array([ True, True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-8</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>  
<span class="go">array([ True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-100</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>  
<span class="go">array([False, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">],</span> <span class="p">[</span><span class="mf">1e-20</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>  
<span class="go">array([ True,  True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">],</span> <span class="p">[</span><span class="mf">1e-20</span><span class="p">,</span> <span class="mf">0.999999e-10</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>  
<span class="go">array([False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.iscomplex">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">iscomplex</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.iscomplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bool array, where True if input element is complex.</p>
<p>This docstring was copied from numpy.iscomplex.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>What is tested is whether the input has a non-zero imaginary part, not if
the input type is complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of bools</span></dt><dd><p>Output array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.isreal" title="dask.array.isreal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isreal</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">iscomplexobj</span></code></dt><dd><p>Return True if x is a complex type or an array of complex numbers.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="n">j</span><span class="p">])</span>  
<span class="go">array([ True, False, False, False, False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.isfinite">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">isfinite</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.isfinite" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.isfinite.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Test element-wise for finiteness (not infinity or not Not a Number).</p>
<p>The result is returned as a boolean array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input values.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray, bool</span></dt><dd><p>True where <code class="docutils literal notranslate"><span class="pre">x</span></code> is not positive infinity, negative infinity,
or NaN; false otherwise.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.isinf" title="dask.array.isinf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinf</span></code></a>, <a class="reference internal" href="#dask.array.isneginf" title="dask.array.isneginf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isneginf</span></code></a>, <a class="reference internal" href="#dask.array.isposinf" title="dask.array.isposinf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isposinf</span></code></a>, <a class="reference internal" href="#dask.array.isnan" title="dask.array.isnan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnan</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Not a Number, positive infinity and negative infinity are considered
to be non-finite.</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Also that positive infinity is not equivalent to negative infinity. But
infinity is equivalent to positive infinity.  Errors result if the
second argument is also supplied when <cite>x</cite> is a scalar input, or if
first and second arguments have different shapes.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">)</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>  
<span class="go">array([False,  True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  
<span class="go">array([0, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>  
<span class="go">array([0, 1, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.isin">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">isin</code><span class="sig-paren">(</span><em class="sig-param">element</em>, <em class="sig-param">test_elements</em>, <em class="sig-param">assume_unique=False</em>, <em class="sig-param">invert=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.isin" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <cite>element in test_elements</cite>, broadcasting over <cite>element</cite> only.
Returns a boolean array of the same shape as <cite>element</cite> that is True
where an element of <cite>element</cite> is in <cite>test_elements</cite> and False otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>element</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>test_elements</strong><span class="classifier">array_like</span></dt><dd><p>The values against which to test each value of <cite>element</cite>.
This argument is flattened if it is an array or array_like.
See notes for behavior with non-array-like parameters.</p>
</dd>
<dt><strong>assume_unique</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the input arrays are both assumed to be unique, which
can speed up the calculation.  Default is False.</p>
</dd>
<dt><strong>invert</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the values in the returned array are inverted, as if
calculating <cite>element not in test_elements</cite>. Default is False.
<code class="docutils literal notranslate"><span class="pre">np.isin(a,</span> <span class="pre">b,</span> <span class="pre">invert=True)</span></code> is equivalent to (but faster
than) <code class="docutils literal notranslate"><span class="pre">np.invert(np.isin(a,</span> <span class="pre">b))</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>isin</strong><span class="classifier">ndarray, bool</span></dt><dd><p>Has the same shape as <cite>element</cite>. The values <cite>element[isin]</cite>
are in <cite>test_elements</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">in1d</span></code></dt><dd><p>Flattened version of this function.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.lib.arraysetops</span></code></dt><dd><p>Module with a number of other functions for performing set operations on arrays.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><cite>isin</cite> is an element-wise function version of the python keyword <cite>in</cite>.
<code class="docutils literal notranslate"><span class="pre">isin(a,</span> <span class="pre">b)</span></code> is roughly equivalent to
<code class="docutils literal notranslate"><span class="pre">np.array([item</span> <span class="pre">in</span> <span class="pre">b</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">a])</span></code> if <cite>a</cite> and <cite>b</cite> are 1-D sequences.</p>
<p><cite>element</cite> and <cite>test_elements</cite> are converted to arrays if they are not
already. If <cite>test_elements</cite> is a set (or other non-sequence collection)
it will be converted to an object array with one element, rather than an
array of the values contained in <cite>test_elements</cite>. This is a consequence
of the <cite>array</cite> constructor’s way of handling non-sequence collections.
Converting the set to a list usually gives the desired behavior.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.0.</span></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">element</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [4, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_elements</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_elements</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([[False,  True],</span>
<span class="go">       [ True, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([2, 4])</span>
</pre></div>
</div>
<p>The indices of the matched values can be obtained with <cite>nonzero</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
<span class="go">(array([0, 1]), array([1, 0]))</span>
</pre></div>
</div>
<p>The test can also be inverted:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_elements</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([[ True, False],</span>
<span class="go">       [False,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([0, 6])</span>
</pre></div>
</div>
<p>Because of how <cite>array</cite> handles sets, the following does not
work as expected:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">test_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_set</span><span class="p">)</span>
<span class="go">array([[False, False],</span>
<span class="go">       [False, False]])</span>
</pre></div>
</div>
<p>Casting the set to a list gives the expected result:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">test_set</span><span class="p">))</span>
<span class="go">array([[False,  True],</span>
<span class="go">       [ True, False]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.isinf">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">isinf</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.isinf" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.isinf.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Test element-wise for positive or negative infinity.</p>
<p>Returns a boolean array of the same shape as <cite>x</cite>, True where <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span>
<span class="pre">+/-inf</span></code>, otherwise False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input values</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">bool (scalar) or boolean ndarray</span></dt><dd><p>True where <code class="docutils literal notranslate"><span class="pre">x</span></code> is positive or negative infinity, false otherwise.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.isneginf" title="dask.array.isneginf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isneginf</span></code></a>, <a class="reference internal" href="#dask.array.isposinf" title="dask.array.isposinf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isposinf</span></code></a>, <a class="reference internal" href="#dask.array.isnan" title="dask.array.isnan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnan</span></code></a>, <a class="reference internal" href="#dask.array.isfinite" title="dask.array.isfinite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfinite</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).</p>
<p>Errors result if the second argument is supplied when the first
argument is a scalar, or if the first and second arguments have
different shapes.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">)</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="go">array([ True,  True, False, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  
<span class="go">array([1, 0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>  
<span class="go">array([1, 0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.isneginf">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">isneginf</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.isneginf" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.equal.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return (x1 == x2) element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>Input arrays. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Output array, element-wise comparison of <cite>x1</cite> and <cite>x2</cite>.
Typically of type bool, unless <code class="docutils literal notranslate"><span class="pre">dtype=object</span></code> is passed.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">not_equal</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">greater_equal</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">less_equal</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">greater</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">less</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  
<span class="go">array([ True,  True, False])</span>
</pre></div>
</div>
<p>What is compared are values, not types. So an int (1) and an array of
length one can evaluate as True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>  
<span class="go">array([ True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.isnan">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">isnan</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.isnan" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.isnan.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Test element-wise for NaN and return result as a boolean array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray or bool</span></dt><dd><p>True where <code class="docutils literal notranslate"><span class="pre">x</span></code> is NaN, false otherwise.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.isinf" title="dask.array.isinf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinf</span></code></a>, <a class="reference internal" href="#dask.array.isneginf" title="dask.array.isneginf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isneginf</span></code></a>, <a class="reference internal" href="#dask.array.isposinf" title="dask.array.isposinf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isposinf</span></code></a>, <a class="reference internal" href="#dask.array.isfinite" title="dask.array.isfinite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfinite</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">isnat</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>  
<span class="go">array([ True, False, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.isnull">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">isnull</code><span class="sig-paren">(</span><em class="sig-param">values</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.isnull" title="Permalink to this definition">¶</a></dt>
<dd><p>pandas.isnull for dask arrays</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.isposinf">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">isposinf</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.isposinf" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.equal.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return (x1 == x2) element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>Input arrays. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Output array, element-wise comparison of <cite>x1</cite> and <cite>x2</cite>.
Typically of type bool, unless <code class="docutils literal notranslate"><span class="pre">dtype=object</span></code> is passed.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">not_equal</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">greater_equal</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">less_equal</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">greater</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">less</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  
<span class="go">array([ True,  True, False])</span>
</pre></div>
</div>
<p>What is compared are values, not types. So an int (1) and an array of
length one can evaluate as True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>  
<span class="go">array([ True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.isreal">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">isreal</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.isreal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bool array, where True if input element is real.</p>
<p>This docstring was copied from numpy.isreal.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>If element has complex type with zero complex part, the return value
for that element is True.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray, bool</span></dt><dd><p>Boolean array of same shape as <cite>x</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.iscomplex" title="dask.array.iscomplex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iscomplex</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">isrealobj</span></code></dt><dd><p>Return True if x is not a complex type.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="n">j</span><span class="p">])</span>  
<span class="go">array([False,  True,  True,  True,  True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ldexp">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">ldexp</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ldexp" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ldexp.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns x1 * 2**x2, element-wise.</p>
<p>The mantissas <cite>x1</cite> and twos exponents <cite>x2</cite> are used to construct
floating point numbers <code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">*</span> <span class="pre">2**x2</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1</strong><span class="classifier">array_like</span></dt><dd><p>Array of multipliers.</p>
</dd>
<dt><strong>x2</strong><span class="classifier">array_like, int</span></dt><dd><p>Array of twos exponents. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The result of <code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">*</span> <span class="pre">2**x2</span></code>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.frexp" title="dask.array.frexp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frexp</span></code></a></dt><dd><p>Return (y1, y2) from <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">y1</span> <span class="pre">*</span> <span class="pre">2**y2</span></code>, inverse to <cite>ldexp</cite>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Complex dtypes are not supported, they will raise a TypeError.</p>
<p><cite>ldexp</cite> is useful as the inverse of <cite>frexp</cite>, if used by itself it is
more clear to simply use the expression <code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">*</span> <span class="pre">2**x2</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ldexp</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>  
<span class="go">array([ 5., 10., 20., 40.], dtype=float16)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ldexp</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">frexp</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  
<span class="go">array([ 0.,  1.,  2.,  3.,  4.,  5.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.linspace">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">linspace</code><span class="sig-paren">(</span><em class="sig-param">start</em>, <em class="sig-param">stop</em>, <em class="sig-param">num=50</em>, <em class="sig-param">endpoint=True</em>, <em class="sig-param">retstep=False</em>, <em class="sig-param">chunks='auto'</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>num</cite> evenly spaced values over the closed interval [<cite>start</cite>,
<cite>stop</cite>].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start</strong><span class="classifier">scalar</span></dt><dd><p>The starting value of the sequence.</p>
</dd>
<dt><strong>stop</strong><span class="classifier">scalar</span></dt><dd><p>The last value of the sequence.</p>
</dd>
<dt><strong>num</strong><span class="classifier">int, optional</span></dt><dd><p>Number of samples to include in the returned dask array, including the
endpoints. Default is 50.</p>
</dd>
<dt><strong>endpoint</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, <code class="docutils literal notranslate"><span class="pre">stop</span></code> is the last sample. Otherwise, it is not included.
Default is True.</p>
</dd>
<dt><strong>retstep</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, return (samples, step), where step is the spacing between
samples. Default is False.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">int</span></dt><dd><p>The number of samples on each block. Note that the last block will have
fewer samples if <cite>num % blocksize != 0</cite></p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>The type of the output array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">dask array</span></dt><dd></dd>
<dt><strong>step</strong><span class="classifier">float, optional</span></dt><dd><p>Only returned if <code class="docutils literal notranslate"><span class="pre">retstep</span></code> is True. Size of spacing between samples.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.arange" title="dask.array.arange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.arange</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.log">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.log" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.log.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Natural logarithm, element-wise.</p>
<p>The natural logarithm <cite>log</cite> is the inverse of the exponential function,
so that <cite>log(exp(x)) = x</cite>. The natural logarithm is logarithm in base
<cite>e</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input value.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The natural logarithm of <cite>x</cite>, element-wise.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.log10" title="dask.array.log10"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log10</span></code></a>, <a class="reference internal" href="#dask.array.log2" title="dask.array.log2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log2</span></code></a>, <a class="reference internal" href="#dask.array.log1p" title="dask.array.log1p"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log1p</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">emath.log</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Logarithm is a multivalued function: for each <cite>x</cite> there is an infinite
number of <cite>z</cite> such that <cite>exp(z) = x</cite>. The convention is to return the
<cite>z</cite> whose imaginary part lies in <cite>[-pi, pi]</cite>.</p>
<p>For real-valued input data types, <cite>log</cite> always returns real output. For
each value that cannot be expressed as a real number or infinity, it
yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>log</cite> is a complex analytical function that
has a branch cut <cite>[-inf, 0]</cite> and is continuous from above on it. <cite>log</cite>
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r180676fcd6e8-1"><span class="brackets"><a class="fn-backref" href="#id21">1</a></span></dt>
<dd><p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 67. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="r180676fcd6e8-2"><span class="brackets"><a class="fn-backref" href="#id22">2</a></span></dt>
<dd><p>Wikipedia, “Logarithm”. <a class="reference external" href="https://en.wikipedia.org/wiki/Logarithm">https://en.wikipedia.org/wiki/Logarithm</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="go">array([  0.,   1.,   2., -Inf])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.log10">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">log10</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.log10" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.log10.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the base 10 logarithm of the input array, element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input values.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The logarithm to the base 10 of <cite>x</cite>, element-wise. NaNs are
returned where x is negative.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">emath.log10</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Logarithm is a multivalued function: for each <cite>x</cite> there is an infinite
number of <cite>z</cite> such that <cite>10**z = x</cite>. The convention is to return the
<cite>z</cite> whose imaginary part lies in <cite>[-pi, pi]</cite>.</p>
<p>For real-valued input data types, <cite>log10</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>log10</cite> is a complex analytical function that
has a branch cut <cite>[-inf, 0]</cite> and is continuous from above on it.
<cite>log10</cite> handles the floating-point negative zero as an infinitesimal
negative number, conforming to the C99 standard.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r66cc1e02625b-1"><span class="brackets"><a class="fn-backref" href="#id23">1</a></span></dt>
<dd><p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 67. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="r66cc1e02625b-2"><span class="brackets"><a class="fn-backref" href="#id24">2</a></span></dt>
<dd><p>Wikipedia, “Logarithm”. <a class="reference external" href="https://en.wikipedia.org/wiki/Logarithm">https://en.wikipedia.org/wiki/Logarithm</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">([</span><span class="mf">1e-15</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">])</span>  
<span class="go">array([-15.,  nan])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.log1p">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">log1p</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.log1p" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.log1p.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the natural logarithm of one plus the input array, element-wise.</p>
<p>Calculates <code class="docutils literal notranslate"><span class="pre">log(1</span> <span class="pre">+</span> <span class="pre">x)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input values.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>Natural logarithm of <cite>1 + x</cite>, element-wise.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.expm1" title="dask.array.expm1"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expm1</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code>, the inverse of <cite>log1p</cite>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For real-valued input, <cite>log1p</cite> is accurate also for <cite>x</cite> so small
that <cite>1 + x == 1</cite> in floating-point accuracy.</p>
<p>Logarithm is a multivalued function: for each <cite>x</cite> there is an infinite
number of <cite>z</cite> such that <cite>exp(z) = 1 + x</cite>. The convention is to return
the <cite>z</cite> whose imaginary part lies in <cite>[-pi, pi]</cite>.</p>
<p>For real-valued input data types, <cite>log1p</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>log1p</cite> is a complex analytical function that
has a branch cut <cite>[-inf, -1]</cite> and is continuous from above on it.
<cite>log1p</cite> handles the floating-point negative zero as an infinitesimal
negative number, conforming to the C99 standard.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r906ced8803b2-1"><span class="brackets"><a class="fn-backref" href="#id25">1</a></span></dt>
<dd><p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 67. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="r906ced8803b2-2"><span class="brackets"><a class="fn-backref" href="#id26">2</a></span></dt>
<dd><p>Wikipedia, “Logarithm”. <a class="reference external" href="https://en.wikipedia.org/wiki/Logarithm">https://en.wikipedia.org/wiki/Logarithm</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="mf">1e-99</span><span class="p">)</span>  
<span class="go">1e-99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-99</span><span class="p">)</span>  
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.log2">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">log2</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.log2" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.log2.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Base-2 logarithm of <cite>x</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input values.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>Base-2 logarithm of <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.log" title="dask.array.log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log</span></code></a>, <a class="reference internal" href="#dask.array.log10" title="dask.array.log10"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log10</span></code></a>, <a class="reference internal" href="#dask.array.log1p" title="dask.array.log1p"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log1p</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">emath.log2</span></code></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p>Logarithm is a multivalued function: for each <cite>x</cite> there is an infinite
number of <cite>z</cite> such that <cite>2**z = x</cite>. The convention is to return the <cite>z</cite>
whose imaginary part lies in <cite>[-pi, pi]</cite>.</p>
<p>For real-valued input data types, <cite>log2</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>log2</cite> is a complex analytical function that
has a branch cut <cite>[-inf, 0]</cite> and is continuous from above on it. <cite>log2</cite>
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">4</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([-Inf,   0.,   1.,   4.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">4.</span><span class="n">j</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>  
<span class="go">array([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.logaddexp">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">logaddexp</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.logaddexp" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.logaddexp.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Logarithm of the sum of exponentiations of the inputs.</p>
<p>Calculates <code class="docutils literal notranslate"><span class="pre">log(exp(x1)</span> <span class="pre">+</span> <span class="pre">exp(x2))</span></code>. This function is useful in
statistics where the calculated probabilities of events may be so small
as to exceed the range of normal floating point numbers.  In such cases
the logarithm of the calculated probability is stored. This function
allows adding probabilities stored in such a fashion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>Input values. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">ndarray</span></dt><dd><p>Logarithm of <code class="docutils literal notranslate"><span class="pre">exp(x1)</span> <span class="pre">+</span> <span class="pre">exp(x2)</span></code>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.logaddexp2" title="dask.array.logaddexp2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logaddexp2</span></code></a></dt><dd><p>Logarithm of the sum of exponentiations of inputs in base 2.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prob1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1e-50</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.5e-50</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logaddexp</span><span class="p">(</span><span class="n">prob1</span><span class="p">,</span> <span class="n">prob2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob12</span>  
<span class="go">-113.87649168120691</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">prob12</span><span class="p">)</span>  
<span class="go">3.5000000000000057e-50</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.logaddexp2">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">logaddexp2</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.logaddexp2" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.logaddexp2.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Logarithm of the sum of exponentiations of the inputs in base-2.</p>
<p>Calculates <code class="docutils literal notranslate"><span class="pre">log2(2**x1</span> <span class="pre">+</span> <span class="pre">2**x2)</span></code>. This function is useful in machine
learning when the calculated probabilities of events may be so small as
to exceed the range of normal floating point numbers.  In such cases
the base-2 logarithm of the calculated probability can be used instead.
This function allows adding probabilities stored in such a fashion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>Input values. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">ndarray</span></dt><dd><p>Base-2 logarithm of <code class="docutils literal notranslate"><span class="pre">2**x1</span> <span class="pre">+</span> <span class="pre">2**x2</span></code>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.logaddexp" title="dask.array.logaddexp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logaddexp</span></code></a></dt><dd><p>Logarithm of the sum of exponentiations of the inputs.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prob1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mf">1e-50</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mf">2.5e-50</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logaddexp2</span><span class="p">(</span><span class="n">prob1</span><span class="p">,</span> <span class="n">prob2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob1</span><span class="p">,</span> <span class="n">prob2</span><span class="p">,</span> <span class="n">prob12</span>  
<span class="go">(-166.09640474436813, -164.77447664948076, -164.28904982231052)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">**</span><span class="n">prob12</span>  
<span class="go">3.4999999999999914e-50</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.logical_and">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">logical_and</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.logical_and" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.logical_and.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute the truth value of x1 AND x2 element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>Input arrays. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray or bool</span></dt><dd><p>Boolean result of the logical AND operation applied to the elements
of <cite>x1</cite> and <cite>x2</cite>; the shape is determined by broadcasting.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.logical_or" title="dask.array.logical_or"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_or</span></code></a>, <a class="reference internal" href="#dask.array.logical_not" title="dask.array.logical_not"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_not</span></code></a>, <a class="reference internal" href="#dask.array.logical_xor" title="dask.array.logical_xor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_xor</span></code></a>, <a class="reference internal" href="#dask.array.bitwise_and" title="dask.array.bitwise_and"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_and</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>  
<span class="go">array([False, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">)</span>  
<span class="go">array([False, False,  True,  True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.logical_not">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">logical_not</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.logical_not" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.logical_not.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute the truth value of NOT x element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Logical NOT is applied to the elements of <cite>x</cite>.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">bool or ndarray of bool</span></dt><dd><p>Boolean result with the same shape as <cite>x</cite> of the NOT operation
on elements of <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.logical_and" title="dask.array.logical_and"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_and</span></code></a>, <a class="reference internal" href="#dask.array.logical_or" title="dask.array.logical_or"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_or</span></code></a>, <a class="reference internal" href="#dask.array.logical_xor" title="dask.array.logical_xor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_xor</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  
<span class="go">array([False,  True,  True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">)</span>  
<span class="go">array([False, False, False,  True,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.logical_or">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">logical_or</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.logical_or" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.logical_or.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute the truth value of x1 OR x2 element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>Logical OR is applied to the elements of <cite>x1</cite> and <cite>x2</cite>.
If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray or bool</span></dt><dd><p>Boolean result of the logical OR operation applied to the elements
of <cite>x1</cite> and <cite>x2</cite>; the shape is determined by broadcasting.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.logical_and" title="dask.array.logical_and"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_and</span></code></a>, <a class="reference internal" href="#dask.array.logical_not" title="dask.array.logical_not"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_not</span></code></a>, <a class="reference internal" href="#dask.array.logical_xor" title="dask.array.logical_xor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_xor</span></code></a>, <a class="reference internal" href="#dask.array.bitwise_or" title="dask.array.bitwise_or"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_or</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>  
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>  
<span class="go">array([ True, False, False, False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.logical_xor">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">logical_xor</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.logical_xor" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.logical_xor.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute the truth value of x1 XOR x2, element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>Logical XOR is applied to the elements of <cite>x1</cite> and <cite>x2</cite>. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">bool or ndarray of bool</span></dt><dd><p>Boolean result of the logical XOR operation applied to the elements
of <cite>x1</cite> and <cite>x2</cite>; the shape is determined by broadcasting.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.logical_and" title="dask.array.logical_and"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_and</span></code></a>, <a class="reference internal" href="#dask.array.logical_or" title="dask.array.logical_or"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_or</span></code></a>, <a class="reference internal" href="#dask.array.logical_not" title="dask.array.logical_not"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logical_not</span></code></a>, <a class="reference internal" href="#dask.array.bitwise_xor" title="dask.array.bitwise_xor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitwise_xor</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>  
<span class="go">array([False,  True,  True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>  
<span class="go">array([ True, False, False, False,  True])</span>
</pre></div>
</div>
<p>Simple example showing support of broadcasting</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>  
<span class="go">array([[ True, False],</span>
<span class="go">       [False,  True]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.map_blocks">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">map_blocks</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">name=None</em>, <em class="sig-param">token=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">chunks=None</em>, <em class="sig-param">drop_axis=[]</em>, <em class="sig-param">new_axis=None</em>, <em class="sig-param">meta=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.map_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a function across all blocks of a dask array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>Function to apply to every block in the array.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dask arrays or other objects</span></dt><dd></dd>
<dt><strong>dtype</strong><span class="classifier">np.dtype, optional</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">dtype</span></code> of the output array. It is recommended to provide this.
If not provided, will be inferred by applying the function to a small
set of fake data.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">tuple, optional</span></dt><dd><p>Chunk shape of resulting blocks if the function does not preserve
shape. If not provided, the resulting array is assumed to have the same
block structure as the first input array.</p>
</dd>
<dt><strong>drop_axis</strong><span class="classifier">number or iterable, optional</span></dt><dd><p>Dimensions lost by the function.</p>
</dd>
<dt><strong>new_axis</strong><span class="classifier">number or iterable, optional</span></dt><dd><p>New dimensions created by the function. Note that these are applied
after <code class="docutils literal notranslate"><span class="pre">drop_axis</span></code> (if present).</p>
</dd>
<dt><strong>token</strong><span class="classifier">string, optional</span></dt><dd><p>The key prefix to use for the output array. If not provided, will be
determined from the function name.</p>
</dd>
<dt><strong>name</strong><span class="classifier">string, optional</span></dt><dd><p>The key name to use for the output array. Note that this fully
specifies the output key name, and must be unique. If not provided,
will be determined by a hash of the arguments.</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Other keyword arguments to pass to function. Values must be constants
(not dask.arrays)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.blockwise" title="dask.array.blockwise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.blockwise</span></code></a></dt><dd><p>Generalized operation with control over block alignment.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([ 0,  2,  4,  6,  8, 10])</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">da.map_blocks</span></code> function can also accept multiple arrays.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([ 0,  2,  6, 12, 20])</span>
</pre></div>
</div>
<p>If the function changes shape of the blocks then you must provide chunks
explicitly.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),))</span>
</pre></div>
</div>
<p>You have a bit of freedom in specifying chunks.  If all of the output chunk
sizes are the same, you can provide just that chunk size as a single tuple.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
</pre></div>
</div>
<p>If the function changes the dimension of the blocks you must specify the
created or destroyed dimensions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="n">new_axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">chunks</span></code> is specified but <code class="docutils literal notranslate"><span class="pre">new_axis</span></code> is not, then it is inferred to
add the necessary number of axes on the left.</p>
<p>Map_blocks aligns blocks by block positions without regard to shape. In the
following example we have two arrays with the same number of blocks but
with different shape and chunk sizes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
</pre></div>
</div>
<p>The relevant attribute to match is numblocks.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">numblocks</span>
<span class="go">(10,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">numblocks</span>
<span class="go">(10,)</span>
</pre></div>
</div>
<p>If these match (up to broadcasting rules) then we can map arbitrary
functions across blocks</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i8&#39;</span><span class="p">)</span>
<span class="go">dask.array&lt;func, shape=(20,), dtype=int64, chunksize=(2,), chunktype=numpy.ndarray&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([ 99,   9, 199,  19, 299,  29, 399,  39, 499,  49, 599,  59, 699,</span>
<span class="go">        69, 799,  79, 899,  89, 999,  99])</span>
</pre></div>
</div>
<p>Your block function get information about where it is in the array by
accepting a special <code class="docutils literal notranslate"><span class="pre">block_info</span></code> keyword argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">block_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
</pre></div>
</div>
<p>This will receive the following information:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_info</span>  
<span class="go">{0: {&#39;shape&#39;: (1000,),</span>
<span class="go">     &#39;num-chunks&#39;: (10,),</span>
<span class="go">     &#39;chunk-location&#39;: (4,),</span>
<span class="go">     &#39;array-location&#39;: [(400, 500)]},</span>
<span class="go"> None: {&#39;shape&#39;: (1000,),</span>
<span class="go">        &#39;num-chunks&#39;: (10,),</span>
<span class="go">        &#39;chunk-location&#39;: (4,),</span>
<span class="go">        &#39;array-location&#39;: [(400, 500)],</span>
<span class="go">        &#39;chunk-shape&#39;: (100,),</span>
<span class="go">        &#39;dtype&#39;: dtype(&#39;float64&#39;)}}</span>
</pre></div>
</div>
<p>For each argument and keyword arguments that are dask arrays (the positions
of which are the first index), you will receive the shape of the full
array, the number of chunks of the full array in each dimension, the chunk
location (for example the fourth chunk over in the first dimension), and
the array location (for example the slice corresponding to <code class="docutils literal notranslate"><span class="pre">40:50</span></code>). The
same information is provided for the output, with the key <code class="docutils literal notranslate"><span class="pre">None</span></code>, plus
the shape and dtype that should be returned.</p>
<p>These features can be combined to synthesize an array from scratch, for
example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">block_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">loc</span> <span class="o">=</span> <span class="n">block_info</span><span class="p">[</span><span class="kc">None</span><span class="p">][</span><span class="s1">&#39;array-location&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
<span class="go">dask.array&lt;func, shape=(8,), dtype=float64, chunksize=(4,), chunktype=numpy.ndarray&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7])</span>
</pre></div>
</div>
<p>You may specify the key name prefix of the resulting task in the graph with
the optional <code class="docutils literal notranslate"><span class="pre">token</span></code> keyword argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;increment&#39;</span><span class="p">)</span>  
<span class="go">dask.array&lt;increment, shape=(100,), dtype=int64, chunksize=(10,), chunktype=numpy.ndarray&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.matmul">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">matmul</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.matmul" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.matmul.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Matrix product of two arrays.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>Input arrays, scalars not allowed.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that matches the signature <cite>(n,k),(k,m)-&gt;(n,m)</cite>. If not
provided or None, a freshly-allocated array is returned.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.16: </span>Now handles ufunc kwargs</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The matrix product of the inputs.
This is a scalar only when both x1, x2 are 1-d vectors.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl>
<dt><strong>ValueError</strong></dt><dd><p>If the last dimension of <cite>a</cite> is not the same size as
the second-to-last dimension of <cite>b</cite>.</p>
<p>If a scalar value is passed in.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.vdot" title="dask.array.vdot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vdot</span></code></a></dt><dd><p>Complex-conjugating dot product.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.tensordot" title="dask.array.tensordot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensordot</span></code></a></dt><dd><p>Sum products over arbitrary axes.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.einsum" title="dask.array.einsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">einsum</span></code></a></dt><dd><p>Einstein summation convention.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.dot" title="dask.array.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code></a></dt><dd><p>alternative matrix product with different broadcasting rules.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The behavior depends on the arguments in the following way.</p>
<ul class="simple">
<li><p>If both arguments are 2-D they are multiplied like conventional
matrices.</p></li>
<li><p>If either argument is N-D, N &gt; 2, it is treated as a stack of
matrices residing in the last two indexes and broadcast accordingly.</p></li>
<li><p>If the first argument is 1-D, it is promoted to a matrix by
prepending a 1 to its dimensions. After matrix multiplication
the prepended 1 is removed.</p></li>
<li><p>If the second argument is 1-D, it is promoted to a matrix by
appending a 1 to its dimensions. After matrix multiplication
the appended 1 is removed.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">matmul</span></code> differs from <code class="docutils literal notranslate"><span class="pre">dot</span></code> in two important ways:</p>
<ul>
<li><p>Multiplication by scalars is not allowed, use <code class="docutils literal notranslate"><span class="pre">*</span></code> instead.</p></li>
<li><p>Stacks of matrices are broadcast together as if the matrices
were elements, respecting the signature <code class="docutils literal notranslate"><span class="pre">(n,k),(k,m)-&gt;(n,m)</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(9, 5, 7, 9, 5, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(9, 5, 7, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n is 7, k is 4, m is 3</span>
</pre></div>
</div>
</li>
</ul>
<p>The matmul function implements the semantics of the <cite>&#64;</cite> operator introduced
in Python 3.5 following PEP465.</p>
<p class="rubric">Examples</p>
<p>For 2-D arrays it is the matrix product:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  
<span class="gp">... </span>              <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([[4, 1],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<p>For 2-D mixed with 1-D, the result is the usual.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">array([1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  
<span class="go">array([1, 2])</span>
</pre></div>
</div>
<p>Broadcasting is conventional for stacks of arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(2, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  
<span class="go">98</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span> <span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">])</span>  
<span class="go">98</span>
</pre></div>
</div>
<p>Vector, vector returns the scalar inner product, but neither argument
is complex-conjugated:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">([</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">])</span>  
<span class="go">(-13+0j)</span>
</pre></div>
</div>
<p>Scalar multiplication raises an error.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">matmul: Input operand 1 does not have enough dimensions ...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.max">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of an array or maximum along an axis.</p>
<p>This docstring was copied from numpy.max.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to operate.  By default, flattened input is
used.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <cite>ufuncs-output-type</cite> for more details.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>amax</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt><strong>initial</strong><span class="classifier">scalar, optional  (Not supported in Dask)</span></dt><dd><p>The minimum value of an output element. Must be present to allow
computation on empty slice. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</dd>
<dt><strong>where</strong><span class="classifier">array_like of bool, optional  (Not supported in Dask)</span></dt><dd><p>Elements to compare for the maximum. See <cite>~numpy.ufunc.reduce</cite>
for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>amax</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Maximum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">amin</span></code></dt><dd><p>The minimum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.nanmax" title="dask.array.nanmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmax</span></code></a></dt><dd><p>The maximum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.maximum" title="dask.array.maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum</span></code></a></dt><dd><p>Element-wise maximum of two arrays, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fmax" title="dask.array.fmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmax</span></code></a></dt><dd><p>Element-wise maximum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.argmax" title="dask.array.argmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax</span></code></a></dt><dd><p>Return the indices of the maximum values.</p>
</dd>
</dl>
<p><a class="reference internal" href="#dask.array.nanmin" title="dask.array.nanmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmin</span></code></a>, <a class="reference internal" href="#dask.array.minimum" title="dask.array.minimum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum</span></code></a>, <a class="reference internal" href="#dask.array.fmin" title="dask.array.fmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmin</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.</p>
<p>Don’t use <cite>amax</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal notranslate"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal notranslate"><span class="pre">maximum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal notranslate"><span class="pre">amax(a,</span> <span class="pre">axis=0)</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Maximum of the flattened array  </span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Maxima along the first axis  </span>
<span class="go">array([2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Maxima along the second axis  </span>
<span class="go">array([1, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">initial</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([-1,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">initial</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="go">4.0</span>
</pre></div>
</div>
<p>You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([ 0, 10])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>  
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>  
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.maximum">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">maximum</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.maximum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Element-wise maximum of array elements.</p>
<p>Compare two arrays and returns a new array containing the element-wise
maxima. If one of the elements being compared is a NaN, then that
element is returned. If both elements are NaNs then the first is
returned. The latter distinction is important for complex NaNs, which
are defined as at least one of the real or imaginary parts being a NaN.
The net effect is that NaNs are propagated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>The arrays holding the elements to be compared. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The maximum of <cite>x1</cite> and <cite>x2</cite>, element-wise.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.minimum" title="dask.array.minimum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum</span></code></a></dt><dd><p>Element-wise minimum of two arrays, propagates NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fmax" title="dask.array.fmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmax</span></code></a></dt><dd><p>Element-wise maximum of two arrays, ignores NaNs.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">amax</span></code></dt><dd><p>The maximum value of an array along a given axis, propagates NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.nanmax" title="dask.array.nanmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmax</span></code></a></dt><dd><p>The maximum value of an array along a given axis, ignores NaNs.</p>
</dd>
</dl>
<p><a class="reference internal" href="#dask.array.fmin" title="dask.array.fmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmin</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">amin</span></code>, <a class="reference internal" href="#dask.array.nanmin" title="dask.array.nanmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmin</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The maximum is equivalent to <code class="docutils literal notranslate"><span class="pre">np.where(x1</span> <span class="pre">&gt;=</span> <span class="pre">x2,</span> <span class="pre">x1,</span> <span class="pre">x2)</span></code> when
neither x1 nor x2 are nans, but it is faster and does proper
broadcasting.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="go">array([2, 5, 4])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="c1"># broadcasting  </span>
<span class="go">array([[ 1. ,  2. ],</span>
<span class="go">       [ 0.5,  2. ]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="go">array([nan, nan, nan])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">Inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  
<span class="go">inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.mean">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the arithmetic mean along the specified axis.</p>
<p>This docstring was copied from numpy.mean.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
<cite>float64</cite> intermediate and return values are used for integer inputs.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose mean is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which the means are computed. The default is to
compute the mean of the flattened array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, a mean is performed over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Type to use in computing the mean.  For integer inputs, the default
is <cite>float64</cite>; for floating point inputs, it is the same as the
input dtype.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary.
See <cite>ufuncs-output-type</cite> for more details.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>mean</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>m</strong><span class="classifier">ndarray, see dtype parameter above</span></dt><dd><p>If <cite>out=None</cite>, returns a new array containing the mean values,
otherwise a reference to the output array is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.average" title="dask.array.average"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average</span></code></a></dt><dd><p>Weighted average</p>
</dd>
</dl>
<p><a class="reference internal" href="#dask.array.std" title="dask.array.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>, <a class="reference internal" href="#dask.array.var" title="dask.array.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>, <a class="reference internal" href="#dask.array.nanmean" title="dask.array.nanmean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmean</span></code></a>, <a class="reference internal" href="#dask.array.nanstd" title="dask.array.nanstd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanstd</span></code></a>, <a class="reference internal" href="#dask.array.nanvar" title="dask.array.nanvar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanvar</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The arithmetic mean is the sum of the elements along the axis divided
by the number of elements.</p>
<p>Note that for floating-point input, the mean is computed using the
same precision the input has.  Depending on the input data, this can
cause the results to be inaccurate, especially for <cite>float32</cite> (see
example below).  Specifying a higher-precision accumulator using the
<cite>dtype</cite> keyword can alleviate this issue.</p>
<p>By default, <cite>float16</cite> results are computed using <cite>float32</cite> intermediates
for extra precision.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([2., 3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([1.5, 3.5])</span>
</pre></div>
</div>
<p>In single precision, <cite>mean</cite> can be inaccurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">0.54999924</span>
</pre></div>
</div>
<p>Computing the mean in float64 is more accurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  
<span class="go">0.55000000074505806 # may vary</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.median">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">median</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median along the specified axis.</p>
<p>This docstring was copied from numpy.median.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This works by automatically chunking the reduced axes to a single chunk
and then calling <code class="docutils literal notranslate"><span class="pre">numpy.median</span></code> function across the remaining dimensions</p>
<p>Returns the median of the array elements.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{int, sequence of int, None}, optional</span></dt><dd><p>Axis or axes along which the medians are computed. The default
is to compute the median along a flattened version of the array.
A sequence of axes is supported since version 1.9.0.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</p>
</dd>
<dt><strong>overwrite_input</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>If True, then allow use of memory of input array <cite>a</cite> for
calculations. The input array will be modified by the call to
<cite>median</cite>. This will save memory when you do not need to preserve
the contents of the input array. Treat the input as undefined,
but it will probably be fully or partially sorted. Default is
False. If <cite>overwrite_input</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code> and <cite>a</cite> is not already an
<cite>ndarray</cite>, an error will be raised.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>arr</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>median</strong><span class="classifier">ndarray</span></dt><dd><p>A new array holding the result. If the input contains integers
or floats smaller than <code class="docutils literal notranslate"><span class="pre">float64</span></code>, then the output data-type is
<code class="docutils literal notranslate"><span class="pre">np.float64</span></code>.  Otherwise, the data-type of the output is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.mean" title="dask.array.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>, <a class="reference internal" href="#dask.array.percentile" title="dask.array.percentile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">percentile</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Given a vector <code class="docutils literal notranslate"><span class="pre">V</span></code> of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, the median of <code class="docutils literal notranslate"><span class="pre">V</span></code> is the
middle value of a sorted copy of <code class="docutils literal notranslate"><span class="pre">V</span></code>, <code class="docutils literal notranslate"><span class="pre">V_sorted</span></code> - i
e., <code class="docutils literal notranslate"><span class="pre">V_sorted[(N-1)/2]</span></code>, when <code class="docutils literal notranslate"><span class="pre">N</span></code> is odd, and the average of the
two middle values of <code class="docutils literal notranslate"><span class="pre">V_sorted</span></code> when <code class="docutils literal notranslate"><span class="pre">N</span></code> is even.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[10,  7,  4],</span>
<span class="go">       [ 3,  2,  1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([6.5, 4.5, 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>  
<span class="go">array([6.5,  4.5,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>  
<span class="go">array([6.5,  4.5,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.meshgrid">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">meshgrid</code><span class="sig-paren">(</span><em class="sig-param">*xi</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.meshgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return coordinate matrices from coordinate vectors.</p>
<p>This docstring was copied from numpy.meshgrid.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Make N-D coordinate arrays for vectorized evaluations of
N-D scalar/vector fields over N-D grids, given
one-dimensional coordinate arrays x1, x2,…, xn.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.9: </span>1-D and 0-D cases are allowed.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x1, x2,…, xn</strong><span class="classifier">array_like</span></dt><dd><p>1-D arrays representing the coordinates of a grid.</p>
</dd>
<dt><strong>indexing</strong><span class="classifier">{‘xy’, ‘ij’}, optional</span></dt><dd><p>Cartesian (‘xy’, default) or matrix (‘ij’) indexing of output.
See Notes for more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, optional</span></dt><dd><p>If True a sparse grid is returned in order to conserve memory.
Default is False.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, a view into the original arrays are returned in order to
conserve memory.  Default is True.  Please note that
<code class="docutils literal notranslate"><span class="pre">sparse=False,</span> <span class="pre">copy=False</span></code> will likely return non-contiguous
arrays.  Furthermore, more than one element of a broadcast array
may refer to a single memory location.  If you need to write to the
arrays, make copies first.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>X1, X2,…, XN</strong><span class="classifier">ndarray</span></dt><dd><p>For vectors <cite>x1</cite>, <cite>x2</cite>,…, ‘xn’ with lengths <code class="docutils literal notranslate"><span class="pre">Ni=len(xi)</span></code> ,
return <code class="docutils literal notranslate"><span class="pre">(N1,</span> <span class="pre">N2,</span> <span class="pre">N3,...Nn)</span></code> shaped arrays if indexing=’ij’
or <code class="docutils literal notranslate"><span class="pre">(N2,</span> <span class="pre">N1,</span> <span class="pre">N3,...Nn)</span></code> shaped arrays if indexing=’xy’
with the elements of <cite>xi</cite> repeated to fill the matrix along
the first dimension for <cite>x1</cite>, the second for <cite>x2</cite> and so on.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">index_tricks.mgrid</span></code></dt><dd><p>Construct a multi-dimensional “meshgrid” using indexing notation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">index_tricks.ogrid</span></code></dt><dd><p>Construct an open multi-dimensional “meshgrid” using indexing notation.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function supports both indexing conventions through the indexing
keyword argument.  Giving the string ‘ij’ returns a meshgrid with
matrix indexing, while ‘xy’ returns a meshgrid with Cartesian indexing.
In the 2-D case with inputs of length M and N, the outputs are of shape
(N, M) for ‘xy’ indexing and (M, N) for ‘ij’ indexing.  In the 3-D case
with inputs of length M, N and P, outputs are of shape (N, M, P) for
‘xy’ indexing and (M, N, P) for ‘ij’ indexing.  The difference is
illustrated by the following code snippet:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
        <span class="c1"># treat xv[i,j], yv[i,j]</span>

<span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
        <span class="c1"># treat xv[j,i], yv[j,i]</span>
</pre></div>
</div>
<p>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>  
<span class="go">array([[0. , 0.5, 1. ],</span>
<span class="go">       [0. , 0.5, 1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>  
<span class="go">array([[0.,  0.,  0.],</span>
<span class="go">       [1.,  1.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># make sparse output arrays  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>  
<span class="go">array([[0. ,  0.5,  1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>  
<span class="go">array([[0.],</span>
<span class="go">       [1.]])</span>
</pre></div>
</div>
<p><cite>meshgrid</cite> is very useful to evaluate functions on a grid.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">xx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">xx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.min">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum of an array or minimum along an axis.</p>
<p>This docstring was copied from numpy.min.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to operate.  By default, flattened input is
used.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, the minimum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <cite>ufuncs-output-type</cite> for more details.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>amin</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt><strong>initial</strong><span class="classifier">scalar, optional  (Not supported in Dask)</span></dt><dd><p>The maximum value of an output element. Must be present to allow
computation on empty slice. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</dd>
<dt><strong>where</strong><span class="classifier">array_like of bool, optional  (Not supported in Dask)</span></dt><dd><p>Elements to compare for the minimum. See <cite>~numpy.ufunc.reduce</cite>
for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>amin</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Minimum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">amax</span></code></dt><dd><p>The maximum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.nanmin" title="dask.array.nanmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmin</span></code></a></dt><dd><p>The minimum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.minimum" title="dask.array.minimum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum</span></code></a></dt><dd><p>Element-wise minimum of two arrays, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fmin" title="dask.array.fmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmin</span></code></a></dt><dd><p>Element-wise minimum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.argmin" title="dask.array.argmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmin</span></code></a></dt><dd><p>Return the indices of the minimum values.</p>
</dd>
</dl>
<p><a class="reference internal" href="#dask.array.nanmax" title="dask.array.nanmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmax</span></code></a>, <a class="reference internal" href="#dask.array.maximum" title="dask.array.maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum</span></code></a>, <a class="reference internal" href="#dask.array.fmax" title="dask.array.fmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmax</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.</p>
<p>Don’t use <cite>amin</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal notranslate"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal notranslate"><span class="pre">minimum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal notranslate"><span class="pre">amin(a,</span> <span class="pre">axis=0)</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Minimum of the flattened array  </span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Minima along the first axis  </span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Minima along the second axis  </span>
<span class="go">array([0, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([10,  1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">initial</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="go">0.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([-50,   0])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
minimum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<p>Notice that this isn’t the same as Python’s <code class="docutils literal notranslate"><span class="pre">default</span></code> argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.minimum">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">minimum</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.minimum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Element-wise minimum of array elements.</p>
<p>Compare two arrays and returns a new array containing the element-wise
minima. If one of the elements being compared is a NaN, then that
element is returned. If both elements are NaNs then the first is
returned. The latter distinction is important for complex NaNs, which
are defined as at least one of the real or imaginary parts being a NaN.
The net effect is that NaNs are propagated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1, x2</strong><span class="classifier">array_like</span></dt><dd><p>The arrays holding the elements to be compared. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The minimum of <cite>x1</cite> and <cite>x2</cite>, element-wise.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.maximum" title="dask.array.maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum</span></code></a></dt><dd><p>Element-wise maximum of two arrays, propagates NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fmin" title="dask.array.fmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmin</span></code></a></dt><dd><p>Element-wise minimum of two arrays, ignores NaNs.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">amin</span></code></dt><dd><p>The minimum value of an array along a given axis, propagates NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.nanmin" title="dask.array.nanmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmin</span></code></a></dt><dd><p>The minimum value of an array along a given axis, ignores NaNs.</p>
</dd>
</dl>
<p><a class="reference internal" href="#dask.array.fmax" title="dask.array.fmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmax</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">amax</span></code>, <a class="reference internal" href="#dask.array.nanmax" title="dask.array.nanmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmax</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The minimum is equivalent to <code class="docutils literal notranslate"><span class="pre">np.where(x1</span> <span class="pre">&lt;=</span> <span class="pre">x2,</span> <span class="pre">x1,</span> <span class="pre">x2)</span></code> when
neither x1 nor x2 are NaNs, but it is faster and does proper
broadcasting.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="go">array([1, 3, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="c1"># broadcasting  </span>
<span class="go">array([[ 0.5,  0. ],</span>
<span class="go">       [ 0. ,  1. ]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="go">array([nan, nan, nan])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">Inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  
<span class="go">-inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.modf">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">modf</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <span class="optional">[</span><em class="sig-param">out1</em>, <em class="sig-param">out2</em>, <span class="optional">]</span><em class="sig-param">/</em>, <span class="optional">[</span><em class="sig-param">out=(None</em>, <em class="sig-param">None)</em>, <span class="optional">]</span><em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.modf" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.modf.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the fractional and integral parts of an array, element-wise.</p>
<p>The fractional and integral parts are negative if the given number is
negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y1</strong><span class="classifier">ndarray</span></dt><dd><p>Fractional part of <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt><strong>y2</strong><span class="classifier">ndarray</span></dt><dd><p>Integral part of <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">divmod</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">divmod(x,</span> <span class="pre">1)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">modf</span></code> with the return values switched, except it always has a positive remainder.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For integer input the return values are floats.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">modf</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">])</span>  
<span class="go">(array([ 0. ,  0.5]), array([ 0.,  3.]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>  
<span class="go">(-0.5, -0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.moment">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">moment</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">order</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">ddof=0</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.moment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="dask.array.moveaxis">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">moveaxis</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">source</em>, <em class="sig-param">destination</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.moveaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Move axes of an array to new positions.</p>
<p>This docstring was copied from numpy.moveaxis.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Other axes remain in their original order.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.11.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">np.ndarray</span></dt><dd><p>The array whose axes should be reordered.</p>
</dd>
<dt><strong>source</strong><span class="classifier">int or sequence of int</span></dt><dd><p>Original positions of the axes to move. These must be unique.</p>
</dd>
<dt><strong>destination</strong><span class="classifier">int or sequence of int</span></dt><dd><p>Destination positions for each of the original axes. These must also be
unique.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array with moved axes. This array is a view of the input array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.transpose" title="dask.array.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a></dt><dd><p>Permute the dimensions of an array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapaxes</span></code></dt><dd><p>Interchange two axes of an array.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(4, 5, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(5, 3, 4)</span>
</pre></div>
</div>
<p>These all achieve the same result:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(5, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(5, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(5, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(5, 4, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nanargmax">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nanargmax</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nanargmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of an array or maximum along an axis, ignoring any
NaNs.  When all-NaN slices are encountered a <code class="docutils literal notranslate"><span class="pre">RuntimeWarning</span></code> is
raised and NaN is returned for that slice.</p>
<p>This docstring was copied from numpy.nanmax.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Array containing numbers whose maximum is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the maximum is computed. The default is to compute
the maximum of the flattened array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary. See
<cite>ufuncs-output-type</cite> for more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>max</cite> method
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nanmax</strong><span class="classifier">ndarray</span></dt><dd><p>An array with the same shape as <cite>a</cite>, with the specified axis removed.
If <cite>a</cite> is a 0-d array, or if axis is None, an ndarray scalar is
returned.  The same dtype as <cite>a</cite> is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.nanmin" title="dask.array.nanmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmin</span></code></a></dt><dd><p>The minimum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">amax</span></code></dt><dd><p>The maximum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fmax" title="dask.array.fmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmax</span></code></a></dt><dd><p>Element-wise maximum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.maximum" title="dask.array.maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum</span></code></a></dt><dd><p>Element-wise maximum of two arrays, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isnan" title="dask.array.isnan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnan</span></code></a></dt><dd><p>Shows which elements are Not a Number (NaN).</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isfinite" title="dask.array.isfinite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfinite</span></code></a></dt><dd><p>Shows which elements are neither NaN nor infinity.</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">amin</span></code>, <a class="reference internal" href="#dask.array.fmin" title="dask.array.fmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmin</span></code></a>, <a class="reference internal" href="#dask.array.minimum" title="dask.array.minimum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.</p>
<p>If the input has a integer type the function is equivalent to np.max.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([3.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([2.,  3.])</span>
</pre></div>
</div>
<p>When positive infinity and negative infinity are present:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>  
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>  
<span class="go">inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nanargmin">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nanargmin</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nanargmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return minimum of an array or minimum along an axis, ignoring any NaNs.
When all-NaN slices are encountered a <code class="docutils literal notranslate"><span class="pre">RuntimeWarning</span></code> is raised and
Nan is returned for that slice.</p>
<p>This docstring was copied from numpy.nanmin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Array containing numbers whose minimum is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the minimum is computed. The default is to compute
the minimum of the flattened array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary. See
<cite>ufuncs-output-type</cite> for more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>min</cite> method
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nanmin</strong><span class="classifier">ndarray</span></dt><dd><p>An array with the same shape as <cite>a</cite>, with the specified axis
removed.  If <cite>a</cite> is a 0-d array, or if axis is None, an ndarray
scalar is returned.  The same dtype as <cite>a</cite> is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.nanmax" title="dask.array.nanmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmax</span></code></a></dt><dd><p>The maximum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">amin</span></code></dt><dd><p>The minimum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fmin" title="dask.array.fmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmin</span></code></a></dt><dd><p>Element-wise minimum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.minimum" title="dask.array.minimum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum</span></code></a></dt><dd><p>Element-wise minimum of two arrays, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isnan" title="dask.array.isnan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnan</span></code></a></dt><dd><p>Shows which elements are Not a Number (NaN).</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isfinite" title="dask.array.isfinite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfinite</span></code></a></dt><dd><p>Shows which elements are neither NaN nor infinity.</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">amax</span></code>, <a class="reference internal" href="#dask.array.fmax" title="dask.array.fmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmax</span></code></a>, <a class="reference internal" href="#dask.array.maximum" title="dask.array.maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.</p>
<p>If the input has a integer type the function is equivalent to np.min.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([1.,  3.])</span>
</pre></div>
</div>
<p>When positive infinity and negative infinity are present:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>  
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>  
<span class="go">-inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nancumprod">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nancumprod</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">axis</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nancumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product of array elements over a given axis treating Not a
Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
encountered and leading NaNs are replaced by ones.</p>
<p>This docstring was copied from numpy.nancumprod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Ones are returned for slices that are all-NaN or empty.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which the cumulative product is computed.  By default
the input is flattened.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Type of the returned array, as well as of the accumulator in which
the elements are multiplied.  If <em>dtype</em> is not specified, it
defaults to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with
a precision less than that of the default platform integer.  In
that case, the default platform integer is used instead.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type of the resulting values will be cast if necessary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nancumprod</strong><span class="classifier">ndarray</span></dt><dd><p>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case it is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.cumprod.html#numpy.cumprod" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.cumprod</span></code></a></dt><dd><p>Cumulative product across array propagating NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isnan" title="dask.array.isnan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnan</span></code></a></dt><dd><p>Show which elements are NaN.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>  
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="go">array([1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">array([1.,  2.,  6.,  6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([[1.,  2.],</span>
<span class="go">       [3.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[1.,  2.],</span>
<span class="go">       [3.,  3.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nancumsum">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nancumsum</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">axis</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nancumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
encountered and leading NaNs are replaced by zeros.</p>
<p>This docstring was copied from numpy.nancumsum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Zeros are returned for slices that are all-NaN or empty.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which the cumulative sum is computed. The default
(None) is to compute the cumsum over the flattened array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Type of the returned array and of the accumulator in which the
elements are summed.  If <cite>dtype</cite> is not specified, it defaults
to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with a
precision less than that of the default platform integer.  In
that case, the default platform integer is used.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type will be cast if necessary. See <cite>ufuncs-output-type</cite> for
more details.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nancumsum</strong><span class="classifier">ndarray.</span></dt><dd><p>A new array holding the result is returned unless <cite>out</cite> is
specified, in which it is returned. The result has the same
size as <cite>a</cite>, and the same shape as <cite>a</cite> if <cite>axis</cite> is not None
or <cite>a</cite> is a 1-d array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.cumsum.html#numpy.cumsum" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.cumsum</span></code></a></dt><dd><p>Cumulative sum across array propagating NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isnan" title="dask.array.isnan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnan</span></code></a></dt><dd><p>Show which elements are NaN.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>  
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="go">array([1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">array([1.,  3.,  6.,  6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([[1.,  2.],</span>
<span class="go">       [4.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[1.,  3.],</span>
<span class="go">       [3.,  3.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nanmax">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nanmax</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nanmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of an array or maximum along an axis, ignoring any
NaNs.  When all-NaN slices are encountered a <code class="docutils literal notranslate"><span class="pre">RuntimeWarning</span></code> is
raised and NaN is returned for that slice.</p>
<p>This docstring was copied from numpy.nanmax.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose maximum is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the maximum is computed. The default is to compute
the maximum of the flattened array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary. See
<cite>ufuncs-output-type</cite> for more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>max</cite> method
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nanmax</strong><span class="classifier">ndarray</span></dt><dd><p>An array with the same shape as <cite>a</cite>, with the specified axis removed.
If <cite>a</cite> is a 0-d array, or if axis is None, an ndarray scalar is
returned.  The same dtype as <cite>a</cite> is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.nanmin" title="dask.array.nanmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmin</span></code></a></dt><dd><p>The minimum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">amax</span></code></dt><dd><p>The maximum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fmax" title="dask.array.fmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmax</span></code></a></dt><dd><p>Element-wise maximum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.maximum" title="dask.array.maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum</span></code></a></dt><dd><p>Element-wise maximum of two arrays, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isnan" title="dask.array.isnan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnan</span></code></a></dt><dd><p>Shows which elements are Not a Number (NaN).</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isfinite" title="dask.array.isfinite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfinite</span></code></a></dt><dd><p>Shows which elements are neither NaN nor infinity.</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">amin</span></code>, <a class="reference internal" href="#dask.array.fmin" title="dask.array.fmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmin</span></code></a>, <a class="reference internal" href="#dask.array.minimum" title="dask.array.minimum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.</p>
<p>If the input has a integer type the function is equivalent to np.max.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([3.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([2.,  3.])</span>
</pre></div>
</div>
<p>When positive infinity and negative infinity are present:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>  
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>  
<span class="go">inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nanmean">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nanmean</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nanmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the arithmetic mean along the specified axis, ignoring NaNs.</p>
<p>This docstring was copied from numpy.nanmean.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute the arithmetic mean along the specified axis, ignoring NaNs.</p>
<p>This docstring was copied from numpy.nanmean.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
<cite>float64</cite> intermediate and return values are used for integer inputs.</p>
<p>For all-NaN slices, NaN is returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose mean is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the means are computed. The default is to compute
the mean of the flattened array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Type to use in computing the mean.  For integer inputs, the default
is <cite>float64</cite>; for inexact inputs, it is the same as the input
dtype.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary. See
<cite>ufuncs-output-type</cite> for more details.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>mean</cite> or <cite>sum</cite> methods
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>m</strong><span class="classifier">ndarray, see dtype parameter above</span></dt><dd><p>If <cite>out=None</cite>, returns a new array containing the mean values,
otherwise a reference to the output array is returned. Nan is
returned for slices that contain only NaNs.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.average" title="dask.array.average"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average</span></code></a></dt><dd><p>Weighted average</p>
</dd>
<dt><a class="reference internal" href="#dask.array.mean" title="dask.array.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a></dt><dd><p>Arithmetic mean taken while not ignoring NaNs</p>
</dd>
</dl>
<p><a class="reference internal" href="#dask.array.var" title="dask.array.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>, <a class="reference internal" href="#dask.array.nanvar" title="dask.array.nanvar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanvar</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The arithmetic mean is the sum of the non-NaN elements along the axis
divided by the number of non-NaN elements.</p>
<p>Note that for floating-point input, the mean is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite>.  Specifying a
higher-precision accumulator using the <cite>dtype</cite> keyword can alleviate
this issue.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">2.6666666666666665</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([2.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([1.,  3.5]) # may vary</span>
</pre></div>
</div>
<p>Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
<cite>float64</cite> intermediate and return values are used for integer inputs.</p>
<p>For all-NaN slices, NaN is returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nanmedian">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nanmedian</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nanmedian" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median along the specified axis, while ignoring NaNs.</p>
<p>This docstring was copied from numpy.nanmedian.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This works by automatically chunking the reduced axes to a single chunk
and then calling <code class="docutils literal notranslate"><span class="pre">numpy.nanmedian</span></code> function across the remaining dimensions</p>
<p>Returns the median of the array elements.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{int, sequence of int, None}, optional</span></dt><dd><p>Axis or axes along which the medians are computed. The default
is to compute the median along a flattened version of the array.
A sequence of axes is supported since version 1.9.0.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</p>
</dd>
<dt><strong>overwrite_input</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>If True, then allow use of memory of input array <cite>a</cite> for
calculations. The input array will be modified by the call to
<cite>median</cite>. This will save memory when you do not need to preserve
the contents of the input array. Treat the input as undefined,
but it will probably be fully or partially sorted. Default is
False. If <cite>overwrite_input</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code> and <cite>a</cite> is not already an
<cite>ndarray</cite>, an error will be raised.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If this is anything but the default value it will be passed
through (in the special case of an empty array) to the
<cite>mean</cite> function of the underlying array.  If the array is
a sub-class and <cite>mean</cite> does not have the kwarg <cite>keepdims</cite> this
will raise a RuntimeError.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>median</strong><span class="classifier">ndarray</span></dt><dd><p>A new array holding the result. If the input contains integers
or floats smaller than <code class="docutils literal notranslate"><span class="pre">float64</span></code>, then the output data-type is
<code class="docutils literal notranslate"><span class="pre">np.float64</span></code>.  Otherwise, the data-type of the output is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.mean" title="dask.array.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>, <a class="reference internal" href="#dask.array.median" title="dask.array.median"><code class="xref py py-obj docutils literal notranslate"><span class="pre">median</span></code></a>, <a class="reference internal" href="#dask.array.percentile" title="dask.array.percentile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">percentile</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Given a vector <code class="docutils literal notranslate"><span class="pre">V</span></code> of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, the median of <code class="docutils literal notranslate"><span class="pre">V</span></code> is the
middle value of a sorted copy of <code class="docutils literal notranslate"><span class="pre">V</span></code>, <code class="docutils literal notranslate"><span class="pre">V_sorted</span></code> - i.e.,
<code class="docutils literal notranslate"><span class="pre">V_sorted[(N-1)/2]</span></code>, when <code class="docutils literal notranslate"><span class="pre">N</span></code> is odd and the average of the two
middle values of <code class="docutils literal notranslate"><span class="pre">V_sorted</span></code> when <code class="docutils literal notranslate"><span class="pre">N</span></code> is even.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[10., nan,  4.],</span>
<span class="go">       [ 3.,  2.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([6.5, 2. , 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([nan,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nanmin">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nanmin</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nanmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return minimum of an array or minimum along an axis, ignoring any NaNs.
When all-NaN slices are encountered a <code class="docutils literal notranslate"><span class="pre">RuntimeWarning</span></code> is raised and
Nan is returned for that slice.</p>
<p>This docstring was copied from numpy.nanmin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose minimum is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the minimum is computed. The default is to compute
the minimum of the flattened array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary. See
<cite>ufuncs-output-type</cite> for more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>min</cite> method
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nanmin</strong><span class="classifier">ndarray</span></dt><dd><p>An array with the same shape as <cite>a</cite>, with the specified axis
removed.  If <cite>a</cite> is a 0-d array, or if axis is None, an ndarray
scalar is returned.  The same dtype as <cite>a</cite> is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.nanmax" title="dask.array.nanmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmax</span></code></a></dt><dd><p>The maximum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">amin</span></code></dt><dd><p>The minimum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fmin" title="dask.array.fmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmin</span></code></a></dt><dd><p>Element-wise minimum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.minimum" title="dask.array.minimum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum</span></code></a></dt><dd><p>Element-wise minimum of two arrays, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isnan" title="dask.array.isnan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnan</span></code></a></dt><dd><p>Shows which elements are Not a Number (NaN).</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isfinite" title="dask.array.isfinite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfinite</span></code></a></dt><dd><p>Shows which elements are neither NaN nor infinity.</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">amax</span></code>, <a class="reference internal" href="#dask.array.fmax" title="dask.array.fmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmax</span></code></a>, <a class="reference internal" href="#dask.array.maximum" title="dask.array.maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.</p>
<p>If the input has a integer type the function is equivalent to np.min.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([1.,  3.])</span>
</pre></div>
</div>
<p>When positive infinity and negative infinity are present:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>  
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>  
<span class="go">-inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nanprod">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nanprod</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nanprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of array elements over a given axis treating Not a
Numbers (NaNs) as ones.</p>
<p>This docstring was copied from numpy.nanprod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>One is returned for slices that are all-NaN or empty.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose product is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the product is computed. The default is to compute
the product of the flattened array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The type of the returned array and of the accumulator in which the
elements are summed.  By default, the dtype of <cite>a</cite> is used.  An
exception is when <cite>a</cite> has an integer type with less precision than
the platform (u)intp. In that case, the default will be either
(u)int32 or (u)int64 depending on whether the platform is 32 or 64
bits. For inexact inputs, dtype must be inexact.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>. If provided, it must have the same shape as the
expected output, but the type will be cast if necessary. See
<cite>ufuncs-output-type</cite> for more details. The casting of NaN to integer
can yield unexpected results.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the axes which are reduced are left in the result as
dimensions with size one. With this option, the result will
broadcast correctly against the original <cite>arr</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nanprod</strong><span class="classifier">ndarray</span></dt><dd><p>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case it is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.prod.html#numpy.prod" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.prod</span></code></a></dt><dd><p>Product across array propagating NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isnan" title="dask.array.isnan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnan</span></code></a></dt><dd><p>Show which elements are NaN.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>  
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">6.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([3., 2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nanstd">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nanstd</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">ddof=0</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nanstd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation along the specified axis, while
ignoring NaNs.</p>
<p>This docstring was copied from numpy.nanstd.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute the standard deviation along the specified axis, while
ignoring NaNs.</p>
<p>This docstring was copied from numpy.nanstd.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns the standard deviation, a measure of the spread of a
distribution, of the non-NaN array elements. The standard deviation is
computed for the flattened array by default, otherwise over the
specified axis.</p>
<p>For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Calculate the standard deviation of the non-NaN values.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the standard deviation is computed. The default is
to compute the standard deviation of the flattened array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Type to use in computing the standard deviation. For arrays of
integer type the default is float64, for arrays of float types it
is the same as the array type.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must have
the same shape as the expected output but the type (of the
calculated values) will be cast if necessary.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, optional</span></dt><dd><p>Means Delta Degrees of Freedom.  The divisor used in calculations
is <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> represents the number of non-NaN
elements.  By default <cite>ddof</cite> is zero.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If this value is anything but the default it is passed through
as-is to the relevant functions of the sub-classes.  If these
functions do not have a <cite>keepdims</cite> kwarg, a RuntimeError will
be raised.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>standard_deviation</strong><span class="classifier">ndarray, see dtype parameter above.</span></dt><dd><p>If <cite>out</cite> is None, return a new array containing the standard
deviation, otherwise return a reference to the output array. If
ddof is &gt;= the number of non-NaN elements in a slice or the slice
contains only NaNs, then the result for that slice is NaN.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.var" title="dask.array.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>, <a class="reference internal" href="#dask.array.mean" title="dask.array.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>, <a class="reference internal" href="#dask.array.std" title="dask.array.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>, <a class="reference internal" href="#dask.array.nanvar" title="dask.array.nanvar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanvar</span></code></a>, <a class="reference internal" href="#dask.array.nanmean" title="dask.array.nanmean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmean</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">ufuncs-output-type</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The standard deviation is the square root of the average of the squared
deviations from the mean: <code class="docutils literal notranslate"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">sqrt(mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2))</span></code>.</p>
<p>The average squared deviation is normally calculated as
<code class="docutils literal notranslate"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.  If, however, <cite>ddof</cite> is
specified, the divisor <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used instead. In standard
statistical practice, <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code> provides an unbiased estimator of the
variance of the infinite population. <code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> provides a maximum
likelihood estimate of the variance for normally distributed variables.
The standard deviation computed in this function is the square root of
the estimated variance, so even with <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code>, it will not be an
unbiased estimate of the standard deviation per se.</p>
<p>Note that, for complex numbers, <cite>std</cite> takes the absolute value before
squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the <em>std</em> is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example
below).  Specifying a higher-accuracy accumulator using the <cite>dtype</cite>
keyword can alleviate this issue.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">1.247219128924647</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([1., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([0.,  0.5]) # may vary</span>
</pre></div>
</div>
<p>Returns the standard deviation, a measure of the spread of a
distribution, of the non-NaN array elements. The standard deviation is
computed for the flattened array by default, otherwise over the
specified axis.</p>
<p>For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nansum">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nansum</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nansum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.</p>
<p>This docstring was copied from numpy.nansum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>In NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or
empty. In later versions zero is returned.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose sum is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the sum is computed. The default is to compute the
sum of the flattened array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The type of the returned array and of the accumulator in which the
elements are summed.  By default, the dtype of <cite>a</cite> is used.  An
exception is when <cite>a</cite> has an integer type with less precision than
the platform (u)intp. In that case, the default will be either
(u)int32 or (u)int64 depending on whether the platform is 32 or 64
bits. For inexact inputs, dtype must be inexact.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>. If provided, it must have the same shape as the
expected output, but the type will be cast if necessary.  See
<cite>ufuncs-output-type</cite> for more details. The casting of NaN to integer
can yield unexpected results.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>mean</cite> or <cite>sum</cite> methods
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nansum</strong><span class="classifier">ndarray.</span></dt><dd><p>A new array holding the result is returned unless <cite>out</cite> is
specified, in which it is returned. The result has the same
size as <cite>a</cite>, and the same shape as <cite>a</cite> if <cite>axis</cite> is not None
or <cite>a</cite> is a 1-d array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html#numpy.sum" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.sum</span></code></a></dt><dd><p>Sum across array propagating NaNs.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isnan" title="dask.array.isnan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnan</span></code></a></dt><dd><p>Show which elements are NaN.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isfinite" title="dask.array.isfinite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfinite</span></code></a></dt><dd><p>Show which elements are not NaN or +/-inf.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If both positive and negative infinity are present, the sum will be Not
A Number (NaN).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>  
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>  
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([2.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>  
<span class="go">inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>  
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.testing</span> <span class="kn">import</span> <span class="n">suppress_warnings</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">suppress_warnings</span><span class="p">()</span> <span class="k">as</span> <span class="n">sup</span><span class="p">:</span>  
<span class="gp">... </span>    <span class="n">sup</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span> <span class="c1"># both +/- infinity present</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nanvar">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nanvar</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">ddof=0</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nanvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance along the specified axis, while ignoring NaNs.</p>
<p>This docstring was copied from numpy.nanvar.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute the variance along the specified axis, while ignoring NaNs.</p>
<p>This docstring was copied from numpy.nanvar.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns the variance of the array elements, a measure of the spread of
a distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.</p>
<p>For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose variance is desired.  If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the variance is computed.  The default is to compute
the variance of the flattened array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Type to use in computing the variance.  For arrays of integer type
the default is <cite>float64</cite>; for arrays of float types it is the same as
the array type.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  It must have
the same shape as the expected output, but the type is cast if
necessary.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, optional</span></dt><dd><p>“Delta Degrees of Freedom”: the divisor used in the calculation is
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> represents the number of non-NaN
elements. By default <cite>ddof</cite> is zero.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>variance</strong><span class="classifier">ndarray, see dtype parameter above</span></dt><dd><p>If <cite>out</cite> is None, return a new array containing the variance,
otherwise return a reference to the output array. If ddof is &gt;= the
number of non-NaN elements in a slice or the slice contains only
NaNs, then the result for that slice is NaN.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.std" title="dask.array.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a></dt><dd><p>Standard deviation</p>
</dd>
<dt><a class="reference internal" href="#dask.array.mean" title="dask.array.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a></dt><dd><p>Average</p>
</dd>
<dt><a class="reference internal" href="#dask.array.var" title="dask.array.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a></dt><dd><p>Variance while not ignoring NaNs</p>
</dd>
</dl>
<p><a class="reference internal" href="#dask.array.nanstd" title="dask.array.nanstd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanstd</span></code></a>, <a class="reference internal" href="#dask.array.nanmean" title="dask.array.nanmean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmean</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">ufuncs-output-type</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The variance is the average of the squared deviations from the mean,
i.e.,  <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2)</span></code>.</p>
<p>The mean is normally calculated as <code class="docutils literal notranslate"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.
If, however, <cite>ddof</cite> is specified, the divisor <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used
instead.  In standard statistical practice, <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code> provides an
unbiased estimator of the variance of a hypothetical infinite
population.  <code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> provides a maximum likelihood estimate of the
variance for normally distributed variables.</p>
<p>Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite> (see example
below).  Specifying a higher-accuracy accumulator using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>
keyword can alleviate this issue.</p>
<p>For this function to work on sub-classes of ndarray, they must define
<cite>sum</cite> with the kwarg <cite>keepdims</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">1.5555555555555554</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([1.,  0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([0.,  0.25])  # may vary</span>
</pre></div>
</div>
<p>Returns the variance of the array elements, a measure of the spread of
a distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.</p>
<p>For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nan_to_num">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nan_to_num</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nan_to_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace NaN with zero and infinity with large finite numbers (default
behaviour) or with the numbers defined by the user using the <cite>nan</cite>, 
<cite>posinf</cite> and/or <cite>neginf</cite> keywords.</p>
<p>This docstring was copied from numpy.nan_to_num.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>If <cite>x</cite> is inexact, NaN is replaced by zero or by the user defined value in
<cite>nan</cite> keyword, infinity is replaced by the largest finite floating point 
values representable by <code class="docutils literal notranslate"><span class="pre">x.dtype</span></code> or by the user defined value in 
<cite>posinf</cite> keyword and -infinity is replaced by the most negative finite 
floating point values representable by <code class="docutils literal notranslate"><span class="pre">x.dtype</span></code> or by the user defined 
value in <cite>neginf</cite> keyword.</p>
<p>For complex dtypes, the above is applied to each of the real and
imaginary components of <cite>x</cite> separately.</p>
<p>If <cite>x</cite> is not inexact, then no replacements are made.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">scalar or array_like  (Not supported in Dask)</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>Whether to create a copy of <cite>x</cite> (True) or to replace values
in-place (False). The in-place operation only occurs if
casting to an array does not require a copy.
Default is True.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.</span></p>
</div>
</dd>
<dt><strong>nan</strong><span class="classifier">int, float, optional  (Not supported in Dask)</span></dt><dd><p>Value to be used to fill NaN values. If no value is passed 
then NaN values will be replaced with 0.0.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.</span></p>
</div>
</dd>
<dt><strong>posinf</strong><span class="classifier">int, float, optional  (Not supported in Dask)</span></dt><dd><p>Value to be used to fill positive infinity values. If no value is 
passed then positive infinity values will be replaced with a very
large number.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.</span></p>
</div>
</dd>
<dt><strong>neginf</strong><span class="classifier">int, float, optional  (Not supported in Dask)</span></dt><dd><p>Value to be used to fill negative infinity values. If no value is 
passed then negative infinity values will be replaced with a very
small (or negative) number.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p><cite>x</cite>, with the non-finite values replaced. If <cite>copy</cite> is False, this may
be <cite>x</cite> itself.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.isinf" title="dask.array.isinf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinf</span></code></a></dt><dd><p>Shows which elements are positive or negative infinity.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isneginf" title="dask.array.isneginf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isneginf</span></code></a></dt><dd><p>Shows which elements are negative infinity.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isposinf" title="dask.array.isposinf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isposinf</span></code></a></dt><dd><p>Shows which elements are positive infinity.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isnan" title="dask.array.isnan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnan</span></code></a></dt><dd><p>Shows which elements are Not a Number (NaN).</p>
</dd>
<dt><a class="reference internal" href="#dask.array.isfinite" title="dask.array.isfinite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfinite</span></code></a></dt><dd><p>Shows which elements are finite (not NaN, not infinity)</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>  
<span class="go">1.7976931348623157e+308</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>  
<span class="go">-1.7976931348623157e+308</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>  
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="o">-</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary</span>
<span class="go">       -1.28000000e+002,  1.28000000e+002])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nan</span><span class="o">=-</span><span class="mi">9999</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="mi">33333333</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="mi">33333333</span><span class="p">)</span>  
<span class="go">array([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03, </span>
<span class="go">       -1.2800000e+02,  1.2800000e+02])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">complex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">complex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)])</span>  
<span class="go">array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary</span>
<span class="go">     -1.28000000e+002,   1.28000000e+002])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  
<span class="go">array([  1.79769313e+308 +0.00000000e+000j, # may vary</span>
<span class="go">         0.00000000e+000 +0.00000000e+000j,</span>
<span class="go">         0.00000000e+000 +1.79769313e+308j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mi">111111</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="mi">222222</span><span class="p">)</span>  
<span class="go">array([222222.+111111.j, 111111.     +0.j, 111111.+222222.j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nextafter">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nextafter</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nextafter" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.nextafter.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the next floating-point value after x1 towards x2, element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x1</strong><span class="classifier">array_like</span></dt><dd><p>Values to find the next representable value of.</p>
</dd>
<dt><strong>x2</strong><span class="classifier">array_like</span></dt><dd><p>The direction where to look for the next representable value of <cite>x1</cite>.
If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The next representable values of <cite>x1</cite> in the direction of <cite>x2</cite>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">eps</span> <span class="o">+</span> <span class="mi">1</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="n">eps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">eps</span><span class="p">]</span>  
<span class="go">array([ True,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.nonzero">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">nonzero</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the elements that are non-zero.</p>
<p>This docstring was copied from numpy.nonzero.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns a tuple of arrays, one for each dimension of <cite>a</cite>,
containing the indices of the non-zero elements in that
dimension. The values in <cite>a</cite> are always tested and returned in
row-major, C-style order.</p>
<p>To group the indices by element, rather than dimension, use <cite>argwhere</cite>,
which returns a row for each non-zero element.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When called on a zero-d array or scalar, <code class="docutils literal notranslate"><span class="pre">nonzero(a)</span></code> is treated
as <code class="docutils literal notranslate"><span class="pre">nonzero(atleast1d(a))</span></code>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.17.0: </span>Use <cite>atleast1d</cite> explicitly if this behavior is deliberate.</p>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tuple_of_arrays</strong><span class="classifier">tuple</span></dt><dd><p>Indices of elements that are non-zero.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.flatnonzero" title="dask.array.flatnonzero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatnonzero</span></code></a></dt><dd><p>Return indices that are non-zero in the flattened version of the input array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.nonzero</span></code></dt><dd><p>Equivalent ndarray method.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.count_nonzero" title="dask.array.count_nonzero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count_nonzero</span></code></a></dt><dd><p>Counts the number of non-zero elements in the input array.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>While the nonzero values can be obtained with <code class="docutils literal notranslate"><span class="pre">a[nonzero(a)]</span></code>, it is
recommended to use <code class="docutils literal notranslate"><span class="pre">x[x.astype(bool)]</span></code> or <code class="docutils literal notranslate"><span class="pre">x[x</span> <span class="pre">!=</span> <span class="pre">0]</span></code> instead, which
will correctly handle 0-d arrays.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">array([[3, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [5, 6, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">(array([0, 1, 2, 2]), array([0, 1, 0, 1]))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>  
<span class="go">array([3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  
<span class="go">array([[0, 0],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [2, 0],</span>
<span class="go">       [2, 1]])</span>
</pre></div>
</div>
<p>A common use for <code class="docutils literal notranslate"><span class="pre">nonzero</span></code> is to find the indices of an array, where
a condition is True.  Given an array <cite>a</cite>, the condition <cite>a</cite> &gt; 3 is a
boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)
yields the indices of the <cite>a</cite> where the condition is true.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span>  
<span class="go">array([[False, False, False],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [ True,  True,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>  
<span class="go">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>
</pre></div>
</div>
<p>Using this result to index <cite>a</cite> is equivalent to using the mask directly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)]</span>  
<span class="go">array([4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># prefer this spelling  </span>
<span class="go">array([4, 5, 6, 7, 8, 9])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">nonzero</span></code> can also be called as a method of the array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>  
<span class="go">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.notnull">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">notnull</code><span class="sig-paren">(</span><em class="sig-param">values</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.notnull" title="Permalink to this definition">¶</a></dt>
<dd><p>pandas.notnull for dask arrays</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.ones">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">ones</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocked variant of ones</p>
<p>Follows the signature of ones exactly except that it also requires a
keyword argument chunks=(…)</p>
<p>Original signature follows below.</p>
<p>Return a new array of given shape and type, filled with ones.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">int or sequence of ints</span></dt><dd><p>Shape of the new array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The desired data-type for the array, e.g., <cite>numpy.int8</cite>.  Default is
<cite>numpy.float64</cite>.</p>
</dd>
<dt><strong>order</strong><span class="classifier">{‘C’, ‘F’}, optional, default: C</span></dt><dd><p>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of ones with the given shape, dtype, and order.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ones_like" title="dask.array.ones_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones_like</span></code></a></dt><dd><p>Return an array of ones with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.empty" title="dask.array.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a></dt><dd><p>Return a new uninitialized array.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.zeros" title="dask.array.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a></dt><dd><p>Return a new array setting values to zero.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.full" title="dask.array.full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code></a></dt><dd><p>Return a new array of given shape filled with value.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([1., 1., 1., 1., 1.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 1, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[1.],</span>
<span class="go">       [1.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">array([[1.,  1.],</span>
<span class="go">       [1.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ones_like">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">ones_like</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">chunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ones_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of ones with the same shape and type as a given array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>The shape and data-type of <cite>a</cite> define these same attributes of
the returned array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Overrides the data type of the result.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">sequence of ints</span></dt><dd><p>The number of samples on each block. Note that the last block will have
fewer samples if <code class="docutils literal notranslate"><span class="pre">len(array)</span> <span class="pre">%</span> <span class="pre">chunks</span> <span class="pre">!=</span> <span class="pre">0</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of ones with the same shape and type as <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.zeros_like" title="dask.array.zeros_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros_like</span></code></a></dt><dd><p>Return an array of zeros with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.empty_like" title="dask.array.empty_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty_like</span></code></a></dt><dd><p>Return an empty array with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.zeros" title="dask.array.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a></dt><dd><p>Return a new array setting values to zero.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ones" title="dask.array.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a></dt><dd><p>Return a new array setting values to one.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.empty" title="dask.array.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a></dt><dd><p>Return a new uninitialized array.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.outer">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">outer</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.outer" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the outer product of two vectors.</p>
<p>This docstring was copied from numpy.outer.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Given two vectors, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">[a0,</span> <span class="pre">a1,</span> <span class="pre">...,</span> <span class="pre">aM]</span></code> and
<code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">[b0,</span> <span class="pre">b1,</span> <span class="pre">...,</span> <span class="pre">bN]</span></code>,
the outer product <a class="reference internal" href="#rc80873b5d19f-1" id="id27">[1]</a> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span><span class="o">*</span><span class="n">b0</span>  <span class="n">a0</span><span class="o">*</span><span class="n">b1</span> <span class="o">...</span> <span class="n">a0</span><span class="o">*</span><span class="n">bN</span> <span class="p">]</span>
 <span class="p">[</span><span class="n">a1</span><span class="o">*</span><span class="n">b0</span>    <span class="o">.</span>
 <span class="p">[</span> <span class="o">...</span>          <span class="o">.</span>
 <span class="p">[</span><span class="n">aM</span><span class="o">*</span><span class="n">b0</span>            <span class="n">aM</span><span class="o">*</span><span class="n">bN</span> <span class="p">]]</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">(M,) array_like</span></dt><dd><p>First input vector.  Input is flattened if
not already 1-dimensional.</p>
</dd>
<dt><strong>b</strong><span class="classifier">(N,) array_like</span></dt><dd><p>Second input vector.  Input is flattened if
not already 1-dimensional.</p>
</dd>
<dt><strong>out</strong><span class="classifier">(M, N) ndarray, optional</span></dt><dd><p>A location where the result is stored</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">out[i,</span> <span class="pre">j]</span> <span class="pre">=</span> <span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[j]</span></code></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">inner</span></code></p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.einsum" title="dask.array.einsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">einsum</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">einsum('i,j-&gt;ij',</span> <span class="pre">a.ravel(),</span> <span class="pre">b.ravel())</span></code> is the equivalent.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ufunc.outer</span></code></dt><dd><p>A generalization to N dimensions and other operations. <code class="docutils literal notranslate"><span class="pre">np.multiply.outer(a.ravel(),</span> <span class="pre">b.ravel())</span></code> is the equivalent.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc80873b5d19f-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id27">1</a>,<a href="#id28">2</a>)</span></dt>
<dd><p>: G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>, 3rd
ed., Baltimore, MD, Johns Hopkins University Press, 1996,
pg. 8.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Make a (<em>very</em> coarse) grid for computing a Mandelbrot set:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,)),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">rl</span>  
<span class="go">array([[-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,)))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span>  
<span class="go">array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],</span>
<span class="go">       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],</span>
<span class="go">       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],</span>
<span class="go">       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],</span>
<span class="go">       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">rl</span> <span class="o">+</span> <span class="n">im</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span>  
<span class="go">array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],</span>
<span class="go">       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],</span>
<span class="go">       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],</span>
<span class="go">       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],</span>
<span class="go">       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])</span>
</pre></div>
</div>
<p>An example using a “vector” of letters:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="go">array([[&#39;a&#39;, &#39;aa&#39;, &#39;aaa&#39;],</span>
<span class="go">       [&#39;b&#39;, &#39;bb&#39;, &#39;bbb&#39;],</span>
<span class="go">       [&#39;c&#39;, &#39;cc&#39;, &#39;ccc&#39;]], dtype=object)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.pad">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">pad</code><span class="sig-paren">(</span><em class="sig-param">array</em>, <em class="sig-param">pad_width</em>, <em class="sig-param">mode</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pad an array.</p>
<p>This docstring was copied from numpy.pad.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>array</strong><span class="classifier">array_like of rank N</span></dt><dd><p>The array to pad.</p>
</dd>
<dt><strong>pad_width</strong><span class="classifier">{sequence, array_like, int}</span></dt><dd><p>Number of values padded to the edges of each axis.
((before_1, after_1), … (before_N, after_N)) unique pad widths
for each axis.
((before, after),) yields same before and after pad for each axis.
(pad,) or int is a shortcut for before = after = pad width for all
axes.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str or function, optional</span></dt><dd><p>One of the following string values or a user supplied function.</p>
<dl>
<dt>‘constant’ (default)</dt><dd><p>Pads with a constant value.</p>
</dd>
<dt>‘edge’</dt><dd><p>Pads with the edge values of array.</p>
</dd>
<dt>‘linear_ramp’</dt><dd><p>Pads with the linear ramp between end_value and the
array edge value.</p>
</dd>
<dt>‘maximum’</dt><dd><p>Pads with the maximum value of all or part of the
vector along each axis.</p>
</dd>
<dt>‘mean’</dt><dd><p>Pads with the mean value of all or part of the
vector along each axis.</p>
</dd>
<dt>‘median’</dt><dd><p>Pads with the median value of all or part of the
vector along each axis.</p>
</dd>
<dt>‘minimum’</dt><dd><p>Pads with the minimum value of all or part of the
vector along each axis.</p>
</dd>
<dt>‘reflect’</dt><dd><p>Pads with the reflection of the vector mirrored on
the first and last values of the vector along each
axis.</p>
</dd>
<dt>‘symmetric’</dt><dd><p>Pads with the reflection of the vector mirrored
along the edge of the array.</p>
</dd>
<dt>‘wrap’</dt><dd><p>Pads with the wrap of the vector along the axis.
The first values are used to pad the end and the
end values are used to pad the beginning.</p>
</dd>
<dt>‘empty’</dt><dd><p>Pads with undefined values.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.</span></p>
</div>
</dd>
<dt>&lt;function&gt;</dt><dd><p>Padding function, see Notes.</p>
</dd>
</dl>
</dd>
<dt><strong>stat_length</strong><span class="classifier">sequence or int, optional</span></dt><dd><p>Used in ‘maximum’, ‘mean’, ‘median’, and ‘minimum’.  Number of
values at edge of each axis used to calculate the statistic value.</p>
<p>((before_1, after_1), … (before_N, after_N)) unique statistic
lengths for each axis.</p>
<p>((before, after),) yields same before and after statistic lengths
for each axis.</p>
<p>(stat_length,) or int is a shortcut for before = after = statistic
length for all axes.</p>
<p>Default is <code class="docutils literal notranslate"><span class="pre">None</span></code>, to use the entire axis.</p>
</dd>
<dt><strong>constant_values</strong><span class="classifier">sequence or scalar, optional</span></dt><dd><p>Used in ‘constant’.  The values to set the padded values for each
axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">((before_1,</span> <span class="pre">after_1),</span> <span class="pre">...</span> <span class="pre">(before_N,</span> <span class="pre">after_N))</span></code> unique pad constants
for each axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">((before,</span> <span class="pre">after),)</span></code> yields same before and after constants for each
axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">(constant,)</span></code> or <code class="docutils literal notranslate"><span class="pre">constant</span></code> is a shortcut for <code class="docutils literal notranslate"><span class="pre">before</span> <span class="pre">=</span> <span class="pre">after</span> <span class="pre">=</span> <span class="pre">constant</span></code> for
all axes.</p>
<p>Default is 0.</p>
</dd>
<dt><strong>end_values</strong><span class="classifier">sequence or scalar, optional</span></dt><dd><p>Used in ‘linear_ramp’.  The values used for the ending value of the
linear_ramp and that will form the edge of the padded array.</p>
<p><code class="docutils literal notranslate"><span class="pre">((before_1,</span> <span class="pre">after_1),</span> <span class="pre">...</span> <span class="pre">(before_N,</span> <span class="pre">after_N))</span></code> unique end values
for each axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">((before,</span> <span class="pre">after),)</span></code> yields same before and after end values for each
axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">(constant,)</span></code> or <code class="docutils literal notranslate"><span class="pre">constant</span></code> is a shortcut for <code class="docutils literal notranslate"><span class="pre">before</span> <span class="pre">=</span> <span class="pre">after</span> <span class="pre">=</span> <span class="pre">constant</span></code> for
all axes.</p>
<p>Default is 0.</p>
</dd>
<dt><strong>reflect_type</strong><span class="classifier">{‘even’, ‘odd’}, optional</span></dt><dd><p>Used in ‘reflect’, and ‘symmetric’.  The ‘even’ style is the
default with an unaltered reflection around the edge value.  For
the ‘odd’ style, the extended part of the array is created by
subtracting the reflected values from two times the edge value.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pad</strong><span class="classifier">ndarray</span></dt><dd><p>Padded array of rank equal to <cite>array</cite> with shape increased
according to <cite>pad_width</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>For an array with rank greater than 1, some of the padding of later
axes is calculated from padding of previous axes.  This is easiest to
think about with a rank 2 array where the corners of the padded array
are calculated by using padded values from the first axis.</p>
<p>The padding function, if used, should modify a rank 1 array in-place. It
has the following signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">padding_func</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">iaxis_pad_width</span><span class="p">,</span> <span class="n">iaxis</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<blockquote>
<div><dl class="simple">
<dt>vector<span class="classifier">ndarray</span></dt><dd><p>A rank 1 array already padded with zeros.  Padded values are
vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].</p>
</dd>
<dt>iaxis_pad_width<span class="classifier">tuple</span></dt><dd><p>A 2-tuple of ints, iaxis_pad_width[0] represents the number of
values padded at the beginning of vector where
iaxis_pad_width[1] represents the number of values padded at
the end of vector.</p>
</dd>
<dt>iaxis<span class="classifier">int</span></dt><dd><p>The axis currently being calculated.</p>
</dd>
<dt>kwargs<span class="classifier">dict</span></dt><dd><p>Any keyword arguments the function requires.</p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>  
<span class="go">array([4, 4, 1, ..., 6, 6, 6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;edge&#39;</span><span class="p">)</span>  
<span class="go">array([1, 1, 1, ..., 5, 5, 5])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;linear_ramp&#39;</span><span class="p">,</span> <span class="n">end_values</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">))</span>  
<span class="go">array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;maximum&#39;</span><span class="p">)</span>  
<span class="go">array([5, 5, 1, 2, 3, 4, 5, 5, 5])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;mean&#39;</span><span class="p">)</span>  
<span class="go">array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;median&#39;</span><span class="p">)</span>  
<span class="go">array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="s1">&#39;minimum&#39;</span><span class="p">)</span>  
<span class="go">array([[1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [3, 3, 3, 4, 3, 3, 3],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;reflect&#39;</span><span class="p">)</span>  
<span class="go">array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">)</span>  
<span class="go">array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>  
<span class="go">array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">)</span>  
<span class="go">array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;wrap&#39;</span><span class="p">)</span>  
<span class="go">array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pad_with</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">iaxis</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="n">pad_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;padder&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">vector</span><span class="p">[:</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pad_value</span>
<span class="gp">... </span>    <span class="n">vector</span><span class="p">[</span><span class="o">-</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">pad_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_with</span><span class="p">)</span>  
<span class="go">array([[10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10,  0,  1,  2, 10, 10],</span>
<span class="go">       [10, 10,  3,  4,  5, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_with</span><span class="p">,</span> <span class="n">padder</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>  
<span class="go">array([[100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100,   0,   1,   2, 100, 100],</span>
<span class="go">       [100, 100,   3,   4,   5, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.percentile">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">percentile</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">q</em>, <em class="sig-param">interpolation='linear'</em>, <em class="sig-param">method='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.percentile" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate percentile of 1-D array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">Array</span></dt><dd></dd>
<dt><strong>q</strong><span class="classifier">array_like of float</span></dt><dd><p>Percentile or sequence of percentiles to compute, which must be between
0 and 100 inclusive.</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">{‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}, optional</span></dt><dd><p>The interpolation method to use when the desired percentile lies
between two data points <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>. Only valid for <code class="docutils literal notranslate"><span class="pre">method='dask'</span></code>.</p>
<ul class="simple">
<li><p>‘linear’: <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">(j</span> <span class="pre">-</span> <span class="pre">i)</span> <span class="pre">*</span> <span class="pre">fraction</span></code>, where <code class="docutils literal notranslate"><span class="pre">fraction</span></code>
is the fractional part of the index surrounded by <code class="docutils literal notranslate"><span class="pre">i</span></code>
and <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></li>
<li><p>‘lower’: <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p></li>
<li><p>‘higher’: <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></li>
<li><p>‘nearest’: <code class="docutils literal notranslate"><span class="pre">i</span></code> or <code class="docutils literal notranslate"><span class="pre">j</span></code>, whichever is nearest.</p></li>
<li><p>‘midpoint’: <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">+</span> <span class="pre">j)</span> <span class="pre">/</span> <span class="pre">2</span></code>.</p></li>
</ul>
</dd>
<dt><strong>method</strong><span class="classifier">{‘default’, ‘dask’, ‘tdigest’}, optional</span></dt><dd><p>What method to use. By default will use dask’s internal custom
algorithm (<code class="docutils literal notranslate"><span class="pre">'dask'</span></code>).  If set to <code class="docutils literal notranslate"><span class="pre">'tdigest'</span></code> will use tdigest for
floats and ints and fallback to the <code class="docutils literal notranslate"><span class="pre">'dask'</span></code> otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.percentile.html#numpy.percentile" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.percentile</span></code></a></dt><dd><p>Numpy’s equivalent Percentile function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.piecewise">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">piecewise</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">condlist</em>, <em class="sig-param">funclist</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.piecewise" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a piecewise-defined function.</p>
<p>This docstring was copied from numpy.piecewise.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Given a set of conditions and corresponding functions, evaluate each
function on the input data wherever its condition is true.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The input domain.</p>
</dd>
<dt><strong>condlist</strong><span class="classifier">list of bool arrays or bool scalars</span></dt><dd><p>Each boolean array corresponds to a function in <cite>funclist</cite>.  Wherever
<cite>condlist[i]</cite> is True, <cite>funclist[i](x)</cite> is used as the output value.</p>
<p>Each boolean array in <cite>condlist</cite> selects a piece of <cite>x</cite>,
and should therefore be of the same shape as <cite>x</cite>.</p>
<p>The length of <cite>condlist</cite> must correspond to that of <cite>funclist</cite>.
If one extra function is given, i.e. if
<code class="docutils literal notranslate"><span class="pre">len(funclist)</span> <span class="pre">==</span> <span class="pre">len(condlist)</span> <span class="pre">+</span> <span class="pre">1</span></code>, then that extra function
is the default value, used wherever all conditions are false.</p>
</dd>
<dt><strong>funclist</strong><span class="classifier">list of callables, f(x,*args,**kw), or scalars</span></dt><dd><p>Each function is evaluated over <cite>x</cite> wherever its corresponding
condition is True.  It should take a 1d array as input and give an 1d
array or a scalar value as output.  If, instead of a callable,
a scalar is provided then a constant function (<code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">scalar</span></code>) is
assumed.</p>
</dd>
<dt><strong>args</strong><span class="classifier">tuple, optional</span></dt><dd><p>Any further arguments given to <cite>piecewise</cite> are passed to the functions
upon execution, i.e., if called <code class="docutils literal notranslate"><span class="pre">piecewise(...,</span> <span class="pre">...,</span> <span class="pre">1,</span> <span class="pre">'a')</span></code>, then
each function is called as <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">1,</span> <span class="pre">'a')</span></code>.</p>
</dd>
<dt><strong>kw</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword arguments used in calling <cite>piecewise</cite> are passed to the
functions upon execution, i.e., if called
<code class="docutils literal notranslate"><span class="pre">piecewise(...,</span> <span class="pre">...,</span> <span class="pre">alpha=1)</span></code>, then each function is called as
<code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">alpha=1)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>The output is the same shape and type as x and is found by
calling the functions in <cite>funclist</cite> on the appropriate portions of <cite>x</cite>,
as defined by the boolean arrays in <cite>condlist</cite>.  Portions not covered
by any condition have a default value of 0.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.choose" title="dask.array.choose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">select</span></code>, <a class="reference internal" href="#dask.array.where" title="dask.array.where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">where</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This is similar to choose or select, except that functions are
evaluated on elements of <cite>x</cite> that satisfy the corresponding condition from
<cite>condlist</cite>.</p>
<p>The result is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="o">|--</span>
      <span class="o">|</span><span class="n">funclist</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">x</span><span class="p">[</span><span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">out</span> <span class="o">=</span> <span class="o">|</span><span class="n">funclist</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">x</span><span class="p">[</span><span class="n">condlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
      <span class="o">|...</span>
      <span class="o">|</span><span class="n">funclist</span><span class="p">[</span><span class="n">n2</span><span class="p">](</span><span class="n">x</span><span class="p">[</span><span class="n">condlist</span><span class="p">[</span><span class="n">n2</span><span class="p">]])</span>
      <span class="o">|--</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<p>Define the sigma function, which is -1 for <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> and +1 for <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  
<span class="go">array([-1., -1., -1.,  1.,  1.,  1.])</span>
</pre></div>
</div>
<p>Define the absolute value, which is <code class="docutils literal notranslate"><span class="pre">-x</span></code> for <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;0</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> for
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">])</span>  
<span class="go">array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])</span>
</pre></div>
</div>
<p>Apply the same function to a scalar value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">piecewise</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">])</span>  
<span class="go">array(2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.prod">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">prod</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of array elements over a given axis.</p>
<p>This docstring was copied from numpy.prod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which a product is performed.  The default,
axis=None, will calculate the product of all the elements in the
input array. If axis is negative it counts from the last to the
first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If axis is a tuple of ints, a product is performed on all of the
axes specified in the tuple instead of a single axis or all the
axes as before.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>The type of the returned array, as well as of the accumulator in
which the elements are multiplied.  The dtype of <cite>a</cite> is used by
default unless <cite>a</cite> has an integer dtype of less precision than the
default platform integer.  In that case, if <cite>a</cite> is signed then the
platform integer is used while if <cite>a</cite> is unsigned then an unsigned
integer of the same precision as the platform integer is used.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>prod</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt><strong>initial</strong><span class="classifier">scalar, optional  (Not supported in Dask)</span></dt><dd><p>The starting value for this product. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</dd>
<dt><strong>where</strong><span class="classifier">array_like of bool, optional  (Not supported in Dask)</span></dt><dd><p>Elements to include in the product. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>product_along_axis</strong><span class="classifier">ndarray, see <cite>dtype</cite> parameter above.</span></dt><dd><p>An array shaped as <cite>a</cite> but with the specified axis removed.
Returns a reference to <cite>out</cite> if specified.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.prod</span></code></dt><dd><p>equivalent method</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ufuncs-output-type</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">16 # may vary</span>
</pre></div>
</div>
<p>The product of an empty array is the neutral element 1:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([])</span>  
<span class="go">1.0</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<p>By default, calculate the product of all elements:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">])</span>  
<span class="go">2.0</span>
</pre></div>
</div>
<p>Even when the input array is two-dimensional:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>  
<span class="go">24.0</span>
</pre></div>
</div>
<p>But we can also specify the axis over which to multiply:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([  2.,  12.])</span>
</pre></div>
</div>
<p>Or select specific elements to include:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>  
<span class="go">3.0</span>
</pre></div>
</div>
<p>If the type of <cite>x</cite> is unsigned, then the output type is
the unsigned platform integer:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint</span>  
<span class="go">True</span>
</pre></div>
</div>
<p>If <cite>x</cite> is of a signed integer type, then the output type
is the default platform integer:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span>  
<span class="go">True</span>
</pre></div>
</div>
<p>You can also start the product with a value other than one:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ptp">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">ptp</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ptp" title="Permalink to this definition">¶</a></dt>
<dd><p>Range of values (maximum - minimum) along an axis.</p>
<p>This docstring was copied from numpy.ptp.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The name of the function comes from the acronym for ‘peak to peak’.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input values.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis along which to find the peaks.  By default, flatten the
array.  <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
<p>If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt><strong>out</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type of the output values will be cast if necessary.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>ptp</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ptp</strong><span class="classifier">ndarray</span></dt><dd><p>A new array holding the result, unless <cite>out</cite> was
specified, in which case a reference to <cite>out</cite> is returned.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([2, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([1, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.rad2deg">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">rad2deg</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.rad2deg" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.rad2deg.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Convert angles from radians to degrees.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Angle in radians.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The corresponding angle in degrees.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.deg2rad" title="dask.array.deg2rad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deg2rad</span></code></a></dt><dd><p>Convert angles from degrees to radians.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">unwrap</span></code></dt><dd><p>Remove large jumps in angle by wrapping.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p>rad2deg(x) is <code class="docutils literal notranslate"><span class="pre">180</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">/</span> <span class="pre">pi</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">90.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.radians">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">radians</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.radians" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.radians.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Convert angles from degrees to radians.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array in degrees.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The corresponding radian values.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.deg2rad" title="dask.array.deg2rad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deg2rad</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Convert a degree array to radians</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">12.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">30.</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">deg</span><span class="p">)</span>  
<span class="go">array([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,</span>
<span class="go">        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,</span>
<span class="go">        5.23598776,  5.75958653])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">deg</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">deg</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ret</span> <span class="ow">is</span> <span class="n">out</span>  
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ravel">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">ravel</code><span class="sig-paren">(</span><em class="sig-param">array</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a contiguous flattened array.</p>
<p>This docstring was copied from numpy.ravel.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>A 1-D array, containing the elements of the input, is returned.  A copy is
made only if needed.</p>
<p>As of NumPy 1.10, the returned array will have the same type as the input
array. (for example, a masked array will be returned for a masked array
input)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input array.  The elements in <cite>a</cite> are read in the order specified by
<cite>order</cite>, and packed as a 1-D array.</p>
</dd>
<dt><strong>order</strong><span class="classifier">{‘C’,’F’, ‘A’, ‘K’}, optional  (Not supported in Dask)</span></dt><dd><p>The elements of <cite>a</cite> are read using this index order. ‘C’ means
to index the elements in row-major, C-style order,
with the last axis index changing fastest, back to the first
axis index changing slowest.  ‘F’ means to index the elements
in column-major, Fortran-style order, with the
first index changing fastest, and the last index changing
slowest. Note that the ‘C’ and ‘F’ options take no account of
the memory layout of the underlying array, and only refer to
the order of axis indexing.  ‘A’ means to read the elements in
Fortran-like index order if <cite>a</cite> is Fortran <em>contiguous</em> in
memory, C-like order otherwise.  ‘K’ means to read the
elements in the order they occur in memory, except for
reversing the data when strides are negative.  By default, ‘C’
index order is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>y is an array of the same subtype as <cite>a</cite>, with shape <code class="docutils literal notranslate"><span class="pre">(a.size,)</span></code>.
Note that matrices are special cased for backward compatibility, if <cite>a</cite>
is a matrix, then y is a 1-D ndarray.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.flat</span></code></dt><dd><p>1-D iterator over an array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.flatten</span></code></dt><dd><p>1-D array copy of the elements of an array in row-major order.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.reshape</span></code></dt><dd><p>Change the shape of an array without changing its data.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>In row-major, C-style order, in two dimensions, the row index
varies the slowest, and the column index the quickest.  This can
be generalized to multiple dimensions, where row-major order
implies that the index along the first axis varies slowest, and
the index along the last quickest.  The opposite holds for
column-major, Fortran-style index ordering.</p>
<p>When a view is desired in as many cases as possible, <code class="docutils literal notranslate"><span class="pre">arr.reshape(-1)</span></code>
may be preferable.</p>
<p class="rubric">Examples</p>
<p>It is equivalent to <code class="docutils literal notranslate"><span class="pre">reshape(-1,</span> <span class="pre">order=order)</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>  
<span class="go">array([1, 4, 2, 5, 3, 6])</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">order</span></code> is ‘A’, it will preserve the array’s ‘C’ or ‘F’ ordering:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  
<span class="go">array([1, 4, 2, 5, 3, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>  
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">order</span></code> is ‘K’, it will preserve orderings that are neither ‘C’
nor ‘F’, but won’t reverse axes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">a</span>  
<span class="go">array([2, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>  
<span class="go">array([2, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>  
<span class="go">array([2, 1, 0])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span>  
<span class="go">array([[[ 0,  2,  4],</span>
<span class="go">        [ 1,  3,  5]],</span>
<span class="go">       [[ 6,  8, 10],</span>
<span class="go">        [ 7,  9, 11]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>  
<span class="go">array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>  
<span class="go">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.real">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">real</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real part of the complex argument.</p>
<p>This docstring was copied from numpy.real.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>val</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The real component of the complex argument. If <cite>val</cite> is real, the type
of <cite>val</cite> is used for the output.  If <cite>val</cite> has complex elements, the
returned type is float.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_if_close</span></code>, <a class="reference internal" href="#dask.array.imag" title="dask.array.imag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">imag</span></code></a>, <a class="reference internal" href="#dask.array.angle" title="dask.array.angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">,</span> <span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span>  
<span class="go">array([1.,  3.,  5.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="mi">9</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([9.+2.j,  9.+4.j,  9.+6.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([9.+2.j,  8.+4.j,  7.+6.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>  
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.rechunk">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">rechunk</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">chunks='auto'</em>, <em class="sig-param">threshold=None</em>, <em class="sig-param">block_size_limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.rechunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert blocks in dask array x for new chunks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x: dask array</strong></dt><dd><p>Array to be rechunked.</p>
</dd>
<dt><strong>chunks:  int, tuple, dict or str, optional</strong></dt><dd><p>The new block dimensions to create. -1 indicates the full size of the
corresponding dimension. Default is “auto” which automatically
determines chunk sizes.</p>
</dd>
<dt><strong>threshold: int, optional</strong></dt><dd><p>The graph growth factor under which we don’t bother introducing an
intermediate step.</p>
</dd>
<dt><strong>block_size_limit: int, optional</strong></dt><dd><p>The maximum block size (in bytes) we want to produce
Defaults to the configuration value <code class="docutils literal notranslate"><span class="pre">array.chunk-size</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
</pre></div>
</div>
<p>Specify uniform chunk sizes with a tuple</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">rechunk</span><span class="p">((</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<p>Or chunk only specific dimensions with a dictionary</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">rechunk</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1000</span><span class="p">})</span>
</pre></div>
</div>
<p>Use the value <code class="docutils literal notranslate"><span class="pre">-1</span></code> to specify that you want a single chunk along a
dimension or the value <code class="docutils literal notranslate"><span class="pre">&quot;auto&quot;</span></code> to specify that dask can freely rechunk a
dimension to attain blocks of a uniform block size</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">rechunk</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;auto&#39;</span><span class="p">},</span> <span class="n">block_size_limit</span><span class="o">=</span><span class="mf">1e8</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.reduction">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">reduction</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">chunk</em>, <em class="sig-param">aggregate</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">combine=None</em>, <em class="sig-param">name=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">concatenate=True</em>, <em class="sig-param">output_size=1</em>, <em class="sig-param">meta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.reduction" title="Permalink to this definition">¶</a></dt>
<dd><p>General version of reductions</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x: Array</strong></dt><dd><p>Data being reduced along one or more axes</p>
</dd>
<dt><strong>chunk: callable(x_chunk, axis, keepdims)</strong></dt><dd><p>First function to be executed when resolving the dask graph.
This function is applied in parallel to all original chunks of x.
See below for function parameters.</p>
</dd>
<dt><strong>combine: callable(x_chunk, axis, keepdims), optional</strong></dt><dd><p>Function used for intermediate recursive aggregation (see
split_every below). If omitted, it defaults to aggregate.
If the reduction can be performed in less than 3 steps, it will not
be invoked at all.</p>
</dd>
<dt><strong>aggregate: callable(x_chunk, axis, keepdims)</strong></dt><dd><p>Last function to be executed when resolving the dask graph,
producing the final output. It is always invoked, even when the reduced
Array counts a single chunk along the reduced axes.</p>
</dd>
<dt><strong>axis: int or sequence of ints, optional</strong></dt><dd><p>Axis or axes to aggregate upon. If omitted, aggregate along all axes.</p>
</dd>
<dt><strong>keepdims: boolean, optional</strong></dt><dd><p>Whether the reduction function should preserve the reduced axes,
leaving them at size <code class="docutils literal notranslate"><span class="pre">output_size</span></code>, or remove them.</p>
</dd>
<dt><strong>dtype: np.dtype, optional</strong></dt><dd><p>Force output dtype. Defaults to x.dtype if omitted.</p>
</dd>
<dt><strong>split_every: int &gt;= 2 or dict(axis: int), optional</strong></dt><dd><p>Determines the depth of the recursive aggregation. If set to or more
than the number of input chunks, the aggregation will be performed in
two steps, one <code class="docutils literal notranslate"><span class="pre">chunk</span></code> function per input chunk and a single
<code class="docutils literal notranslate"><span class="pre">aggregate</span></code> function at the end. If set to less than that, an
intermediate <code class="docutils literal notranslate"><span class="pre">combine</span></code> function will be used, so that any one
<code class="docutils literal notranslate"><span class="pre">combine</span></code> or <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> function has no more than <code class="docutils literal notranslate"><span class="pre">split_every</span></code>
inputs. The depth of the aggregation graph will be
<span class="math notranslate nohighlight">\(log_{split_every}(input chunks along reduced axes)\)</span>. Setting to
a low value can reduce cache size and network transfers, at the cost of
more CPU and a larger dask graph.</p>
<p>Omit to let dask heuristically decide a good default. A default can
also be set globally with the <code class="docutils literal notranslate"><span class="pre">split_every</span></code> key in
<code class="xref py py-mod docutils literal notranslate"><span class="pre">dask.config</span></code>.</p>
</dd>
<dt><strong>name: str, optional</strong></dt><dd><p>Prefix of the keys of the intermediate and output nodes. If omitted it
defaults to the function names.</p>
</dd>
<dt><strong>out: Array, optional</strong></dt><dd><p>Another dask array whose contents will be replaced. Omit to create a
new one. Note that, unlike in numpy, this setting gives no performance
benefits whatsoever, but can still be useful  if one needs to preserve
the references to a previously existing Array.</p>
</dd>
<dt><strong>concatenate: bool, optional</strong></dt><dd><p>If True (the default), the outputs of the <code class="docutils literal notranslate"><span class="pre">chunk</span></code>/<code class="docutils literal notranslate"><span class="pre">combine</span></code>
functions are concatenated into a single np.array before being passed
to the <code class="docutils literal notranslate"><span class="pre">combine</span></code>/<code class="docutils literal notranslate"><span class="pre">aggregate</span></code> functions. If False, the input of
<code class="docutils literal notranslate"><span class="pre">combine</span></code> and <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> will be either a list of the raw outputs
of the previous step or a single output, and the function will have to
concatenate it itself. It can be useful to set this to False if the
chunk and/or combine steps do not produce np.arrays.</p>
</dd>
<dt><strong>output_size: int &gt;= 1, optional</strong></dt><dd><p>Size of the output of the <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> function along the reduced
axes. Ignored if keepdims is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dask array</strong></dt><dd></dd>
<dt><strong>**Function Parameters**</strong></dt><dd></dd>
<dt><strong>x_chunk: numpy.ndarray</strong></dt><dd><p>Individual input chunk. For <code class="docutils literal notranslate"><span class="pre">chunk</span></code> functions, it is one of the
original chunks of x. For <code class="docutils literal notranslate"><span class="pre">combine</span></code> and <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> functions, it’s
the concatenation of the outputs produced by the previous <code class="docutils literal notranslate"><span class="pre">chunk</span></code> or
<code class="docutils literal notranslate"><span class="pre">combine</span></code> functions. If concatenate=False, it’s a list of the raw
outputs from the previous functions.</p>
</dd>
<dt><strong>axis: tuple</strong></dt><dd><p>Normalized list of axes to reduce upon, e.g. <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">)</span></code>
Scalar, negative, and None axes have been normalized away.
Note that some numpy reduction functions cannot reduce along multiple
axes at once and strictly require an int in input. Such functions have
to be wrapped to cope.</p>
</dd>
<dt><strong>keepdims: bool</strong></dt><dd><p>Whether the reduction function should preserve the reduced axes or
remove them.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.array.repeat">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">repeat</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">repeats</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeat elements of an array.</p>
<p>This docstring was copied from numpy.repeat.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int or array of ints</span></dt><dd><p>The number of repetitions for each element.  <cite>repeats</cite> is broadcasted
to fit the shape of the given axis.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>The axis along which to repeat values.  By default, use the
flattened input array, and return a flat output array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>repeated_array</strong><span class="classifier">ndarray</span></dt><dd><p>Output array which has the same shape as <cite>a</cite>, except along
the given axis.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.tile" title="dask.array.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a></dt><dd><p>Tile an array.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  
<span class="go">array([3, 3, 3, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">array([1, 1, 2, 2, 3, 3, 4, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[1, 1, 1, 2, 2, 2],</span>
<span class="go">       [3, 3, 3, 4, 4, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.reshape">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">reshape</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">shape</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape array to new shape</p>
<p>This is a parallelized version of the <code class="docutils literal notranslate"><span class="pre">np.reshape</span></code> function with the
following limitations:</p>
<ol class="arabic simple">
<li><p>It assumes that the array is stored in <a class="reference external" href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">row-major order</a></p></li>
<li><p>It only allows for reshapings that collapse or merge dimensions like
<code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4)</span> <span class="pre">-&gt;</span> <span class="pre">(1,</span> <span class="pre">6,</span> <span class="pre">4)</span></code> or <code class="docutils literal notranslate"><span class="pre">(64,)</span> <span class="pre">-&gt;</span> <span class="pre">(4,</span> <span class="pre">4,</span> <span class="pre">4)</span></code></p></li>
</ol>
<p>When communication is necessary this algorithm depends on the logic within
rechunk.  It endeavors to keep chunk sizes roughly the same when possible.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.rechunk" title="dask.array.rechunk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.rechunk</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html#numpy.reshape" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.reshape</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.result_type">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">result_type</code><span class="sig-paren">(</span><em class="sig-param">*arrays_and_dtypes</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.result_type" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.result_type.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns the type that results from applying the NumPy
type promotion rules to the arguments.</p>
<p>Type promotion in NumPy works similarly to the rules in languages
like C++, with some slight differences.  When both scalars and
arrays are used, the array’s type takes precedence and the actual value
of the scalar is taken into account.</p>
<p>For example, calculating 3*a, where a is an array of 32-bit floats,
intuitively should result in a 32-bit float output.  If the 3 is a
32-bit integer, the NumPy rules indicate it can’t convert losslessly
into a 32-bit float, so a 64-bit float should be the result type.
By examining the value of the constant, ‘3’, we see that it fits in
an 8-bit integer, which can be cast losslessly into the 32-bit float.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arrays_and_dtypes</strong><span class="classifier">list of arrays and dtypes</span></dt><dd><p>The operands of some operation whose result type is needed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">dtype</span></dt><dd><p>The result type.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">promote_types</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">min_scalar_type</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">can_cast</span></code></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
<p>The specific algorithm used is as follows.</p>
<p>Categories are determined by first checking which of boolean,
integer (int/uint), or floating point (float/complex) the maximum
kind of all the arrays and the scalars are.</p>
<p>If there are only scalars or the maximum category of the scalars
is higher than the maximum category of the arrays,
the data types are combined with <code class="xref py py-func docutils literal notranslate"><span class="pre">promote_types()</span></code>
to produce the return value.</p>
<p>Otherwise, <cite>min_scalar_type</cite> is called on each array, and
the resulting data types are all combined with <code class="xref py py-func docutils literal notranslate"><span class="pre">promote_types()</span></code>
to produce the return value.</p>
<p>The set of int values is not a subset of the uint values for types
with the same number of bits, something not reflected in
<code class="xref py py-func docutils literal notranslate"><span class="pre">min_scalar_type()</span></code>, but handled as a special case in <cite>result_type</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i1&#39;</span><span class="p">))</span>  
<span class="go">dtype(&#39;int8&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;c8&#39;</span><span class="p">)</span>  
<span class="go">dtype(&#39;complex128&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.rint">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">rint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.rint" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.rint.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Round elements of the array to the nearest integer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Output array is same shape and type as <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.ceil" title="dask.array.ceil"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceil</span></code></a>, <a class="reference internal" href="#dask.array.floor" title="dask.array.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a>, <a class="reference internal" href="#dask.array.trunc" title="dask.array.trunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trunc</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">array([-2., -2., -0.,  0.,  2.,  2.,  2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.roll">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">roll</code><span class="sig-paren">(</span><em class="sig-param">array</em>, <em class="sig-param">shift</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.roll" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll array elements along a given axis.</p>
<p>This docstring was copied from numpy.roll.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Elements that roll beyond the last position are re-introduced at
the first.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>shift</strong><span class="classifier">int or tuple of ints</span></dt><dd><p>The number of places by which elements are shifted.  If a tuple,
then <cite>axis</cite> must be a tuple of the same size, and each of the
given axes is shifted by the corresponding number.  If an int
while <cite>axis</cite> is a tuple of ints, then the same value is used for
all given axes.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which elements are shifted.  By default, the
array is flattened before shifting, after which the original
shape is restored.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>res</strong><span class="classifier">ndarray</span></dt><dd><p>Output array, with the same shape as <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.rollaxis" title="dask.array.rollaxis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rollaxis</span></code></a></dt><dd><p>Roll the specified axis backwards, until it lies in a given position.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<p>Supports rolling over multiple dimensions simultaneously.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span>  
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [5, 6, 7, 8, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[9, 0, 1, 2, 3],</span>
<span class="go">       [4, 5, 6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[1, 2, 3, 4, 5],</span>
<span class="go">       [6, 7, 8, 9, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([[5, 6, 7, 8, 9],</span>
<span class="go">       [0, 1, 2, 3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([[5, 6, 7, 8, 9],</span>
<span class="go">       [0, 1, 2, 3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[4, 0, 1, 2, 3],</span>
<span class="go">       [9, 5, 6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[1, 2, 3, 4, 0],</span>
<span class="go">       [6, 7, 8, 9, 5]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.rollaxis">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">rollaxis</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis</em>, <em class="sig-param">start=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.rollaxis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="dask.array.round">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">round</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">decimals=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Round an array to the given number of decimals.</p>
<p>This docstring was copied from numpy.round.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.around" title="dask.array.around"><code class="xref py py-obj docutils literal notranslate"><span class="pre">around</span></code></a></dt><dd><p>equivalent function; see for details.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.sign">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">sign</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.sign.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns an element-wise indication of the sign of a number.</p>
<p>The <cite>sign</cite> function returns <code class="docutils literal notranslate"><span class="pre">-1</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0,</span> <span class="pre">0</span> <span class="pre">if</span> <span class="pre">x==0,</span> <span class="pre">1</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.  nan
is returned for nan inputs.</p>
<p>For complex inputs, the <cite>sign</cite> function returns
<code class="docutils literal notranslate"><span class="pre">sign(x.real)</span> <span class="pre">+</span> <span class="pre">0j</span> <span class="pre">if</span> <span class="pre">x.real</span> <span class="pre">!=</span> <span class="pre">0</span> <span class="pre">else</span> <span class="pre">sign(x.imag)</span> <span class="pre">+</span> <span class="pre">0j</span></code>.</p>
<p>complex(nan, 0) is returned for complex nan inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input values.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The sign of <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>There is more than one definition of sign in common use for complex
numbers.  The definition used here is equivalent to <span class="math notranslate nohighlight">\(x/\sqrt{x*x}\)</span>
which is different from a common alternative, <span class="math notranslate nohighlight">\(x/|x|\)</span>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">([</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">])</span>  
<span class="go">array([-1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="p">)</span>  
<span class="go">(1+0j)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.signbit">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">signbit</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.signbit" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.signbit.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns element-wise True where signbit is set (less than zero).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>The input value(s).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">ndarray of bool</span></dt><dd><p>Output array, or reference to <cite>out</cite> if that was supplied.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">signbit</span><span class="p">(</span><span class="o">-</span><span class="mf">1.2</span><span class="p">)</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">signbit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">]))</span>  
<span class="go">array([False,  True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.sin">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">sin</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.sin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Trigonometric sine, element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Angle, in radians (<span class="math notranslate nohighlight">\(2 \pi\)</span> rad equals 360 degrees).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>The sine of each element of x.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.arcsin" title="dask.array.arcsin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arcsin</span></code></a>, <a class="reference internal" href="#dask.array.sinh" title="dask.array.sinh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sinh</span></code></a>, <a class="reference internal" href="#dask.array.cos" title="dask.array.cos"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cos</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The sine is one of the fundamental functions of trigonometry (the
mathematical study of triangles).  Consider a circle of radius 1
centered on the origin.  A ray comes in from the <span class="math notranslate nohighlight">\(+x\)</span> axis, makes
an angle at the origin (measured counter-clockwise from that axis), and
departs from the origin.  The <span class="math notranslate nohighlight">\(y\)</span> coordinate of the outgoing
ray’s intersection with the unit circle is the sine of that angle.  It
ranges from -1 for <span class="math notranslate nohighlight">\(x=3\pi / 2\)</span> to +1 for <span class="math notranslate nohighlight">\(\pi / 2.\)</span>  The
function has zeroes where the angle is a multiple of <span class="math notranslate nohighlight">\(\pi\)</span>.
Sines of angles between <span class="math notranslate nohighlight">\(\pi\)</span> and <span class="math notranslate nohighlight">\(2\pi\)</span> are negative.
The numerous properties of the sine and related functions are included
in any standard trigonometry text.</p>
<p class="rubric">Examples</p>
<p>Print sine of one angle:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>  
<span class="go">1.0</span>
</pre></div>
</div>
<p>Print sines of an array of angles given in degrees:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">30.</span><span class="p">,</span> <span class="mf">45.</span><span class="p">,</span> <span class="mf">60.</span><span class="p">,</span> <span class="mf">90.</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.</span> <span class="p">)</span>  
<span class="go">array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])</span>
</pre></div>
</div>
<p>Plot the sine function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">201</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Angle [rad]&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;sin(x)&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.sinh">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">sinh</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.sinh" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.sinh.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Hyperbolic sine, element-wise.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">1/2</span> <span class="pre">*</span> <span class="pre">(np.exp(x)</span> <span class="pre">-</span> <span class="pre">np.exp(-x))</span></code> or
<code class="docutils literal notranslate"><span class="pre">-1j</span> <span class="pre">*</span> <span class="pre">np.sin(1j*x)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The corresponding hyperbolic sine values.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <cite>out</cite> is provided, the function writes the result into it,
and returns a reference to <cite>out</cite>.  (See Examples)</p>
<p class="rubric">References</p>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972, pg. 83.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">1j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="c1"># (exact value is 0)  </span>
<span class="go">1.2246063538223773e-016j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Discrepancy due to vagaries of floating point arithmetic.</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of providing the optional output parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">([</span><span class="mf">0.1</span><span class="p">],</span> <span class="n">out1</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="ow">is</span> <span class="n">out1</span>  
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of ValueError due to provision of shape mis-matched `out`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operands could not be broadcast together with shapes (3,3) (2,2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.sqrt">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">sqrt</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.sqrt.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the non-negative square-root of an array, element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>The values whose square-roots are required.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>An array of the same shape as <cite>x</cite>, containing the positive
square-root of each element in <cite>x</cite>.  If any element in <cite>x</cite> is
complex, a complex array is returned (and the square-roots of
negative reals are calculated).  If all of the elements in <cite>x</cite>
are real, so is <cite>y</cite>, with negative elements returning <code class="docutils literal notranslate"><span class="pre">nan</span></code>.
If <cite>out</cite> was provided, <cite>y</cite> is a reference to it.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">lib.scimath.sqrt</span></code></dt><dd><p>A version which returns complex numbers when given negative reals.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><em>sqrt</em> has–consistent with common convention–as its branch cut the
real “interval” [<cite>-inf</cite>, 0), and is continuous from above on it.
A branch cut is a curve in the complex plane across which a given
complex function fails to be continuous.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>  
<span class="go">array([ 1.,  2.,  3.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">J</span><span class="p">])</span>  
<span class="go">array([ 2.+0.j,  0.+1.j,  1.+2.j])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>  
<span class="go">array([ 2., nan, inf])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.square">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">square</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.square" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.square.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the element-wise square of the input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Element-wise <cite>x*x</cite>, of the same shape and dtype as <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.matrix_power.html#numpy.linalg.matrix_power" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.linalg.matrix_power</span></code></a>, <a class="reference internal" href="#dask.array.sqrt" title="dask.array.sqrt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sqrt</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">power</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  
<span class="go">array([-1.-0.j,  1.+0.j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.squeeze">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">squeeze</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove single-dimensional entries from the shape of an array.</p>
<p>This docstring was copied from numpy.squeeze.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>Selects a subset of the single-dimensional entries in the
shape. If an axis is selected with shape entry greater than
one, an error is raised.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>squeezed</strong><span class="classifier">ndarray</span></dt><dd><p>The input array, but with all or a subset of the
dimensions of length 1 removed. This is always <cite>a</cite> itself
or a view into <cite>a</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If <cite>axis</cite> is not None, and an axis being squeezed is not of length 1</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_dims</span></code></dt><dd><p>The inverse operation, adding singleton dimensions</p>
</dd>
<dt><a class="reference internal" href="#dask.array.reshape" title="dask.array.reshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code></a></dt><dd><p>Insert, remove, and combine dimensions, and resize existing ones</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(1, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(3,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">cannot select an axis to squeeze out which has size not equal to one</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(1, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">stack</code><span class="sig-paren">(</span><em class="sig-param">seq</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span></dt>
<dd><p>Stack arrays along a new axis</p>
<p>Given a sequence of dask arrays, form a new dask array by stacking them
along a new dimension (axis=0 by default)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.concatenate" title="dask.array.concatenate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concatenate</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Create slices</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">from_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 4, 4)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 3, 4)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 4, 3)</span>
</pre></div>
</div>
<p>Result is a new dask Array</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.std">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">ddof=0</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation along the specified axis.</p>
<p>This docstring was copied from numpy.std.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns the standard deviation, a measure of the spread of a distribution,
of the array elements. The standard deviation is computed for the
flattened array by default, otherwise over the specified axis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Calculate the standard deviation of these values.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which the standard deviation is computed. The
default is to compute the standard deviation of the flattened array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, a standard deviation is performed over
multiple axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Type to use in computing the standard deviation. For arrays of
integer type the default is float64, for arrays of float types it is
the same as the array type.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must have
the same shape as the expected output but the type (of the calculated
values) will be cast if necessary.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, optional</span></dt><dd><p>Means Delta Degrees of Freedom.  The divisor used in calculations
is <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> represents the number of elements.
By default <cite>ddof</cite> is zero.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>std</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>standard_deviation</strong><span class="classifier">ndarray, see dtype parameter above.</span></dt><dd><p>If <cite>out</cite> is None, return a new array containing the standard deviation,
otherwise return a reference to the output array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.var" title="dask.array.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>, <a class="reference internal" href="#dask.array.mean" title="dask.array.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>, <a class="reference internal" href="#dask.array.nanmean" title="dask.array.nanmean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmean</span></code></a>, <a class="reference internal" href="#dask.array.nanstd" title="dask.array.nanstd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanstd</span></code></a>, <a class="reference internal" href="#dask.array.nanvar" title="dask.array.nanvar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanvar</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">ufuncs-output-type</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The standard deviation is the square root of the average of the squared
deviations from the mean, i.e., <code class="docutils literal notranslate"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">sqrt(mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2))</span></code>.</p>
<p>The average squared deviation is normally calculated as
<code class="docutils literal notranslate"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.  If, however, <cite>ddof</cite> is specified,
the divisor <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used instead. In standard statistical
practice, <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code> provides an unbiased estimator of the variance
of the infinite population. <code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> provides a maximum likelihood
estimate of the variance for normally distributed variables. The
standard deviation computed in this function is the square root of
the estimated variance, so even with <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code>, it will not be an
unbiased estimate of the standard deviation per se.</p>
<p>Note that, for complex numbers, <cite>std</cite> takes the absolute
value before squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the <em>std</em> is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example below).
Specifying a higher-accuracy accumulator using the <cite>dtype</cite> keyword can
alleviate this issue.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">1.1180339887498949 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([0.5,  0.5])</span>
</pre></div>
</div>
<p>In single precision, std() can be inaccurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">0.45000005</span>
</pre></div>
</div>
<p>Computing the standard deviation in float64 is more accurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  
<span class="go">0.44999999925494177 # may vary</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.sum">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of array elements over a given axis.</p>
<p>This docstring was copied from numpy.sum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Elements to sum.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which a sum is performed.  The default,
axis=None, will sum all of the elements of the input array.  If
axis is negative it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If axis is a tuple of ints, a sum is performed on all of the axes
specified in the tuple instead of a single axis or all the axes as
before.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>The type of the returned array and of the accumulator in which the
elements are summed.  The dtype of <cite>a</cite> is used by default unless <cite>a</cite>
has an integer dtype of less precision than the default platform
integer.  In that case, if <cite>a</cite> is signed then the platform integer
is used while if <cite>a</cite> is unsigned then an unsigned integer of the
same precision as the platform integer is used.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>sum</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt><strong>initial</strong><span class="classifier">scalar, optional  (Not supported in Dask)</span></dt><dd><p>Starting value for the sum. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</dd>
<dt><strong>where</strong><span class="classifier">array_like of bool, optional  (Not supported in Dask)</span></dt><dd><p>Elements to include in the sum. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sum_along_axis</strong><span class="classifier">ndarray</span></dt><dd><p>An array with the same shape as <cite>a</cite>, with the specified
axis removed.   If <cite>a</cite> is a 0-d array, or if <cite>axis</cite> is None, a scalar
is returned.  If an output array is specified, a reference to
<cite>out</cite> is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.sum</span></code></dt><dd><p>Equivalent method.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">add.reduce</span></code></dt><dd><p>Equivalent functionality of <cite>add</cite>.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.cumsum" title="dask.array.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code></a></dt><dd><p>Cumulative sum of array elements.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">trapz</span></code></dt><dd><p>Integration of array values using the composite trapezoidal rule.</p>
</dd>
</dl>
<p><a class="reference internal" href="#dask.array.mean" title="dask.array.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>, <a class="reference internal" href="#dask.array.average" title="dask.array.average"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p>The sum of an empty array is the neutral element 0:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([])</span>  
<span class="go">0.0</span>
</pre></div>
</div>
<p>For floating point numbers the numerical precision of sum (and
<code class="docutils literal notranslate"><span class="pre">np.add.reduce</span></code>) is in general limited by directly adding each number
individually to the result causing rounding errors in every step.
However, often numpy will use a  numerically better approach (partial
pairwise summation) leading to improved precision in many use-cases.
This improved precision is always provided when no <code class="docutils literal notranslate"><span class="pre">axis</span></code> is given.
When <code class="docutils literal notranslate"><span class="pre">axis</span></code> is given, it will depend on which axis is summed.
Technically, to provide the best speed possible, the improved precision
is only used when the summation is along the fast axis in memory.
Note that the exact precision may vary depending on other parameters.
In contrast to NumPy, Python’s <code class="docutils literal notranslate"><span class="pre">math.fsum</span></code> function uses a slower but
more precise approach to summation.
Especially when summing a large number of lower precision floating point
numbers, such as <code class="docutils literal notranslate"><span class="pre">float32</span></code>, numerical errors can become significant.
In such cases it can be advisable to use <cite>dtype=”float64”</cite> to use a higher
precision for the output.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>  
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>  
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([0, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([1, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([1., 5.])</span>
</pre></div>
</div>
<p>If the accumulator is too small, overflow occurs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>  
<span class="go">-128</span>
</pre></div>
</div>
<p>You can also start the sum with a value other than zero:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  
<span class="go">15</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.take">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">take</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">indices</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Take elements from an array along an axis.</p>
<p>This docstring was copied from numpy.take.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>When axis is not None, this function does the same thing as “fancy”
indexing (indexing arrays using arrays); however, it can be easier to use
if you need elements along a given axis. A call such as
<code class="docutils literal notranslate"><span class="pre">np.take(arr,</span> <span class="pre">indices,</span> <span class="pre">axis=3)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">arr[:,:,:,indices,...]</span></code>.</p>
<p>Explained without fancy indexing, this is equivalent to the following use
of <cite>ndindex</cite>, which sets each of <code class="docutils literal notranslate"><span class="pre">ii</span></code>, <code class="docutils literal notranslate"><span class="pre">jj</span></code>, and <code class="docutils literal notranslate"><span class="pre">kk</span></code> to a tuple of
indices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">Nj</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nj</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">jj</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">jj</span><span class="p">],)</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like (Ni…, M, Nk…)</span></dt><dd><p>The source array.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">array_like (Nj…)</span></dt><dd><p>The indices of the values to extract.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<p>Also allow scalars for indices.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>The axis over which to select values. By default, the flattened
input array is used.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional (Ni…, Nj…, Nk…)</span></dt><dd><p>If provided, the result will be placed in this array. It should
be of the appropriate shape and dtype. Note that <cite>out</cite> is always
buffered if <cite>mode=’raise’</cite>; use other modes for better performance.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘raise’, ‘wrap’, ‘clip’}, optional  (Not supported in Dask)</span></dt><dd><p>Specifies how out-of-bounds indices will behave.</p>
<ul class="simple">
<li><p>‘raise’ – raise an error (default)</p></li>
<li><p>‘wrap’ – wrap around</p></li>
<li><p>‘clip’ – clip to the range</p></li>
</ul>
<p>‘clip’ mode means that all indices that are too large are replaced
by the index that addresses the last element along that axis. Note
that this disables indexing with negative numbers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray (Ni…, Nj…, Nk…)</span></dt><dd><p>The returned array has the same type as <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.compress" title="dask.array.compress"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress</span></code></a></dt><dd><p>Take elements using a boolean mask</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.take</span></code></dt><dd><p>equivalent method</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">take_along_axis</span></code></dt><dd><p>Take elements by matching the array and the index arrays</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>By eliminating the inner loop in the description above, and using <cite>s_</cite> to
build simple slice objects, <cite>take</cite> can be expressed  in terms of applying
fancy indexing to each 1-d slice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nj</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[</span><span class="o">...</span><span class="p">,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
</pre></div>
</div>
<p>For this reason, it is equivalent to (but faster than) the following use
of <cite>apply_along_axis</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a_1d</span><span class="p">:</span> <span class="n">a_1d</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>  
<span class="go">array([4, 3, 6])</span>
</pre></div>
</div>
<p>In this example if <cite>a</cite> is an ndarray, “fancy” indexing can be used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>  
<span class="go">array([4, 3, 6])</span>
</pre></div>
</div>
<p>If <cite>indices</cite> is not one dimensional, the output also has these dimensions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>  
<span class="go">array([[4, 3],</span>
<span class="go">       [5, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.tan">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">tan</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.tan" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.tan.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute tangent element-wise.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">np.sin(x)/np.cos(x)</span></code> element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The corresponding tangent values.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <cite>out</cite> is provided, the function writes the result into it,
and returns a reference to <cite>out</cite>.  (See Examples)</p>
<p class="rubric">References</p>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">pi</span><span class="p">]))</span>  
<span class="go">array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of providing the optional output parameter illustrating</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># that what is returned is a reference to said parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">([</span><span class="mf">0.1</span><span class="p">],</span> <span class="n">out1</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="ow">is</span> <span class="n">out1</span>  
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of ValueError due to provision of shape mis-matched `out`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operands could not be broadcast together with shapes (3,3) (2,2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.tanh">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">tanh</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.tanh.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Compute hyperbolic tangent element-wise.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">np.sinh(x)/np.cosh(x)</span></code> or <code class="docutils literal notranslate"><span class="pre">-1j</span> <span class="pre">*</span> <span class="pre">np.tan(1j*x)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The corresponding hyperbolic tangent values.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <cite>out</cite> is provided, the function writes the result into it,
and returns a reference to <cite>out</cite>.  (See Examples)</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r49d276f13e29-1"><span class="brackets"><a class="fn-backref" href="#id29">1</a></span></dt>
<dd><p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972, pg. 83.
<a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="r49d276f13e29-2"><span class="brackets"><a class="fn-backref" href="#id30">2</a></span></dt>
<dd><p>Wikipedia, “Hyperbolic function”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Hyperbolic_function">https://en.wikipedia.org/wiki/Hyperbolic_function</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>  
<span class="go">array([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of providing the optional output parameter illustrating</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># that what is returned is a reference to said parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">([</span><span class="mf">0.1</span><span class="p">],</span> <span class="n">out1</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="ow">is</span> <span class="n">out1</span>  
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of ValueError due to provision of shape mis-matched `out`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operands could not be broadcast together with shapes (3,3) (2,2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.tensordot">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">tensordot</code><span class="sig-paren">(</span><em class="sig-param">lhs</em>, <em class="sig-param">rhs</em>, <em class="sig-param">axes=2</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.tensordot" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute tensor dot product along specified axes.</p>
<p>This docstring was copied from numpy.tensordot.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Given two tensors, <cite>a</cite> and <cite>b</cite>, and an array_like object containing
two array_like objects, <code class="docutils literal notranslate"><span class="pre">(a_axes,</span> <span class="pre">b_axes)</span></code>, sum the products of
<cite>a</cite>’s and <cite>b</cite>’s elements (components) over the axes specified by
<code class="docutils literal notranslate"><span class="pre">a_axes</span></code> and <code class="docutils literal notranslate"><span class="pre">b_axes</span></code>. The third argument can be a single non-negative
integer_like scalar, <code class="docutils literal notranslate"><span class="pre">N</span></code>; if it is such, then the last <code class="docutils literal notranslate"><span class="pre">N</span></code> dimensions
of <cite>a</cite> and the first <code class="docutils literal notranslate"><span class="pre">N</span></code> dimensions of <cite>b</cite> are summed over.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a, b</strong><span class="classifier">array_like</span></dt><dd><p>Tensors to “dot”.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">int or (2,) array_like</span></dt><dd><ul class="simple">
<li><p>integer_like
If an int N, sum over the last N axes of <cite>a</cite> and the first N axes
of <cite>b</cite> in order. The sizes of the corresponding axes must match.</p></li>
<li><p>(2,) array_like
Or, a list of axes to be summed over, first sequence applying to <cite>a</cite>,
second to <cite>b</cite>. Both elements array_like must be of the same length.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>The tensor dot product of the input.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.dot" title="dask.array.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code></a>, <a class="reference internal" href="#dask.array.einsum" title="dask.array.einsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">einsum</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Three common use cases are:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">axes</span> <span class="pre">=</span> <span class="pre">0</span></code> : tensor product <span class="math notranslate nohighlight">\(a\otimes b\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">axes</span> <span class="pre">=</span> <span class="pre">1</span></code> : tensor dot product <span class="math notranslate nohighlight">\(a\cdot b\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">axes</span> <span class="pre">=</span> <span class="pre">2</span></code> : (default) tensor double contraction <span class="math notranslate nohighlight">\(a:b\)</span></p></li>
</ul>
</dd>
</dl>
<p>When <cite>axes</cite> is integer_like, the sequence for evaluation will be: first
the -Nth axis in <cite>a</cite> and 0th axis in <cite>b</cite>, and the -1th axis in <cite>a</cite> and
Nth axis in <cite>b</cite> last.</p>
<p>When there is more than one axis to sum over - and they are not the last
(first) axes of <cite>a</cite> (<cite>b</cite>) - the argument <cite>axes</cite> should consist of
two sequences of the same length, with the first axis to sum over given
first in both sequences, the second axis second, and so forth.</p>
<p>The shape of the result consists of the non-contracted axes of the
first tensor, followed by the non-contracted axes of the second.</p>
<p class="rubric">Examples</p>
<p>A “traditional” example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">60.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">24.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(5, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>  
<span class="go">array([[4400., 4730.],</span>
<span class="go">       [4532., 4874.],</span>
<span class="go">       [4664., 5018.],</span>
<span class="go">       [4796., 5162.],</span>
<span class="go">       [4928., 5306.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># A slower but equivalent way of computing the same...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>  
<span class="gp">... </span>  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">==</span> <span class="n">d</span>  
<span class="go">array([[ True,  True],</span>
<span class="go">       [ True,  True],</span>
<span class="go">       [ True,  True],</span>
<span class="go">       [ True,  True],</span>
<span class="go">       [ True,  True]])</span>
</pre></div>
</div>
<p>An extended example taking advantage of the overloading of + and *:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">;</span> <span class="n">A</span>  
<span class="go">array([[[1, 2],</span>
<span class="go">        [3, 4]],</span>
<span class="go">       [[5, 6],</span>
<span class="go">        [7, 8]]])</span>
<span class="go">array([[&#39;a&#39;, &#39;b&#39;],</span>
<span class="go">       [&#39;c&#39;, &#39;d&#39;]], dtype=object)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span> <span class="c1"># third argument default is 2 for double-contraction  </span>
<span class="go">array([&#39;abbcccdddd&#39;, &#39;aaaaabbbbbbcccccccdddddddd&#39;], dtype=object)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[[&#39;acc&#39;, &#39;bdd&#39;],</span>
<span class="go">        [&#39;aaacccc&#39;, &#39;bbbdddd&#39;]],</span>
<span class="go">       [[&#39;aaaaacccccc&#39;, &#39;bbbbbdddddd&#39;],</span>
<span class="go">        [&#39;aaaaaaacccccccc&#39;, &#39;bbbbbbbdddddddd&#39;]]], dtype=object)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># tensor product (result too long to incl.)  </span>
<span class="go">array([[[[[&#39;a&#39;, &#39;b&#39;],</span>
<span class="go">          [&#39;c&#39;, &#39;d&#39;]],</span>
<span class="go">          ...</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  
<span class="go">array([[[&#39;abbbbb&#39;, &#39;cddddd&#39;],</span>
<span class="go">        [&#39;aabbbbbb&#39;, &#39;ccdddddd&#39;]],</span>
<span class="go">       [[&#39;aaabbbbbbb&#39;, &#39;cccddddddd&#39;],</span>
<span class="go">        [&#39;aaaabbbbbbbb&#39;, &#39;ccccdddddddd&#39;]]], dtype=object)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  
<span class="go">array([[[&#39;abb&#39;, &#39;cdd&#39;],</span>
<span class="go">        [&#39;aaabbbb&#39;, &#39;cccdddd&#39;]],</span>
<span class="go">       [[&#39;aaaaabbbbbb&#39;, &#39;cccccdddddd&#39;],</span>
<span class="go">        [&#39;aaaaaaabbbbbbbb&#39;, &#39;cccccccdddddddd&#39;]]], dtype=object)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>  
<span class="go">array([&#39;abbbcccccddddddd&#39;, &#39;aabbbbccccccdddddddd&#39;], dtype=object)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>  
<span class="go">array([&#39;acccbbdddd&#39;, &#39;aaaaacccccccbbbbbbdddddddd&#39;], dtype=object)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.tile">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">tile</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">reps</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array by repeating A the number of times given by reps.</p>
<p>This docstring was copied from numpy.tile.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>If <cite>reps</cite> has length <code class="docutils literal notranslate"><span class="pre">d</span></code>, the result will have dimension of
<code class="docutils literal notranslate"><span class="pre">max(d,</span> <span class="pre">A.ndim)</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">A.ndim</span> <span class="pre">&lt;</span> <span class="pre">d</span></code>, <cite>A</cite> is promoted to be d-dimensional by prepending new
axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,
or shape (1, 1, 3) for 3-D replication. If this is not the desired
behavior, promote <cite>A</cite> to d-dimensions manually before calling this
function.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">A.ndim</span> <span class="pre">&gt;</span> <span class="pre">d</span></code>, <cite>reps</cite> is promoted to <cite>A</cite>.ndim by pre-pending 1’s to it.
Thus for an <cite>A</cite> of shape (2, 3, 4, 5), a <cite>reps</cite> of (2, 2) is treated as
(1, 1, 2, 2).</p>
<p>Note : Although tile may be used for broadcasting, it is strongly
recommended to use numpy’s broadcasting operations and functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">array_like</span></dt><dd><p>The input array.</p>
</dd>
<dt><strong>reps</strong><span class="classifier">array_like</span></dt><dd><p>The number of repetitions of <cite>A</cite> along each axis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>c</strong><span class="classifier">ndarray</span></dt><dd><p>The tiled output array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.repeat" title="dask.array.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a></dt><dd><p>Repeat elements of an array.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.broadcast_to" title="dask.array.broadcast_to"><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast_to</span></code></a></dt><dd><p>Broadcast an array to a new shape</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">array([0, 1, 2, 0, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  
<span class="go">array([[0, 1, 2, 0, 1, 2],</span>
<span class="go">       [0, 1, 2, 0, 1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  
<span class="go">array([[[0, 1, 2, 0, 1, 2]],</span>
<span class="go">       [[0, 1, 2, 0, 1, 2]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">array([[1, 2, 1, 2],</span>
<span class="go">       [3, 4, 3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">c</span><span class="p">,(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>  
<span class="go">array([[1, 2, 3, 4],</span>
<span class="go">       [1, 2, 3, 4],</span>
<span class="go">       [1, 2, 3, 4],</span>
<span class="go">       [1, 2, 3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.topk">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">topk</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">k</em>, <em class="sig-param">axis=-1</em>, <em class="sig-param">split_every=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.topk" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the k largest elements from a on the given axis,
and return them sorted from largest to smallest.
If k is negative, extract the -k smallest elements instead,
and return them sorted from smallest to largest.</p>
<p>This performs best when <code class="docutils literal notranslate"><span class="pre">k</span></code> is much smaller than the chunk size. All
results will be returned in a single chunk along the given axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x: Array</strong></dt><dd><p>Data being sorted</p>
</dd>
<dt><strong>k: int</strong></dt><dd></dd>
<dt><strong>axis: int, optional</strong></dt><dd></dd>
<dt><strong>split_every: int &gt;=2, optional</strong></dt><dd><p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">reduce()</span></code>. This parameter becomes very important when k is
on the same order of magnitude of the chunk size or more, as it
prevents getting the whole or a significant portion of the input array
in memory all at once, with a negative impact on network transfer
too when running on distributed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Selection of x with size abs(k) along the given axis.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([6, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([1, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.transpose">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">transpose</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute the dimensions of an array.</p>
<p>This docstring was copied from numpy.transpose.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">list of ints, optional</span></dt><dd><p>By default, reverse the dimensions, otherwise permute the axes
according to the values given.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>p</strong><span class="classifier">ndarray</span></dt><dd><p><cite>a</cite> with its axes permuted.  A view is returned whenever
possible.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.moveaxis" title="dask.array.moveaxis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moveaxis</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Use <cite>transpose(a, argsort(axes))</cite> to invert the transposition of tensors
when using the <cite>axes</cite> keyword argument.</p>
<p>Transposing a 1-D array returns an unchanged view of the original array.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">array([[0, 2],</span>
<span class="go">       [1, 3]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(2, 1, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.tril">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">tril</code><span class="sig-paren">(</span><em class="sig-param">m</em>, <em class="sig-param">k=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.tril" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower triangle of an array with elements above the <cite>k</cite>-th diagonal zeroed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>m</strong><span class="classifier">array_like, shape (M, M)</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int, optional</span></dt><dd><p>Diagonal above which to zero elements.  <cite>k = 0</cite> (the default) is the
main diagonal, <cite>k &lt; 0</cite> is below it and <cite>k &gt; 0</cite> is above.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tril</strong><span class="classifier">ndarray, shape (M, M)</span></dt><dd><p>Lower triangle of <cite>m</cite>, of same shape and data-type as <cite>m</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.triu" title="dask.array.triu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triu</span></code></a></dt><dd><p>upper triangle of an array</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.triu">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">triu</code><span class="sig-paren">(</span><em class="sig-param">m</em>, <em class="sig-param">k=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.triu" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper triangle of an array with elements below the <cite>k</cite>-th diagonal zeroed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>m</strong><span class="classifier">array_like, shape (M, N)</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int, optional</span></dt><dd><p>Diagonal below which to zero elements.  <cite>k = 0</cite> (the default) is the
main diagonal, <cite>k &lt; 0</cite> is below it and <cite>k &gt; 0</cite> is above.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>triu</strong><span class="classifier">ndarray, shape (M, N)</span></dt><dd><p>Upper triangle of <cite>m</cite>, of same shape and data-type as <cite>m</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.tril" title="dask.array.tril"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tril</span></code></a></dt><dd><p>lower triangle of an array</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.trunc">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">trunc</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">/</em>, <em class="sig-param">out=None</em>, <em class="sig-param">*</em>, <em class="sig-param">where=True</em>, <em class="sig-param">casting='same_kind'</em>, <em class="sig-param">order='K'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">subok=True</em><span class="optional">[</span>, <em class="sig-param">signature</em>, <em class="sig-param">extobj</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.trunc" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.trunc.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the truncated value of the input, element-wise.</p>
<p>The truncated value of the scalar <cite>x</cite> is the nearest integer <cite>i</cite> which
is closer to zero than <cite>x</cite> is. In short, the fractional part of the
signed number <cite>x</cite> is discarded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt><strong>where</strong><span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>For other keyword-only arguments, see the
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufuncs-kwargs" title="(in NumPy v1.17)"><span class="xref std std-ref">ufunc docs</span></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The truncated value of each element in <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.ceil" title="dask.array.ceil"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceil</span></code></a>, <a class="reference internal" href="#dask.array.floor" title="dask.array.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a>, <a class="reference internal" href="#dask.array.rint" title="dask.array.rint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rint</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">array([-1., -1., -0.,  0.,  1.,  1.,  2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.unique">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">unique</code><span class="sig-paren">(</span><em class="sig-param">ar</em>, <em class="sig-param">return_index=False</em>, <em class="sig-param">return_inverse=False</em>, <em class="sig-param">return_counts=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the unique elements of an array.</p>
<p>This docstring was copied from numpy.unique.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns the sorted unique elements of an array. There are three optional
outputs in addition to the unique elements:</p>
<ul class="simple">
<li><p>the indices of the input array that give the unique values</p></li>
<li><p>the indices of the unique array that reconstruct the input array</p></li>
<li><p>the number of times each unique value comes up in the input array</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ar</strong><span class="classifier">array_like</span></dt><dd><p>Input array. Unless <cite>axis</cite> is specified, this will be flattened if it
is not already 1-D.</p>
</dd>
<dt><strong>return_index</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, also return the indices of <cite>ar</cite> (along the specified axis,
if provided, or in the flattened array) that result in the unique array.</p>
</dd>
<dt><strong>return_inverse</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, also return the indices of the unique array (for the specified
axis, if provided) that can be used to reconstruct <cite>ar</cite>.</p>
</dd>
<dt><strong>return_counts</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, also return the number of times each unique item appears
in <cite>ar</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
</dd>
<dt><strong>axis</strong><span class="classifier">int or None, optional  (Not supported in Dask)</span></dt><dd><p>The axis to operate on. If None, <cite>ar</cite> will be flattened. If an integer,
the subarrays indexed by the given axis will be flattened and treated
as the elements of a 1-D array with the dimension of the given axis,
see the notes for more details.  Object arrays or structured arrays
that contain objects are not supported if the <cite>axis</cite> kwarg is used. The
default is None.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>unique</strong><span class="classifier">ndarray</span></dt><dd><p>The sorted unique values.</p>
</dd>
<dt><strong>unique_indices</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The indices of the first occurrences of the unique values in the
original array. Only provided if <cite>return_index</cite> is True.</p>
</dd>
<dt><strong>unique_inverse</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The indices to reconstruct the original array from the
unique array. Only provided if <cite>return_inverse</cite> is True.</p>
</dd>
<dt><strong>unique_counts</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The number of times each of the unique values comes up in the
original array. Only provided if <cite>return_counts</cite> is True.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.lib.arraysetops</span></code></dt><dd><p>Module with a number of other functions for performing set operations on arrays.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When an axis is specified the subarrays indexed by the axis are sorted.
This is done by making the specified axis the first dimension of the array
(move the axis to the first dimension to keep the order of the other axes)
and then flattening the subarrays in C order. The flattened subarrays are
then viewed as a structured type with each element given a label, with the
effect that we end up with a 1-D array of structured types that can be
treated in the same way as any other 1-D array. The result is that the
flattened subarrays are sorted in lexicographic order starting with the
first element.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="go">array([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<p>Return the unique rows of a 2D array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([[1, 0, 0], [2, 3, 4]])</span>
</pre></div>
</div>
<p>Return the indices of the original array that give the unique values:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>  
<span class="go">array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;&lt;U1&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span>  
<span class="go">array([0, 1, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>  
<span class="go">array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;&lt;U1&#39;)</span>
</pre></div>
</div>
<p>Reconstruct the input array from the unique values:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>  
<span class="go">array([1, 2, 3, 4, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span>  
<span class="go">array([0, 1, 4, ..., 1, 2, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>  
<span class="go">array([1, 2, 6, ..., 2, 3, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.unravel_index">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">unravel_index</code><span class="sig-paren">(</span><em class="sig-param">indices</em>, <em class="sig-param">shape</em>, <em class="sig-param">order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.unravel_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.unravel_index.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Converts a flat index or array of flat indices into a tuple
of coordinate arrays.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>indices</strong><span class="classifier">array_like</span></dt><dd><p>An integer array whose elements are indices into the flattened
version of an array of dimensions <code class="docutils literal notranslate"><span class="pre">shape</span></code>. Before version 1.6.0,
this function accepted just one index value.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple of ints</span></dt><dd><p>The shape of the array to use for unraveling <code class="docutils literal notranslate"><span class="pre">indices</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.16.0: </span>Renamed from <code class="docutils literal notranslate"><span class="pre">dims</span></code> to <code class="docutils literal notranslate"><span class="pre">shape</span></code>.</p>
</div>
</dd>
<dt><strong>order</strong><span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Determines whether the indices should be viewed as indexing in
row-major (C-style) or column-major (Fortran-style) order.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>unraveled_coords</strong><span class="classifier">tuple of ndarray</span></dt><dd><p>Each array in the tuple has the same shape as the <code class="docutils literal notranslate"><span class="pre">indices</span></code>
array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ravel_multi_index</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">([</span><span class="mi">22</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">37</span><span class="p">],</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>  
<span class="go">(array([3, 6, 6]), array([4, 5, 1]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">([</span><span class="mi">31</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>  
<span class="go">(array([3, 6, 6]), array([4, 5, 1]))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="mi">1621</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>  
<span class="go">(3, 1, 4, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.var">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">ddof=0</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance along the specified axis.</p>
<p>This docstring was copied from numpy.var.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose variance is desired.  If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which the variance is computed.  The default is to
compute the variance of the flattened array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, a variance is performed over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Type to use in computing the variance.  For arrays of integer type
the default is <cite>float64</cite>; for arrays of float types it is the same as
the array type.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  It must have
the same shape as the expected output, but the type is cast if
necessary.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, optional</span></dt><dd><p>“Delta Degrees of Freedom”: the divisor used in the calculation is
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> represents the number of elements. By
default <cite>ddof</cite> is zero.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>var</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>variance</strong><span class="classifier">ndarray, see dtype parameter above</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">out=None</span></code>, returns a new array containing the variance;
otherwise, a reference to the output array is returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.std" title="dask.array.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>, <a class="reference internal" href="#dask.array.mean" title="dask.array.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>, <a class="reference internal" href="#dask.array.nanmean" title="dask.array.nanmean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmean</span></code></a>, <a class="reference internal" href="#dask.array.nanstd" title="dask.array.nanstd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanstd</span></code></a>, <a class="reference internal" href="#dask.array.nanvar" title="dask.array.nanvar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanvar</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">ufuncs-output-type</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The variance is the average of the squared deviations from the mean,
i.e.,  <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2)</span></code>.</p>
<p>The mean is normally calculated as <code class="docutils literal notranslate"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.
If, however, <cite>ddof</cite> is specified, the divisor <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used
instead.  In standard statistical practice, <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code> provides an
unbiased estimator of the variance of a hypothetical infinite population.
<code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> provides a maximum likelihood estimate of the variance for
normally distributed variables.</p>
<p>Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite> (see example
below).  Specifying a higher-accuracy accumulator using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>
keyword can alleviate this issue.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">1.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([0.25,  0.25])</span>
</pre></div>
</div>
<p>In single precision, var() can be inaccurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">0.20250003</span>
</pre></div>
</div>
<p>Computing the variance in float64 is more accurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  
<span class="go">0.20249999932944759 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="mf">0.55</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.1</span><span class="o">-</span><span class="mf">0.55</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>  
<span class="go">0.2025</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.vdot">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">vdot</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.vdot" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.vdot.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the dot product of two vectors.</p>
<p>The vdot(<cite>a</cite>, <cite>b</cite>) function handles complex numbers differently than
dot(<cite>a</cite>, <cite>b</cite>).  If the first argument is complex the complex conjugate
of the first argument is used for the calculation of the dot product.</p>
<p>Note that <cite>vdot</cite> handles multidimensional arrays differently than <cite>dot</cite>:
it does <em>not</em> perform a matrix product, but flattens input arguments
to 1-D vectors first. Consequently, it should only be used for vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>If <cite>a</cite> is complex the complex conjugate is taken before calculation
of the dot product.</p>
</dd>
<dt><strong>b</strong><span class="classifier">array_like</span></dt><dd><p>Second argument to the dot product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>Dot product of <cite>a</cite> and <cite>b</cite>.  Can be an int, float, or
complex depending on the types of <cite>a</cite> and <cite>b</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.dot" title="dask.array.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code></a></dt><dd><p>Return the dot product without using the complex conjugate of the first argument.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">,</span><span class="mi">7</span><span class="o">+</span><span class="mi">8</span><span class="n">j</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">(70-8j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  
<span class="go">(70+8j)</span>
</pre></div>
</div>
<p>Note that higher-dimensional arrays are flattened!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="mi">2</span>  
<span class="go">30</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.vstack">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">vstack</code><span class="sig-paren">(</span><em class="sig-param">tup</em>, <em class="sig-param">allow_unknown_chunksizes=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.vstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence vertically (row wise).</p>
<p>This docstring was copied from numpy.vstack.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This is equivalent to concatenation along the first axis after 1-D arrays
of shape <cite>(N,)</cite> have been reshaped to <cite>(1,N)</cite>. Rebuilds arrays divided by
<cite>vsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tup</strong><span class="classifier">sequence of ndarrays</span></dt><dd><p>The arrays must have the same shape along all but the first axis.
1-D arrays must have the same length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stacked</strong><span class="classifier">ndarray</span></dt><dd><p>The array formed by stacking the given arrays, will be at least 2-D.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.stack" title="dask.array.stack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack</span></code></a></dt><dd><p>Join a sequence of arrays along a new axis.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.hstack" title="dask.array.hstack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hstack</span></code></a></dt><dd><p>Stack arrays in sequence horizontally (column wise).</p>
</dd>
<dt><a class="reference internal" href="#dask.array.dstack" title="dask.array.dstack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dstack</span></code></a></dt><dd><p>Stack arrays in sequence depth wise (along third dimension).</p>
</dd>
<dt><a class="reference internal" href="#dask.array.concatenate" title="dask.array.concatenate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concatenate</span></code></a></dt><dd><p>Join a sequence of arrays along an existing axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vsplit</span></code></dt><dd><p>Split array into a list of multiple sub-arrays vertically.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.block" title="dask.array.block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">block</span></code></a></dt><dd><p>Assemble arrays from blocks.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>  
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [2, 3, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>  
<span class="go">array([[1],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.where">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">where</code><span class="sig-paren">(</span><em class="sig-param">condition</em><span class="optional">[</span>, <em class="sig-param">x</em>, <em class="sig-param">y</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.where" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.where.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return elements chosen from <cite>x</cite> or <cite>y</cite> depending on <cite>condition</cite>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When only <cite>condition</cite> is provided, this function is a shorthand for
<code class="docutils literal notranslate"><span class="pre">np.asarray(condition).nonzero()</span></code>. Using <cite>nonzero</cite> directly should be
preferred, as it behaves correctly for subclasses. The rest of this
documentation covers only the case where all three arguments are
provided.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>condition</strong><span class="classifier">array_like, bool</span></dt><dd><p>Where True, yield <cite>x</cite>, otherwise yield <cite>y</cite>.</p>
</dd>
<dt><strong>x, y</strong><span class="classifier">array_like</span></dt><dd><p>Values from which to choose. <cite>x</cite>, <cite>y</cite> and <cite>condition</cite> need to be
broadcastable to some shape.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>An array with elements from <cite>x</cite> where <cite>condition</cite> is True, and elements
from <cite>y</cite> elsewhere.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.choose" title="dask.array.choose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose</span></code></a></p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.nonzero" title="dask.array.nonzero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code></a></dt><dd><p>The function that is called when x and y are omitted</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If all the arrays are 1-D, <cite>where</cite> is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">xv</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="n">yv</span>
 <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>  
<span class="go">array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])</span>
</pre></div>
</div>
<p>This can be used on multidimensional arrays too:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]],</span>  
<span class="gp">... </span>         <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
<span class="gp">... </span>         <span class="p">[[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="go">array([[1, 8],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>The shapes of x, y, and the condition are broadcast together:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># both x and 10+y are broadcast  </span>
<span class="go">array([[10,  0,  0,  0],</span>
<span class="go">       [10, 11,  1,  1],</span>
<span class="go">       [10, 11, 12,  2]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>  
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># -1 is broadcast  </span>
<span class="go">array([[ 0,  1,  2],</span>
<span class="go">       [ 0,  2, -1],</span>
<span class="go">       [ 0,  3, -1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.zeros">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">zeros</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocked variant of zeros</p>
<p>Follows the signature of zeros exactly except that it also requires a
keyword argument chunks=(…)</p>
<p>Original signature follows below.
zeros(shape, dtype=float, order=’C’)</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">int or tuple of ints</span></dt><dd><p>Shape of the new array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The desired data-type for the array, e.g., <cite>numpy.int8</cite>.  Default is
<cite>numpy.float64</cite>.</p>
</dd>
<dt><strong>order</strong><span class="classifier">{‘C’, ‘F’}, optional, default: ‘C’</span></dt><dd><p>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of zeros with the given shape, dtype, and order.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.zeros_like" title="dask.array.zeros_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros_like</span></code></a></dt><dd><p>Return an array of zeros with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.empty" title="dask.array.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a></dt><dd><p>Return a new uninitialized array.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ones" title="dask.array.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a></dt><dd><p>Return a new array setting values to one.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.full" title="dask.array.full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code></a></dt><dd><p>Return a new array of given shape filled with value.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([ 0.,  0.,  0.,  0.,  0.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([0, 0, 0, 0, 0])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.],</span>
<span class="go">       [ 0.,  0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">)])</span> <span class="c1"># custom dtype</span>
<span class="go">array([(0, 0), (0, 0)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.zeros_like">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">zeros_like</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">chunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.zeros_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of zeros with the same shape and type as a given array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>The shape and data-type of <cite>a</cite> define these same attributes of
the returned array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Overrides the data type of the result.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">sequence of ints</span></dt><dd><p>The number of samples on each block. Note that the last block will have
fewer samples if <code class="docutils literal notranslate"><span class="pre">len(array)</span> <span class="pre">%</span> <span class="pre">chunks</span> <span class="pre">!=</span> <span class="pre">0</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of zeros with the same shape and type as <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ones_like" title="dask.array.ones_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones_like</span></code></a></dt><dd><p>Return an array of ones with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.empty_like" title="dask.array.empty_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty_like</span></code></a></dt><dd><p>Return an empty array with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.zeros" title="dask.array.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a></dt><dd><p>Return a new array setting values to zero.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ones" title="dask.array.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a></dt><dd><p>Return a new array setting values to one.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.empty" title="dask.array.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a></dt><dd><p>Return a new uninitialized array.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.linalg.cholesky">
<code class="sig-prename descclassname">dask.array.linalg.</code><code class="sig-name descname">cholesky</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">lower=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.linalg.cholesky" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Cholesky decomposition, <span class="math notranslate nohighlight">\(A = L L^*\)</span> or
<span class="math notranslate nohighlight">\(A = U^* U\)</span> of a Hermitian positive-definite matrix A.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(M, M) array_like</span></dt><dd><p>Matrix to be decomposed</p>
</dd>
<dt><strong>lower</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to compute the upper or lower triangular Cholesky
factorization.  Default is upper-triangular.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>c</strong><span class="classifier">(M, M) Array</span></dt><dd><p>Upper- or lower-triangular Cholesky factor of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.array.linalg.inv">
<code class="sig-prename descclassname">dask.array.linalg.</code><code class="sig-name descname">inv</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.linalg.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of a matrix with LU decomposition and
forward / backward substitutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Square matrix to be inverted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ainv</strong><span class="classifier">Array</span></dt><dd><p>Inverse of the matrix <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.array.linalg.lstsq">
<code class="sig-prename descclassname">dask.array.linalg.</code><code class="sig-name descname">lstsq</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.linalg.lstsq" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the least-squares solution to a linear matrix equation using
QR decomposition.</p>
<p>Solves the equation <cite>a x = b</cite> by computing a vector <cite>x</cite> that
minimizes the Euclidean 2-norm <cite>|| b - a x ||^2</cite>.  The equation may
be under-, well-, or over- determined (i.e., the number of
linearly independent rows of <cite>a</cite> can be less than, equal to, or
greater than its number of linearly independent columns).  If <cite>a</cite>
is square and of full rank, then <cite>x</cite> (but for round-off error) is
the “exact” solution of the equation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(M, N) array_like</span></dt><dd><p>“Coefficient” matrix.</p>
</dd>
<dt><strong>b</strong><span class="classifier">(M,) array_like</span></dt><dd><p>Ordinate or “dependent variable” values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x</strong><span class="classifier">(N,) Array</span></dt><dd><p>Least-squares solution. If <cite>b</cite> is two-dimensional,
the solutions are in the <cite>K</cite> columns of <cite>x</cite>.</p>
</dd>
<dt><strong>residuals</strong><span class="classifier">(1,) Array</span></dt><dd><p>Sums of residuals; squared Euclidean 2-norm for each column in
<code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-</span> <span class="pre">a*x</span></code>.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">Array</span></dt><dd><p>Rank of matrix <cite>a</cite>.</p>
</dd>
<dt><strong>s</strong><span class="classifier">(min(M, N),) Array</span></dt><dd><p>Singular values of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.array.linalg.lu">
<code class="sig-prename descclassname">dask.array.linalg.</code><code class="sig-name descname">lu</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.linalg.lu" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the lu decomposition of a matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p:  Array, permutation matrix</strong></dt><dd></dd>
<dt><strong>l:  Array, lower triangular matrix with unit diagonal.</strong></dt><dd></dd>
<dt><strong>u:  Array, upper triangular matrix</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.linalg.norm">
<code class="sig-prename descclassname">dask.array.linalg.</code><code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">ord=None</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.linalg.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix or vector norm.</p>
<p>This docstring was copied from numpy.linalg.norm.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This function is able to return one of eight different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <code class="docutils literal notranslate"><span class="pre">ord</span></code> parameter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array.  If <cite>axis</cite> is None, <cite>x</cite> must be 1-D or 2-D, unless <cite>ord</cite>
is None. If both <cite>axis</cite> and <cite>ord</cite> are None, the 2-norm of
<code class="docutils literal notranslate"><span class="pre">x.ravel</span></code> will be returned.</p>
</dd>
<dt><strong>ord</strong><span class="classifier">{non-zero int, inf, -inf, ‘fro’, ‘nuc’}, optional</span></dt><dd><p>Order of the norm (see table under <code class="docutils literal notranslate"><span class="pre">Notes</span></code>). inf means numpy’s
<cite>inf</cite> object. The default is None.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{None, int, 2-tuple of ints}, optional.</span></dt><dd><p>If <cite>axis</cite> is an integer, it specifies the axis of <cite>x</cite> along which to
compute the vector norms.  If <cite>axis</cite> is a 2-tuple, it specifies the
axes that hold 2-D matrices, and the matrix norms of these matrices
are computed.  If <cite>axis</cite> is None then either a vector norm (when <cite>x</cite>
is 1-D) or a matrix norm (when <cite>x</cite> is 2-D) is returned. The default
is None.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are normed over are left in the
result as dimensions with size one.  With this option the result will
broadcast correctly against the original <cite>x</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>n</strong><span class="classifier">float or ndarray</span></dt><dd><p>Norm of the matrix or vector(s).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For values of <code class="docutils literal notranslate"><span class="pre">ord</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code>, the result is, strictly speaking, not a
mathematical ‘norm’, but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 47%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ord</p></th>
<th class="head"><p>norm for matrices</p></th>
<th class="head"><p>norm for vectors</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>None</p></td>
<td><p>Frobenius norm</p></td>
<td><p>2-norm</p></td>
</tr>
<tr class="row-odd"><td><p>‘fro’</p></td>
<td><p>Frobenius norm</p></td>
<td><p>–</p></td>
</tr>
<tr class="row-even"><td><p>‘nuc’</p></td>
<td><p>nuclear norm</p></td>
<td><p>–</p></td>
</tr>
<tr class="row-odd"><td><p>inf</p></td>
<td><p>max(sum(abs(x), axis=1))</p></td>
<td><p>max(abs(x))</p></td>
</tr>
<tr class="row-even"><td><p>-inf</p></td>
<td><p>min(sum(abs(x), axis=1))</p></td>
<td><p>min(abs(x))</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>–</p></td>
<td><p>sum(x != 0)</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>max(sum(abs(x), axis=0))</p></td>
<td><p>as below</p></td>
</tr>
<tr class="row-odd"><td><p>-1</p></td>
<td><p>min(sum(abs(x), axis=0))</p></td>
<td><p>as below</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>2-norm (largest sing. value)</p></td>
<td><p>as below</p></td>
</tr>
<tr class="row-odd"><td><p>-2</p></td>
<td><p>smallest singular value</p></td>
<td><p>as below</p></td>
</tr>
<tr class="row-even"><td><p>other</p></td>
<td><p>–</p></td>
<td><p>sum(abs(x)**ord)**(1./ord)</p></td>
</tr>
</tbody>
</table>
<p>The Frobenius norm is given by <a class="reference internal" href="#r1bae488c141b-1" id="id31">[1]</a>:</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}\)</span></p>
</div></blockquote>
<p>The nuclear norm is the sum of the singular values.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1bae488c141b-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id31">1</a>,<a href="#id32">2</a>)</span></dt>
<dd><p>G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span> <span class="k">as</span> <span class="n">LA</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([-4, -3, -2, ...,  2,  3,  4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">array([[-4, -3, -2],</span>
<span class="go">       [-1,  0,  1],</span>
<span class="go">       [ 2,  3,  4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">7.745966692414834</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="go">7.745966692414834</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span>  
<span class="go">7.745966692414834</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>  
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>  
<span class="go">9.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>  
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>  
<span class="go">2.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  
<span class="go">20.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  
<span class="go">7.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">-4.6566128774142013e-010</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">6.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">7.745966692414834</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">7.3484692283495345</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">1.8570331885190563e-016 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  
<span class="go">5.8480354764257312 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>  
<span class="go">0.0</span>
</pre></div>
</div>
<p>Using the <cite>axis</cite> argument to compute vector norms:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>  
<span class="gp">... </span>              <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">array([ 1.41421356,  2.23606798,  5.        ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([ 3.74165739,  4.24264069])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([ 6.,  6.])</span>
</pre></div>
</div>
<p>Using the <cite>axis</cite> argument to compute matrix norms:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  
<span class="go">array([  3.74165739,  11.22497216])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]),</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>  
<span class="go">(3.7416573867739413, 11.224972160321824)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.linalg.qr">
<code class="sig-prename descclassname">dask.array.linalg.</code><code class="sig-name descname">qr</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.linalg.qr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the qr factorization of a matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">Array</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>q:  Array, orthonormal</strong></dt><dd></dd>
<dt><strong>r:  Array, upper-triangular</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.qr.html#numpy.linalg.qr" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.linalg.qr</span></code></a></dt><dd><p>Equivalent NumPy Operation</p>
</dd>
<dt><a class="reference internal" href="#dask.array.linalg.tsqr" title="dask.array.linalg.tsqr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.linalg.tsqr</span></code></a></dt><dd><p>Implementation for tall-and-skinny arrays</p>
</dd>
<dt><a class="reference internal" href="#dask.array.linalg.sfqr" title="dask.array.linalg.sfqr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.linalg.sfqr</span></code></a></dt><dd><p>Implementation for short-and-fat arrays</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.linalg.solve">
<code class="sig-prename descclassname">dask.array.linalg.</code><code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">sym_pos=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.linalg.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the equation <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></code> for <code class="docutils literal notranslate"><span class="pre">x</span></code>. By default, use LU
decomposition and forward / backward substitutions. When <code class="docutils literal notranslate"><span class="pre">sym_pos</span></code> is
<code class="docutils literal notranslate"><span class="pre">True</span></code>, use Cholesky decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(M, M) array_like</span></dt><dd><p>A square matrix.</p>
</dd>
<dt><strong>b</strong><span class="classifier">(M,) or (M, N) array_like</span></dt><dd><p>Right-hand side matrix in <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></code>.</p>
</dd>
<dt><strong>sym_pos</strong><span class="classifier">bool</span></dt><dd><p>Assume a is symmetric and positive definite. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, use Cholesky
decomposition.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x</strong><span class="classifier">(M,) or (M, N) Array</span></dt><dd><p>Solution to the system <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></code>.  Shape of the return matches the
shape of <cite>b</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.array.linalg.solve_triangular">
<code class="sig-prename descclassname">dask.array.linalg.</code><code class="sig-name descname">solve_triangular</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">lower=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.linalg.solve_triangular" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the equation <cite>a x = b</cite> for <cite>x</cite>, assuming a is a triangular matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(M, M) array_like</span></dt><dd><p>A triangular matrix</p>
</dd>
<dt><strong>b</strong><span class="classifier">(M,) or (M, N) array_like</span></dt><dd><p>Right-hand side matrix in <cite>a x = b</cite></p>
</dd>
<dt><strong>lower</strong><span class="classifier">bool, optional</span></dt><dd><p>Use only data contained in the lower triangle of <cite>a</cite>.
Default is to use upper triangle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x</strong><span class="classifier">(M,) or (M, N) array</span></dt><dd><p>Solution to the system <cite>a x = b</cite>. Shape of return matches <cite>b</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.array.linalg.svd">
<code class="sig-prename descclassname">dask.array.linalg.</code><code class="sig-name descname">svd</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.linalg.svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the singular value decomposition of a matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u:  Array, unitary / orthogonal</strong></dt><dd></dd>
<dt><strong>s:  Array, singular values in decreasing order (largest first)</strong></dt><dd></dd>
<dt><strong>v:  Array, unitary / orthogonal</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.linalg.svd</span></code></dt><dd><p>Equivalent NumPy Operation</p>
</dd>
<dt><a class="reference internal" href="#dask.array.linalg.tsqr" title="dask.array.linalg.tsqr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.linalg.tsqr</span></code></a></dt><dd><p>Implementation for tall-and-skinny arrays</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.linalg.svd_compressed">
<code class="sig-prename descclassname">dask.array.linalg.</code><code class="sig-name descname">svd_compressed</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">k</em>, <em class="sig-param">n_power_iter=0</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">compute=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.linalg.svd_compressed" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly compressed rank-k thin Singular Value Decomposition.</p>
<p>This computes the approximate singular value decomposition of a large
array.  This algorithm is generally faster than the normal algorithm
but does not provide exact results.  One can balance between
performance and accuracy with input parameters (see below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a: Array</strong></dt><dd><p>Input array</p>
</dd>
<dt><strong>k: int</strong></dt><dd><p>Rank of the desired thin SVD decomposition.</p>
</dd>
<dt><strong>n_power_iter: int</strong></dt><dd><p>Number of power iterations, useful when the singular values
decay slowly. Error decreases exponentially as n_power_iter
increases. In practice, set n_power_iter &lt;= 4.</p>
</dd>
<dt><strong>compute</strong><span class="classifier">bool</span></dt><dd><p>Whether or not to compute data at each use.
Recomputing the input while performing several passes reduces memory
pressure, but means that we have to compute the input multiple times.
This is a good choice if the data is larger than memory and cheap to
recreate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>u:  Array, unitary / orthogonal</strong></dt><dd></dd>
<dt><strong>s:  Array, singular values in decreasing order (largest first)</strong></dt><dd></dd>
<dt><strong>v:  Array, unitary / orthogonal</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>N. Halko, P. G. Martinsson, and J. A. Tropp.
Finding structure with randomness: Probabilistic algorithms for
constructing approximate matrix decompositions.
SIAM Rev., Survey and Review section, Vol. 53, num. 2,
pp. 217-288, June 2011
<a class="reference external" href="https://arxiv.org/abs/0909.4061">https://arxiv.org/abs/0909.4061</a></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">svd_compressed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.linalg.sfqr">
<code class="sig-prename descclassname">dask.array.linalg.</code><code class="sig-name descname">sfqr</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.linalg.sfqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct Short-and-Fat QR</p>
<p>Currently, this is a quick hack for non-tall-and-skinny matrices which
are one chunk tall and (unless they are one chunk wide) have chunks
that are wider than they are tall</p>
<p>Q [R_1 R_2 …] = [A_1 A_2 …]</p>
<p>it computes the factorization Q R_1 = A_1, then computes the other
R_k’s in parallel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data: Array</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.linalg.qr" title="dask.array.linalg.qr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.linalg.qr</span></code></a></dt><dd><p>Main user API that uses this function</p>
</dd>
<dt><a class="reference internal" href="#dask.array.linalg.tsqr" title="dask.array.linalg.tsqr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.linalg.tsqr</span></code></a></dt><dd><p>Variant for tall-and-skinny case</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.linalg.tsqr">
<code class="sig-prename descclassname">dask.array.linalg.</code><code class="sig-name descname">tsqr</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">compute_svd=False</em>, <em class="sig-param">_max_vchunk_size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.linalg.tsqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct Tall-and-Skinny QR algorithm</p>
<p>As presented in:</p>
<blockquote>
<div><p>A. Benson, D. Gleich, and J. Demmel.
Direct QR factorizations for tall-and-skinny matrices in
MapReduce architectures.
IEEE International Conference on Big Data, 2013.
<a class="reference external" href="https://arxiv.org/abs/1301.1071">https://arxiv.org/abs/1301.1071</a></p>
</div></blockquote>
<p>This algorithm is used to compute both the QR decomposition and the
Singular Value Decomposition.  It requires that the input array have a
single column of blocks, each of which fit in memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data: Array</strong></dt><dd></dd>
<dt><strong>compute_svd: bool</strong></dt><dd><p>Whether to compute the SVD rather than the QR decomposition</p>
</dd>
<dt><strong>_max_vchunk_size: Integer</strong></dt><dd><p>Used internally in recursion to set the maximum row dimension
of chunks in subsequent recursive calls.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.linalg.qr" title="dask.array.linalg.qr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.linalg.qr</span></code></a></dt><dd><p>Powered by this algorithm</p>
</dd>
<dt><a class="reference internal" href="#dask.array.linalg.svd" title="dask.array.linalg.svd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.linalg.svd</span></code></a></dt><dd><p>Powered by this algorithm</p>
</dd>
<dt><a class="reference internal" href="#dask.array.linalg.sfqr" title="dask.array.linalg.sfqr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.linalg.sfqr</span></code></a></dt><dd><p>Variant for short-and-fat arrays</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>With <code class="docutils literal notranslate"><span class="pre">k</span></code> blocks of size <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n)</span></code>, this algorithm has memory use that
scales as <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">n</span></code>.</p>
<p>The implementation here is the recursive variant due to the ultimate
need for one “single core” QR decomposition. In the non-recursive version
of the algorithm, given <code class="docutils literal notranslate"><span class="pre">k</span></code> blocks, after <code class="docutils literal notranslate"><span class="pre">k</span></code> <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span></code> QR
decompositions, there will be a “single core” QR decomposition that will
have to work with a <code class="docutils literal notranslate"><span class="pre">(k</span> <span class="pre">*</span> <span class="pre">n,</span> <span class="pre">n)</span></code> matrix.</p>
<p>Here, recursion is applied as necessary to ensure that <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">*</span> <span class="pre">n</span></code> is not
larger than <code class="docutils literal notranslate"><span class="pre">m</span></code> (if <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code>). In particular, this is done
to ensure that single core computations do not have to work on blocks
larger than <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n)</span></code>.</p>
<p>Where blocks are irregular, the above logic is applied with the “height” of
the “tallest” block used in place of <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<p>Consider use of the <code class="docutils literal notranslate"><span class="pre">rechunk</span></code> method to control this behavior.
Taller blocks will reduce overall memory use (assuming that many of them
still fit in memory at once).</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.average">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">average</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">weights=None</em>, <em class="sig-param">returned=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the weighted average of array over the given axis.</p>
<p>This docstring was copied from numpy.ma.average.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Data to be averaged.
Masked entries are not taken into account in the computation.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which to average <cite>a</cite>. If None, averaging is done over
the flattened array.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">array_like, optional</span></dt><dd><p>The importance that each element has in the computation of the average.
The weights array can either be 1-D (in which case its length must be
the size of <cite>a</cite> along the given axis) or of the same shape as <cite>a</cite>.
If <code class="docutils literal notranslate"><span class="pre">weights=None</span></code>, then all data in <cite>a</cite> are assumed to have a
weight equal to one.  The 1-D calculation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">avg</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
<p>The only constraint on <cite>weights</cite> is that <cite>sum(weights)</cite> must not be 0.</p>
</dd>
<dt><strong>returned</strong><span class="classifier">bool, optional</span></dt><dd><p>Flag indicating whether a tuple <code class="docutils literal notranslate"><span class="pre">(result,</span> <span class="pre">sum</span> <span class="pre">of</span> <span class="pre">weights)</span></code>
should be returned as output (True), or just the result (False).
Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>average, [sum_of_weights]</strong><span class="classifier">(tuple of) scalar or MaskedArray</span></dt><dd><p>The average along the specified axis. When returned is <cite>True</cite>,
return a tuple with the average as the first element and the sum
of the weights as the second element. The return type is <cite>np.float64</cite>
if <cite>a</cite> is of integer type and floats smaller than <cite>float64</cite>, or the
input data-type, otherwise. If returned, <cite>sum_of_weights</cite> is always
<cite>float64</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="go">1.25</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">6.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">masked_array(</span>
<span class="go">  data=[[0., 1.],</span>
<span class="go">        [2., 3.],</span>
<span class="go">        [4., 5.]],</span>
<span class="go">  mask=False,</span>
<span class="go">  fill_value=1e+20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg</span><span class="p">,</span> <span class="n">sumweights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>  
<span class="gp">... </span>                                <span class="n">returned</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg</span>  
<span class="go">masked_array(data=[2.6666666666666665, 3.6666666666666665],</span>
<span class="go">             mask=[False, False],</span>
<span class="go">       fill_value=1e+20)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.filled">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">filled</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.filled" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input as an array with masked data replaced by a fill value.</p>
<p>This docstring was copied from numpy.ma.filled.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>If <cite>a</cite> is not a <cite>MaskedArray</cite>, <cite>a</cite> itself is returned.
If <cite>a</cite> is a <cite>MaskedArray</cite> and <cite>fill_value</cite> is None, <cite>fill_value</cite> is set to
<code class="docutils literal notranslate"><span class="pre">a.fill_value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">MaskedArray or array_like</span></dt><dd><p>An input object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">array_like, optional.</span></dt><dd><p>Can be scalar or non-scalar. If non-scalar, the
resulting filled array should be broadcastable
over input array. Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a</strong><span class="classifier">ndarray</span></dt><dd><p>The filled array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compressed</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  
<span class="gp">... </span>                                                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>  
<span class="go">array([[999999,      1,      2],</span>
<span class="go">       [999999,      4,      5],</span>
<span class="go">       [     6,      7,      8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="mi">333</span><span class="p">)</span>  
<span class="go">array([[333,   1,   2],</span>
<span class="go">       [333,   4,   5],</span>
<span class="go">       [  6,   7,   8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [0, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.fix_invalid">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">fix_invalid</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.fix_invalid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input with invalid data masked and replaced by a fill value.</p>
<p>This docstring was copied from numpy.ma.fix_invalid.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Invalid data means values of <cite>nan</cite>, <cite>inf</cite>, etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array, a (subclass of) ndarray.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">sequence, optional  (Not supported in Dask)</span></dt><dd><p>Mask. Must be convertible to an array of booleans with the same
shape as <cite>data</cite>. True indicates a masked (i.e. invalid) data.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>Whether to use a copy of <cite>a</cite> (True) or to fix <cite>a</cite> in place (False).
Default is True.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value used for fixing invalid data. Default is None, in which case
the <code class="docutils literal notranslate"><span class="pre">a.fill_value</span></code> is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>b</strong><span class="classifier">MaskedArray</span></dt><dd><p>The input array with invalid entries fixed.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A copy is performed by default.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">masked_array(data=[--, -1.0, nan, inf],</span>
<span class="go">             mask=[ True, False, False, False],</span>
<span class="go">       fill_value=1e+20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">fix_invalid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">masked_array(data=[--, -1.0, --, --],</span>
<span class="go">             mask=[ True, False,  True,  True],</span>
<span class="go">       fill_value=1e+20)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">fix_invalid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">fixed</span><span class="o">.</span><span class="n">data</span>  
<span class="go">array([ 1.e+00, -1.e+00,  1.e+20,  1.e+20])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">data</span>  
<span class="go">array([ 1., -1., nan, inf])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.getdata">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">getdata</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.getdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the data of a masked array as an ndarray.</p>
<p>This docstring was copied from numpy.ma.getdata.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the data of <cite>a</cite> (if any) as an ndarray if <cite>a</cite> is a <code class="docutils literal notranslate"><span class="pre">MaskedArray</span></code>,
else return <cite>a</cite> as a ndarray or subclass (depending on <cite>subok</cite>) if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input <code class="docutils literal notranslate"><span class="pre">MaskedArray</span></code>, alternatively a ndarray or a subclass thereof.</p>
</dd>
<dt><strong>subok</strong><span class="classifier">bool  (Not supported in Dask)</span></dt><dd><p>Whether to force the output to be a <cite>pure</cite> ndarray (False) or to
return a subclass of ndarray if appropriate (True, default).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">getmask</span></code></dt><dd><p>Return the mask of a masked array, or nomask.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ma.getmaskarray" title="dask.array.ma.getmaskarray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getmaskarray</span></code></a></dt><dd><p>Return the mask of a masked array, or full array of False.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_equal</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">masked_array(</span>
<span class="go">  data=[[1, --],</span>
<span class="go">        [3, 4]],</span>
<span class="go">  mask=[[False,  True],</span>
<span class="go">        [False, False]],</span>
<span class="go">  fill_value=2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>Equivalently use the <code class="docutils literal notranslate"><span class="pre">MaskedArray</span></code> <cite>data</cite> attribute.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">data</span>  
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.getmaskarray">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">getmaskarray</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.getmaskarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mask of a masked array, or full boolean array of False.</p>
<p>This docstring was copied from numpy.ma.getmaskarray.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the mask of <cite>arr</cite> as an ndarray if <cite>arr</cite> is a <cite>MaskedArray</cite> and
the mask is not <cite>nomask</cite>, else return a full boolean array of False of
the same shape as <cite>arr</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr</strong><span class="classifier">array_like  (Not supported in Dask)</span></dt><dd><p>Input <cite>MaskedArray</cite> for which the mask is required.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">getmask</span></code></dt><dd><p>Return the mask of a masked array, or nomask.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ma.getdata" title="dask.array.ma.getdata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getdata</span></code></a></dt><dd><p>Return the data of a masked array as an ndarray.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_equal</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">masked_array(</span>
<span class="go">  data=[[1, --],</span>
<span class="go">        [3, 4]],</span>
<span class="go">  mask=[[False,  True],</span>
<span class="go">        [False, False]],</span>
<span class="go">  fill_value=2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">array([[False,  True],</span>
<span class="go">       [False, False]])</span>
</pre></div>
</div>
<p>Result when mask == <code class="docutils literal notranslate"><span class="pre">nomask</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">masked_array(</span>
<span class="go">  data=[[1, 2],</span>
<span class="go">        [3, 4]],</span>
<span class="go">  mask=False,</span>
<span class="go">  fill_value=999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="go">array([[False, False],</span>
<span class="go">       [False, False]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.masked_array">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">masked_array</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">mask=False</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.masked_array" title="Permalink to this definition">¶</a></dt>
<dd><p>An array class with possibly masked values.</p>
<p>This docstring was copied from numpy.ma.masked_array.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Masked values of True exclude the corresponding element from any
computation.</p>
<p>Construction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">nomask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">ndmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hard_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">shrink</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">sequence, optional</span></dt><dd><p>Mask. Must be convertible to an array of booleans with the same
shape as <cite>data</cite>. True indicates a masked (i.e. invalid) data.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional  (Not supported in Dask)</span></dt><dd><p>Data type of the output.
If <cite>dtype</cite> is None, the type of the data argument (<code class="docutils literal notranslate"><span class="pre">data.dtype</span></code>)
is used. If <cite>dtype</cite> is not None and different from <code class="docutils literal notranslate"><span class="pre">data.dtype</span></code>,
a copy is performed.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>Whether to copy the input data (True), or to use a reference instead.
Default is False.</p>
</dd>
<dt><strong>subok</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>Whether to return a subclass of <cite>MaskedArray</cite> if possible (True) or a
plain <cite>MaskedArray</cite>. Default is True.</p>
</dd>
<dt><strong>ndmin</strong><span class="classifier">int, optional  (Not supported in Dask)</span></dt><dd><p>Minimum number of dimensions. Default is 0.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value used to fill in the masked values when necessary.
If None, a default based on the data-type is used.</p>
</dd>
<dt><strong>keep_mask</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>Whether to combine <cite>mask</cite> with the mask of the input data, if any
(True), or to use only <cite>mask</cite> for the output (False). Default is True.</p>
</dd>
<dt><strong>hard_mask</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>Whether to use a hard mask or not. With a hard mask, masked values
cannot be unmasked. Default is False.</p>
</dd>
<dt><strong>shrink</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>Whether to force compression of an empty mask. Default is True.</p>
</dd>
<dt><strong>order</strong><span class="classifier">{‘C’, ‘F’, ‘A’}, optional  (Not supported in Dask)</span></dt><dd><p>Specify the order of the array.  If order is ‘C’, then the array
will be in C-contiguous order (last-index varies the fastest).
If order is ‘F’, then the returned array will be in
Fortran-contiguous order (first-index varies the fastest).
If order is ‘A’ (default), then the returned array may be
in any order (either C-, Fortran-contiguous, or even discontiguous),
unless a copy is required, in which case it will be C-contiguous.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.masked_equal">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">masked_equal</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.masked_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask an array where equal to a given value.</p>
<p>This docstring was copied from numpy.ma.masked_equal.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This function is a shortcut to <code class="docutils literal notranslate"><span class="pre">masked_where</span></code>, with
<cite>condition</cite> = (x == value).  For floating point arrays,
consider using <code class="docutils literal notranslate"><span class="pre">masked_values(x,</span> <span class="pre">value)</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ma.masked_where" title="dask.array.ma.masked_where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_where</span></code></a></dt><dd><p>Mask where a condition is met.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ma.masked_values" title="dask.array.ma.masked_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_values</span></code></a></dt><dd><p>Mask using floating point equality.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([0, 1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">masked_array(data=[0, 1, --, 3],</span>
<span class="go">             mask=[False, False,  True, False],</span>
<span class="go">       fill_value=2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.masked_greater">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">masked_greater</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">value</em>, <em class="sig-param">copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.masked_greater" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask an array where greater than a given value.</p>
<p>This function is a shortcut to <code class="docutils literal notranslate"><span class="pre">masked_where</span></code>, with
<cite>condition</cite> = (x &gt; value).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ma.masked_where" title="dask.array.ma.masked_where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_where</span></code></a></dt><dd><p>Mask where a condition is met.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">masked_array(data=[0, 1, 2, --],</span>
<span class="go">             mask=[False, False, False,  True],</span>
<span class="go">       fill_value=999999)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.masked_greater_equal">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">masked_greater_equal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">value</em>, <em class="sig-param">copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.masked_greater_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask an array where greater than or equal to a given value.</p>
<p>This function is a shortcut to <code class="docutils literal notranslate"><span class="pre">masked_where</span></code>, with
<cite>condition</cite> = (x &gt;= value).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ma.masked_where" title="dask.array.ma.masked_where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_where</span></code></a></dt><dd><p>Mask where a condition is met.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">masked_array(data=[0, 1, --, --],</span>
<span class="go">             mask=[False, False,  True,  True],</span>
<span class="go">       fill_value=999999)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.masked_inside">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">masked_inside</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">v1</em>, <em class="sig-param">v2</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.masked_inside" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask an array inside a given interval.</p>
<p>This docstring was copied from numpy.ma.masked_inside.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Shortcut to <code class="docutils literal notranslate"><span class="pre">masked_where</span></code>, where <cite>condition</cite> is True for <cite>x</cite> inside
the interval [v1,v2] (v1 &lt;= x &lt;= v2).  The boundaries <cite>v1</cite> and <cite>v2</cite>
can be given in either order.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ma.masked_where" title="dask.array.ma.masked_where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_where</span></code></a></dt><dd><p>Mask where a condition is met.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The array <cite>x</cite> is prefilled with its filling value.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.31</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.1</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>  
<span class="go">masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],</span>
<span class="go">             mask=[False, False,  True,  True, False, False],</span>
<span class="go">       fill_value=1e+20)</span>
</pre></div>
</div>
<p>The order of <cite>v1</cite> and <cite>v2</cite> doesn’t matter.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">)</span>  
<span class="go">masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],</span>
<span class="go">             mask=[False, False,  True,  True, False, False],</span>
<span class="go">       fill_value=1e+20)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.masked_invalid">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">masked_invalid</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.masked_invalid" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask an array where invalid values occur (NaNs or infs).</p>
<p>This docstring was copied from numpy.ma.masked_invalid.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This function is a shortcut to <code class="docutils literal notranslate"><span class="pre">masked_where</span></code>, with
<cite>condition</cite> = ~(np.isfinite(a)). Any pre-existing mask is conserved.
Only applies to arrays with a dtype where NaNs or infs make sense
(i.e. floating point types), but accepts any array_like object.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ma.masked_where" title="dask.array.ma.masked_where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_where</span></code></a></dt><dd><p>Mask where a condition is met.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">PINF</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([ 0.,  1., nan, inf,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  
<span class="go">masked_array(data=[0.0, 1.0, --, --, 4.0],</span>
<span class="go">             mask=[False, False,  True,  True, False],</span>
<span class="go">       fill_value=1e+20)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.masked_less">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">masked_less</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">value</em>, <em class="sig-param">copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.masked_less" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask an array where less than a given value.</p>
<p>This function is a shortcut to <code class="docutils literal notranslate"><span class="pre">masked_where</span></code>, with
<cite>condition</cite> = (x &lt; value).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ma.masked_where" title="dask.array.ma.masked_where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_where</span></code></a></dt><dd><p>Mask where a condition is met.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_less</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">masked_array(data=[--, --, 2, 3],</span>
<span class="go">             mask=[ True,  True, False, False],</span>
<span class="go">       fill_value=999999)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.masked_less_equal">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">masked_less_equal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">value</em>, <em class="sig-param">copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.masked_less_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask an array where less than or equal to a given value.</p>
<p>This function is a shortcut to <code class="docutils literal notranslate"><span class="pre">masked_where</span></code>, with
<cite>condition</cite> = (x &lt;= value).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ma.masked_where" title="dask.array.ma.masked_where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_where</span></code></a></dt><dd><p>Mask where a condition is met.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_less_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">masked_array(data=[--, --, --, 3],</span>
<span class="go">             mask=[ True,  True,  True, False],</span>
<span class="go">       fill_value=999999)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.masked_not_equal">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">masked_not_equal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">value</em>, <em class="sig-param">copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.masked_not_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask an array where <cite>not</cite> equal to a given value.</p>
<p>This function is a shortcut to <code class="docutils literal notranslate"><span class="pre">masked_where</span></code>, with
<cite>condition</cite> = (x != value).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ma.masked_where" title="dask.array.ma.masked_where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_where</span></code></a></dt><dd><p>Mask where a condition is met.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_not_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">masked_array(data=[--, --, 2, --],</span>
<span class="go">             mask=[ True,  True, False,  True],</span>
<span class="go">       fill_value=999999)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.masked_outside">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">masked_outside</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">v1</em>, <em class="sig-param">v2</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.masked_outside" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask an array outside a given interval.</p>
<p>This docstring was copied from numpy.ma.masked_outside.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Shortcut to <code class="docutils literal notranslate"><span class="pre">masked_where</span></code>, where <cite>condition</cite> is True for <cite>x</cite> outside
the interval [v1,v2] (x &lt; v1)|(x &gt; v2).
The boundaries <cite>v1</cite> and <cite>v2</cite> can be given in either order.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ma.masked_where" title="dask.array.ma.masked_where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_where</span></code></a></dt><dd><p>Mask where a condition is met.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The array <cite>x</cite> is prefilled with its filling value.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.31</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.1</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_outside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>  
<span class="go">masked_array(data=[--, --, 0.01, 0.2, --, --],</span>
<span class="go">             mask=[ True,  True, False, False,  True,  True],</span>
<span class="go">       fill_value=1e+20)</span>
</pre></div>
</div>
<p>The order of <cite>v1</cite> and <cite>v2</cite> doesn’t matter.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_outside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">)</span>  
<span class="go">masked_array(data=[--, --, 0.01, 0.2, --, --],</span>
<span class="go">             mask=[ True,  True, False, False,  True,  True],</span>
<span class="go">       fill_value=1e+20)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.masked_values">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">masked_values</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">value</em>, <em class="sig-param">rtol=1e-05</em>, <em class="sig-param">atol=1e-08</em>, <em class="sig-param">shrink=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.masked_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask using floating point equality.</p>
<p>This docstring was copied from numpy.ma.masked_values.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return a MaskedArray, masked where the data in array <cite>x</cite> are approximately
equal to <cite>value</cite>, determined using <cite>isclose</cite>. The default tolerances for
<cite>masked_values</cite> are the same as those for <cite>isclose</cite>.</p>
<p>For integer types, exact equality is used, in the same way as
<cite>masked_equal</cite>.</p>
<p>The fill_value is set to <cite>value</cite> and the mask is set to <code class="docutils literal notranslate"><span class="pre">nomask</span></code> if
possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Array to mask.</p>
</dd>
<dt><strong>value</strong><span class="classifier">float</span></dt><dd><p>Masking value.</p>
</dd>
<dt><strong>rtol, atol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance parameters passed on to <cite>isclose</cite></p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional  (Not supported in Dask)</span></dt><dd><p>Whether to return a copy of <cite>x</cite>.</p>
</dd>
<dt><strong>shrink</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to collapse a mask full of False to <code class="docutils literal notranslate"><span class="pre">nomask</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">MaskedArray</span></dt><dd><p>The result of masking <cite>x</cite> where approximately equal to <cite>value</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ma.masked_where" title="dask.array.ma.masked_where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_where</span></code></a></dt><dd><p>Mask where a condition is met.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ma.masked_equal" title="dask.array.ma.masked_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_equal</span></code></a></dt><dd><p>Mask where equal to a given value (integers).</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">)</span>  
<span class="go">masked_array(data=[1.0, --, 2.0, --, 3.0],</span>
<span class="go">             mask=[False,  True, False,  True, False],</span>
<span class="go">       fill_value=1.1)</span>
</pre></div>
</div>
<p>Note that <cite>mask</cite> is set to <code class="docutils literal notranslate"><span class="pre">nomask</span></code> if possible.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>  
<span class="go">masked_array(data=[1. , 1.1, 2. , 1.1, 3. ],</span>
<span class="go">             mask=False,</span>
<span class="go">       fill_value=1.5)</span>
</pre></div>
</div>
<p>For integers, the fill value will be different in general to the
result of <code class="docutils literal notranslate"><span class="pre">masked_equal</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  
<span class="go">array([0, 1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">masked_array(data=[0, 1, --, 3, 4],</span>
<span class="go">             mask=[False, False,  True, False, False],</span>
<span class="go">       fill_value=2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">masked_array(data=[0, 1, --, 3, 4],</span>
<span class="go">             mask=[False, False,  True, False, False],</span>
<span class="go">       fill_value=2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.masked_where">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">masked_where</code><span class="sig-paren">(</span><em class="sig-param">condition</em>, <em class="sig-param">a</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.masked_where" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask an array where a condition is met.</p>
<p>This docstring was copied from numpy.ma.masked_where.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return <cite>a</cite> as an array masked where <cite>condition</cite> is True.
Any masked values of <cite>a</cite> or <cite>condition</cite> are also masked in the output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>condition</strong><span class="classifier">array_like</span></dt><dd><p>Masking condition.  When <cite>condition</cite> tests floating point values for
equality, consider using <code class="docutils literal notranslate"><span class="pre">masked_values</span></code> instead.</p>
</dd>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Array to mask.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool  (Not supported in Dask)</span></dt><dd><p>If True (default) make a copy of <cite>a</cite> in the result.  If False modify
<cite>a</cite> in place and return a view.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">MaskedArray</span></dt><dd><p>The result of masking <cite>a</cite> where <cite>condition</cite> is True.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.ma.masked_values" title="dask.array.ma.masked_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_values</span></code></a></dt><dd><p>Mask using floating point equality.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ma.masked_equal" title="dask.array.ma.masked_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_equal</span></code></a></dt><dd><p>Mask where equal to a given value.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ma.masked_not_equal" title="dask.array.ma.masked_not_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_not_equal</span></code></a></dt><dd><p>Mask where <cite>not</cite> equal to a given value.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ma.masked_less_equal" title="dask.array.ma.masked_less_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_less_equal</span></code></a></dt><dd><p>Mask where less than or equal to a given value.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ma.masked_greater_equal" title="dask.array.ma.masked_greater_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_greater_equal</span></code></a></dt><dd><p>Mask where greater than or equal to a given value.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ma.masked_less" title="dask.array.ma.masked_less"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_less</span></code></a></dt><dd><p>Mask where less than a given value.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ma.masked_greater" title="dask.array.ma.masked_greater"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_greater</span></code></a></dt><dd><p>Mask where greater than a given value.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ma.masked_inside" title="dask.array.ma.masked_inside"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_inside</span></code></a></dt><dd><p>Mask inside a given interval.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ma.masked_outside" title="dask.array.ma.masked_outside"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_outside</span></code></a></dt><dd><p>Mask outside a given interval.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.ma.masked_invalid" title="dask.array.ma.masked_invalid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_invalid</span></code></a></dt><dd><p>Mask invalid values (NaNs or infs).</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([0, 1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  
<span class="go">masked_array(data=[--, --, --, 3],</span>
<span class="go">             mask=[ True,  True,  True, False],</span>
<span class="go">       fill_value=999999)</span>
</pre></div>
</div>
<p>Mask array <cite>b</cite> conditional on <cite>a</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">masked_array(data=[&#39;a&#39;, &#39;b&#39;, --, &#39;d&#39;],</span>
<span class="go">             mask=[False, False,  True, False],</span>
<span class="go">       fill_value=&#39;N/A&#39;,</span>
<span class="go">            dtype=&#39;&lt;U1&#39;)</span>
</pre></div>
</div>
<p>Effect of the <cite>copy</cite> argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>  
<span class="go">masked_array(data=[--, --, --, 3],</span>
<span class="go">             mask=[ True,  True,  True, False],</span>
<span class="go">       fill_value=999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>  
<span class="go">masked_array(data=[99, --, --, 3],</span>
<span class="go">             mask=[False,  True,  True, False],</span>
<span class="go">       fill_value=999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([0, 1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>  
<span class="go">masked_array(data=[99, --, --, 3],</span>
<span class="go">             mask=[False,  True,  True, False],</span>
<span class="go">       fill_value=999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([99,  1,  2,  3])</span>
</pre></div>
</div>
<p>When <cite>condition</cite> or <cite>a</cite> contain masked values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">masked_array(data=[0, 1, --, 3],</span>
<span class="go">             mask=[False, False,  True, False],</span>
<span class="go">       fill_value=999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">masked_array(data=[--, 1, 2, 3],</span>
<span class="go">             mask=[ True, False, False, False],</span>
<span class="go">       fill_value=999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="go">masked_array(data=[--, 1, --, --],</span>
<span class="go">             mask=[ True, False,  True,  True],</span>
<span class="go">       fill_value=999999)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.ma.set_fill_value">
<code class="sig-prename descclassname">dask.array.ma.</code><code class="sig-name descname">set_fill_value</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">fill_value</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.ma.set_fill_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the filling value of a, if a is a masked array.</p>
<p>This docstring was copied from numpy.ma.set_fill_value.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This function changes the fill value of the masked array <cite>a</cite> in place.
If <cite>a</cite> is not a masked array, the function returns silently, without
doing anything.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">dtype</span></dt><dd><p>Filling value. A consistency test is performed to make sure
the value is compatible with the dtype of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>None</strong></dt><dd><p>Nothing returned by this function.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">maximum_fill_value</span></code></dt><dd><p>Return the default fill value for a dtype.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">MaskedArray.fill_value</span></code></dt><dd><p>Return current fill value.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">MaskedArray.set_fill_value</span></code></dt><dd><p>Equivalent method.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([0, 1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">masked_array(data=[--, --, --, 3, 4],</span>
<span class="go">             mask=[ True,  True,  True, False, False],</span>
<span class="go">       fill_value=999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">set_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">999</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">masked_array(data=[--, --, --, 3, 4],</span>
<span class="go">             mask=[ True,  True,  True, False, False],</span>
<span class="go">       fill_value=-999)</span>
</pre></div>
</div>
<p>Nothing happens if <cite>a</cite> is not a masked array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">set_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([0, 1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">set_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([0, 1, 2, 3, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.overlap.overlap">
<code class="sig-prename descclassname">dask.array.overlap.</code><code class="sig-name descname">overlap</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">depth</em>, <em class="sig-param">boundary</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.overlap.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Share boundaries between neighboring blocks</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x: da.Array</strong></dt><dd><p>A dask array</p>
</dd>
<dt><strong>depth: dict</strong></dt><dd><p>The size of the shared boundary per axis</p>
</dd>
<dt><strong>boundary: dict</strong></dt><dd><p>The boundary condition on each axis. Options are ‘reflect’, ‘periodic’,
‘nearest’, ‘none’, or an array value.  Such a value will fill the
boundary with that value.</p>
</dd>
<dt><strong>The depth input informs how many cells to overlap between neighboring</strong></dt><dd></dd>
<dt><strong>blocks ``{0: 2, 2: 5}`` means share two cells in 0 axis, 5 cells in 2 axis.</strong></dt><dd></dd>
<dt><strong>Axes missing from this input will not be overlapped.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">chunks</span>
<span class="go">((4, 4), (4, 4))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">overlap</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
<span class="gp">... </span>                      <span class="n">boundary</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;reflect&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">chunks</span>
<span class="go">((8, 8), (6, 6))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">array([[100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [  0,   0,   1,   2,   3,   4,   3,   4,   5,   6,   7,   7],</span>
<span class="go">       [  8,   8,   9,  10,  11,  12,  11,  12,  13,  14,  15,  15],</span>
<span class="go">       [ 16,  16,  17,  18,  19,  20,  19,  20,  21,  22,  23,  23],</span>
<span class="go">       [ 24,  24,  25,  26,  27,  28,  27,  28,  29,  30,  31,  31],</span>
<span class="go">       [ 32,  32,  33,  34,  35,  36,  35,  36,  37,  38,  39,  39],</span>
<span class="go">       [ 40,  40,  41,  42,  43,  44,  43,  44,  45,  46,  47,  47],</span>
<span class="go">       [ 16,  16,  17,  18,  19,  20,  19,  20,  21,  22,  23,  23],</span>
<span class="go">       [ 24,  24,  25,  26,  27,  28,  27,  28,  29,  30,  31,  31],</span>
<span class="go">       [ 32,  32,  33,  34,  35,  36,  35,  36,  37,  38,  39,  39],</span>
<span class="go">       [ 40,  40,  41,  42,  43,  44,  43,  44,  45,  46,  47,  47],</span>
<span class="go">       [ 48,  48,  49,  50,  51,  52,  51,  52,  53,  54,  55,  55],</span>
<span class="go">       [ 56,  56,  57,  58,  59,  60,  59,  60,  61,  62,  63,  63],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.overlap.map_overlap">
<code class="sig-prename descclassname">dask.array.overlap.</code><code class="sig-name descname">map_overlap</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">func</em>, <em class="sig-param">depth</em>, <em class="sig-param">boundary=None</em>, <em class="sig-param">trim=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.overlap.map_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a function over blocks of the array with some overlap</p>
<p>We share neighboring zones between blocks of the array, then map a
function, then trim away the neighboring strips.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func: function</strong></dt><dd><p>The function to apply to each extended block</p>
</dd>
<dt><strong>depth: int, tuple, or dict</strong></dt><dd><p>The number of elements that each block should share with its neighbors
If a tuple or dict then this can be different per axis.
Asymmetric depths may be specified using a dict value of (-/+) tuples.
Note that asymmetric depths are currently only supported when
<code class="docutils literal notranslate"><span class="pre">boundary</span></code> is ‘none’.</p>
</dd>
<dt><strong>boundary: str, tuple, dict</strong></dt><dd><p>How to handle the boundaries.
Values include ‘reflect’, ‘periodic’, ‘nearest’, ‘none’,
or any constant value like 0 or np.nan</p>
</dd>
<dt><strong>trim: bool</strong></dt><dd><p>Whether or not to trim <code class="docutils literal notranslate"><span class="pre">depth</span></code> elements from each block after
calling the map function.
Set this to False if your mapping function already does this for you</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>Other keyword arguments valid in <code class="docutils literal notranslate"><span class="pre">map_blocks</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span><span class="n">derivative</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([ 1,  0,  1,  1,  0,  0, -1, -1,  0])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([[16, 17, 18, 19],</span>
<span class="go">       [20, 21, 22, 23],</span>
<span class="go">       [24, 25, 26, 27],</span>
<span class="go">       [28, 29, 30, 31]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">depth</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">boundary</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;none&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>  
<span class="go">array([[12,  13,  14,  15],</span>
<span class="go">       [16,  17,  18,  19],</span>
<span class="go">       [20,  21,  22,  23],</span>
<span class="go">       [24,  25,  26,  27]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.overlap.trim_internal">
<code class="sig-prename descclassname">dask.array.overlap.</code><code class="sig-name descname">trim_internal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">axes</em>, <em class="sig-param">boundary=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.overlap.trim_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>Trim sides from each block</p>
<p>This couples well with the overlap operation, which may leave excess data on
each block</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.chunk.trim</span></code>, <a class="reference internal" href="#dask.array.map_blocks" title="dask.array.map_blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.map_blocks</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.overlap.trim_overlap">
<code class="sig-prename descclassname">dask.array.overlap.</code><code class="sig-name descname">trim_overlap</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">depth</em>, <em class="sig-param">boundary=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.overlap.trim_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Trim sides from each block.</p>
<p>This couples well with the <code class="docutils literal notranslate"><span class="pre">map_overlap</span></code> operation which may leave
excess data on each block.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.overlap.map_overlap" title="dask.array.overlap.map_overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.overlap.map_overlap</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">from_array</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">chunks='auto'</em>, <em class="sig-param">name=None</em>, <em class="sig-param">lock=False</em>, <em class="sig-param">asarray=None</em>, <em class="sig-param">fancy=True</em>, <em class="sig-param">getitem=None</em>, <em class="sig-param">meta=None</em><span class="sig-paren">)</span></dt>
<dd><p>Create dask array from something that looks like an array</p>
<p>Input must have a <code class="docutils literal notranslate"><span class="pre">.shape</span></code>, <code class="docutils literal notranslate"><span class="pre">.ndim</span></code>, <code class="docutils literal notranslate"><span class="pre">.dtype</span></code> and support numpy-style slicing.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>chunks</strong><span class="classifier">int, tuple</span></dt><dd><p>How to chunk the array. Must be one of the following forms:</p>
<ul class="simple">
<li><p>A blocksize like 1000.</p></li>
<li><p>A blockshape like (1000, 1000).</p></li>
<li><p>Explicit sizes of all blocks along all dimensions like
((1000, 1000, 500), (400, 400)).</p></li>
<li><p>A size in bytes, like “100 MiB” which will choose a uniform
block-like shape</p></li>
<li><p>The word “auto” which acts like the above, but uses a configuration
value <code class="docutils literal notranslate"><span class="pre">array.chunk-size</span></code> for the chunk size</p></li>
</ul>
<p>-1 or None as a blocksize indicate the size of the corresponding
dimension.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>The key name to use for the array. Defaults to a hash of <code class="docutils literal notranslate"><span class="pre">x</span></code>.
By default, hash uses python’s standard sha1. This behaviour can be
changed by installing cityhash, xxhash or murmurhash. If installed,
a large-factor speedup can be obtained in the tokenisation step.
Use <code class="docutils literal notranslate"><span class="pre">name=False</span></code> to generate a random name instead of hashing (fast)</p>
</dd>
<dt><strong>lock</strong><span class="classifier">bool or Lock, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> doesn’t support concurrent reads then provide a lock here, or
pass in True to have dask.array create one for you.</p>
</dd>
<dt><strong>asarray</strong><span class="classifier">bool, optional</span></dt><dd><p>If True then call np.asarray on chunks to convert them to numpy arrays.
If False then chunks are passed through unchanged.
If None (default) then we use True if the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> method
is undefined.</p>
</dd>
<dt><strong>fancy</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> doesn’t support fancy indexing (e.g. indexing with lists or
arrays) then set to False. Default is True.</p>
</dd>
<dt><strong>meta</strong><span class="classifier">Array-like, optional</span></dt><dd><p>The metadata for the resulting dask array.  This is the kind of array
that will result from slicing the input array.
Defaults to the input array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)[</span><span class="s1">&#39;/data/path&#39;</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>  
</pre></div>
</div>
<p>If your underlying datastore does not support concurrent reads then include
the <code class="docutils literal notranslate"><span class="pre">lock=True</span></code> keyword argument or <code class="docutils literal notranslate"><span class="pre">lock=mylock</span></code> if you want multiple
arrays to coordinate around the same lock.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="n">lock</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
</pre></div>
</div>
<p>If your underlying datastore has a <code class="docutils literal notranslate"><span class="pre">.chunks</span></code> attribute (as h5py and zarr
datasets do) then a multiple of that chunk shape will be used if you
do not provide a chunk shape.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="s1">&#39;100 MiB&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">from_delayed</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">shape</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">meta=None</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span></dt>
<dd><p>Create a dask array from a dask delayed value</p>
<p>This routine is useful for constructing dask arrays in an ad-hoc fashion
using dask delayed, particularly when combined with stack and concatenate.</p>
<p>The dask array will consist of a single chunk.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">)(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_delayed</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span>
<span class="go">dask.array&lt;from-value, shape=(5,), dtype=float64, chunksize=(5,), chunktype=numpy.ndarray&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([1., 1., 1., 1., 1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.from_npy_stack">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">from_npy_stack</code><span class="sig-paren">(</span><em class="sig-param">dirname</em>, <em class="sig-param">mmap_mode='r'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.from_npy_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Load dask array from stack of npy files</p>
<p>See <code class="docutils literal notranslate"><span class="pre">da.to_npy_stack</span></code> for docstring</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dirname: string</strong></dt><dd><p>Directory of .npy files</p>
</dd>
<dt><strong>mmap_mode: (None or ‘r’)</strong></dt><dd><p>Read data in memory map mode</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.array.from_zarr">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">from_zarr</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">component=None</em>, <em class="sig-param">storage_options=None</em>, <em class="sig-param">chunks=None</em>, <em class="sig-param">name=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.from_zarr" title="Permalink to this definition">¶</a></dt>
<dd><p>Load array from the zarr storage format</p>
<p>See <a class="reference external" href="https://zarr.readthedocs.io">https://zarr.readthedocs.io</a> for details about the format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>url: Zarr Array or str or MutableMapping</strong></dt><dd><p>Location of the data. A URL can include a protocol specifier like s3://
for remote data. Can also be any MutableMapping instance, which should
be serializable if used in multiple processes.</p>
</dd>
<dt><strong>component: str or None</strong></dt><dd><p>If the location is a zarr group rather than an array, this is the
subcomponent that should be loaded, something like <code class="docutils literal notranslate"><span class="pre">'foo/bar'</span></code>.</p>
</dd>
<dt><strong>storage_options: dict</strong></dt><dd><p>Any additional parameters for the storage backend (ignored for local
paths)</p>
</dd>
<dt><strong>chunks: tuple of ints or tuples of ints</strong></dt><dd><p>Passed to <code class="docutils literal notranslate"><span class="pre">da.from_array</span></code>, allows setting the chunks on
initialisation, if the chunking scheme in the on-disc dataset is not
optimal for the calculations to follow.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>An optional keyname for the array.  Defaults to hashing the input</p>
</dd>
<dt><strong>kwargs: passed to ``zarr.Array``.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.array.from_tiledb">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">from_tiledb</code><span class="sig-paren">(</span><em class="sig-param">uri</em>, <em class="sig-param">attribute=None</em>, <em class="sig-param">chunks=None</em>, <em class="sig-param">storage_options=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.from_tiledb" title="Permalink to this definition">¶</a></dt>
<dd><p>Load array from the TileDB storage format</p>
<p>See <a class="reference external" href="https://docs.tiledb.io">https://docs.tiledb.io</a> for more information about TileDB.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>uri: TileDB array or str</strong></dt><dd><p>Location to save the data</p>
</dd>
<dt><strong>attribute: str or None</strong></dt><dd><p>Attribute selection (single-attribute view on multi-attribute array)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>A Dask Array</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># create a tiledb array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">tiledb</span><span class="o">,</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span><span class="o">,</span> <span class="nn">tempfile</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">uri</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">tiledb</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  
<span class="go">&lt;tiledb.libtiledb.DenseArray object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># read back the array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">tdb_ar</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_tiledb</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">tdb_ar</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(3, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tdb_ar</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>  
<span class="go">4.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">store</code><span class="sig-paren">(</span><em class="sig-param">sources</em>, <em class="sig-param">targets</em>, <em class="sig-param">lock=True</em>, <em class="sig-param">regions=None</em>, <em class="sig-param">compute=True</em>, <em class="sig-param">return_stored=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Store dask arrays in array-like objects, overwrite data in target</p>
<p>This stores dask arrays into object that supports numpy-style setitem
indexing.  It stores values chunk by chunk so that it does not have to
fill up memory.  For best performance you can align the block size of
the storage target with the block size of your array.</p>
<p>If your data fits in memory then you may prefer calling
<code class="docutils literal notranslate"><span class="pre">np.array(myarray)</span></code> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sources: Array or iterable of Arrays</strong></dt><dd></dd>
<dt><strong>targets: array-like or Delayed or iterable of array-likes and/or Delayeds</strong></dt><dd><p>These should support setitem syntax <code class="docutils literal notranslate"><span class="pre">target[10:20]</span> <span class="pre">=</span> <span class="pre">...</span></code></p>
</dd>
<dt><strong>lock: boolean or threading.Lock, optional</strong></dt><dd><p>Whether or not to lock the data stores while storing.
Pass True (lock each file individually), False (don’t lock) or a
particular <code class="docutils literal notranslate"><span class="pre">threading.Lock</span></code> object to be shared among all writes.</p>
</dd>
<dt><strong>regions: tuple of slices or list of tuples of slices</strong></dt><dd><p>Each <code class="docutils literal notranslate"><span class="pre">region</span></code> tuple in <code class="docutils literal notranslate"><span class="pre">regions</span></code> should be such that
<code class="docutils literal notranslate"><span class="pre">target[region].shape</span> <span class="pre">=</span> <span class="pre">source.shape</span></code>
for the corresponding source and target in sources and targets,
respectively. If this is a tuple, the contents will be assumed to be
slices, so do not provide a tuple of tuples.</p>
</dd>
<dt><strong>compute: boolean, optional</strong></dt><dd><p>If true compute immediately, return <code class="docutils literal notranslate"><span class="pre">dask.delayed.Delayed</span></code> otherwise</p>
</dd>
<dt><strong>return_stored: boolean, optional</strong></dt><dd><p>Optionally return the stored result (default False).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="o">...</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">h5py</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;myfile.hdf5&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">dset</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;/data&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">chunks</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">store</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dset</span><span class="p">)</span>  
</pre></div>
</div>
<p>Alternatively store many arrays at the same time</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">store</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="p">[</span><span class="n">dset1</span><span class="p">,</span> <span class="n">dset2</span><span class="p">,</span> <span class="n">dset3</span><span class="p">])</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.to_hdf5">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">to_hdf5</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.to_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Store arrays in HDF5 file</p>
<p>This saves several dask arrays into several datapaths in an HDF5 file.
It creates the necessary datasets and handles clean file opening/closing.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">to_hdf5</span><span class="p">(</span><span class="s1">&#39;myfile.hdf5&#39;</span><span class="p">,</span> <span class="s1">&#39;/x&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>  
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">to_hdf5</span><span class="p">(</span><span class="s1">&#39;myfile.hdf5&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;/x&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;/y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>  
</pre></div>
</div>
<p>Optionally provide arguments as though to <code class="docutils literal notranslate"><span class="pre">h5py.File.create_dataset</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">to_hdf5</span><span class="p">(</span><span class="s1">&#39;myfile.hdf5&#39;</span><span class="p">,</span> <span class="s1">&#39;/x&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s1">&#39;lzf&#39;</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
</pre></div>
</div>
<p>This can also be used as a method on a single Array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_hdf5</span><span class="p">(</span><span class="s1">&#39;myfile.hdf5&#39;</span><span class="p">,</span> <span class="s1">&#39;/x&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">da.store</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">h5py.File.create_dataset</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.to_zarr">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">to_zarr</code><span class="sig-paren">(</span><em class="sig-param">arr</em>, <em class="sig-param">url</em>, <em class="sig-param">component=None</em>, <em class="sig-param">storage_options=None</em>, <em class="sig-param">overwrite=False</em>, <em class="sig-param">compute=True</em>, <em class="sig-param">return_stored=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.to_zarr" title="Permalink to this definition">¶</a></dt>
<dd><p>Save array to the zarr storage format</p>
<p>See <a class="reference external" href="https://zarr.readthedocs.io">https://zarr.readthedocs.io</a> for details about the format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr: dask.array</strong></dt><dd><p>Data to store</p>
</dd>
<dt><strong>url: Zarr Array or str or MutableMapping</strong></dt><dd><p>Location of the data. A URL can include a protocol specifier like s3://
for remote data. Can also be any MutableMapping instance, which should
be serializable if used in multiple processes.</p>
</dd>
<dt><strong>component: str or None</strong></dt><dd><p>If the location is a zarr group rather than an array, this is the
subcomponent that should be created/over-written.</p>
</dd>
<dt><strong>storage_options: dict</strong></dt><dd><p>Any additional parameters for the storage backend (ignored for local
paths)</p>
</dd>
<dt><strong>overwrite: bool</strong></dt><dd><p>If given array already exists, overwrite=False will cause an error,
where overwrite=True will replace the existing data.  Note that this
check is done at computation time, not during graph creation.</p>
</dd>
<dt><strong>compute, return_stored: see ``store()``</strong></dt><dd></dd>
<dt><strong>kwargs: passed to the ``zarr.create()`` function, e.g., compression options</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">arr</span></code> has unknown chunk sizes, which is not supported by Zarr.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.Array.compute_chunk_sizes" title="dask.array.Array.compute_chunk_sizes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array.compute_chunk_sizes</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.to_npy_stack">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">to_npy_stack</code><span class="sig-paren">(</span><em class="sig-param">dirname</em>, <em class="sig-param">x</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.to_npy_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Write dask array to a stack of .npy files</p>
<p>This partitions the dask.array along one axis and stores each block along
that axis as a single .npy file in the specified directory</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.from_npy_stack" title="dask.array.from_npy_stack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_npy_stack</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">to_npy_stack</span><span class="p">(</span><span class="s1">&#39;data/&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">.npy</span></code> files store numpy arrays for <code class="docutils literal notranslate"><span class="pre">x[0:2],</span> <span class="pre">x[2:4],</span> <span class="pre">and</span> <span class="pre">x[4:5]</span></code>
respectively, as is specified by the chunk size along the zeroth axis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ tree data/
data/
|-- 0.npy
|-- 1.npy
|-- 2.npy
|-- info
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">info</span></code> file stores the dtype, chunks, and axis information of the array.
You can load these stacks with the <code class="docutils literal notranslate"><span class="pre">da.from_npy_stack</span></code> function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_npy_stack</span><span class="p">(</span><span class="s1">&#39;data/&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.to_tiledb">
<code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">to_tiledb</code><span class="sig-paren">(</span><em class="sig-param">darray</em>, <em class="sig-param">uri</em>, <em class="sig-param">compute=True</em>, <em class="sig-param">return_stored=False</em>, <em class="sig-param">storage_options=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.to_tiledb" title="Permalink to this definition">¶</a></dt>
<dd><p>Save array to the TileDB storage format</p>
<p>Save ‘array’ using the TileDB storage manager, to any TileDB-supported URI,
including local disk, S3, or HDFS.</p>
<p>See <a class="reference external" href="https://docs.tiledb.io">https://docs.tiledb.io</a> for more information about TileDB.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>darray: dask.array</strong></dt><dd><p>A dask array to write.</p>
</dd>
<dt><strong>uri:</strong></dt><dd><p>Any supported TileDB storage location.</p>
</dd>
<dt><strong>storage_options: dict</strong></dt><dd><p>Dict containing any configuration options for the TileDB backend.
see <a class="reference external" href="https://docs.tiledb.io/en/stable/tutorials/config.html">https://docs.tiledb.io/en/stable/tutorials/config.html</a></p>
</dd>
<dt><strong>compute, return_stored: see ``store()``</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>None</strong></dt><dd><p>Unless <code class="docutils literal notranslate"><span class="pre">return_stored</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>TileDB only supports regularly-chunked arrays.
TileDB <a class="reference external" href="http://docs.dask.org/en/latest/array-chunks.html">tile extents</a> correspond to form 2 of the dask
<a class="reference external" href="https://docs.tiledb.io/en/stable/tutorials/tiling-dense.html">chunk specification</a>, and the conversion is
done automatically for supported arrays.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span><span class="o">,</span> <span class="nn">tempfile</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">uri</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>   
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">to_tiledb</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">uri</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">tiledb</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">tdb_ar</span> <span class="o">=</span> <span class="n">tiledb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="nb">all</span><span class="p">(</span><span class="n">tdb_ar</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span>  
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.fft_wrap">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">fft_wrap</code><span class="sig-paren">(</span><em class="sig-param">fft_func</em>, <em class="sig-param">kind=None</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.fft_wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap 1D, 2D, and ND real and complex FFT functions</p>
<p>Takes a function that behaves like <code class="docutils literal notranslate"><span class="pre">numpy.fft</span></code> functions and
a specified kind to match it to that are named after the functions
in the <code class="docutils literal notranslate"><span class="pre">numpy.fft</span></code> API.</p>
<p>Supported kinds include:</p>
<blockquote>
<div><ul class="simple">
<li><p>fft</p></li>
<li><p>fft2</p></li>
<li><p>fftn</p></li>
<li><p>ifft</p></li>
<li><p>ifft2</p></li>
<li><p>ifftn</p></li>
<li><p>rfft</p></li>
<li><p>rfft2</p></li>
<li><p>rfftn</p></li>
<li><p>irfft</p></li>
<li><p>irfft2</p></li>
<li><p>irfftn</p></li>
<li><p>hfft</p></li>
<li><p>ihfft</p></li>
</ul>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parallel_fft</span> <span class="o">=</span> <span class="n">fft_wrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parallel_ifft</span> <span class="o">=</span> <span class="n">fft_wrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.fft">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">fft</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">n=None</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.fft</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.fft docstring follows below:</p>
<p>Compute the one-dimensional discrete Fourier Transform.</p>
<p>This function computes the one-dimensional <em>n</em>-point discrete Fourier
Transform (DFT) with the efficient Fast Fourier Transform (FFT)
algorithm [CT].</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array, can be complex.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>Length of the transformed axis of the output.
If <cite>n</cite> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If <cite>n</cite> is not given,
the length of the input along the axis specified by <cite>axis</cite> is used.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis over which to compute the FFT.  If not given, the last axis is
used.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">complex ndarray</span></dt><dd><p>The truncated or zero-padded input, transformed along the axis
indicated by <cite>axis</cite>, or the last one if <cite>axis</cite> is not specified.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>IndexError</strong></dt><dd><p>if <cite>axes</cite> is larger than the last axis of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/routines.fft.html#module-numpy.fft" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.fft</span></code></a></dt><dd><p>for definition of the DFT and conventions used.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.ifft" title="dask.array.fft.ifft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifft</span></code></a></dt><dd><p>The inverse of <cite>fft</cite>.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fft2" title="dask.array.fft.fft2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft2</span></code></a></dt><dd><p>The two-dimensional FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fftn" title="dask.array.fft.fftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftn</span></code></a></dt><dd><p>The <em>n</em>-dimensional FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.rfftn" title="dask.array.fft.rfftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfftn</span></code></a></dt><dd><p>The <em>n</em>-dimensional FFT of real input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fftfreq" title="dask.array.fft.fftfreq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftfreq</span></code></a></dt><dd><p>Frequency bins for given FFT parameters.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>FFT (Fast Fourier Transform) refers to a way the discrete Fourier
Transform (DFT) can be calculated efficiently, by using symmetries in the
calculated terms.  The symmetry is highest when <cite>n</cite> is a power of 2, and
the transform is therefore most efficient for these sizes.</p>
<p>The DFT is defined, with the conventions used in this implementation, in
the documentation for the <cite>numpy.fft</cite> module.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r83543ef959bc-ct"><span class="brackets"><a class="fn-backref" href="#id33">CT</a></span></dt>
<dd><p>Cooley, James W., and John W. Tukey, 1965, “An algorithm for the
machine calculation of complex Fourier series,” <em>Math. Comput.</em>
19: 297-301.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,</span>
<span class="go">        2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,</span>
<span class="go">       -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,</span>
<span class="go">        1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])</span>
</pre></div>
</div>
<p>In this example, real input has an FFT which is Hermitian, i.e., symmetric
in the real part and anti-symmetric in the imaginary part, as described in
the <cite>numpy.fft</cite> documentation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;, &lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.fft2">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">fft2</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">s=None</em>, <em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.fft2" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.fft2</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.fft2 docstring follows below:</p>
<p>Compute the 2-dimensional discrete Fourier Transform</p>
<p>This function computes the <em>n</em>-dimensional discrete Fourier Transform
over any axes in an <em>M</em>-dimensional array by means of the
Fast Fourier Transform (FFT).  By default, the transform is computed over
the last two axes of the input array, i.e., a 2-dimensional FFT.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array, can be complex</p>
</dd>
<dt><strong>s</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Shape (length of each transformed axis) of the output
(<code class="docutils literal notranslate"><span class="pre">s[0]</span></code> refers to axis 0, <code class="docutils literal notranslate"><span class="pre">s[1]</span></code> to axis 1, etc.).
This corresponds to <code class="docutils literal notranslate"><span class="pre">n</span></code> for <code class="docutils literal notranslate"><span class="pre">fft(x,</span> <span class="pre">n)</span></code>.
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <cite>s</cite> is not given, the shape of the input along the axes specified
by <cite>axes</cite> is used.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Axes over which to compute the FFT.  If not given, the last two
axes are used.  A repeated index in <cite>axes</cite> means the transform over
that axis is performed multiple times.  A one-element sequence means
that a one-dimensional FFT is performed.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">complex ndarray</span></dt><dd><p>The truncated or zero-padded input, transformed along the axes
indicated by <cite>axes</cite>, or the last two axes if <cite>axes</cite> is not given.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If <cite>s</cite> and <cite>axes</cite> have different length, or <cite>axes</cite> not given and
<code class="docutils literal notranslate"><span class="pre">len(s)</span> <span class="pre">!=</span> <span class="pre">2</span></code>.</p>
</dd>
<dt><strong>IndexError</strong></dt><dd><p>If an element of <cite>axes</cite> is larger than than the number of axes of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/routines.fft.html#module-numpy.fft" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.fft</span></code></a></dt><dd><p>Overall view of discrete Fourier transforms, with definitions and conventions used.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.ifft2" title="dask.array.fft.ifft2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifft2</span></code></a></dt><dd><p>The inverse two-dimensional FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fft" title="dask.array.fft.fft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft</span></code></a></dt><dd><p>The one-dimensional FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fftn" title="dask.array.fft.fftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftn</span></code></a></dt><dd><p>The <em>n</em>-dimensional FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fftshift" title="dask.array.fft.fftshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftshift</span></code></a></dt><dd><p>Shifts zero-frequency terms to the center of the array. For two-dimensional input, swaps first and third quadrants, and second and fourth quadrants.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><cite>fft2</cite> is just <cite>fftn</cite> with a different default for <cite>axes</cite>.</p>
<p>The output, analogously to <cite>fft</cite>, contains the term for zero frequency in
the low-order corner of the transformed axes, the positive frequency terms
in the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
the axes, in order of decreasingly negative frequency.</p>
<p>See <cite>fftn</cite> for details and a plotting example, and <cite>numpy.fft</cite> for
definitions and conventions used.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="mi">5</span><span class="p">,</span> <span class="p">:</span><span class="mi">5</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary</span>
<span class="go">          0.  +0.j        ,   0.  +0.j        ],</span>
<span class="go">       [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,</span>
<span class="go">          0.  +0.j        ,   0.  +0.j        ],</span>
<span class="go">       [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,</span>
<span class="go">          0.  +0.j        ,   0.  +0.j        ],</span>
<span class="go">       [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,</span>
<span class="go">          0.  +0.j        ,   0.  +0.j        ],</span>
<span class="go">       [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,</span>
<span class="go">          0.  +0.j        ,   0.  +0.j        ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.fftn">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">fftn</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">s=None</em>, <em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.fftn" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.fftn</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.fftn docstring follows below:</p>
<p>Compute the N-dimensional discrete Fourier Transform.</p>
<p>This function computes the <em>N</em>-dimensional discrete Fourier Transform over
any number of axes in an <em>M</em>-dimensional array by means of the Fast Fourier
Transform (FFT).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array, can be complex.</p>
</dd>
<dt><strong>s</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Shape (length of each transformed axis) of the output
(<code class="docutils literal notranslate"><span class="pre">s[0]</span></code> refers to axis 0, <code class="docutils literal notranslate"><span class="pre">s[1]</span></code> to axis 1, etc.).
This corresponds to <code class="docutils literal notranslate"><span class="pre">n</span></code> for <code class="docutils literal notranslate"><span class="pre">fft(x,</span> <span class="pre">n)</span></code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <cite>s</cite> is not given, the shape of the input along the axes specified
by <cite>axes</cite> is used.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Axes over which to compute the FFT.  If not given, the last <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>
axes are used, or all axes if <cite>s</cite> is also not specified.
Repeated indices in <cite>axes</cite> means that the transform over that axis is
performed multiple times.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">complex ndarray</span></dt><dd><p>The truncated or zero-padded input, transformed along the axes
indicated by <cite>axes</cite>, or by a combination of <cite>s</cite> and <cite>a</cite>,
as explained in the parameters section above.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If <cite>s</cite> and <cite>axes</cite> have different length.</p>
</dd>
<dt><strong>IndexError</strong></dt><dd><p>If an element of <cite>axes</cite> is larger than than the number of axes of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/routines.fft.html#module-numpy.fft" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.fft</span></code></a></dt><dd><p>Overall view of discrete Fourier transforms, with definitions and conventions used.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.ifftn" title="dask.array.fft.ifftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifftn</span></code></a></dt><dd><p>The inverse of <cite>fftn</cite>, the inverse <em>n</em>-dimensional FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fft" title="dask.array.fft.fft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft</span></code></a></dt><dd><p>The one-dimensional FFT, with definitions and conventions used.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.rfftn" title="dask.array.fft.rfftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfftn</span></code></a></dt><dd><p>The <em>n</em>-dimensional FFT of real input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fft2" title="dask.array.fft.fft2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft2</span></code></a></dt><dd><p>The two-dimensional FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fftshift" title="dask.array.fft.fftshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftshift</span></code></a></dt><dd><p>Shifts zero-frequency terms to centre of array</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The output, analogously to <cite>fft</cite>, contains the term for zero frequency in
the low-order corner of all axes, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.</p>
<p>See <cite>numpy.fft</cite> for details, definitions and conventions used.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">array([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary</span>
<span class="go">        [ 0.+0.j,   0.+0.j,   0.+0.j],</span>
<span class="go">        [ 0.+0.j,   0.+0.j,   0.+0.j]],</span>
<span class="go">       [[ 9.+0.j,   0.+0.j,   0.+0.j],</span>
<span class="go">        [ 0.+0.j,   0.+0.j,   0.+0.j],</span>
<span class="go">        [ 0.+0.j,   0.+0.j,   0.+0.j]],</span>
<span class="go">       [[18.+0.j,   0.+0.j,   0.+0.j],</span>
<span class="go">        [ 0.+0.j,   0.+0.j,   0.+0.j],</span>
<span class="go">        [ 0.+0.j,   0.+0.j,   0.+0.j]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary</span>
<span class="go">        [ 0.+0.j,  0.+0.j,  0.+0.j]],</span>
<span class="go">       [[-2.+0.j, -2.+0.j, -2.+0.j],</span>
<span class="go">        [ 0.+0.j,  0.+0.j,  0.+0.j]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="o">/</span> <span class="mi">12</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="o">/</span> <span class="mi">34</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">FS</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="go">&lt;matplotlib.image.AxesImage object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.ifft">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">ifft</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">n=None</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.ifft" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.ifft</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.ifft docstring follows below:</p>
<p>Compute the one-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the one-dimensional <em>n</em>-point
discrete Fourier transform computed by <cite>fft</cite>.  In other words,
<code class="docutils literal notranslate"><span class="pre">ifft(fft(a))</span> <span class="pre">==</span> <span class="pre">a</span></code> to within numerical accuracy.
For a general description of the algorithm and definitions,
see <cite>numpy.fft</cite>.</p>
<p>The input should be ordered in the same way as is returned by <cite>fft</cite>,
i.e.,</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a[0]</span></code> should contain the zero frequency term,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a[1:n//2]</span></code> should contain the positive-frequency terms,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a[n//2</span> <span class="pre">+</span> <span class="pre">1:]</span></code> should contain the negative-frequency terms, in
increasing order starting from the most negative frequency.</p></li>
</ul>
<p>For an even number of input points, <code class="docutils literal notranslate"><span class="pre">A[n//2]</span></code> represents the sum of
the values at the positive and negative Nyquist frequencies, as the two
are aliased together. See <cite>numpy.fft</cite> for details.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array, can be complex.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>Length of the transformed axis of the output.
If <cite>n</cite> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If <cite>n</cite> is not given,
the length of the input along the axis specified by <cite>axis</cite> is used.
See notes about padding issues.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis over which to compute the inverse DFT.  If not given, the last
axis is used.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">complex ndarray</span></dt><dd><p>The truncated or zero-padded input, transformed along the axis
indicated by <cite>axis</cite>, or the last one if <cite>axis</cite> is not specified.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>IndexError</strong></dt><dd><p>If <cite>axes</cite> is larger than the last axis of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/routines.fft.html#module-numpy.fft" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.fft</span></code></a></dt><dd><p>An introduction, with definitions and general explanations.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fft" title="dask.array.fft.fft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft</span></code></a></dt><dd><p>The one-dimensional (forward) FFT, of which <cite>ifft</cite> is the inverse</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.ifft2" title="dask.array.fft.ifft2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifft2</span></code></a></dt><dd><p>The two-dimensional inverse FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.ifftn" title="dask.array.fft.ifftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifftn</span></code></a></dt><dd><p>The n-dimensional inverse FFT.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If the input parameter <cite>n</cite> is larger than the size of the input, the input
is padded by appending zeros at the end.  Even though this is the common
approach, it might lead to surprising results.  If a different padding is
desired, it must be performed before calling <cite>ifft</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary</span>
</pre></div>
</div>
<p>Create and plot a band-limited signal with random phases:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">400</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">400</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">[</span><span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="mi">20</span><span class="p">,)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at ...&gt;, &lt;matplotlib.lines.Line2D object at ...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">((</span><span class="s1">&#39;real&#39;</span><span class="p">,</span> <span class="s1">&#39;imaginary&#39;</span><span class="p">))</span>
<span class="go">&lt;matplotlib.legend.Legend object at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.ifft2">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">ifft2</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">s=None</em>, <em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.ifft2" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.ifft2</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.ifft2 docstring follows below:</p>
<p>Compute the 2-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the 2-dimensional discrete Fourier
Transform over any number of axes in an M-dimensional array by means of
the Fast Fourier Transform (FFT).  In other words, <code class="docutils literal notranslate"><span class="pre">ifft2(fft2(a))</span> <span class="pre">==</span> <span class="pre">a</span></code>
to within numerical accuracy.  By default, the inverse transform is
computed over the last two axes of the input array.</p>
<p>The input, analogously to <cite>ifft</cite>, should be ordered in the same way as is
returned by <cite>fft2</cite>, i.e. it should have the term for zero frequency
in the low-order corner of the two axes, the positive frequency terms in
the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
both axes, in order of decreasingly negative frequency.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array, can be complex.</p>
</dd>
<dt><strong>s</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Shape (length of each axis) of the output (<code class="docutils literal notranslate"><span class="pre">s[0]</span></code> refers to axis 0,
<code class="docutils literal notranslate"><span class="pre">s[1]</span></code> to axis 1, etc.).  This corresponds to <cite>n</cite> for <code class="docutils literal notranslate"><span class="pre">ifft(x,</span> <span class="pre">n)</span></code>.
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <cite>s</cite> is not given, the shape of the input along the axes specified
by <cite>axes</cite> is used.  See notes for issue on <cite>ifft</cite> zero padding.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Axes over which to compute the FFT.  If not given, the last two
axes are used.  A repeated index in <cite>axes</cite> means the transform over
that axis is performed multiple times.  A one-element sequence means
that a one-dimensional FFT is performed.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">complex ndarray</span></dt><dd><p>The truncated or zero-padded input, transformed along the axes
indicated by <cite>axes</cite>, or the last two axes if <cite>axes</cite> is not given.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If <cite>s</cite> and <cite>axes</cite> have different length, or <cite>axes</cite> not given and
<code class="docutils literal notranslate"><span class="pre">len(s)</span> <span class="pre">!=</span> <span class="pre">2</span></code>.</p>
</dd>
<dt><strong>IndexError</strong></dt><dd><p>If an element of <cite>axes</cite> is larger than than the number of axes of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/routines.fft.html#module-numpy.fft" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.fft</span></code></a></dt><dd><p>Overall view of discrete Fourier transforms, with definitions and conventions used.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fft2" title="dask.array.fft.fft2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft2</span></code></a></dt><dd><p>The forward 2-dimensional FFT, of which <cite>ifft2</cite> is the inverse.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.ifftn" title="dask.array.fft.ifftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifftn</span></code></a></dt><dd><p>The inverse of the <em>n</em>-dimensional FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fft" title="dask.array.fft.fft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft</span></code></a></dt><dd><p>The one-dimensional FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.ifft" title="dask.array.fft.ifft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifft</span></code></a></dt><dd><p>The one-dimensional inverse FFT.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><cite>ifft2</cite> is just <cite>ifftn</cite> with a different default for <cite>axes</cite>.</p>
<p>See <cite>ifftn</cite> for details and a plotting example, and <cite>numpy.fft</cite> for
definition and conventions used.</p>
<p>Zero-padding, analogously with <cite>ifft</cite>, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before <cite>ifft2</cite> is called.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary</span>
<span class="go">       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],</span>
<span class="go">       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],</span>
<span class="go">       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.ifftn">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">ifftn</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">s=None</em>, <em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.ifftn" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.ifftn</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.ifftn docstring follows below:</p>
<p>Compute the N-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the N-dimensional discrete
Fourier Transform over any number of axes in an M-dimensional array by
means of the Fast Fourier Transform (FFT).  In other words,
<code class="docutils literal notranslate"><span class="pre">ifftn(fftn(a))</span> <span class="pre">==</span> <span class="pre">a</span></code> to within numerical accuracy.
For a description of the definitions and conventions used, see <cite>numpy.fft</cite>.</p>
<p>The input, analogously to <cite>ifft</cite>, should be ordered in the same way as is
returned by <cite>fftn</cite>, i.e. it should have the term for zero frequency
in all axes in the low-order corner, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array, can be complex.</p>
</dd>
<dt><strong>s</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Shape (length of each transformed axis) of the output
(<code class="docutils literal notranslate"><span class="pre">s[0]</span></code> refers to axis 0, <code class="docutils literal notranslate"><span class="pre">s[1]</span></code> to axis 1, etc.).
This corresponds to <code class="docutils literal notranslate"><span class="pre">n</span></code> for <code class="docutils literal notranslate"><span class="pre">ifft(x,</span> <span class="pre">n)</span></code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <cite>s</cite> is not given, the shape of the input along the axes specified
by <cite>axes</cite> is used.  See notes for issue on <cite>ifft</cite> zero padding.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Axes over which to compute the IFFT.  If not given, the last <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>
axes are used, or all axes if <cite>s</cite> is also not specified.
Repeated indices in <cite>axes</cite> means that the inverse transform over that
axis is performed multiple times.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">complex ndarray</span></dt><dd><p>The truncated or zero-padded input, transformed along the axes
indicated by <cite>axes</cite>, or by a combination of <cite>s</cite> or <cite>a</cite>,
as explained in the parameters section above.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If <cite>s</cite> and <cite>axes</cite> have different length.</p>
</dd>
<dt><strong>IndexError</strong></dt><dd><p>If an element of <cite>axes</cite> is larger than than the number of axes of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/routines.fft.html#module-numpy.fft" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.fft</span></code></a></dt><dd><p>Overall view of discrete Fourier transforms, with definitions and conventions used.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fftn" title="dask.array.fft.fftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftn</span></code></a></dt><dd><p>The forward <em>n</em>-dimensional FFT, of which <cite>ifftn</cite> is the inverse.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.ifft" title="dask.array.fft.ifft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifft</span></code></a></dt><dd><p>The one-dimensional inverse FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.ifft2" title="dask.array.fft.ifft2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifft2</span></code></a></dt><dd><p>The two-dimensional inverse FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.ifftshift" title="dask.array.fft.ifftshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifftshift</span></code></a></dt><dd><p>Undoes <cite>fftshift</cite>, shifts zero-frequency terms to beginning of array.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>See <cite>numpy.fft</cite> for definitions and conventions used.</p>
<p>Zero-padding, analogously with <cite>ifft</cite>, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before <cite>ifftn</cite> is called.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,)),</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary</span>
<span class="go">       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],</span>
<span class="go">       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],</span>
<span class="go">       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])</span>
</pre></div>
</div>
<p>Create and plot an image with band-limited frequency content:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span><span class="mi">200</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">[</span><span class="mi">60</span><span class="p">:</span><span class="mi">80</span><span class="p">,</span> <span class="mi">20</span><span class="p">:</span><span class="mi">40</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
<span class="go">&lt;matplotlib.image.AxesImage object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.rfft">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">rfft</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">n=None</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.rfft" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.rfft</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.rfft docstring follows below:</p>
<p>Compute the one-dimensional discrete Fourier Transform for real input.</p>
<p>This function computes the one-dimensional <em>n</em>-point discrete Fourier
Transform (DFT) of a real-valued array by means of an efficient algorithm
called the Fast Fourier Transform (FFT).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>Number of points along transformation axis in the input to use.
If <cite>n</cite> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros. If <cite>n</cite> is not given,
the length of the input along the axis specified by <cite>axis</cite> is used.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis over which to compute the FFT. If not given, the last axis is
used.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">complex ndarray</span></dt><dd><p>The truncated or zero-padded input, transformed along the axis
indicated by <cite>axis</cite>, or the last one if <cite>axis</cite> is not specified.
If <cite>n</cite> is even, the length of the transformed axis is <code class="docutils literal notranslate"><span class="pre">(n/2)+1</span></code>.
If <cite>n</cite> is odd, the length is <code class="docutils literal notranslate"><span class="pre">(n+1)/2</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>IndexError</strong></dt><dd><p>If <cite>axis</cite> is larger than the last axis of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/routines.fft.html#module-numpy.fft" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.fft</span></code></a></dt><dd><p>For definition of the DFT and conventions used.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.irfft" title="dask.array.fft.irfft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irfft</span></code></a></dt><dd><p>The inverse of <cite>rfft</cite>.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fft" title="dask.array.fft.fft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft</span></code></a></dt><dd><p>The one-dimensional FFT of general (complex) input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fftn" title="dask.array.fft.fftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftn</span></code></a></dt><dd><p>The <em>n</em>-dimensional FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.rfftn" title="dask.array.fft.rfftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfftn</span></code></a></dt><dd><p>The <em>n</em>-dimensional FFT of real input.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When the DFT is computed for purely real input, the output is
Hermitian-symmetric, i.e. the negative frequency terms are just the complex
conjugates of the corresponding positive-frequency terms, and the
negative-frequency terms are therefore redundant.  This function does not
compute the negative frequency terms, and the length of the transformed
axis of the output is therefore <code class="docutils literal notranslate"><span class="pre">n//2</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">rfft(a)</span></code> and fs is the sampling frequency, <code class="docutils literal notranslate"><span class="pre">A[0]</span></code> contains
the zero-frequency term 0*fs, which is real due to Hermitian symmetry.</p>
<p>If <cite>n</cite> is even, <code class="docutils literal notranslate"><span class="pre">A[-1]</span></code> contains the term representing both positive
and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely
real. If <cite>n</cite> is odd, there is no term at fs/2; <code class="docutils literal notranslate"><span class="pre">A[-1]</span></code> contains
the largest positive frequency (fs/2*(n-1)/n), and is complex in the
general case.</p>
<p>If the input <cite>a</cite> contains an imaginary part, it is silently discarded.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">array([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary</span>
</pre></div>
</div>
<p>Notice how the final element of the <cite>fft</cite> output is the complex conjugate
of the second element, for real input. For <cite>rfft</cite>, this symmetry is
exploited to compute only the non-negative frequency terms.</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.rfft2">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">rfft2</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">s=None</em>, <em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.rfft2" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.rfft2</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.rfft2 docstring follows below:</p>
<p>Compute the 2-dimensional FFT of a real array.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array</span></dt><dd><p>Input array, taken to be real.</p>
</dd>
<dt><strong>s</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Shape of the FFT.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Axes over which to compute the FFT.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>The result of the real 2-D FFT.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.fft.rfftn" title="dask.array.fft.rfftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfftn</span></code></a></dt><dd><p>Compute the N-dimensional discrete Fourier Transform for real input.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This is really just <cite>rfftn</cite> with different default behavior.
For more details see <cite>rfftn</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.rfftn">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">rfftn</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">s=None</em>, <em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.rfftn" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.rfftn</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.rfftn docstring follows below:</p>
<p>Compute the N-dimensional discrete Fourier Transform for real input.</p>
<p>This function computes the N-dimensional discrete Fourier Transform over
any number of axes in an M-dimensional real array by means of the Fast
Fourier Transform (FFT).  By default, all axes are transformed, with the
real transform performed over the last axis, while the remaining
transforms are complex.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array, taken to be real.</p>
</dd>
<dt><strong>s</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Shape (length along each transformed axis) to use from the input.
(<code class="docutils literal notranslate"><span class="pre">s[0]</span></code> refers to axis 0, <code class="docutils literal notranslate"><span class="pre">s[1]</span></code> to axis 1, etc.).
The final element of <cite>s</cite> corresponds to <cite>n</cite> for <code class="docutils literal notranslate"><span class="pre">rfft(x,</span> <span class="pre">n)</span></code>, while
for the remaining axes, it corresponds to <cite>n</cite> for <code class="docutils literal notranslate"><span class="pre">fft(x,</span> <span class="pre">n)</span></code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <cite>s</cite> is not given, the shape of the input along the axes specified
by <cite>axes</cite> is used.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Axes over which to compute the FFT.  If not given, the last <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>
axes are used, or all axes if <cite>s</cite> is also not specified.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">complex ndarray</span></dt><dd><p>The truncated or zero-padded input, transformed along the axes
indicated by <cite>axes</cite>, or by a combination of <cite>s</cite> and <cite>a</cite>,
as explained in the parameters section above.
The length of the last axis transformed will be <code class="docutils literal notranslate"><span class="pre">s[-1]//2+1</span></code>,
while the remaining transformed axes will have lengths according to
<cite>s</cite>, or unchanged from the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If <cite>s</cite> and <cite>axes</cite> have different length.</p>
</dd>
<dt><strong>IndexError</strong></dt><dd><p>If an element of <cite>axes</cite> is larger than than the number of axes of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.fft.irfftn" title="dask.array.fft.irfftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irfftn</span></code></a></dt><dd><p>The inverse of <cite>rfftn</cite>, i.e. the inverse of the n-dimensional FFT of real input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fft" title="dask.array.fft.fft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft</span></code></a></dt><dd><p>The one-dimensional FFT, with definitions and conventions used.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.rfft" title="dask.array.fft.rfft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfft</span></code></a></dt><dd><p>The one-dimensional FFT of real input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fftn" title="dask.array.fft.fftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftn</span></code></a></dt><dd><p>The n-dimensional FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.rfft2" title="dask.array.fft.rfft2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfft2</span></code></a></dt><dd><p>The two-dimensional FFT of real input.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The transform for real input is performed over the last transformation
axis, as by <cite>rfft</cite>, then the transform over the remaining axes is
performed as by <cite>fftn</cite>.  The order of the output is as for <cite>rfft</cite> for the
final transformation axis, and as for <cite>fftn</cite> for the remaining
transformation axes.</p>
<p>See <cite>fft</cite> for details, definitions and conventions used.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftn</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[[8.+0.j,  0.+0.j], # may vary</span>
<span class="go">        [0.+0.j,  0.+0.j]],</span>
<span class="go">       [[0.+0.j,  0.+0.j],</span>
<span class="go">        [0.+0.j,  0.+0.j]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">array([[[4.+0.j,  0.+0.j], # may vary</span>
<span class="go">        [4.+0.j,  0.+0.j]],</span>
<span class="go">       [[0.+0.j,  0.+0.j],</span>
<span class="go">        [0.+0.j,  0.+0.j]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.irfft">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">irfft</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">n=None</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.irfft" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.irfft</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.irfft docstring follows below:</p>
<p>Compute the inverse of the n-point DFT for real input.</p>
<p>This function computes the inverse of the one-dimensional <em>n</em>-point
discrete Fourier Transform of real input computed by <cite>rfft</cite>.
In other words, <code class="docutils literal notranslate"><span class="pre">irfft(rfft(a),</span> <span class="pre">len(a))</span> <span class="pre">==</span> <span class="pre">a</span></code> to within numerical
accuracy. (See Notes below for why <code class="docutils literal notranslate"><span class="pre">len(a)</span></code> is necessary here.)</p>
<p>The input is expected to be in the form returned by <cite>rfft</cite>, i.e. the
real zero-frequency term followed by the complex positive frequency terms
in order of increasing frequency.  Since the discrete Fourier Transform of
real input is Hermitian-symmetric, the negative frequency terms are taken
to be the complex conjugates of the corresponding positive frequency terms.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>The input array.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>Length of the transformed axis of the output.
For <cite>n</cite> output points, <code class="docutils literal notranslate"><span class="pre">n//2+1</span></code> input points are necessary.  If the
input is longer than this, it is cropped.  If it is shorter than this,
it is padded with zeros.  If <cite>n</cite> is not given, it is taken to be
<code class="docutils literal notranslate"><span class="pre">2*(m-1)</span></code> where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the length of the input along the axis
specified by <cite>axis</cite>.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis over which to compute the inverse FFT. If not given, the last
axis is used.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>The truncated or zero-padded input, transformed along the axis
indicated by <cite>axis</cite>, or the last one if <cite>axis</cite> is not specified.
The length of the transformed axis is <cite>n</cite>, or, if <cite>n</cite> is not given,
<code class="docutils literal notranslate"><span class="pre">2*(m-1)</span></code> where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the length of the transformed axis of the
input. To get an odd number of output points, <cite>n</cite> must be specified.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>IndexError</strong></dt><dd><p>If <cite>axis</cite> is larger than the last axis of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/routines.fft.html#module-numpy.fft" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.fft</span></code></a></dt><dd><p>For definition of the DFT and conventions used.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.rfft" title="dask.array.fft.rfft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfft</span></code></a></dt><dd><p>The one-dimensional FFT of real input, of which <cite>irfft</cite> is inverse.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fft" title="dask.array.fft.fft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft</span></code></a></dt><dd><p>The one-dimensional FFT.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.irfft2" title="dask.array.fft.irfft2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irfft2</span></code></a></dt><dd><p>The inverse of the two-dimensional FFT of real input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.irfftn" title="dask.array.fft.irfftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irfftn</span></code></a></dt><dd><p>The inverse of the <em>n</em>-dimensional FFT of real input.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Returns the real valued <cite>n</cite>-point inverse discrete Fourier transform
of <cite>a</cite>, where <cite>a</cite> contains the non-negative frequency terms of a
Hermitian-symmetric sequence. <cite>n</cite> is the length of the result, not the
input.</p>
<p>If you specify an <cite>n</cite> such that <cite>a</cite> must be zero-padded or truncated, the
extra/removed values will be added/removed at high frequencies. One can
thus resample a series to <cite>m</cite> points via Fourier interpolation by:
<code class="docutils literal notranslate"><span class="pre">a_resamp</span> <span class="pre">=</span> <span class="pre">irfft(rfft(a),</span> <span class="pre">m)</span></code>.</p>
<p>The correct interpretation of the hermitian input depends on the length of
the original data, as given by <cite>n</cite>. This is because each input shape could
correspond to either an odd or even length signal. By default, <cite>irfft</cite>
assumes an even output length which puts the last entry at the Nyquist
frequency; aliasing with its symmetric counterpart. By Hermitian symmetry,
the value is thus treated as purely real. To avoid losing information, the
correct length of the real input <strong>must</strong> be given.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">])</span>
<span class="go">array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([0.,  1.,  0.,  0.])</span>
</pre></div>
</div>
<p>Notice how the last term in the input to the ordinary <cite>ifft</cite> is the
complex conjugate of the second term, and the output has zero imaginary
part everywhere.  When calling <cite>irfft</cite>, the negative frequencies are not
specified, and the output array is purely real.</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.irfft2">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">irfft2</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">s=None</em>, <em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.irfft2" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.irfft2</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.irfft2 docstring follows below:</p>
<p>Compute the 2-dimensional inverse FFT of a real array.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>The input array</p>
</dd>
<dt><strong>s</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Shape of the real output to the inverse FFT.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>The axes over which to compute the inverse fft.
Default is the last two axes.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>The result of the inverse real 2-D FFT.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.fft.irfftn" title="dask.array.fft.irfftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irfftn</span></code></a></dt><dd><p>Compute the inverse of the N-dimensional FFT of real input.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This is really <cite>irfftn</cite> with different defaults.
For more details see <cite>irfftn</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.irfftn">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">irfftn</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">s=None</em>, <em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.irfftn" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.irfftn</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.irfftn docstring follows below:</p>
<p>Compute the inverse of the N-dimensional FFT of real input.</p>
<p>This function computes the inverse of the N-dimensional discrete
Fourier Transform for real input over any number of axes in an
M-dimensional array by means of the Fast Fourier Transform (FFT).  In
other words, <code class="docutils literal notranslate"><span class="pre">irfftn(rfftn(a),</span> <span class="pre">a.shape)</span> <span class="pre">==</span> <span class="pre">a</span></code> to within numerical
accuracy. (The <code class="docutils literal notranslate"><span class="pre">a.shape</span></code> is necessary like <code class="docutils literal notranslate"><span class="pre">len(a)</span></code> is for <cite>irfft</cite>,
and for the same reason.)</p>
<p>The input should be ordered in the same way as is returned by <cite>rfftn</cite>,
i.e. as for <cite>irfft</cite> for the final transformation axis, and as for <cite>ifftn</cite>
along all the other axes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>s</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Shape (length of each transformed axis) of the output
(<code class="docutils literal notranslate"><span class="pre">s[0]</span></code> refers to axis 0, <code class="docutils literal notranslate"><span class="pre">s[1]</span></code> to axis 1, etc.). <cite>s</cite> is also the
number of input points used along this axis, except for the last axis,
where <code class="docutils literal notranslate"><span class="pre">s[-1]//2+1</span></code> points of the input are used.
Along any axis, if the shape indicated by <cite>s</cite> is smaller than that of
the input, the input is cropped.  If it is larger, the input is padded
with zeros. If <cite>s</cite> is not given, the shape of the input along the axes
specified by axes is used. Except for the last axis which is taken to be
<code class="docutils literal notranslate"><span class="pre">2*(m-1)</span></code> where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the length of the input along that axis.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">sequence of ints, optional</span></dt><dd><p>Axes over which to compute the inverse FFT. If not given, the last
<cite>len(s)</cite> axes are used, or all axes if <cite>s</cite> is also not specified.
Repeated indices in <cite>axes</cite> means that the inverse transform over that
axis is performed multiple times.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>The truncated or zero-padded input, transformed along the axes
indicated by <cite>axes</cite>, or by a combination of <cite>s</cite> or <cite>a</cite>,
as explained in the parameters section above.
The length of each transformed axis is as given by the corresponding
element of <cite>s</cite>, or the length of the input in every axis except for the
last one if <cite>s</cite> is not given.  In the final transformed axis the length
of the output when <cite>s</cite> is not given is <code class="docutils literal notranslate"><span class="pre">2*(m-1)</span></code> where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the
length of the final transformed axis of the input.  To get an odd
number of output points in the final axis, <cite>s</cite> must be specified.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If <cite>s</cite> and <cite>axes</cite> have different length.</p>
</dd>
<dt><strong>IndexError</strong></dt><dd><p>If an element of <cite>axes</cite> is larger than than the number of axes of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.fft.rfftn" title="dask.array.fft.rfftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfftn</span></code></a></dt><dd><p>The forward n-dimensional FFT of real input, of which <cite>ifftn</cite> is the inverse.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.fft" title="dask.array.fft.fft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fft</span></code></a></dt><dd><p>The one-dimensional FFT, with definitions and conventions used.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.irfft" title="dask.array.fft.irfft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irfft</span></code></a></dt><dd><p>The inverse of the one-dimensional FFT of real input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.irfft2" title="dask.array.fft.irfft2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irfft2</span></code></a></dt><dd><p>The inverse of the two-dimensional FFT of real input.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>See <cite>fft</cite> for definitions and conventions used.</p>
<p>See <cite>rfft</cite> for definitions and conventions used for real input.</p>
<p>The correct interpretation of the hermitian input depends on the shape of
the original data, as given by <cite>s</cite>. This is because each input shape could
correspond to either an odd or even length signal. By default, <cite>irfftn</cite>
assumes an even output length which puts the last entry at the Nyquist
frequency; aliasing with its symmetric counterpart. When performing the
final complex to real transform, the last value is thus treated as purely
real. To avoid losing information, the correct shape of the real input
<strong>must</strong> be given.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfftn</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[[1.,  1.],</span>
<span class="go">        [1.,  1.]],</span>
<span class="go">       [[1.,  1.],</span>
<span class="go">        [1.,  1.]],</span>
<span class="go">       [[1.,  1.],</span>
<span class="go">        [1.,  1.]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.hfft">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">hfft</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">n=None</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.hfft" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.hfft</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.hfft docstring follows below:</p>
<p>Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
spectrum.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>The input array.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>Length of the transformed axis of the output. For <cite>n</cite> output
points, <code class="docutils literal notranslate"><span class="pre">n//2</span> <span class="pre">+</span> <span class="pre">1</span></code> input points are necessary.  If the input is
longer than this, it is cropped.  If it is shorter than this, it is
padded with zeros.  If <cite>n</cite> is not given, it is taken to be <code class="docutils literal notranslate"><span class="pre">2*(m-1)</span></code>
where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the length of the input along the axis specified by
<cite>axis</cite>.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis over which to compute the FFT. If not given, the last
axis is used.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>The truncated or zero-padded input, transformed along the axis
indicated by <cite>axis</cite>, or the last one if <cite>axis</cite> is not specified.
The length of the transformed axis is <cite>n</cite>, or, if <cite>n</cite> is not given,
<code class="docutils literal notranslate"><span class="pre">2*m</span> <span class="pre">-</span> <span class="pre">2</span></code> where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the length of the transformed axis of
the input. To get an odd number of output points, <cite>n</cite> must be
specified, for instance as <code class="docutils literal notranslate"><span class="pre">2*m</span> <span class="pre">-</span> <span class="pre">1</span></code> in the typical case,</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>IndexError</strong></dt><dd><p>If <cite>axis</cite> is larger than the last axis of <cite>a</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.fft.rfft" title="dask.array.fft.rfft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfft</span></code></a></dt><dd><p>Compute the one-dimensional FFT for real input.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.fft.ihfft" title="dask.array.fft.ihfft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ihfft</span></code></a></dt><dd><p>The inverse of <cite>hfft</cite>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><cite>hfft</cite>/<cite>ihfft</cite> are a pair analogous to <cite>rfft</cite>/<cite>irfft</cite>, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it’s <cite>hfft</cite> for
which you must supply the length of the result if it is to be odd.</p>
<ul class="simple">
<li><p>even: <code class="docutils literal notranslate"><span class="pre">ihfft(hfft(a,</span> <span class="pre">2*len(a)</span> <span class="pre">-</span> <span class="pre">2)</span> <span class="pre">==</span> <span class="pre">a</span></code>, within roundoff error,</p></li>
<li><p>odd: <code class="docutils literal notranslate"><span class="pre">ihfft(hfft(a,</span> <span class="pre">2*len(a)</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">==</span> <span class="pre">a</span></code>, within roundoff error.</p></li>
</ul>
<p>The correct interpretation of the hermitian input depends on the length of
the original data, as given by <cite>n</cite>. This is because each input shape could
correspond to either an odd or even length signal. By default, <cite>hfft</cite>
assumes an even output length which puts the last entry at the Nyquist
frequency; aliasing with its symmetric counterpart. By Hermitian symmetry,
the value is thus treated as purely real. To avoid losing information, the
shape of the full signal <strong>must</strong> be given.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
<span class="go">array([15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j]) # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">hfft</span><span class="p">(</span><span class="n">signal</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span> <span class="c1"># Input first half of signal</span>
<span class="go">array([15.,  -4.,   0.,  -1.,   0.,  -4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">hfft</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>  <span class="c1"># Input entire signal and truncate</span>
<span class="go">array([15.,  -4.,   0.,  -1.,   0.,  -4.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="n">signal</span>   <span class="c1"># check Hermitian symmetry</span>
<span class="go">array([[ 0.-0.j,  -0.+0.j], # may vary</span>
<span class="go">       [ 0.+0.j,  0.-0.j]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">hfft</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq_spectrum</span>
<span class="go">array([[ 1.,  1.],</span>
<span class="go">       [ 2., -2.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.ihfft">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">ihfft</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">n=None</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.ihfft" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of numpy.fft.ihfft</p>
<p>The axis along which the FFT is applied must have only one chunk. To change
the array’s chunking use dask.Array.rechunk.</p>
<p>The numpy.fft.ihfft docstring follows below:</p>
<p>Compute the inverse FFT of a signal that has Hermitian symmetry.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>Length of the inverse FFT, the number of points along
transformation axis in the input to use.  If <cite>n</cite> is smaller than
the length of the input, the input is cropped.  If it is larger,
the input is padded with zeros. If <cite>n</cite> is not given, the length of
the input along the axis specified by <cite>axis</cite> is used.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis over which to compute the inverse FFT. If not given, the last
axis is used.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">{None, “ortho”}, optional</span></dt><dd><p>Normalization mode (see <cite>numpy.fft</cite>). Default is None.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">complex ndarray</span></dt><dd><p>The truncated or zero-padded input, transformed along the axis
indicated by <cite>axis</cite>, or the last one if <cite>axis</cite> is not specified.
The length of the transformed axis is <code class="docutils literal notranslate"><span class="pre">n//2</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.fft.hfft" title="dask.array.fft.hfft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hfft</span></code></a>, <a class="reference internal" href="#dask.array.fft.irfft" title="dask.array.fft.irfft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">irfft</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p><cite>hfft</cite>/<cite>ihfft</cite> are a pair analogous to <cite>rfft</cite>/<cite>irfft</cite>, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it’s <cite>hfft</cite> for
which you must supply the length of the result if it is to be odd:</p>
<ul class="simple">
<li><p>even: <code class="docutils literal notranslate"><span class="pre">ihfft(hfft(a,</span> <span class="pre">2*len(a)</span> <span class="pre">-</span> <span class="pre">2)</span> <span class="pre">==</span> <span class="pre">a</span></code>, within roundoff error,</p></li>
<li><p>odd: <code class="docutils literal notranslate"><span class="pre">ihfft(hfft(a,</span> <span class="pre">2*len(a)</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">==</span> <span class="pre">a</span></code>, within roundoff error.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="mi">15</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
<span class="go">array([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ihfft</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
<span class="go">array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.fftfreq">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">fftfreq</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">d=1.0</em>, <em class="sig-param">chunks='auto'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.fftfreq" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Discrete Fourier Transform sample frequencies.</p>
<p>This docstring was copied from numpy.fft.fftfreq.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The returned float array <cite>f</cite> contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.</p>
<p>Given a window length <cite>n</cite> and a sample spacing <cite>d</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>   <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>     <span class="o">-</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>   <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="n">even</span>
<span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>   <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="n">odd</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Window length.</p>
</dd>
<dt><strong>d</strong><span class="classifier">scalar, optional</span></dt><dd><p>Sample spacing (inverse of the sampling rate). Defaults to 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">ndarray</span></dt><dd><p>Array of length <cite>n</cite> containing the sample frequencies.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">fourier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">size</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestep</span> <span class="o">=</span> <span class="mf">0.1</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">timestep</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span>  
<span class="go">array([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.rfftfreq">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">rfftfreq</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">d=1.0</em>, <em class="sig-param">chunks='auto'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.rfftfreq" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Discrete Fourier Transform sample frequencies
(for usage with rfft, irfft).</p>
<p>This docstring was copied from numpy.fft.rfftfreq.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The returned float array <cite>f</cite> contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.</p>
<p>Given a window length <cite>n</cite> and a sample spacing <cite>d</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>     <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>     <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>   <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="n">even</span>
<span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>   <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="n">odd</span>
</pre></div>
</div>
<p>Unlike <cite>fftfreq</cite> (but like <cite>scipy.fftpack.rfftfreq</cite>)
the Nyquist frequency component is considered to be positive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Window length.</p>
</dd>
<dt><strong>d</strong><span class="classifier">scalar, optional</span></dt><dd><p>Sample spacing (inverse of the sampling rate). Defaults to 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">ndarray</span></dt><dd><p>Array of length <code class="docutils literal notranslate"><span class="pre">n//2</span> <span class="pre">+</span> <span class="pre">1</span></code> containing the sample frequencies.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">fourier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">size</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample_rate</span> <span class="o">=</span> <span class="mi">100</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="n">sample_rate</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span>  
<span class="go">array([  0.,  10.,  20., ..., -30., -20., -10.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="n">sample_rate</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span>  
<span class="go">array([  0.,  10.,  20.,  30.,  40.,  50.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.fftshift">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">fftshift</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.fftshift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the zero-frequency component to the center of the spectrum.</p>
<p>This docstring was copied from numpy.fft.fftshift.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This function swaps half-spaces for all axes listed (defaults to all).
Note that <code class="docutils literal notranslate"><span class="pre">y[0]</span></code> is the Nyquist component only if <code class="docutils literal notranslate"><span class="pre">len(x)</span></code> is even.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">int or shape tuple, optional</span></dt><dd><p>Axes over which to shift.  Default is None, which shifts all axes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The shifted array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.fft.ifftshift" title="dask.array.fft.ifftshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifftshift</span></code></a></dt><dd><p>The inverse of <cite>fftshift</cite>.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span>  
<span class="go">array([ 0.,  1.,  2., ..., -3., -2., -1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>  
<span class="go">array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</span>
</pre></div>
</div>
<p>Shift the zero-frequency component only along the second axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span>  
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4., -4.],</span>
<span class="go">       [-3., -2., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>  
<span class="go">array([[ 2.,  0.,  1.],</span>
<span class="go">       [-4.,  3.,  4.],</span>
<span class="go">       [-1., -3., -2.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.fft.ifftshift">
<code class="sig-prename descclassname">dask.array.fft.</code><code class="sig-name descname">ifftshift</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.fft.ifftshift" title="Permalink to this definition">¶</a></dt>
<dd><p>The inverse of <cite>fftshift</cite>. Although identical for even-length <cite>x</cite>, the
functions differ by one sample for odd-length <cite>x</cite>.</p>
<p>This docstring was copied from numpy.fft.ifftshift.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">int or shape tuple, optional</span></dt><dd><p>Axes over which to calculate.  Defaults to None, which shifts all axes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The shifted array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.fft.fftshift" title="dask.array.fft.fftshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftshift</span></code></a></dt><dd><p>Shift zero-frequency component to the center of the spectrum.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span>  
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4., -4.],</span>
<span class="go">       [-3., -2., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>  
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4., -4.],</span>
<span class="go">       [-3., -2., -1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.beta">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">beta</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.beta" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.beta.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a Beta distribution.</p>
<p>The Beta distribution is a special case of the Dirichlet distribution,
and is related to the Gamma distribution.  It has the probability
distribution function</p>
<div class="math notranslate nohighlight">
\[f(x; a,b) = \frac{1}{B(\alpha, \beta)} x^{\alpha - 1}
(1 - x)^{\beta - 1},\]</div>
<p>where the normalization, B, is the beta function,</p>
<div class="math notranslate nohighlight">
\[B(\alpha, \beta) = \int_0^1 t^{\alpha - 1}
(1 - t)^{\beta - 1} dt.\]</div>
<p>It is often seen in Bayesian inference and order statistics.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">beta</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Alpha, positive (&gt;0).</p>
</dd>
<dt><strong>b</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Beta, positive (&gt;0).</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(a,</span> <span class="pre">b).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized beta distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.beta</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.binomial">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">binomial</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">p</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.binomial.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a binomial distribution.</p>
<p>Samples are drawn from a binomial distribution with specified
parameters, n trials and p probability of success where
n an integer &gt;= 0 and p is in the interval [0,1]. (n may be
input as a float, but it is truncated to an integer in use)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">binomial</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int or array_like of ints</span></dt><dd><p>Parameter of the distribution, &gt;= 0. Floats are also accepted,
but they will be truncated to integers.</p>
</dd>
<dt><strong>p</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Parameter of the distribution, &gt;= 0 and &lt;=1.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">p</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(n,</span> <span class="pre">p).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized binomial distribution, where
each sample is equal to the number of successes over the n trials.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.binom</span></code></dt><dd><p>probability density function, distribution or cumulative density function, etc.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.binomial</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density for the binomial distribution is</p>
<div class="math notranslate nohighlight">
\[P(N) = \binom{n}{N}p^N(1-p)^{n-N},\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the number of trials, <span class="math notranslate nohighlight">\(p\)</span> is the probability
of success, and <span class="math notranslate nohighlight">\(N\)</span> is the number of successes.</p>
<p>When estimating the standard error of a proportion in a population by
using a random sample, the normal distribution works well unless the
product p*n &lt;=5, where p = population proportion estimate, and n =
number of samples, in which case the binomial distribution is used
instead. For example, a sample of 15 people shows 4 who are left
handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,
so the binomial distribution should be used in this case.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r6ecd0f02e456-1"><span class="brackets"><a class="fn-backref" href="#id34">1</a></span></dt>
<dd><p>Dalgaard, Peter, “Introductory Statistics with R”,
Springer-Verlag, 2002.</p>
</dd>
<dt class="label" id="r6ecd0f02e456-2"><span class="brackets"><a class="fn-backref" href="#id35">2</a></span></dt>
<dd><p>Glantz, Stanton A. “Primer of Biostatistics.”, McGraw-Hill,
Fifth Edition, 2002.</p>
</dd>
<dt class="label" id="r6ecd0f02e456-3"><span class="brackets"><a class="fn-backref" href="#id36">3</a></span></dt>
<dd><p>Lentner, Marvin, “Elementary Applied Statistics”, Bogden
and Quigley, 1972.</p>
</dd>
<dt class="label" id="r6ecd0f02e456-4"><span class="brackets"><a class="fn-backref" href="#id37">4</a></span></dt>
<dd><p>Weisstein, Eric W. “Binomial Distribution.” From MathWorld–A
Wolfram Web Resource.
<a class="reference external" href="http://mathworld.wolfram.com/BinomialDistribution.html">http://mathworld.wolfram.com/BinomialDistribution.html</a></p>
</dd>
<dt class="label" id="r6ecd0f02e456-5"><span class="brackets"><a class="fn-backref" href="#id38">5</a></span></dt>
<dd><p>Wikipedia, “Binomial distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Binomial_distribution">https://en.wikipedia.org/wiki/Binomial_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span>  <span class="c1"># number of trials, probability of each trial  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  
<span class="go"># result of flipping a coin 10 times, tested 1000 times.</span>
</pre></div>
</div>
<p>A real world example. A company drills 9 wild-cat oil exploration
wells, each with an estimated probability of success of 0.1. All nine
wells fail. What is the probability of that happening?</p>
<p>Let’s do 20,000 trials of the model, and count the number that
generate zero positive results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">20000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="mf">20000.</span>  
<span class="go"># answer = 0.38885, or 38%.</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.chisquare">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">chisquare</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.chisquare" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.chisquare.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a chi-square distribution.</p>
<p>When <cite>df</cite> independent random variables, each with standard normal
distributions (mean 0, variance 1), are squared and summed, the
resulting distribution is chi-square (see Notes).  This distribution
is often used in hypothesis testing.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">chisquare</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Number of degrees of freedom, must be &gt; 0.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">df</span></code> is a scalar.  Otherwise,
<code class="docutils literal notranslate"><span class="pre">np.array(df).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized chi-square distribution.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>When <cite>df</cite> &lt;= 0 or when an inappropriate <cite>size</cite> (e.g. <code class="docutils literal notranslate"><span class="pre">size=-1</span></code>)
is given.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.chisquare</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The variable obtained by summing the squares of <cite>df</cite> independent,
standard normally distributed random variables:</p>
<div class="math notranslate nohighlight">
\[Q = \sum_{i=0}^{\mathtt{df}} X^2_i\]</div>
<p>is chi-square distributed, denoted</p>
<div class="math notranslate nohighlight">
\[Q \sim \chi^2_k.\]</div>
<p>The probability density function of the chi-squared distribution is</p>
<div class="math notranslate nohighlight">
\[p(x) = \frac{(1/2)^{k/2}}{\Gamma(k/2)}
x^{k/2 - 1} e^{-x/2},\]</div>
<p>where <span class="math notranslate nohighlight">\(\Gamma\)</span> is the gamma function,</p>
<div class="math notranslate nohighlight">
\[\Gamma(x) = \int_0^{-\infty} t^{x - 1} e^{-t} dt.\]</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf28719ccdef3-1"><span class="brackets"><a class="fn-backref" href="#id39">1</a></span></dt>
<dd><p>NIST “Engineering Statistics Handbook”
<a class="reference external" href="https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm">https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">chisquare</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>  
<span class="go">array([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.choice">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">choice</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">size=None</em>, <em class="sig-param">replace=True</em>, <em class="sig-param">p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.choice" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.choice.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Generates a random sample from a given 1-D array</p>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">choice</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">1-D array-like or int</span></dt><dd><p>If an ndarray, a random sample is generated from its elements.
If an int, the random sample is generated as if a were np.arange(a)</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  Default is None, in which case a
single value is returned.</p>
</dd>
<dt><strong>replace</strong><span class="classifier">boolean, optional</span></dt><dd><p>Whether the sample is with or without replacement</p>
</dd>
<dt><strong>p</strong><span class="classifier">1-D array-like, optional</span></dt><dd><p>The probabilities associated with each entry in a.
If not given the sample assumes a uniform distribution over all
entries in a.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">single item or ndarray</span></dt><dd><p>The generated random samples</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If a is an int and less than zero, if a or p are not 1-dimensional,
if a is an array-like of size 0, if p is not a vector of
probabilities, if a and p have different lengths, or if
replace=False and the sample size is greater than the population
size</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.random.randint" title="dask.array.random.randint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">randint</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">shuffle</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">permutation</span></code></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.choice</span></code></dt><dd><p>which should be used in new code</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Generate a uniform random sample from np.arange(5) of size 3:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  
<span class="go">array([0, 3, 4]) # random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#This is equivalent to np.random.randint(0,5,3)</span>
</pre></div>
</div>
<p>Generate a non-uniform random sample from np.arange(5) of size 3:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="go">array([3, 3, 0]) # random</span>
</pre></div>
</div>
<p>Generate a uniform random sample from np.arange(5) of size 3 without
replacement:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">array([3,1,0]) # random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#This is equivalent to np.random.permutation(np.arange(5))[:3]</span>
</pre></div>
</div>
<p>Generate a non-uniform random sample from np.arange(5) of size
3 without replacement:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="go">array([2, 3, 0]) # random</span>
</pre></div>
</div>
<p>Any of the above can be repeated with an arbitrary array-like
instead of just integers. For instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aa_milne_arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pooh&#39;</span><span class="p">,</span> <span class="s1">&#39;rabbit&#39;</span><span class="p">,</span> <span class="s1">&#39;piglet&#39;</span><span class="p">,</span> <span class="s1">&#39;Christopher&#39;</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">aa_milne_arr</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>  
<span class="go">array([&#39;pooh&#39;, &#39;pooh&#39;, &#39;pooh&#39;, &#39;Christopher&#39;, &#39;piglet&#39;], # random</span>
<span class="go">      dtype=&#39;&lt;U11&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.exponential">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">exponential</code><span class="sig-paren">(</span><em class="sig-param">scale=1.0</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.exponential.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from an exponential distribution.</p>
<p>Its probability density function is</p>
<div class="math notranslate nohighlight">
\[f(x; \frac{1}{\beta}) = \frac{1}{\beta} \exp(-\frac{x}{\beta}),\]</div>
<p>for <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> and 0 elsewhere. <span class="math notranslate nohighlight">\(\beta\)</span> is the scale parameter,
which is the inverse of the rate parameter <span class="math notranslate nohighlight">\(\lambda = 1/\beta\)</span>.
The rate parameter is an alternative, widely used parameterization
of the exponential distribution <a class="reference internal" href="#rafc1e1899521-3" id="id40">[3]</a>.</p>
<p>The exponential distribution is a continuous analogue of the
geometric distribution.  It describes many common situations, such as
the size of raindrops measured over many rainstorms <a class="reference internal" href="#rafc1e1899521-1" id="id41">[1]</a>, or the time
between page requests to Wikipedia <a class="reference internal" href="#rafc1e1899521-2" id="id42">[2]</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">exponential</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scale</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>The scale parameter, <span class="math notranslate nohighlight">\(\beta = 1/\lambda\)</span>. Must be
non-negative.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">scale</span></code> is a scalar.  Otherwise,
<code class="docutils literal notranslate"><span class="pre">np.array(scale).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized exponential distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.exponential</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rafc1e1899521-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id41">1</a>,<a href="#id43">2</a>)</span></dt>
<dd><p>Peyton Z. Peebles Jr., “Probability, Random Variables and
Random Signal Principles”, 4th ed, 2001, p. 57.</p>
</dd>
<dt class="label" id="rafc1e1899521-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id42">1</a>,<a href="#id44">2</a>)</span></dt>
<dd><p>Wikipedia, “Poisson process”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Poisson_process">https://en.wikipedia.org/wiki/Poisson_process</a></p>
</dd>
<dt class="label" id="rafc1e1899521-3"><span class="brackets">3</span><span class="fn-backref">(<a href="#id40">1</a>,<a href="#id45">2</a>)</span></dt>
<dd><p>Wikipedia, “Exponential distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Exponential_distribution">https://en.wikipedia.org/wiki/Exponential_distribution</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.f">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">f</code><span class="sig-paren">(</span><em class="sig-param">dfnum</em>, <em class="sig-param">dfden</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.f" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.f.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from an F distribution.</p>
<p>Samples are drawn from an F distribution with specified parameters,
<cite>dfnum</cite> (degrees of freedom in numerator) and <cite>dfden</cite> (degrees of
freedom in denominator), where both parameters must be greater than
zero.</p>
<p>The random variate of the F distribution (also known as the
Fisher distribution) is a continuous probability distribution
that arises in ANOVA tests, and is the ratio of two chi-square
variates.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">f</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dfnum</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Degrees of freedom in numerator, must be &gt; 0.</p>
</dd>
<dt><strong>dfden</strong><span class="classifier">float or array_like of float</span></dt><dd><p>Degrees of freedom in denominator, must be &gt; 0.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">dfnum</span></code> and <code class="docutils literal notranslate"><span class="pre">dfden</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(dfnum,</span> <span class="pre">dfden).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized Fisher distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.f</span></code></dt><dd><p>probability density function, distribution or cumulative density function, etc.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.f</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The F statistic is used to compare in-group variances to between-group
variances. Calculating the distribution depends on the sampling, and
so it is a function of the respective degrees of freedom in the
problem.  The variable <cite>dfnum</cite> is the number of samples minus one, the
between-groups degrees of freedom, while <cite>dfden</cite> is the within-groups
degrees of freedom, the sum of the number of samples in each group
minus the number of groups.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r29e9850c7ea2-1"><span class="brackets"><a class="fn-backref" href="#id46">1</a></span></dt>
<dd><p>Glantz, Stanton A. “Primer of Biostatistics.”, McGraw-Hill,
Fifth Edition, 2002.</p>
</dd>
<dt class="label" id="r29e9850c7ea2-2"><span class="brackets"><a class="fn-backref" href="#id47">2</a></span></dt>
<dd><p>Wikipedia, “F-distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/F-distribution">https://en.wikipedia.org/wiki/F-distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>An example from Glantz[1], pp 47-40:</p>
<p>Two groups, children of diabetics (25 people) and children from people
without diabetes (25 controls). Fasting blood glucose was measured,
case group had a mean value of 86.1, controls had a mean value of
82.2. Standard deviations were 2.09 and 2.49 respectively. Are these
data consistent with the null hypothesis that the parents diabetic
status does not affect their children’s blood glucose levels?
Calculating the F statistic from the data gives a value of 36.01.</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dfnum</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># between group degrees of freedom  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfden</span> <span class="o">=</span> <span class="mf">48.</span> <span class="c1"># within groups degrees of freedom  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">dfnum</span><span class="p">,</span> <span class="n">dfden</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  
</pre></div>
</div>
<p>The lower bound for the top 1% of the samples is :</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span>  
<span class="go">7.61988120985 # random</span>
</pre></div>
</div>
<p>So there is about a 1% chance that the F statistic will exceed 7.62,
the measured value is 36, so the null hypothesis is rejected at the 1%
level.</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.gamma">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">gamma</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">scale=1.0</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.gamma.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a Gamma distribution.</p>
<p>Samples are drawn from a Gamma distribution with specified parameters,
<cite>shape</cite> (sometimes designated “k”) and <cite>scale</cite> (sometimes designated
“theta”), where both parameters are &gt; 0.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">gamma</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>The shape of the gamma distribution. Must be non-negative.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">float or array_like of floats, optional</span></dt><dd><p>The scale of the gamma distribution. Must be non-negative.
Default is equal to 1.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">shape</span></code> and <code class="docutils literal notranslate"><span class="pre">scale</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(shape,</span> <span class="pre">scale).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized gamma distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.gamma</span></code></dt><dd><p>probability density function, distribution or cumulative density function, etc.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.gamma</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density for the Gamma distribution is</p>
<div class="math notranslate nohighlight">
\[p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},\]</div>
<p>where <span class="math notranslate nohighlight">\(k\)</span> is the shape and <span class="math notranslate nohighlight">\(\theta\)</span> the scale,
and <span class="math notranslate nohighlight">\(\Gamma\)</span> is the Gamma function.</p>
<p>The Gamma distribution is often used to model the times to failure of
electronic components, and arises naturally in processes for which the
waiting times between Poisson distributed events are relevant.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r88bc8c61f191-1"><span class="brackets"><a class="fn-backref" href="#id48">1</a></span></dt>
<dd><p>Weisstein, Eric W. “Gamma Distribution.” From MathWorld–A
Wolfram Web Resource.
<a class="reference external" href="http://mathworld.wolfram.com/GammaDistribution.html">http://mathworld.wolfram.com/GammaDistribution.html</a></p>
</dd>
<dt class="label" id="r88bc8c61f191-2"><span class="brackets"><a class="fn-backref" href="#id49">2</a></span></dt>
<dd><p>Wikipedia, “Gamma distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Gamma_distribution">https://en.wikipedia.org/wiki/Gamma_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span>  <span class="c1"># mean=4, std=2*sqrt(2)  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  
</pre></div>
</div>
<p>Display the histogram of the samples, along with
the probability density function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">sps</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bins</span><span class="o">**</span><span class="p">(</span><span class="n">shape</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">bins</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span> <span class="o">/</span>  
<span class="gp">... </span>                     <span class="p">(</span><span class="n">sps</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span><span class="o">**</span><span class="n">shape</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.geometric">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">geometric</code><span class="sig-paren">(</span><em class="sig-param">p</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.geometric" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.geometric.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from the geometric distribution.</p>
<p>Bernoulli trials are experiments with one of two outcomes:
success or failure (an example of such an experiment is flipping
a coin).  The geometric distribution models the number of trials
that must be run in order to achieve success.  It is therefore
supported on the positive integers, <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...</span></code>.</p>
<p>The probability mass function of the geometric distribution is</p>
<div class="math notranslate nohighlight">
\[f(k) = (1 - p)^{k - 1} p\]</div>
<p>where <cite>p</cite> is the probability of success of an individual trial.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">geometric</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>The probability of success of an individual trial.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">p</span></code> is a scalar.  Otherwise,
<code class="docutils literal notranslate"><span class="pre">np.array(p).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized geometric distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.geometric</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Draw ten thousand values from the geometric distribution,
with the probability of an individual success equal to 0.35:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">geometric</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>  
</pre></div>
</div>
<p>How many trials succeeded after a single run?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mf">10000.</span>  
<span class="go">0.34889999999999999 #random</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.gumbel">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">gumbel</code><span class="sig-paren">(</span><em class="sig-param">loc=0.0</em>, <em class="sig-param">scale=1.0</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.gumbel" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.gumbel.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a Gumbel distribution.</p>
<p>Draw samples from a Gumbel distribution with specified location and
scale.  For more information on the Gumbel distribution, see
Notes and References below.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">gumbel</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>loc</strong><span class="classifier">float or array_like of floats, optional</span></dt><dd><p>The location of the mode of the distribution. Default is 0.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">float or array_like of floats, optional</span></dt><dd><p>The scale parameter of the distribution. Default is 1. Must be non-
negative.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">loc</span></code> and <code class="docutils literal notranslate"><span class="pre">scale</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(loc,</span> <span class="pre">scale).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized Gumbel distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.gumbel_l</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.gumbel_r</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.genextreme</span></code>, <a class="reference internal" href="#dask.array.random.weibull" title="dask.array.random.weibull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">weibull</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.gumbel</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme
Value Type I) distribution is one of a class of Generalized Extreme
Value (GEV) distributions used in modeling extreme value problems.
The Gumbel is a special case of the Extreme Value Type I distribution
for maximums from distributions with “exponential-like” tails.</p>
<p>The probability density for the Gumbel distribution is</p>
<div class="math notranslate nohighlight">
\[p(x) = \frac{e^{-(x - \mu)/ \beta}}{\beta} e^{ -e^{-(x - \mu)/
\beta}},\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu\)</span> is the mode, a location parameter, and
<span class="math notranslate nohighlight">\(\beta\)</span> is the scale parameter.</p>
<p>The Gumbel (named for German mathematician Emil Julius Gumbel) was used
very early in the hydrology literature, for modeling the occurrence of
flood events. It is also used for modeling maximum wind speed and
rainfall rates.  It is a “fat-tailed” distribution - the probability of
an event in the tail of the distribution is larger than if one used a
Gaussian, hence the surprisingly frequent occurrence of 100-year
floods. Floods were initially modeled as a Gaussian process, which
underestimated the frequency of extreme events.</p>
<p>It is one of a class of extreme value distributions, the Generalized
Extreme Value (GEV) distributions, which also includes the Weibull and
Frechet.</p>
<p>The function has a mean of <span class="math notranslate nohighlight">\(\mu + 0.57721\beta\)</span> and a variance
of <span class="math notranslate nohighlight">\(\frac{\pi^2}{6}\beta^2\)</span>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r2ad7560d469c-1"><span class="brackets"><a class="fn-backref" href="#id50">1</a></span></dt>
<dd><p>Gumbel, E. J., “Statistics of Extremes,”
New York: Columbia University Press, 1958.</p>
</dd>
<dt class="label" id="r2ad7560d469c-2"><span class="brackets"><a class="fn-backref" href="#id51">2</a></span></dt>
<dd><p>Reiss, R.-D. and Thomas, M., “Statistical Analysis of Extreme
Values from Insurance, Finance, Hydrology and Other Fields,”
Basel: Birkhauser Verlag, 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span> <span class="c1"># location and scale  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">gumbel</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  
</pre></div>
</div>
<p>Display the histogram of the samples, along with
the probability density function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">bins</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span>  
<span class="gp">... </span>         <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="p">(</span><span class="n">bins</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span><span class="n">beta</span><span class="p">)</span> <span class="p">),</span>
<span class="gp">... </span>         <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
<p>Show how an extreme value distribution can arise from a Gaussian process
and compare to a Gaussian:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">maxima</span> <span class="o">=</span> <span class="p">[]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span> <span class="p">:</span>  
<span class="gp">... </span>   <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">... </span>   <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="gp">... </span>   <span class="n">maxima</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">maxima</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">maxima</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">maxima</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.57721</span><span class="o">*</span><span class="n">beta</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">bins</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span>  
<span class="gp">... </span>         <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">bins</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="n">beta</span><span class="p">)),</span>
<span class="gp">... </span>         <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>  
<span class="gp">... </span>         <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">bins</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">beta</span><span class="o">**</span><span class="mi">2</span><span class="p">)),</span>
<span class="gp">... </span>         <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.hypergeometric">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">hypergeometric</code><span class="sig-paren">(</span><em class="sig-param">ngood</em>, <em class="sig-param">nbad</em>, <em class="sig-param">nsample</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.hypergeometric" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.hypergeometric.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a Hypergeometric distribution.</p>
<p>Samples are drawn from a hypergeometric distribution with specified
parameters, <cite>ngood</cite> (ways to make a good selection), <cite>nbad</cite> (ways to make
a bad selection), and <cite>nsample</cite> (number of items sampled, which is less
than or equal to the sum <code class="docutils literal notranslate"><span class="pre">ngood</span> <span class="pre">+</span> <span class="pre">nbad</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">hypergeometric</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ngood</strong><span class="classifier">int or array_like of ints</span></dt><dd><p>Number of ways to make a good selection.  Must be nonnegative.</p>
</dd>
<dt><strong>nbad</strong><span class="classifier">int or array_like of ints</span></dt><dd><p>Number of ways to make a bad selection.  Must be nonnegative.</p>
</dd>
<dt><strong>nsample</strong><span class="classifier">int or array_like of ints</span></dt><dd><p>Number of items sampled.  Must be at least 1 and at most
<code class="docutils literal notranslate"><span class="pre">ngood</span> <span class="pre">+</span> <span class="pre">nbad</span></code>.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <cite>ngood</cite>, <cite>nbad</cite>, and <cite>nsample</cite>
are all scalars.  Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(ngood,</span> <span class="pre">nbad,</span> <span class="pre">nsample).size</span></code>
samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized hypergeometric distribution. Each
sample is the number of good items within a randomly selected subset of
size <cite>nsample</cite> taken from a set of <cite>ngood</cite> good items and <cite>nbad</cite> bad items.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.hypergeom</span></code></dt><dd><p>probability density function, distribution or cumulative density function, etc.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.hypergeometric</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density for the Hypergeometric distribution is</p>
<div class="math notranslate nohighlight">
\[P(x) = \frac{\binom{g}{x}\binom{b}{n-x}}{\binom{g+b}{n}},\]</div>
<p>where <span class="math notranslate nohighlight">\(0 \le x \le n\)</span> and <span class="math notranslate nohighlight">\(n-b \le x \le g\)</span></p>
<p>for P(x) the probability of <code class="docutils literal notranslate"><span class="pre">x</span></code> good results in the drawn sample,
g = <cite>ngood</cite>, b = <cite>nbad</cite>, and n = <cite>nsample</cite>.</p>
<p>Consider an urn with black and white marbles in it, <cite>ngood</cite> of them
are black and <cite>nbad</cite> are white. If you draw <cite>nsample</cite> balls without
replacement, then the hypergeometric distribution describes the
distribution of black balls in the drawn sample.</p>
<p>Note that this distribution is very similar to the binomial
distribution, except that in this case, samples are drawn without
replacement, whereas in the Binomial case samples are drawn with
replacement (or the sample space is infinite). As the sample space
becomes large, this distribution approaches the binomial.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd169c6b22090-1"><span class="brackets"><a class="fn-backref" href="#id52">1</a></span></dt>
<dd><p>Lentner, Marvin, “Elementary Applied Statistics”, Bogden
and Quigley, 1972.</p>
</dd>
<dt class="label" id="rd169c6b22090-2"><span class="brackets"><a class="fn-backref" href="#id53">2</a></span></dt>
<dd><p>Weisstein, Eric W. “Hypergeometric Distribution.” From
MathWorld–A Wolfram Web Resource.
<a class="reference external" href="http://mathworld.wolfram.com/HypergeometricDistribution.html">http://mathworld.wolfram.com/HypergeometricDistribution.html</a></p>
</dd>
<dt class="label" id="rd169c6b22090-3"><span class="brackets"><a class="fn-backref" href="#id54">3</a></span></dt>
<dd><p>Wikipedia, “Hypergeometric distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Hypergeometric_distribution">https://en.wikipedia.org/wiki/Hypergeometric_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ngood</span><span class="p">,</span> <span class="n">nbad</span><span class="p">,</span> <span class="n">nsamp</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span>  
<span class="go"># number of good, number of bad, and number of samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">hypergeometric</span><span class="p">(</span><span class="n">ngood</span><span class="p">,</span> <span class="n">nbad</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">hist</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  
<span class="go">#   note that it is very unlikely to grab both bad items</span>
</pre></div>
</div>
<p>Suppose you have an urn with 15 white and 15 black marbles.
If you pull 15 marbles at random, how likely is it that
12 or more of them are one color?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">hypergeometric</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="o">&gt;=</span><span class="mi">12</span><span class="p">)</span><span class="o">/</span><span class="mf">100000.</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="o">&lt;=</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mf">100000.</span>  
<span class="go">#   answer = 0.003 ... pretty unlikely!</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.laplace">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">laplace</code><span class="sig-paren">(</span><em class="sig-param">loc=0.0</em>, <em class="sig-param">scale=1.0</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.laplace" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.laplace.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from the Laplace or double exponential distribution with
specified location (or mean) and scale (decay).</p>
<p>The Laplace distribution is similar to the Gaussian/normal distribution,
but is sharper at the peak and has fatter tails. It represents the
difference between two independent, identically distributed exponential
random variables.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">laplace</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>loc</strong><span class="classifier">float or array_like of floats, optional</span></dt><dd><p>The position, <span class="math notranslate nohighlight">\(\mu\)</span>, of the distribution peak. Default is 0.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">float or array_like of floats, optional</span></dt><dd><p><span class="math notranslate nohighlight">\(\lambda\)</span>, the exponential decay. Default is 1. Must be non-
negative.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">loc</span></code> and <code class="docutils literal notranslate"><span class="pre">scale</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(loc,</span> <span class="pre">scale).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized Laplace distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.laplace</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>It has the probability density function</p>
<div class="math notranslate nohighlight">
\[f(x; \mu, \lambda) = \frac{1}{2\lambda}
\exp\left(-\frac{|x - \mu|}{\lambda}\right).\]</div>
<p>The first law of Laplace, from 1774, states that the frequency
of an error can be expressed as an exponential function of the
absolute magnitude of the error, which leads to the Laplace
distribution. For many problems in economics and health
sciences, this distribution seems to model the data better
than the standard Gaussian distribution.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5fc0d3d63f10-1"><span class="brackets"><a class="fn-backref" href="#id55">1</a></span></dt>
<dd><p>Abramowitz, M. and Stegun, I. A. (Eds.). “Handbook of
Mathematical Functions with Formulas, Graphs, and Mathematical
Tables, 9th printing,” New York: Dover, 1972.</p>
</dd>
<dt class="label" id="r5fc0d3d63f10-2"><span class="brackets"><a class="fn-backref" href="#id56">2</a></span></dt>
<dd><p>Kotz, Samuel, et. al. “The Laplace Distribution and
Generalizations, ” Birkhauser, 2001.</p>
</dd>
<dt class="label" id="r5fc0d3d63f10-3"><span class="brackets"><a class="fn-backref" href="#id57">3</a></span></dt>
<dd><p>Weisstein, Eric W. “Laplace Distribution.”
From MathWorld–A Wolfram Web Resource.
<a class="reference external" href="http://mathworld.wolfram.com/LaplaceDistribution.html">http://mathworld.wolfram.com/LaplaceDistribution.html</a></p>
</dd>
<dt class="label" id="r5fc0d3d63f10-4"><span class="brackets"><a class="fn-backref" href="#id58">4</a></span></dt>
<dd><p>Wikipedia, “Laplace distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Laplace_distribution">https://en.wikipedia.org/wiki/Laplace_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">laplace</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  
</pre></div>
</div>
<p>Display the histogram of the samples, along with
the probability density function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">8.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="o">.</span><span class="mi">01</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">loc</span><span class="p">)</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">scale</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pdf</span><span class="p">)</span>  
</pre></div>
</div>
<p>Plot Gaussian for comparison:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">*</span>  
<span class="gp">... </span>     <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">loc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">scale</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">g</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.logistic">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">logistic</code><span class="sig-paren">(</span><em class="sig-param">loc=0.0</em>, <em class="sig-param">scale=1.0</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.logistic" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.logistic.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a logistic distribution.</p>
<p>Samples are drawn from a logistic distribution with specified
parameters, loc (location or mean, also median), and scale (&gt;0).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">logistic</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>loc</strong><span class="classifier">float or array_like of floats, optional</span></dt><dd><p>Parameter of the distribution. Default is 0.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">float or array_like of floats, optional</span></dt><dd><p>Parameter of the distribution. Must be non-negative.
Default is 1.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">loc</span></code> and <code class="docutils literal notranslate"><span class="pre">scale</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(loc,</span> <span class="pre">scale).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized logistic distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.logistic</span></code></dt><dd><p>probability density function, distribution or cumulative density function, etc.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.logistic</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density for the Logistic distribution is</p>
<div class="math notranslate nohighlight">
\[P(x) = P(x) = \frac{e^{-(x-\mu)/s}}{s(1+e^{-(x-\mu)/s})^2},\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu\)</span> = location and <span class="math notranslate nohighlight">\(s\)</span> = scale.</p>
<p>The Logistic distribution is used in Extreme Value problems where it
can act as a mixture of Gumbel distributions, in Epidemiology, and by
the World Chess Federation (FIDE) where it is used in the Elo ranking
system, assuming the performance of each player is a logistically
distributed random variable.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r562dced5abf9-1"><span class="brackets"><a class="fn-backref" href="#id59">1</a></span></dt>
<dd><p>Reiss, R.-D. and Thomas M. (2001), “Statistical Analysis of
Extreme Values, from Insurance, Finance, Hydrology and Other
Fields,” Birkhauser Verlag, Basel, pp 132-133.</p>
</dd>
<dt class="label" id="r562dced5abf9-2"><span class="brackets"><a class="fn-backref" href="#id60">2</a></span></dt>
<dd><p>Weisstein, Eric W. “Logistic Distribution.” From
MathWorld–A Wolfram Web Resource.
<a class="reference external" href="http://mathworld.wolfram.com/LogisticDistribution.html">http://mathworld.wolfram.com/LogisticDistribution.html</a></p>
</dd>
<dt class="label" id="r562dced5abf9-3"><span class="brackets"><a class="fn-backref" href="#id61">3</a></span></dt>
<dd><p>Wikipedia, “Logistic-distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Logistic_distribution">https://en.wikipedia.org/wiki/Logistic_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">logistic</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>  
</pre></div>
</div>
<p>#   plot against distribution</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">logist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">loc</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">scale</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">loc</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">scale</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lgst_val</span> <span class="o">=</span> <span class="n">logist</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">lgst_val</span> <span class="o">*</span> <span class="n">count</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">lgst_val</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.lognormal">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">lognormal</code><span class="sig-paren">(</span><em class="sig-param">mean=0.0</em>, <em class="sig-param">sigma=1.0</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.lognormal" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.lognormal.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a log-normal distribution.</p>
<p>Draw samples from a log-normal distribution with specified mean,
standard deviation, and array shape.  Note that the mean and standard
deviation are not the values for the distribution itself, but of the
underlying normal distribution it is derived from.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">lognormal</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mean</strong><span class="classifier">float or array_like of floats, optional</span></dt><dd><p>Mean value of the underlying normal distribution. Default is 0.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float or array_like of floats, optional</span></dt><dd><p>Standard deviation of the underlying normal distribution. Must be
non-negative. Default is 1.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">mean</span></code> and <code class="docutils literal notranslate"><span class="pre">sigma</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(mean,</span> <span class="pre">sigma).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized log-normal distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.lognorm</span></code></dt><dd><p>probability density function, distribution, cumulative density function, etc.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.lognormal</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>A variable <cite>x</cite> has a log-normal distribution if <cite>log(x)</cite> is normally
distributed.  The probability density function for the log-normal
distribution is:</p>
<div class="math notranslate nohighlight">
\[p(x) = \frac{1}{\sigma x \sqrt{2\pi}}
e^{(-\frac{(ln(x)-\mu)^2}{2\sigma^2})}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu\)</span> is the mean and <span class="math notranslate nohighlight">\(\sigma\)</span> is the standard
deviation of the normally distributed logarithm of the variable.
A log-normal distribution results if a random variable is the <em>product</em>
of a large number of independent, identically-distributed variables in
the same way that a normal distribution results if the variable is the
<em>sum</em> of a large number of independent, identically-distributed
variables.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb00f061ac669-1"><span class="brackets"><a class="fn-backref" href="#id62">1</a></span></dt>
<dd><p>Limpert, E., Stahel, W. A., and Abbt, M., “Log-normal
Distributions across the Sciences: Keys and Clues,”
BioScience, Vol. 51, No. 5, May, 2001.
<a class="reference external" href="https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf">https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf</a></p>
</dd>
<dt class="label" id="rb00f061ac669-2"><span class="brackets"><a class="fn-backref" href="#id63">2</a></span></dt>
<dd><p>Reiss, R.D. and Thomas, M., “Statistical Analysis of Extreme
Values,” Basel: Birkhauser Verlag, 2001, pp. 31-32.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span> <span class="c1"># mean and standard deviation  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">lognormal</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  
</pre></div>
</div>
<p>Display the histogram of the samples, along with
the probability density function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;mid&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">bins</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">bins</span><span class="p">),</span> <span class="mi">10000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>  
<span class="gp">... </span>       <span class="o">/</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
<p>Demonstrate that taking the products of random samples from a uniform
distribution can be fit well by a log-normal probability density
function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a thousand samples: each is the product of 100 random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># values, drawn from a normal distribution.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>  
<span class="gp">... </span>   <span class="n">a</span> <span class="o">=</span> <span class="mf">10.</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">... </span>   <span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1"># scale values to be positive  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;mid&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">bins</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">bins</span><span class="p">),</span> <span class="mi">10000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>  
<span class="gp">... </span>       <span class="o">/</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.logseries">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">logseries</code><span class="sig-paren">(</span><em class="sig-param">p</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.logseries" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.logseries.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a logarithmic series distribution.</p>
<p>Samples are drawn from a log series distribution with specified
shape parameter, 0 &lt; <code class="docutils literal notranslate"><span class="pre">p</span></code> &lt; 1.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">logseries</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Shape parameter for the distribution.  Must be in the range (0, 1).</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">p</span></code> is a scalar.  Otherwise,
<code class="docutils literal notranslate"><span class="pre">np.array(p).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized logarithmic series distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.logser</span></code></dt><dd><p>probability density function, distribution or cumulative density function, etc.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.logseries</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density for the Log Series distribution is</p>
<div class="math notranslate nohighlight">
\[P(k) = \frac{-p^k}{k \ln(1-p)},\]</div>
<p>where p = probability.</p>
<p>The log series distribution is frequently used to represent species
richness and occurrence, first proposed by Fisher, Corbet, and
Williams in 1943 [2].  It may also be used to model the numbers of
occupants seen in cars [3].</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r63ce279e21e5-1"><span class="brackets"><a class="fn-backref" href="#id64">1</a></span></dt>
<dd><p>Buzas, Martin A.; Culver, Stephen J.,  Understanding regional
species diversity through the log series distribution of
occurrences: BIODIVERSITY RESEARCH Diversity &amp; Distributions,
Volume 5, Number 5, September 1999 , pp. 187-195(9).</p>
</dd>
<dt class="label" id="r63ce279e21e5-2"><span class="brackets"><a class="fn-backref" href="#id65">2</a></span></dt>
<dd><p>Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The
relation between the number of species and the number of
individuals in a random sample of an animal population.
Journal of Animal Ecology, 12:42-58.</p>
</dd>
<dt class="label" id="r63ce279e21e5-3"><span class="brackets"><a class="fn-backref" href="#id66">3</a></span></dt>
<dd><p>D. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small
Data Sets, CRC Press, 1994.</p>
</dd>
<dt class="label" id="r63ce279e21e5-4"><span class="brackets"><a class="fn-backref" href="#id67">4</a></span></dt>
<dd><p>Wikipedia, “Logarithmic distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Logarithmic_distribution">https://en.wikipedia.org/wiki/Logarithmic_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="o">.</span><span class="mi">6</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">logseries</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  
</pre></div>
</div>
<p>#   plot against distribution</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">logseries</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="k">return</span> <span class="o">-</span><span class="n">p</span><span class="o">**</span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">logseries</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">count</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">/</span>  
<span class="gp">... </span>         <span class="n">logseries</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.negative_binomial">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">negative_binomial</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">p</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.negative_binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.negative_binomial.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a negative binomial distribution.</p>
<p>Samples are drawn from a negative binomial distribution with specified
parameters, <cite>n</cite> successes and <cite>p</cite> probability of success where <cite>n</cite>
is &gt; 0 and <cite>p</cite> is in the interval [0, 1].</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">negative_binomial</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Parameter of the distribution, &gt; 0.</p>
</dd>
<dt><strong>p</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Parameter of the distribution, &gt;= 0 and &lt;=1.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">p</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(n,</span> <span class="pre">p).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized negative binomial distribution,
where each sample is equal to N, the number of failures that
occurred before a total of n successes was reached.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.negative_binomial</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability mass function of the negative binomial distribution is</p>
<div class="math notranslate nohighlight">
\[P(N;n,p) = \frac{\Gamma(N+n)}{N!\Gamma(n)}p^{n}(1-p)^{N},\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the number of successes, <span class="math notranslate nohighlight">\(p\)</span> is the
probability of success, <span class="math notranslate nohighlight">\(N+n\)</span> is the number of trials, and
<span class="math notranslate nohighlight">\(\Gamma\)</span> is the gamma function. When <span class="math notranslate nohighlight">\(n\)</span> is an integer,
<span class="math notranslate nohighlight">\(\frac{\Gamma(N+n)}{N!\Gamma(n)} = \binom{N+n-1}{N}\)</span>, which is
the more common form of this term in the the pmf. The negative
binomial distribution gives the probability of N failures given n
successes, with a success on the last trial.</p>
<p>If one throws a die repeatedly until the third time a “1” appears,
then the probability distribution of the number of non-“1”s that
appear before the third “1” is a negative binomial distribution.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1cda82fbb720-1"><span class="brackets"><a class="fn-backref" href="#id68">1</a></span></dt>
<dd><p>Weisstein, Eric W. “Negative Binomial Distribution.” From
MathWorld–A Wolfram Web Resource.
<a class="reference external" href="http://mathworld.wolfram.com/NegativeBinomialDistribution.html">http://mathworld.wolfram.com/NegativeBinomialDistribution.html</a></p>
</dd>
<dt class="label" id="r1cda82fbb720-2"><span class="brackets"><a class="fn-backref" href="#id69">2</a></span></dt>
<dd><p>Wikipedia, “Negative binomial distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Negative_binomial_distribution">https://en.wikipedia.org/wiki/Negative_binomial_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<p>A real world example. A company drills wild-cat oil
exploration wells, each with an estimated probability of
success of 0.1.  What is the probability of having one success
for each successive well, that is what is the probability of a
single success after drilling 5 wells, after 6 wells, etc.?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">negative_binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span> 
<span class="gp">... </span>   <span class="n">probability</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="o">&lt;</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100000.</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;wells drilled, probability of one success =&quot;</span><span class="p">,</span> <span class="n">probability</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.noncentral_chisquare">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">noncentral_chisquare</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">nonc</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.noncentral_chisquare" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.noncentral_chisquare.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a noncentral chi-square distribution.</p>
<p>The noncentral <span class="math notranslate nohighlight">\(\chi^2\)</span> distribution is a generalization of
the <span class="math notranslate nohighlight">\(\chi^2\)</span> distribution.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">noncentral_chisquare</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>df</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Degrees of freedom, must be &gt; 0.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.10.0: </span>Earlier NumPy versions required dfnum &gt; 1.</p>
</div>
</dd>
<dt><strong>nonc</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Non-centrality, must be non-negative.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">df</span></code> and <code class="docutils literal notranslate"><span class="pre">nonc</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(df,</span> <span class="pre">nonc).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized noncentral chi-square distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.noncentral_chisquare</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density function for the noncentral Chi-square
distribution is</p>
<div class="math notranslate nohighlight">
\[P(x;df,nonc) = \sum^{\infty}_{i=0}
\frac{e^{-nonc/2}(nonc/2)^{i}}{i!}
P_{Y_{df+2i}}(x),\]</div>
<p>where <span class="math notranslate nohighlight">\(Y_{q}\)</span> is the Chi-square with q degrees of freedom.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8d93b7d92358-1"><span class="brackets"><a class="fn-backref" href="#id70">1</a></span></dt>
<dd><p>Wikipedia, “Noncentral chi-squared distribution”
<a class="reference external" href="https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution">https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw values from the distribution and plot the histogram</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">noncentral_chisquare</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">100000</span><span class="p">),</span>  
<span class="gp">... </span>                  <span class="n">bins</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
<p>Draw values from a noncentral chisquare with very small noncentrality,
and compare to a chisquare.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">noncentral_chisquare</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">.</span><span class="mi">0000001</span><span class="p">,</span> <span class="mi">100000</span><span class="p">),</span>  
<span class="gp">... </span>                  <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">),</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">chisquare</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100000</span><span class="p">),</span>  
<span class="gp">... </span>                   <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">),</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">values2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;ob&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
<p>Demonstrate how large values of non-centrality lead to a more symmetric
distribution.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">noncentral_chisquare</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">100000</span><span class="p">),</span>  
<span class="gp">... </span>                  <span class="n">bins</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.noncentral_f">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">noncentral_f</code><span class="sig-paren">(</span><em class="sig-param">dfnum</em>, <em class="sig-param">dfden</em>, <em class="sig-param">nonc</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.noncentral_f" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.noncentral_f.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from the noncentral F distribution.</p>
<p>Samples are drawn from an F distribution with specified parameters,
<cite>dfnum</cite> (degrees of freedom in numerator) and <cite>dfden</cite> (degrees of
freedom in denominator), where both parameters &gt; 1.
<cite>nonc</cite> is the non-centrality parameter.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">noncentral_f</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>dfnum</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Numerator degrees of freedom, must be &gt; 0.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.14.0: </span>Earlier NumPy versions required dfnum &gt; 1.</p>
</div>
</dd>
<dt><strong>dfden</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Denominator degrees of freedom, must be &gt; 0.</p>
</dd>
<dt><strong>nonc</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Non-centrality parameter, the sum of the squares of the numerator
means, must be &gt;= 0.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">dfnum</span></code>, <code class="docutils literal notranslate"><span class="pre">dfden</span></code>, and <code class="docutils literal notranslate"><span class="pre">nonc</span></code>
are all scalars.  Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(dfnum,</span> <span class="pre">dfden,</span> <span class="pre">nonc).size</span></code>
samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized noncentral Fisher distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.noncentral_f</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When calculating the power of an experiment (power = probability of
rejecting the null hypothesis when a specific alternative is true) the
non-central F statistic becomes important.  When the null hypothesis is
true, the F statistic follows a central F distribution. When the null
hypothesis is not true, then it follows a non-central F statistic.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r86eb94b022fc-1"><span class="brackets"><a class="fn-backref" href="#id71">1</a></span></dt>
<dd><p>Weisstein, Eric W. “Noncentral F-Distribution.”
From MathWorld–A Wolfram Web Resource.
<a class="reference external" href="http://mathworld.wolfram.com/NoncentralF-Distribution.html">http://mathworld.wolfram.com/NoncentralF-Distribution.html</a></p>
</dd>
<dt class="label" id="r86eb94b022fc-2"><span class="brackets"><a class="fn-backref" href="#id72">2</a></span></dt>
<dd><p>Wikipedia, “Noncentral F-distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Noncentral_F-distribution">https://en.wikipedia.org/wiki/Noncentral_F-distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In a study, testing for a specific alternative to the null hypothesis
requires use of the Noncentral F distribution. We need to calculate the
area in the tail of the distribution that exceeds the value of the F
distribution for the null hypothesis.  We’ll plot the two probability
distributions for comparison.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dfnum</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># between group deg of freedom  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfden</span> <span class="o">=</span> <span class="mi">20</span> <span class="c1"># within groups degrees of freedom  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonc</span> <span class="o">=</span> <span class="mf">3.0</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">nc_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">noncentral_f</span><span class="p">(</span><span class="n">dfnum</span><span class="p">,</span> <span class="n">dfden</span><span class="p">,</span> <span class="n">nonc</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">NF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">nc_vals</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">dfnum</span><span class="p">,</span> <span class="n">dfden</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">c_vals</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span> <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">NF</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span> <span class="n">NF</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.normal">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">normal</code><span class="sig-paren">(</span><em class="sig-param">loc=0.0</em>, <em class="sig-param">scale=1.0</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.normal" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.normal.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw random samples from a normal (Gaussian) distribution.</p>
<p>The probability density function of the normal distribution, first
derived by De Moivre and 200 years later by both Gauss and Laplace
independently <a class="reference internal" href="#r06ed1c8cfe9e-2" id="id73">[2]</a>, is often called the bell curve because of
its characteristic shape (see the example below).</p>
<p>The normal distributions occurs often in nature.  For example, it
describes the commonly occurring distribution of samples influenced
by a large number of tiny, random disturbances, each with its own
unique distribution <a class="reference internal" href="#r06ed1c8cfe9e-2" id="id74">[2]</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">normal</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>loc</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Mean (“centre”) of the distribution.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Standard deviation (spread or “width”) of the distribution. Must be
non-negative.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">loc</span></code> and <code class="docutils literal notranslate"><span class="pre">scale</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(loc,</span> <span class="pre">scale).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized normal distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.norm</span></code></dt><dd><p>probability density function, distribution or cumulative density function, etc.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.normal</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density for the Gaussian distribution is</p>
<div class="math notranslate nohighlight">
\[p(x) = \frac{1}{\sqrt{ 2 \pi \sigma^2 }}
e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} },\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu\)</span> is the mean and <span class="math notranslate nohighlight">\(\sigma\)</span> the standard
deviation. The square of the standard deviation, <span class="math notranslate nohighlight">\(\sigma^2\)</span>,
is called the variance.</p>
<p>The function has its peak at the mean, and its “spread” increases with
the standard deviation (the function reaches 0.607 times its maximum at
<span class="math notranslate nohighlight">\(x + \sigma\)</span> and <span class="math notranslate nohighlight">\(x - \sigma\)</span> <a class="reference internal" href="#r06ed1c8cfe9e-2" id="id75">[2]</a>).  This implies that
normal is more likely to return samples lying close to the mean, rather
than those far away.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r06ed1c8cfe9e-1"><span class="brackets"><a class="fn-backref" href="#id76">1</a></span></dt>
<dd><p>Wikipedia, “Normal distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Normal_distribution">https://en.wikipedia.org/wiki/Normal_distribution</a></p>
</dd>
<dt class="label" id="r06ed1c8cfe9e-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id73">1</a>,<a href="#id74">2</a>,<a href="#id75">3</a>,<a href="#id77">4</a>)</span></dt>
<dd><p>P. R. Peebles Jr., “Central Limit Theorem” in “Probability,
Random Variables and Random Signal Principles”, 4th ed., 2001,
pp. 51, 51, 125.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span> <span class="c1"># mean and standard deviation  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  
</pre></div>
</div>
<p>Verify the mean and the variance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">mu</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>  
<span class="go">0.0  # may vary</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">sigma</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>  
<span class="go">0.1  # may vary</span>
</pre></div>
</div>
<p>Display the histogram of the samples, along with
the probability density function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">*</span>  
<span class="gp">... </span>               <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span> <span class="p">(</span><span class="n">bins</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="p">),</span>
<span class="gp">... </span>         <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
<p>Two-by-four array of samples from N(3, 6.25):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>  
<span class="go">array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random</span>
<span class="go">       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.pareto">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">pareto</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.pareto" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.pareto.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a Pareto II or Lomax distribution with
specified shape.</p>
<p>The Lomax or Pareto II distribution is a shifted Pareto
distribution. The classical Pareto distribution can be
obtained from the Lomax distribution by adding 1 and
multiplying by the scale parameter <code class="docutils literal notranslate"><span class="pre">m</span></code> (see Notes).  The
smallest value of the Lomax distribution is zero while for the
classical Pareto distribution it is <code class="docutils literal notranslate"><span class="pre">mu</span></code>, where the standard
Pareto distribution has location <code class="docutils literal notranslate"><span class="pre">mu</span> <span class="pre">=</span> <span class="pre">1</span></code>.  Lomax can also
be considered as a simplified version of the Generalized
Pareto distribution (available in SciPy), with the scale set
to one and the location set to zero.</p>
<p>The Pareto distribution must be greater than zero, and is
unbounded above.  It is also known as the “80-20 rule”.  In
this distribution, 80 percent of the weights are in the lowest
20 percent of the range, while the other 20 percent fill the
remaining 80 percent of the range.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">pareto</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Shape of the distribution. Must be positive.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">a</span></code> is a scalar.  Otherwise,
<code class="docutils literal notranslate"><span class="pre">np.array(a).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized Pareto distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.lomax</span></code></dt><dd><p>probability density function, distribution or cumulative density function, etc.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.genpareto</span></code></dt><dd><p>probability density function, distribution or cumulative density function, etc.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.pareto</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density for the Pareto distribution is</p>
<div class="math notranslate nohighlight">
\[p(x) = \frac{am^a}{x^{a+1}}\]</div>
<p>where <span class="math notranslate nohighlight">\(a\)</span> is the shape and <span class="math notranslate nohighlight">\(m\)</span> the scale.</p>
<p>The Pareto distribution, named after the Italian economist
Vilfredo Pareto, is a power law probability distribution
useful in many real world problems.  Outside the field of
economics it is generally referred to as the Bradford
distribution. Pareto developed the distribution to describe
the distribution of wealth in an economy.  It has also found
use in insurance, web page access statistics, oil field sizes,
and many other problems, including the download frequency for
projects in Sourceforge <a class="reference internal" href="#r8b836986745a-1" id="id78">[1]</a>.  It is one of the so-called
“fat-tailed” distributions.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8b836986745a-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id78">1</a>,<a href="#id79">2</a>)</span></dt>
<dd><p>Francis Hunt and Paul Johnson, On the Pareto Distribution of
Sourceforge projects.</p>
</dd>
<dt class="label" id="r8b836986745a-2"><span class="brackets"><a class="fn-backref" href="#id80">2</a></span></dt>
<dd><p>Pareto, V. (1896). Course of Political Economy. Lausanne.</p>
</dd>
<dt class="label" id="r8b836986745a-3"><span class="brackets"><a class="fn-backref" href="#id81">3</a></span></dt>
<dd><p>Reiss, R.D., Thomas, M.(2001), Statistical Analysis of Extreme
Values, Birkhauser Verlag, Basel, pp 23-30.</p>
</dd>
<dt class="label" id="r8b836986745a-4"><span class="brackets"><a class="fn-backref" href="#id82">4</a></span></dt>
<dd><p>Wikipedia, “Pareto distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Pareto_distribution">https://en.wikipedia.org/wiki/Pareto_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span>  <span class="c1"># shape and mode  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">pareto</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span>  
</pre></div>
</div>
<p>Display the histogram of the samples, along with the probability
density function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">fit</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">m</span><span class="o">**</span><span class="n">a</span> <span class="o">/</span> <span class="n">bins</span><span class="o">**</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="o">*</span><span class="n">fit</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">fit</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.poisson">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">poisson</code><span class="sig-paren">(</span><em class="sig-param">lam=1.0</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.poisson" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.poisson.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a Poisson distribution.</p>
<p>The Poisson distribution is the limit of the binomial distribution
for large N.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">poisson</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lam</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Expectation of interval, must be &gt;= 0. A sequence of expectation
intervals must be broadcastable over the requested size.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">lam</span></code> is a scalar. Otherwise,
<code class="docutils literal notranslate"><span class="pre">np.array(lam).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized Poisson distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.poisson</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The Poisson distribution</p>
<div class="math notranslate nohighlight">
\[f(k; \lambda)=\frac{\lambda^k e^{-\lambda}}{k!}\]</div>
<p>For events with an expected separation <span class="math notranslate nohighlight">\(\lambda\)</span> the Poisson
distribution <span class="math notranslate nohighlight">\(f(k; \lambda)\)</span> describes the probability of
<span class="math notranslate nohighlight">\(k\)</span> events occurring within the observed
interval <span class="math notranslate nohighlight">\(\lambda\)</span>.</p>
<p>Because the output is limited to the range of the C int64 type, a
ValueError is raised when <cite>lam</cite> is within 10 sigma of the maximum
representable value.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r031daf7dbd26-1"><span class="brackets"><a class="fn-backref" href="#id83">1</a></span></dt>
<dd><p>Weisstein, Eric W. “Poisson Distribution.”
From MathWorld–A Wolfram Web Resource.
<a class="reference external" href="http://mathworld.wolfram.com/PoissonDistribution.html">http://mathworld.wolfram.com/PoissonDistribution.html</a></p>
</dd>
<dt class="label" id="r031daf7dbd26-2"><span class="brackets"><a class="fn-backref" href="#id84">2</a></span></dt>
<dd><p>Wikipedia, “Poisson distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Poisson_distribution">https://en.wikipedia.org/wiki/Poisson_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>  
</pre></div>
</div>
<p>Display histogram of the sample:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
<p>Draw each 100 values for lambda 100 and 500:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="p">(</span><span class="mf">100.</span><span class="p">,</span> <span class="mf">500.</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.power">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">power</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.power" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.power.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draws samples in [0, 1] from a power distribution with positive
exponent a - 1.</p>
<p>Also known as the power function distribution.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">power</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Parameter of the distribution. Must be non-negative.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">a</span></code> is a scalar.  Otherwise,
<code class="docutils literal notranslate"><span class="pre">np.array(a).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized power distribution.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If a &lt; 1.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.power</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density function is</p>
<div class="math notranslate nohighlight">
\[P(x; a) = ax^{a-1}, 0 \le x \le 1, a&gt;0.\]</div>
<p>The power function distribution is just the inverse of the Pareto
distribution. It may also be seen as a special case of the Beta
distribution.</p>
<p>It is used, for example, in modeling the over-reporting of insurance
claims.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="recf9603c0c16-1"><span class="brackets"><a class="fn-backref" href="#id85">1</a></span></dt>
<dd><p>Christian Kleiber, Samuel Kotz, “Statistical size distributions
in economics and actuarial sciences”, Wiley, 2003.</p>
</dd>
<dt class="label" id="recf9603c0c16-2"><span class="brackets"><a class="fn-backref" href="#id86">2</a></span></dt>
<dd><p>Heckert, N. A. and Filliben, James J. “NIST Handbook 148:
Dataplot Reference Manual, Volume 2: Let Subcommands and Library
Functions”, National Institute of Standards and Technology
Handbook Series, June 2003.
<a class="reference external" href="https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf">https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">5.</span> <span class="c1"># shape  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="mi">1000</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span>  
</pre></div>
</div>
<p>Display the histogram of the samples, along with
the probability density function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">normed_y</span> <span class="o">=</span> <span class="n">samples</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">y</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">normed_y</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
<p>Compare the power function distribution to the inverse of the Pareto.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">rvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">rvsp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">pareto</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">powpdf</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">powerlaw</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">rvs</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">powpdf</span><span class="p">,</span><span class="s1">&#39;r-&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;np.random.power(5)&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">rvsp</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">powpdf</span><span class="p">,</span><span class="s1">&#39;r-&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;inverse of 1 + np.random.pareto(5)&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">rvsp</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">powpdf</span><span class="p">,</span><span class="s1">&#39;r-&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;inverse of stats.pareto(5)&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.randint">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">randint</code><span class="sig-paren">(</span><em class="sig-param">low</em>, <em class="sig-param">high=None</em>, <em class="sig-param">size=None</em>, <em class="sig-param">dtype='l'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.randint" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.randint.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return random integers from <cite>low</cite> (inclusive) to <cite>high</cite> (exclusive).</p>
<p>Return random integers from the “discrete uniform” distribution of
the specified dtype in the “half-open” interval [<cite>low</cite>, <cite>high</cite>). If
<cite>high</cite> is None (the default), then results are from [0, <cite>low</cite>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">integers</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>low</strong><span class="classifier">int or array-like of ints</span></dt><dd><p>Lowest (signed) integers to be drawn from the distribution (unless
<code class="docutils literal notranslate"><span class="pre">high=None</span></code>, in which case this parameter is one above the
<em>highest</em> such integer).</p>
</dd>
<dt><strong>high</strong><span class="classifier">int or array-like of ints, optional</span></dt><dd><p>If provided, one above the largest (signed) integer to be drawn
from the distribution (see above for behavior if <code class="docutils literal notranslate"><span class="pre">high=None</span></code>).
If array-like, must contain integer values</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  Default is None, in which case a
single value is returned.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Desired dtype of the result. All dtypes are determined by their
name, i.e., ‘int64’, ‘int’, etc, so byteorder is not available
and a specific precision may have different C types depending
on the platform. The default value is <cite>np.int_</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.11.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">int or ndarray of ints</span></dt><dd><p><cite>size</cite>-shaped array of random integers from the appropriate
distribution, or a single such random int if <cite>size</cite> not provided.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_integers</span></code></dt><dd><p>similar to <cite>randint</cite>, only for the closed interval [<cite>low</cite>, <cite>high</cite>], and 1 is the lowest value if <cite>high</cite> is omitted.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.integers</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</span>
</pre></div>
</div>
<p>Generate a 2 x 4 array of ints between 0 and 4, inclusive:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>  
<span class="go">array([[4, 0, 2, 1], # random</span>
<span class="go">       [3, 2, 2, 0]])</span>
</pre></div>
</div>
<p>Generate a 1 x 3 array with 3 different upper bounds</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>  
<span class="go">array([2, 2, 9]) # random</span>
</pre></div>
</div>
<p>Generate a 1 by 3 array with 3 different lower bounds</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>  
<span class="go">array([9, 8, 7]) # random</span>
</pre></div>
</div>
<p>Generate a 2 by 4 array using broadcasting with dtype of uint8</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[[</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  
<span class="go">array([[ 8,  6,  9,  7], # random</span>
<span class="go">       [ 1, 16,  9, 12]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.random">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">random</code><span class="sig-paren">(</span><em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.random" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.random_sample.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return random floats in the half-open interval [0.0, 1.0).</p>
<p>Results are from the “continuous uniform” distribution over the
stated interval.  To sample <span class="math notranslate nohighlight">\(Unif[a, b), b &gt; a\)</span> multiply
the output of <cite>random_sample</cite> by <cite>(b-a)</cite> and add <cite>a</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">random_sample</span><span class="p">()</span> <span class="o">+</span> <span class="n">a</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">random</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  Default is None, in which case a
single value is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">float or ndarray of floats</span></dt><dd><p>Array of random floats of shape <cite>size</cite> (unless <code class="docutils literal notranslate"><span class="pre">size=None</span></code>, in which
case a single float is returned).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.random</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>  
<span class="go">0.47108547995356098 # random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">())</span>  
<span class="go">&lt;class &#39;float&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">((</span><span class="mi">5</span><span class="p">,))</span>  
<span class="go">array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random</span>
</pre></div>
</div>
<p>Three-by-two array of random numbers from [-5, 0):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">5</span>  
<span class="go">array([[-3.99149989, -0.52338984], # random</span>
<span class="go">       [-2.99091858, -0.79479508],</span>
<span class="go">       [-1.23204345, -1.75224494]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.random_sample">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">random_sample</code><span class="sig-paren">(</span><em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.random_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.random_sample.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return random floats in the half-open interval [0.0, 1.0).</p>
<p>Results are from the “continuous uniform” distribution over the
stated interval.  To sample <span class="math notranslate nohighlight">\(Unif[a, b), b &gt; a\)</span> multiply
the output of <cite>random_sample</cite> by <cite>(b-a)</cite> and add <cite>a</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">random_sample</span><span class="p">()</span> <span class="o">+</span> <span class="n">a</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">random</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  Default is None, in which case a
single value is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">float or ndarray of floats</span></dt><dd><p>Array of random floats of shape <cite>size</cite> (unless <code class="docutils literal notranslate"><span class="pre">size=None</span></code>, in which
case a single float is returned).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.random</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>  
<span class="go">0.47108547995356098 # random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">())</span>  
<span class="go">&lt;class &#39;float&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">((</span><span class="mi">5</span><span class="p">,))</span>  
<span class="go">array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random</span>
</pre></div>
</div>
<p>Three-by-two array of random numbers from [-5, 0):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">5</span>  
<span class="go">array([[-3.99149989, -0.52338984], # random</span>
<span class="go">       [-2.99091858, -0.79479508],</span>
<span class="go">       [-1.23204345, -1.75224494]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.rayleigh">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">rayleigh</code><span class="sig-paren">(</span><em class="sig-param">scale=1.0</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.rayleigh" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.rayleigh.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a Rayleigh distribution.</p>
<p>The <span class="math notranslate nohighlight">\(\chi\)</span> and Weibull distributions are generalizations of the
Rayleigh.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">rayleigh</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scale</strong><span class="classifier">float or array_like of floats, optional</span></dt><dd><p>Scale, also equals the mode. Must be non-negative. Default is 1.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">scale</span></code> is a scalar.  Otherwise,
<code class="docutils literal notranslate"><span class="pre">np.array(scale).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized Rayleigh distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.rayleigh</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density function for the Rayleigh distribution is</p>
<div class="math notranslate nohighlight">
\[P(x;scale) = \frac{x}{scale^2}e^{\frac{-x^2}{2 \cdotp scale^2}}\]</div>
<p>The Rayleigh distribution would arise, for example, if the East
and North components of the wind velocity had identical zero-mean
Gaussian distributions.  Then the wind speed would have a Rayleigh
distribution.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5f8f8ec55a63-1"><span class="brackets"><a class="fn-backref" href="#id87">1</a></span></dt>
<dd><p>Brighton Webs Ltd., “Rayleigh Distribution,”
<a class="reference external" href="https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp">https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp</a></p>
</dd>
<dt class="label" id="r5f8f8ec55a63-2"><span class="brackets"><a class="fn-backref" href="#id88">2</a></span></dt>
<dd><p>Wikipedia, “Rayleigh distribution”
<a class="reference external" href="https://en.wikipedia.org/wiki/Rayleigh_distribution">https://en.wikipedia.org/wiki/Rayleigh_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw values from the distribution and plot the histogram</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">hist</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rayleigh</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100000</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
</pre></div>
</div>
<p>Wave heights tend to follow a Rayleigh distribution. If the mean wave
height is 1 meter, what fraction of waves are likely to be larger than 3
meters?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">meanvalue</span> <span class="o">=</span> <span class="mi">1</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">modevalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">meanvalue</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rayleigh</span><span class="p">(</span><span class="n">modevalue</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span>  
</pre></div>
</div>
<p>The percentage of waves larger than 3 meters is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">100.</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mf">1000000.</span>  
<span class="go">0.087300000000000003 # random</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.standard_cauchy">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">standard_cauchy</code><span class="sig-paren">(</span><em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.standard_cauchy" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.standard_cauchy.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a standard Cauchy distribution with mode = 0.</p>
<p>Also known as the Lorentz distribution.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">standard_cauchy</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  Default is None, in which case a
single value is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>The drawn samples.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.standard_cauchy</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density function for the full Cauchy distribution is</p>
<div class="math notranslate nohighlight">
\[P(x; x_0, \gamma) = \frac{1}{\pi \gamma \bigl[ 1+
(\frac{x-x_0}{\gamma})^2 \bigr] }\]</div>
<p>and the Standard Cauchy distribution just sets <span class="math notranslate nohighlight">\(x_0=0\)</span> and
<span class="math notranslate nohighlight">\(\gamma=1\)</span></p>
<p>The Cauchy distribution arises in the solution to the driven harmonic
oscillator problem, and also describes spectral line broadening. It
also describes the distribution of values at which a line tilted at
a random angle will cut the x axis.</p>
<p>When studying hypothesis tests that assume normality, seeing how the
tests perform on data from a Cauchy distribution is a good indicator of
their sensitivity to a heavy-tailed distribution, since the Cauchy looks
very much like a Gaussian distribution, but with heavier tails.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r47ee0e8a4f4f-1"><span class="brackets"><a class="fn-backref" href="#id89">1</a></span></dt>
<dd><p>NIST/SEMATECH e-Handbook of Statistical Methods, “Cauchy
Distribution”,
<a class="reference external" href="https://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm">https://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm</a></p>
</dd>
<dt class="label" id="r47ee0e8a4f4f-2"><span class="brackets"><a class="fn-backref" href="#id90">2</a></span></dt>
<dd><p>Weisstein, Eric W. “Cauchy Distribution.” From MathWorld–A
Wolfram Web Resource.
<a class="reference external" href="http://mathworld.wolfram.com/CauchyDistribution.html">http://mathworld.wolfram.com/CauchyDistribution.html</a></p>
</dd>
<dt class="label" id="r47ee0e8a4f4f-3"><span class="brackets"><a class="fn-backref" href="#id91">3</a></span></dt>
<dd><p>Wikipedia, “Cauchy distribution”
<a class="reference external" href="https://en.wikipedia.org/wiki/Cauchy_distribution">https://en.wikipedia.org/wiki/Cauchy_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples and plot the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_cauchy</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[(</span><span class="n">s</span><span class="o">&gt;-</span><span class="mi">25</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">s</span><span class="o">&lt;</span><span class="mi">25</span><span class="p">)]</span>  <span class="c1"># truncate distribution so it plots well  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.standard_exponential">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">standard_exponential</code><span class="sig-paren">(</span><em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.standard_exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.standard_exponential.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from the standard exponential distribution.</p>
<p><cite>standard_exponential</cite> is identical to the exponential distribution
with a scale parameter of 1.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">standard_exponential</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  Default is None, in which case a
single value is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">float or ndarray</span></dt><dd><p>Drawn samples.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.standard_exponential</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Output a 3x8000 array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_exponential</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.standard_gamma">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">standard_gamma</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.standard_gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.standard_gamma.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a standard Gamma distribution.</p>
<p>Samples are drawn from a Gamma distribution with specified parameters,
shape (sometimes designated “k”) and scale=1.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">standard_gamma</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Parameter, must be non-negative.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">shape</span></code> is a scalar.  Otherwise,
<code class="docutils literal notranslate"><span class="pre">np.array(shape).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized standard gamma distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.gamma</span></code></dt><dd><p>probability density function, distribution or cumulative density function, etc.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.standard_gamma</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density for the Gamma distribution is</p>
<div class="math notranslate nohighlight">
\[p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},\]</div>
<p>where <span class="math notranslate nohighlight">\(k\)</span> is the shape and <span class="math notranslate nohighlight">\(\theta\)</span> the scale,
and <span class="math notranslate nohighlight">\(\Gamma\)</span> is the Gamma function.</p>
<p>The Gamma distribution is often used to model the times to failure of
electronic components, and arises naturally in processes for which the
waiting times between Poisson distributed events are relevant.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r3da21ab12790-1"><span class="brackets"><a class="fn-backref" href="#id92">1</a></span></dt>
<dd><p>Weisstein, Eric W. “Gamma Distribution.” From MathWorld–A
Wolfram Web Resource.
<a class="reference external" href="http://mathworld.wolfram.com/GammaDistribution.html">http://mathworld.wolfram.com/GammaDistribution.html</a></p>
</dd>
<dt class="label" id="r3da21ab12790-2"><span class="brackets"><a class="fn-backref" href="#id93">2</a></span></dt>
<dd><p>Wikipedia, “Gamma distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Gamma_distribution">https://en.wikipedia.org/wiki/Gamma_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span> <span class="c1"># mean and width  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_gamma</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span>  
</pre></div>
</div>
<p>Display the histogram of the samples, along with
the probability density function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">sps</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bins</span><span class="o">**</span><span class="p">(</span><span class="n">shape</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">bins</span><span class="o">/</span><span class="n">scale</span><span class="p">))</span><span class="o">/</span>  
<span class="gp">... </span>                      <span class="p">(</span><span class="n">sps</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span><span class="o">**</span><span class="n">shape</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.standard_normal">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">standard_normal</code><span class="sig-paren">(</span><em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.standard_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.standard_normal.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a standard Normal distribution (mean=0, stdev=1).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">standard_normal</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  Default is None, in which case a
single value is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">float or ndarray</span></dt><dd><p>A floating-point array of shape <code class="docutils literal notranslate"><span class="pre">size</span></code> of drawn samples, or a
single sample if <code class="docutils literal notranslate"><span class="pre">size</span></code> was not specified.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.random.normal" title="dask.array.random.normal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normal</span></code></a></dt><dd><p>Equivalent function with additional <code class="docutils literal notranslate"><span class="pre">loc</span></code> and <code class="docutils literal notranslate"><span class="pre">scale</span></code> arguments for setting the mean and standard deviation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.standard_normal</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For random samples from <span class="math notranslate nohighlight">\(N(\mu, \sigma^2)\)</span>, use one of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mu</span> <span class="o">+</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">size</span><span class="o">=...</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">size</span><span class="o">=...</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">()</span>  
<span class="go">2.1923875335537315 #random</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="mi">8000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">array([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random</span>
<span class="go">       -0.38672696, -0.4685006 ])                                # random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(8000,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(3, 4, 2)</span>
</pre></div>
</div>
<p>Two-by-four array of samples from <span class="math notranslate nohighlight">\(N(3, 6.25)\)</span>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="o">+</span> <span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>  
<span class="go">array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random</span>
<span class="go">       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.standard_t">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">standard_t</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.standard_t" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.standard_t.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a standard Student’s t distribution with <cite>df</cite> degrees
of freedom.</p>
<p>A special case of the hyperbolic distribution.  As <cite>df</cite> gets
large, the result resembles that of the standard normal
distribution (<cite>standard_normal</cite>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">standard_t</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Degrees of freedom, must be &gt; 0.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">df</span></code> is a scalar.  Otherwise,
<code class="docutils literal notranslate"><span class="pre">np.array(df).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized standard Student’s t distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.standard_t</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density function for the t distribution is</p>
<div class="math notranslate nohighlight">
\[P(x, df) = \frac{\Gamma(\frac{df+1}{2})}{\sqrt{\pi df}
\Gamma(\frac{df}{2})}\Bigl( 1+\frac{x^2}{df} \Bigr)^{-(df+1)/2}\]</div>
<p>The t test is based on an assumption that the data come from a
Normal distribution. The t test provides a way to test whether
the sample mean (that is the mean calculated from the data) is
a good estimate of the true mean.</p>
<p>The derivation of the t-distribution was first published in
1908 by William Gosset while working for the Guinness Brewery
in Dublin. Due to proprietary issues, he had to publish under
a pseudonym, and so he used the name Student.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf4c55e723b8f-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id94">1</a>,<a href="#id96">2</a>)</span></dt>
<dd><p>Dalgaard, Peter, “Introductory Statistics With R”,
Springer, 2002.</p>
</dd>
<dt class="label" id="rf4c55e723b8f-2"><span class="brackets"><a class="fn-backref" href="#id95">2</a></span></dt>
<dd><p>Wikipedia, “Student’s t-distribution”
<a class="reference external" href="https://en.wikipedia.org/wiki/Student's_t-distribution">https://en.wikipedia.org/wiki/Student’s_t-distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>From Dalgaard page 83 <a class="reference internal" href="#rf4c55e723b8f-1" id="id96">[1]</a>, suppose the daily energy intake for 11
women in kilojoules (kJ) is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">intake</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">5260.</span><span class="p">,</span> <span class="mi">5470</span><span class="p">,</span> <span class="mi">5640</span><span class="p">,</span> <span class="mi">6180</span><span class="p">,</span> <span class="mi">6390</span><span class="p">,</span> <span class="mi">6515</span><span class="p">,</span> <span class="mi">6805</span><span class="p">,</span> <span class="mi">7515</span><span class="p">,</span> \  
<span class="gp">... </span>                   <span class="mi">7515</span><span class="p">,</span> <span class="mi">8230</span><span class="p">,</span> <span class="mi">8770</span><span class="p">])</span>
</pre></div>
</div>
<p>Does their energy intake deviate systematically from the recommended
value of 7725 kJ?</p>
<p>We have 10 degrees of freedom, so is the sample mean within 95% of the
recommended value?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_t</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">intake</span><span class="p">)</span>  
<span class="go">6753.636363636364</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intake</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">1142.1232221373727</span>
</pre></div>
</div>
<p>Calculate the t statistic, setting the ddof parameter to the unbiased
value so the divisor in the standard deviation will be degrees of
freedom, N-1.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">intake</span><span class="p">)</span><span class="o">-</span><span class="mi">7725</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">intake</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intake</span><span class="p">)))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
</pre></div>
</div>
<p>For a one-sided t-test, how far out in the distribution does the t
statistic appear?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">s</span><span class="o">&lt;</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>  
<span class="go">0.0090699999999999999  #random</span>
</pre></div>
</div>
<p>So the p-value is about 0.009, which says the null hypothesis has a
probability of about 99% of being true.</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.triangular">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">triangular</code><span class="sig-paren">(</span><em class="sig-param">left</em>, <em class="sig-param">mode</em>, <em class="sig-param">right</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.triangular" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.triangular.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from the triangular distribution over the
interval <code class="docutils literal notranslate"><span class="pre">[left,</span> <span class="pre">right]</span></code>.</p>
<p>The triangular distribution is a continuous probability
distribution with lower limit left, peak at mode, and upper
limit right. Unlike the other distributions, these parameters
directly define the shape of the pdf.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">triangular</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>left</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Lower limit.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>The value where the peak of the distribution occurs.
The value must fulfill the condition <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">&lt;=</span> <span class="pre">mode</span> <span class="pre">&lt;=</span> <span class="pre">right</span></code>.</p>
</dd>
<dt><strong>right</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Upper limit, must be larger than <cite>left</cite>.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">left</span></code>, <code class="docutils literal notranslate"><span class="pre">mode</span></code>, and <code class="docutils literal notranslate"><span class="pre">right</span></code>
are all scalars.  Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(left,</span> <span class="pre">mode,</span> <span class="pre">right).size</span></code>
samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized triangular distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.triangular</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density function for the triangular distribution is</p>
<div class="math notranslate nohighlight">
\[\begin{split}P(x;l, m, r) = \begin{cases}
\frac{2(x-l)}{(r-l)(m-l)}&amp; \text{for $l \leq x \leq m$},\\
\frac{2(r-x)}{(r-l)(r-m)}&amp; \text{for $m \leq x \leq r$},\\
0&amp; \text{otherwise}.
\end{cases}\end{split}\]</div>
<p>The triangular distribution is often used in ill-defined
problems where the underlying distribution is not known, but
some knowledge of the limits and mode exists. Often it is used
in simulations.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd22b0bd42f87-1"><span class="brackets"><a class="fn-backref" href="#id97">1</a></span></dt>
<dd><p>Wikipedia, “Triangular distribution”
<a class="reference external" href="https://en.wikipedia.org/wiki/Triangular_distribution">https://en.wikipedia.org/wiki/Triangular_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw values from the distribution and plot the histogram:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">triangular</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">100000</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>  
<span class="gp">... </span>             <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.uniform">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">uniform</code><span class="sig-paren">(</span><em class="sig-param">low=0.0</em>, <em class="sig-param">high=1.0</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.uniform.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a uniform distribution.</p>
<p>Samples are uniformly distributed over the half-open interval
<code class="docutils literal notranslate"><span class="pre">[low,</span> <span class="pre">high)</span></code> (includes low, but excludes high).  In other words,
any value within the given interval is equally likely to be drawn
by <cite>uniform</cite>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">uniform</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>low</strong><span class="classifier">float or array_like of floats, optional</span></dt><dd><p>Lower boundary of the output interval.  All values generated will be
greater than or equal to low.  The default value is 0.</p>
</dd>
<dt><strong>high</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Upper boundary of the output interval.  All values generated will be
less than high.  The default value is 1.0.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">low</span></code> and <code class="docutils literal notranslate"><span class="pre">high</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(low,</span> <span class="pre">high).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized uniform distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.random.randint" title="dask.array.random.randint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">randint</span></code></a></dt><dd><p>Discrete uniform distribution, yielding integers.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_integers</span></code></dt><dd><p>Discrete uniform distribution over the closed interval <code class="docutils literal notranslate"><span class="pre">[low,</span> <span class="pre">high]</span></code>.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.random.random_sample" title="dask.array.random.random_sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_sample</span></code></a></dt><dd><p>Floats uniformly distributed over <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1)</span></code>.</p>
</dd>
<dt><a class="reference internal" href="#dask.array.random.random" title="dask.array.random.random"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random</span></code></a></dt><dd><p>Alias for <cite>random_sample</cite>.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">rand</span></code></dt><dd><p>Convenience function that accepts dimensions as input, e.g., <code class="docutils literal notranslate"><span class="pre">rand(2,2)</span></code> would generate a 2-by-2 array of floats, uniformly distributed over <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1)</span></code>.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.uniform</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density function of the uniform distribution is</p>
<div class="math notranslate nohighlight">
\[p(x) = \frac{1}{b - a}\]</div>
<p>anywhere within the interval <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b)</span></code>, and zero elsewhere.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">high</span></code> == <code class="docutils literal notranslate"><span class="pre">low</span></code>, values of <code class="docutils literal notranslate"><span class="pre">low</span></code> will be returned.
If <code class="docutils literal notranslate"><span class="pre">high</span></code> &lt; <code class="docutils literal notranslate"><span class="pre">low</span></code>, the results are officially undefined
and may eventually raise an error, i.e. do not rely on this
function to behave when passed arguments satisfying that
inequality condition.</p>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>  
</pre></div>
</div>
<p>All values are within the given interval:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>  
<span class="go">True</span>
</pre></div>
</div>
<p>Display the histogram of the samples, along with the
probability density function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">bins</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.vonmises">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">vonmises</code><span class="sig-paren">(</span><em class="sig-param">mu</em>, <em class="sig-param">kappa</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.vonmises" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.vonmises.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a von Mises distribution.</p>
<p>Samples are drawn from a von Mises distribution with specified mode
(mu) and dispersion (kappa), on the interval [-pi, pi].</p>
<p>The von Mises distribution (also known as the circular normal
distribution) is a continuous probability distribution on the unit
circle.  It may be thought of as the circular analogue of the normal
distribution.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">vonmises</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mu</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Mode (“center”) of the distribution.</p>
</dd>
<dt><strong>kappa</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Dispersion of the distribution, has to be &gt;=0.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">mu</span></code> and <code class="docutils literal notranslate"><span class="pre">kappa</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(mu,</span> <span class="pre">kappa).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized von Mises distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.vonmises</span></code></dt><dd><p>probability density function, distribution, or cumulative density function, etc.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.vonmises</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density for the von Mises distribution is</p>
<div class="math notranslate nohighlight">
\[p(x) = \frac{e^{\kappa cos(x-\mu)}}{2\pi I_0(\kappa)},\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu\)</span> is the mode and <span class="math notranslate nohighlight">\(\kappa\)</span> the dispersion,
and <span class="math notranslate nohighlight">\(I_0(\kappa)\)</span> is the modified Bessel function of order 0.</p>
<p>The von Mises is named for Richard Edler von Mises, who was born in
Austria-Hungary, in what is now the Ukraine.  He fled to the United
States in 1939 and became a professor at Harvard.  He worked in
probability theory, aerodynamics, fluid mechanics, and philosophy of
science.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf7bb34de95c1-1"><span class="brackets"><a class="fn-backref" href="#id98">1</a></span></dt>
<dd><p>Abramowitz, M. and Stegun, I. A. (Eds.). “Handbook of
Mathematical Functions with Formulas, Graphs, and Mathematical
Tables, 9th printing,” New York: Dover, 1972.</p>
</dd>
<dt class="label" id="rf7bb34de95c1-2"><span class="brackets"><a class="fn-backref" href="#id99">2</a></span></dt>
<dd><p>von Mises, R., “Mathematical Theory of Probability
and Statistics”, New York: Academic Press, 1964.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">4.0</span> <span class="c1"># mean and dispersion  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">vonmises</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  
</pre></div>
</div>
<p>Display the histogram of the samples, along with
the probability density function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">i0</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">51</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">kappa</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mu</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">i0</span><span class="p">(</span><span class="n">kappa</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.wald">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">wald</code><span class="sig-paren">(</span><em class="sig-param">mean</em>, <em class="sig-param">scale</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.wald" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.wald.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a Wald, or inverse Gaussian, distribution.</p>
<p>As the scale approaches infinity, the distribution becomes more like a
Gaussian. Some references claim that the Wald is an inverse Gaussian
with mean equal to 1, but this is by no means universal.</p>
<p>The inverse Gaussian distribution was first studied in relationship to
Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian
because there is an inverse relationship between the time to cover a
unit distance and distance covered in unit time.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">wald</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mean</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Distribution mean, must be &gt; 0.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Scale parameter, must be &gt; 0.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">mean</span></code> and <code class="docutils literal notranslate"><span class="pre">scale</span></code> are both scalars.
Otherwise, <code class="docutils literal notranslate"><span class="pre">np.broadcast(mean,</span> <span class="pre">scale).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized Wald distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.wald</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The probability density function for the Wald distribution is</p>
<div class="math notranslate nohighlight">
\[P(x;mean,scale) = \sqrt{\frac{scale}{2\pi x^3}}e^
\frac{-scale(x-mean)^2}{2\cdotp mean^2x}\]</div>
<p>As noted above the inverse Gaussian distribution first arise
from attempts to model Brownian motion. It is also a
competitor to the Weibull for use in reliability modeling and
modeling stock returns and interest rate processes.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="raf4feca2cdcb-1"><span class="brackets"><a class="fn-backref" href="#id100">1</a></span></dt>
<dd><p>Brighton Webs Ltd., Wald Distribution,
<a class="reference external" href="https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp">https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp</a></p>
</dd>
<dt class="label" id="raf4feca2cdcb-2"><span class="brackets"><a class="fn-backref" href="#id101">2</a></span></dt>
<dd><p>Chhikara, Raj S., and Folks, J. Leroy, “The Inverse Gaussian
Distribution: Theory : Methodology, and Applications”, CRC Press,
1988.</p>
</dd>
<dt class="label" id="raf4feca2cdcb-3"><span class="brackets"><a class="fn-backref" href="#id102">3</a></span></dt>
<dd><p>Wikipedia, “Inverse Gaussian distribution”
<a class="reference external" href="https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution">https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw values from the distribution and plot the histogram:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">wald</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100000</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.weibull">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">weibull</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.weibull" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.random.mtrand.RandomState.weibull.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Draw samples from a Weibull distribution.</p>
<p>Draw samples from a 1-parameter Weibull distribution with the given
shape parameter <cite>a</cite>.</p>
<div class="math notranslate nohighlight">
\[X = (-ln(U))^{1/a}\]</div>
<p>Here, U is drawn from the uniform distribution over (0,1].</p>
<p>The more common 2-parameter Weibull, including a scale parameter
<span class="math notranslate nohighlight">\(\lambda\)</span> is just <span class="math notranslate nohighlight">\(X = \lambda(-ln(U))^{1/a}\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code class="docutils literal notranslate"><span class="pre">weibull</span></code> method of a <code class="docutils literal notranslate"><span class="pre">default_rng()</span></code>
instance instead; see <cite>random-quick-start</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">float or array_like of floats</span></dt><dd><p>Shape parameter of the distribution.  Must be nonnegative.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  If size is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default),
a single value is returned if <code class="docutils literal notranslate"><span class="pre">a</span></code> is a scalar.  Otherwise,
<code class="docutils literal notranslate"><span class="pre">np.array(a).size</span></code> samples are drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray or scalar</span></dt><dd><p>Drawn samples from the parameterized Weibull distribution.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.weibull_max</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.weibull_min</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.genextreme</span></code>, <a class="reference internal" href="#dask.array.random.gumbel" title="dask.array.random.gumbel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gumbel</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Generator.weibull</span></code></dt><dd><p>which should be used for new code.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The Weibull (or Type III asymptotic extreme value distribution
for smallest values, SEV Type III, or Rosin-Rammler
distribution) is one of a class of Generalized Extreme Value
(GEV) distributions used in modeling extreme value problems.
This class includes the Gumbel and Frechet distributions.</p>
<p>The probability density for the Weibull distribution is</p>
<div class="math notranslate nohighlight">
\[p(x) = \frac{a}
{\lambda}(\frac{x}{\lambda})^{a-1}e^{-(x/\lambda)^a},\]</div>
<p>where <span class="math notranslate nohighlight">\(a\)</span> is the shape and <span class="math notranslate nohighlight">\(\lambda\)</span> the scale.</p>
<p>The function has its peak (the mode) at
<span class="math notranslate nohighlight">\(\lambda(\frac{a-1}{a})^{1/a}\)</span>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1</span></code>, the Weibull distribution reduces to the exponential
distribution.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r47d454931768-1"><span class="brackets"><a class="fn-backref" href="#id103">1</a></span></dt>
<dd><p>Waloddi Weibull, Royal Technical University, Stockholm,
1939 “A Statistical Theory Of The Strength Of Materials”,
Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939,
Generalstabens Litografiska Anstalts Forlag, Stockholm.</p>
</dd>
<dt class="label" id="r47d454931768-2"><span class="brackets"><a class="fn-backref" href="#id104">2</a></span></dt>
<dd><p>Waloddi Weibull, “A Statistical Distribution Function of
Wide Applicability”, Journal Of Applied Mechanics ASME Paper
1951.</p>
</dd>
<dt class="label" id="r47d454931768-3"><span class="brackets"><a class="fn-backref" href="#id105">3</a></span></dt>
<dd><p>Wikipedia, “Weibull distribution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Weibull_distribution">https://en.wikipedia.org/wiki/Weibull_distribution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Draw samples from the distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">5.</span> <span class="c1"># shape  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">weibull</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  
</pre></div>
</div>
<p>Display the histogram of the samples, along with
the probability density function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">100.</span><span class="p">)</span><span class="o">/</span><span class="mf">50.</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">weib</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">a</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span><span class="o">**</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">weibull</span><span class="p">(</span><span class="mf">5.</span><span class="p">,</span><span class="mi">1000</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">100.</span><span class="p">)</span><span class="o">/</span><span class="mf">50.</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">/</span><span class="n">weib</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">weib</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.random.zipf">
<code class="sig-prename descclassname">dask.array.random.</code><code class="sig-name descname">zipf</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.random.zipf" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard distributions</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.stats.ttest_ind">
<code class="sig-prename descclassname">dask.array.stats.</code><code class="sig-name descname">ttest_ind</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">equal_var=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.stats.ttest_ind" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the T-test for the means of <em>two independent</em> samples of scores.</p>
<p>This docstring was copied from scipy.stats.ttest_ind.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This is a two-sided test for the null hypothesis that 2 independent samples
have identical average (expected) values. This test assumes that the
populations have identical variances by default.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a, b</strong><span class="classifier">array_like</span></dt><dd><p>The arrays must have the same shape, except in the dimension
corresponding to <cite>axis</cite> (the first, by default).</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>Axis along which to compute test. If None, compute over the whole
arrays, <cite>a</cite>, and <cite>b</cite>.</p>
</dd>
<dt><strong>equal_var</strong><span class="classifier">bool, optional</span></dt><dd><p>If True (default), perform a standard independent 2 sample test
that assumes equal population variances <a class="reference internal" href="#rc139d793e52e-1" id="id106">[1]</a>.
If False, perform Welch’s t-test, which does not assume equal
population variance <a class="reference internal" href="#rc139d793e52e-2" id="id107">[2]</a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.11.0.</span></p>
</div>
</dd>
<dt><strong>nan_policy</strong><span class="classifier">{‘propagate’, ‘raise’, ‘omit’}, optional  (Not supported in Dask)</span></dt><dd><p>Defines how to handle when input contains nan.
The following options are available (default is ‘propagate’):</p>
<blockquote>
<div><ul class="simple">
<li><p>‘propagate’: returns nan</p></li>
<li><p>‘raise’: throws an error</p></li>
<li><p>‘omit’: performs the calculations ignoring nan values</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>statistic</strong><span class="classifier">float or array</span></dt><dd><p>The calculated t-statistic.</p>
</dd>
<dt><strong>pvalue</strong><span class="classifier">float or array</span></dt><dd><p>The two-tailed p-value.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We can use this test, if we observe two independent samples from
the same or different population, e.g. exam scores of boys and
girls or of two ethnic groups. The test measures whether the
average (expected) value differs significantly across samples. If
we observe a large p-value, for example larger than 0.05 or 0.1,
then we cannot reject the null hypothesis of identical average scores.
If the p-value is smaller than the threshold, e.g. 1%, 5% or 10%,
then we reject the null hypothesis of equal averages.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc139d793e52e-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id106">1</a>,<a href="#id108">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test">https://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test</a></p>
</dd>
<dt class="label" id="rc139d793e52e-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id107">1</a>,<a href="#id109">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Welch%27s_t-test">https://en.wikipedia.org/wiki/Welch%27s_t-test</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">12345678</span><span class="p">)</span>  
</pre></div>
</div>
<p>Test with sample with identical means:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rvs1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">rvs2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_ind</span><span class="p">(</span><span class="n">rvs1</span><span class="p">,</span><span class="n">rvs2</span><span class="p">)</span>  
<span class="go">(0.26833823296239279, 0.78849443369564776)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_ind</span><span class="p">(</span><span class="n">rvs1</span><span class="p">,</span><span class="n">rvs2</span><span class="p">,</span> <span class="n">equal_var</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>  
<span class="go">(0.26833823296239279, 0.78849452749500748)</span>
</pre></div>
</div>
<p><cite>ttest_ind</cite> underestimates p for unequal variances:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rvs3</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_ind</span><span class="p">(</span><span class="n">rvs1</span><span class="p">,</span> <span class="n">rvs3</span><span class="p">)</span>  
<span class="go">(-0.46580283298287162, 0.64145827413436174)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_ind</span><span class="p">(</span><span class="n">rvs1</span><span class="p">,</span> <span class="n">rvs3</span><span class="p">,</span> <span class="n">equal_var</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>  
<span class="go">(-0.46580283298287162, 0.64149646246569292)</span>
</pre></div>
</div>
<p>When n1 != n2, the equal variance t-statistic is no longer equal to the
unequal variance t-statistic:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rvs4</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_ind</span><span class="p">(</span><span class="n">rvs1</span><span class="p">,</span> <span class="n">rvs4</span><span class="p">)</span>  
<span class="go">(-0.99882539442782481, 0.3182832709103896)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_ind</span><span class="p">(</span><span class="n">rvs1</span><span class="p">,</span> <span class="n">rvs4</span><span class="p">,</span> <span class="n">equal_var</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>  
<span class="go">(-0.69712570584654099, 0.48716927725402048)</span>
</pre></div>
</div>
<p>T-test with different means, variance, and n:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rvs5</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_ind</span><span class="p">(</span><span class="n">rvs1</span><span class="p">,</span> <span class="n">rvs5</span><span class="p">)</span>  
<span class="go">(-1.4679669854490653, 0.14263895620529152)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_ind</span><span class="p">(</span><span class="n">rvs1</span><span class="p">,</span> <span class="n">rvs5</span><span class="p">,</span> <span class="n">equal_var</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>  
<span class="go">(-0.94365973617132992, 0.34744170334794122)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.stats.ttest_1samp">
<code class="sig-prename descclassname">dask.array.stats.</code><code class="sig-name descname">ttest_1samp</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">popmean</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">nan_policy='propagate'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.stats.ttest_1samp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the T-test for the mean of ONE group of scores.</p>
<p>This docstring was copied from scipy.stats.ttest_1samp.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This is a two-sided test for the null hypothesis that the expected value
(mean) of a sample of independent observations <cite>a</cite> is equal to the given
population mean, <cite>popmean</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Sample observation.</p>
</dd>
<dt><strong>popmean</strong><span class="classifier">float or array_like</span></dt><dd><p>Expected value in null hypothesis. If array_like, then it must have the
same shape as <cite>a</cite> excluding the axis dimension.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>Axis along which to compute test. If None, compute over the whole
array <cite>a</cite>.</p>
</dd>
<dt><strong>nan_policy</strong><span class="classifier">{‘propagate’, ‘raise’, ‘omit’}, optional</span></dt><dd><p>Defines how to handle when input contains nan.
The following options are available (default is ‘propagate’):</p>
<blockquote>
<div><ul class="simple">
<li><p>‘propagate’: returns nan</p></li>
<li><p>‘raise’: throws an error</p></li>
<li><p>‘omit’: performs the calculations ignoring nan values</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>statistic</strong><span class="classifier">float or array</span></dt><dd><p>t-statistic.</p>
</dd>
<dt><strong>pvalue</strong><span class="classifier">float or array</span></dt><dd><p>Two-sided p-value.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">7654567</span><span class="p">)</span>  <span class="c1"># fix seed to get the same result  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rvs</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  
</pre></div>
</div>
<p>Test if mean of random sample is equal to true mean, and different mean.
We reject the null hypothesis in the second case and don’t reject it in
the first case.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_1samp</span><span class="p">(</span><span class="n">rvs</span><span class="p">,</span><span class="mf">5.0</span><span class="p">)</span>  
<span class="go">(array([-0.68014479, -0.04323899]), array([ 0.49961383,  0.96568674]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_1samp</span><span class="p">(</span><span class="n">rvs</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>  
<span class="go">(array([ 2.77025808,  4.11038784]), array([ 0.00789095,  0.00014999]))</span>
</pre></div>
</div>
<p>Examples using axis and non-scalar dimension for population mean.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_1samp</span><span class="p">(</span><span class="n">rvs</span><span class="p">,[</span><span class="mf">5.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">])</span>  
<span class="go">(array([-0.68014479,  4.11038784]), array([  4.99613833e-01,   1.49986458e-04]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_1samp</span><span class="p">(</span><span class="n">rvs</span><span class="o">.</span><span class="n">T</span><span class="p">,[</span><span class="mf">5.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">(array([-0.68014479,  4.11038784]), array([  4.99613833e-01,   1.49986458e-04]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_1samp</span><span class="p">(</span><span class="n">rvs</span><span class="p">,[[</span><span class="mf">5.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">]])</span>  
<span class="go">(array([[-0.68014479, -0.04323899],</span>
<span class="go">       [ 2.77025808,  4.11038784]]), array([[  4.99613833e-01,   9.65686743e-01],</span>
<span class="go">       [  7.89094663e-03,   1.49986458e-04]]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.stats.ttest_rel">
<code class="sig-prename descclassname">dask.array.stats.</code><code class="sig-name descname">ttest_rel</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">nan_policy='propagate'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.stats.ttest_rel" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the t-test on TWO RELATED samples of scores, a and b.</p>
<p>This docstring was copied from scipy.stats.ttest_rel.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This is a two-sided test for the null hypothesis that 2 related or
repeated samples have identical average (expected) values.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a, b</strong><span class="classifier">array_like</span></dt><dd><p>The arrays must have the same shape.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>Axis along which to compute test. If None, compute over the whole
arrays, <cite>a</cite>, and <cite>b</cite>.</p>
</dd>
<dt><strong>nan_policy</strong><span class="classifier">{‘propagate’, ‘raise’, ‘omit’}, optional</span></dt><dd><p>Defines how to handle when input contains nan.
The following options are available (default is ‘propagate’):</p>
<blockquote>
<div><ul class="simple">
<li><p>‘propagate’: returns nan</p></li>
<li><p>‘raise’: throws an error</p></li>
<li><p>‘omit’: performs the calculations ignoring nan values</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>statistic</strong><span class="classifier">float or array</span></dt><dd><p>t-statistic.</p>
</dd>
<dt><strong>pvalue</strong><span class="classifier">float or array</span></dt><dd><p>Two-sided p-value.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Examples for use are scores of the same set of student in
different exams, or repeated sampling from the same units. The
test measures whether the average score differs significantly
across samples (e.g. exams). If we observe a large p-value, for
example greater than 0.05 or 0.1 then we cannot reject the null
hypothesis of identical average scores. If the p-value is smaller
than the threshold, e.g. 1%, 5% or 10%, then we reject the null
hypothesis of equal averages. Small p-values are associated with
large t-statistics.</p>
<p class="rubric">References</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/T-test#Dependent_t-test_for_paired_samples">https://en.wikipedia.org/wiki/T-test#Dependent_t-test_for_paired_samples</a></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">12345678</span><span class="p">)</span> <span class="c1"># fix random seed to get same numbers  </span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rvs1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">rvs2</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span> <span class="o">+</span>  
<span class="gp">... </span>        <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_rel</span><span class="p">(</span><span class="n">rvs1</span><span class="p">,</span><span class="n">rvs2</span><span class="p">)</span>  
<span class="go">(0.24101764965300962, 0.80964043445811562)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rvs3</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span> <span class="o">+</span>  
<span class="gp">... </span>        <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_rel</span><span class="p">(</span><span class="n">rvs1</span><span class="p">,</span><span class="n">rvs3</span><span class="p">)</span>  
<span class="go">(-3.9995108708727933, 7.3082402191726459e-005)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.stats.chisquare">
<code class="sig-prename descclassname">dask.array.stats.</code><code class="sig-name descname">chisquare</code><span class="sig-paren">(</span><em class="sig-param">f_obs</em>, <em class="sig-param">f_exp=None</em>, <em class="sig-param">ddof=0</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.stats.chisquare" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a one-way chi-square test.</p>
<p>This docstring was copied from scipy.stats.chisquare.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The chi-square test tests the null hypothesis that the categorical data
has the given frequencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f_obs</strong><span class="classifier">array_like</span></dt><dd><p>Observed frequencies in each category.</p>
</dd>
<dt><strong>f_exp</strong><span class="classifier">array_like, optional</span></dt><dd><p>Expected frequencies in each category.  By default the categories are
assumed to be equally likely.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, optional</span></dt><dd><p>“Delta degrees of freedom”: adjustment to the degrees of freedom
for the p-value.  The p-value is computed using a chi-squared
distribution with <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">-</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">ddof</span></code> degrees of freedom, where <cite>k</cite>
is the number of observed frequencies.  The default value of <cite>ddof</cite>
is 0.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>The axis of the broadcast result of <cite>f_obs</cite> and <cite>f_exp</cite> along which to
apply the test.  If axis is None, all values in <cite>f_obs</cite> are treated
as a single data set.  Default is 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>chisq</strong><span class="classifier">float or ndarray</span></dt><dd><p>The chi-squared test statistic.  The value is a float if <cite>axis</cite> is
None or <cite>f_obs</cite> and <cite>f_exp</cite> are 1-D.</p>
</dd>
<dt><strong>p</strong><span class="classifier">float or ndarray</span></dt><dd><p>The p-value of the test.  The value is a float if <cite>ddof</cite> and the
return value <cite>chisq</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.power_divergence</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This test is invalid when the observed or expected frequencies in each
category are too small.  A typical rule is that all of the observed
and expected frequencies should be at least 5.</p>
<p>The default degrees of freedom, k-1, are for the case when no parameters
of the distribution are estimated. If p parameters are estimated by
efficient maximum likelihood then the correct degrees of freedom are
k-1-p. If the parameters are estimated in a different way, then the
dof can be between k-1-p and k-1. However, it is also possible that
the asymptotic distribution is not chi-square, in which case this test
is not appropriate.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r61559b4de06f-1"><span class="brackets"><a class="fn-backref" href="#id110">1</a></span></dt>
<dd><p>Lowry, Richard.  “Concepts and Applications of Inferential
Statistics”. Chapter 8.
<a class="reference external" href="https://web.archive.org/web/20171022032306/http://vassarstats.net:80/textbook/ch8pt1.html">https://web.archive.org/web/20171022032306/http://vassarstats.net:80/textbook/ch8pt1.html</a></p>
</dd>
<dt class="label" id="r61559b4de06f-2"><span class="brackets"><a class="fn-backref" href="#id111">2</a></span></dt>
<dd><p>“Chi-squared test”, <a class="reference external" href="https://en.wikipedia.org/wiki/Chi-squared_test">https://en.wikipedia.org/wiki/Chi-squared_test</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>When just <cite>f_obs</cite> is given, it is assumed that the expected frequencies
are uniform and given by the mean of the observed frequencies.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">chisquare</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">chisquare</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>  
<span class="go">(2.0, 0.84914503608460956)</span>
</pre></div>
</div>
<p>With <cite>f_exp</cite> the expected frequencies can be given.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chisquare</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">f_exp</span><span class="o">=</span><span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>  
<span class="go">(3.5, 0.62338762774958223)</span>
</pre></div>
</div>
<p>When <cite>f_obs</cite> is 2-D, by default the test is applied to each column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="p">[</span><span class="mi">32</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">24</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(6, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chisquare</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>  
<span class="go">(array([ 2.        ,  6.66666667]), array([ 0.84914504,  0.24663415]))</span>
</pre></div>
</div>
<p>By setting <code class="docutils literal notranslate"><span class="pre">axis=None</span></code>, the test is applied to all data in the array,
which is equivalent to applying the test to the flattened array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chisquare</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  
<span class="go">(23.31034482758621, 0.015975692534127565)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chisquare</span><span class="p">(</span><span class="n">obs</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>  
<span class="go">(23.31034482758621, 0.015975692534127565)</span>
</pre></div>
</div>
<p><cite>ddof</cite> is the change to make to the default degrees of freedom.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chisquare</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">(2.0, 0.73575888234288467)</span>
</pre></div>
</div>
<p>The calculation of the p-values is done by broadcasting the
chi-squared statistic with <cite>ddof</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chisquare</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">ddof</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>  
<span class="go">(2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))</span>
</pre></div>
</div>
<p><cite>f_obs</cite> and <cite>f_exp</cite> are also broadcast.  In the following, <cite>f_obs</cite> has
shape (6,) and <cite>f_exp</cite> has shape (2, 6), so the result of broadcasting
<cite>f_obs</cite> and <cite>f_exp</cite> has shape (2, 6).  To compute the desired chi-squared
statistics, we use <code class="docutils literal notranslate"><span class="pre">axis=1</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chisquare</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>  
<span class="gp">... </span>          <span class="n">f_exp</span><span class="o">=</span><span class="p">[[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">]],</span>
<span class="gp">... </span>          <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.stats.power_divergence">
<code class="sig-prename descclassname">dask.array.stats.</code><code class="sig-name descname">power_divergence</code><span class="sig-paren">(</span><em class="sig-param">f_obs</em>, <em class="sig-param">f_exp=None</em>, <em class="sig-param">ddof=0</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">lambda_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.stats.power_divergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Cressie-Read power divergence statistic and goodness of fit test.</p>
<p>This docstring was copied from scipy.stats.power_divergence.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This function tests the null hypothesis that the categorical data
has the given frequencies, using the Cressie-Read power divergence
statistic.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_obs</strong><span class="classifier">array_like</span></dt><dd><p>Observed frequencies in each category.</p>
</dd>
<dt><strong>f_exp</strong><span class="classifier">array_like, optional</span></dt><dd><p>Expected frequencies in each category.  By default the categories are
assumed to be equally likely.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, optional</span></dt><dd><p>“Delta degrees of freedom”: adjustment to the degrees of freedom
for the p-value.  The p-value is computed using a chi-squared
distribution with <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">-</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">ddof</span></code> degrees of freedom, where <cite>k</cite>
is the number of observed frequencies.  The default value of <cite>ddof</cite>
is 0.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>The axis of the broadcast result of <cite>f_obs</cite> and <cite>f_exp</cite> along which to
apply the test.  If axis is None, all values in <cite>f_obs</cite> are treated
as a single data set.  Default is 0.</p>
</dd>
<dt><strong>lambda_</strong><span class="classifier">float or str, optional</span></dt><dd><p>The power in the Cressie-Read power divergence statistic.  The default
is 1.  For convenience, <cite>lambda_</cite> may be assigned one of the following
strings, in which case the corresponding numerical value is used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>String              Value   Description
&quot;pearson&quot;             1     Pearson&#39;s chi-squared statistic.
                            In this case, the function is
                            equivalent to `stats.chisquare`.
&quot;log-likelihood&quot;      0     Log-likelihood ratio. Also known as
                            the G-test [R5ed189a69e5c-3]_.
&quot;freeman-tukey&quot;      -1/2   Freeman-Tukey statistic.
&quot;mod-log-likelihood&quot; -1     Modified log-likelihood ratio.
&quot;neyman&quot;             -2     Neyman&#39;s statistic.
&quot;cressie-read&quot;        2/3   The power recommended in [R5ed189a69e5c-5]_.
</pre></div>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>statistic</strong><span class="classifier">float or ndarray</span></dt><dd><p>The Cressie-Read power divergence test statistic.  The value is
a float if <cite>axis</cite> is None or if` <cite>f_obs</cite> and <cite>f_exp</cite> are 1-D.</p>
</dd>
<dt><strong>pvalue</strong><span class="classifier">float or ndarray</span></dt><dd><p>The p-value of the test.  The value is a float if <cite>ddof</cite> and the
return value <cite>stat</cite> are scalars.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.stats.chisquare" title="dask.array.stats.chisquare"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chisquare</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This test is invalid when the observed or expected frequencies in each
category are too small.  A typical rule is that all of the observed
and expected frequencies should be at least 5.</p>
<p>When <cite>lambda_</cite> is less than zero, the formula for the statistic involves
dividing by <cite>f_obs</cite>, so a warning or error may be generated if any value
in <cite>f_obs</cite> is 0.</p>
<p>Similarly, a warning or error may be generated if any value in <cite>f_exp</cite> is
zero when <cite>lambda_</cite> &gt;= 0.</p>
<p>The default degrees of freedom, k-1, are for the case when no parameters
of the distribution are estimated. If p parameters are estimated by
efficient maximum likelihood then the correct degrees of freedom are
k-1-p. If the parameters are estimated in a different way, then the
dof can be between k-1-p and k-1. However, it is also possible that
the asymptotic distribution is not a chisquare, in which case this
test is not appropriate.</p>
<p>This function handles masked arrays.  If an element of <cite>f_obs</cite> or <cite>f_exp</cite>
is masked, then data at that position is ignored, and does not count
towards the size of the data set.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.13.0.</span></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5ed189a69e5c-1"><span class="brackets"><a class="fn-backref" href="#id112">1</a></span></dt>
<dd><p>Lowry, Richard.  “Concepts and Applications of Inferential
Statistics”. Chapter 8.
<a class="reference external" href="https://web.archive.org/web/20171015035606/http://faculty.vassar.edu/lowry/ch8pt1.html">https://web.archive.org/web/20171015035606/http://faculty.vassar.edu/lowry/ch8pt1.html</a></p>
</dd>
<dt class="label" id="r5ed189a69e5c-2"><span class="brackets"><a class="fn-backref" href="#id113">2</a></span></dt>
<dd><p>“Chi-squared test”, <a class="reference external" href="https://en.wikipedia.org/wiki/Chi-squared_test">https://en.wikipedia.org/wiki/Chi-squared_test</a></p>
</dd>
<dt class="label" id="r5ed189a69e5c-3"><span class="brackets"><a class="fn-backref" href="#id114">3</a></span></dt>
<dd><p>“G-test”, <a class="reference external" href="https://en.wikipedia.org/wiki/G-test">https://en.wikipedia.org/wiki/G-test</a></p>
</dd>
<dt class="label" id="r5ed189a69e5c-4"><span class="brackets"><a class="fn-backref" href="#id115">4</a></span></dt>
<dd><p>Sokal, R. R. and Rohlf, F. J. “Biometry: the principles and
practice of statistics in biological research”, New York: Freeman
(1981)</p>
</dd>
<dt class="label" id="r5ed189a69e5c-5"><span class="brackets"><a class="fn-backref" href="#id116">5</a></span></dt>
<dd><p>Cressie, N. and Read, T. R. C., “Multinomial Goodness-of-Fit
Tests”, J. Royal Stat. Soc. Series B, Vol. 46, No. 3 (1984),
pp. 440-464.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>(See <cite>chisquare</cite> for more examples.)</p>
<p>When just <cite>f_obs</cite> is given, it is assumed that the expected frequencies
are uniform and given by the mean of the observed frequencies.  Here we
perform a G-test (i.e. use the log-likelihood ratio statistic):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">power_divergence</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">power_divergence</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">lambda_</span><span class="o">=</span><span class="s1">&#39;log-likelihood&#39;</span><span class="p">)</span>  
<span class="go">(2.006573162632538, 0.84823476779463769)</span>
</pre></div>
</div>
<p>The expected frequencies can be given with the <cite>f_exp</cite> argument:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">power_divergence</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>  
<span class="gp">... </span>                 <span class="n">f_exp</span><span class="o">=</span><span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="n">lambda_</span><span class="o">=</span><span class="s1">&#39;log-likelihood&#39;</span><span class="p">)</span>
<span class="go">(3.3281031458963746, 0.6495419288047497)</span>
</pre></div>
</div>
<p>When <cite>f_obs</cite> is 2-D, by default the test is applied to each column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="p">[</span><span class="mi">32</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">24</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(6, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">power_divergence</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">lambda_</span><span class="o">=</span><span class="s2">&quot;log-likelihood&quot;</span><span class="p">)</span>  
<span class="go">(array([ 2.00657316,  6.77634498]), array([ 0.84823477,  0.23781225]))</span>
</pre></div>
</div>
<p>By setting <code class="docutils literal notranslate"><span class="pre">axis=None</span></code>, the test is applied to all data in the array,
which is equivalent to applying the test to the flattened array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">power_divergence</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  
<span class="go">(23.31034482758621, 0.015975692534127565)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">power_divergence</span><span class="p">(</span><span class="n">obs</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>  
<span class="go">(23.31034482758621, 0.015975692534127565)</span>
</pre></div>
</div>
<p><cite>ddof</cite> is the change to make to the default degrees of freedom.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">power_divergence</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">(2.0, 0.73575888234288467)</span>
</pre></div>
</div>
<p>The calculation of the p-values is done by broadcasting the
test statistic with <cite>ddof</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">power_divergence</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">ddof</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>  
<span class="go">(2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))</span>
</pre></div>
</div>
<p><cite>f_obs</cite> and <cite>f_exp</cite> are also broadcast.  In the following, <cite>f_obs</cite> has
shape (6,) and <cite>f_exp</cite> has shape (2, 6), so the result of broadcasting
<cite>f_obs</cite> and <cite>f_exp</cite> has shape (2, 6).  To compute the desired chi-squared
statistics, we must use <code class="docutils literal notranslate"><span class="pre">axis=1</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">power_divergence</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>  
<span class="gp">... </span>                 <span class="n">f_exp</span><span class="o">=</span><span class="p">[[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">]],</span>
<span class="gp">... </span>                 <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.stats.skew">
<code class="sig-prename descclassname">dask.array.stats.</code><code class="sig-name descname">skew</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">bias=True</em>, <em class="sig-param">nan_policy='propagate'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.stats.skew" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sample skewness of a data set.</p>
<p>This docstring was copied from scipy.stats.skew.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>For normally distributed data, the skewness should be about zero. For
unimodal continuous distributions, a skewness value greater than zero means
that there is more weight in the right tail of the distribution. The
function <cite>skewtest</cite> can be used to determine if the skewness value
is close enough to zero, statistically speaking.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">ndarray</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>Axis along which skewness is calculated. Default is 0.
If None, compute over the whole array <cite>a</cite>.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, then the calculations are corrected for statistical bias.</p>
</dd>
<dt><strong>nan_policy</strong><span class="classifier">{‘propagate’, ‘raise’, ‘omit’}, optional</span></dt><dd><p>Defines how to handle when input contains nan.
The following options are available (default is ‘propagate’):</p>
<blockquote>
<div><ul class="simple">
<li><p>‘propagate’: returns nan</p></li>
<li><p>‘raise’: throws an error</p></li>
<li><p>‘omit’: performs the calculations ignoring nan values</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>skewness</strong><span class="classifier">ndarray</span></dt><dd><p>The skewness of values along an axis, returning 0 where all values are
equal.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The sample skewness is computed as the Fisher-Pearson coefficient
of skewness, i.e.</p>
<div class="math notranslate nohighlight">
\[g_1=\frac{m_3}{m_2^{3/2}}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i\]</div>
<p>is the biased sample <span class="math notranslate nohighlight">\(i\texttt{th}\)</span> central moment, and <span class="math notranslate nohighlight">\(\bar{x}\)</span> is
the sample mean.  If <code class="docutils literal notranslate"><span class="pre">bias</span></code> is False, the calculations are
corrected for bias and the value computed is the adjusted
Fisher-Pearson standardized moment coefficient, i.e.</p>
<div class="math notranslate nohighlight">
\[G_1=\frac{k_3}{k_2^{3/2}}=
    \frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.\]</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re53051c20fe6-1"><span class="brackets"><a class="fn-backref" href="#id117">1</a></span></dt>
<dd><p>Zwillinger, D. and Kokoska, S. (2000). CRC Standard
Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New
York. 2000.
Section 2.2.24.1</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">skew</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">skew</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>  
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skew</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="go">0.2650554122698573</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.stats.skewtest">
<code class="sig-prename descclassname">dask.array.stats.</code><code class="sig-name descname">skewtest</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">nan_policy='propagate'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.stats.skewtest" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the skew is different from the normal distribution.</p>
<p>This docstring was copied from scipy.stats.skewtest.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This function tests the null hypothesis that the skewness of
the population that the sample was drawn from is the same
as that of a corresponding normal distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array</span></dt><dd><p>The data to be tested.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>Axis along which statistics are calculated. Default is 0.
If None, compute over the whole array <cite>a</cite>.</p>
</dd>
<dt><strong>nan_policy</strong><span class="classifier">{‘propagate’, ‘raise’, ‘omit’}, optional</span></dt><dd><p>Defines how to handle when input contains nan.
The following options are available (default is ‘propagate’):</p>
<blockquote>
<div><ul class="simple">
<li><p>‘propagate’: returns nan</p></li>
<li><p>‘raise’: throws an error</p></li>
<li><p>‘omit’: performs the calculations ignoring nan values</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>statistic</strong><span class="classifier">float</span></dt><dd><p>The computed z-score for this test.</p>
</dd>
<dt><strong>pvalue</strong><span class="classifier">float</span></dt><dd><p>Two-sided p-value for the hypothesis test.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The sample size must be at least 8.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7e8e195c3317-1"><span class="brackets"><a class="fn-backref" href="#id118">1</a></span></dt>
<dd><p>R. B. D’Agostino, A. J. Belanger and R. B. D’Agostino Jr.,
“A suggestion for using powerful and informative tests of
normality”, American Statistician 44, pp. 316-321, 1990.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">skewtest</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">skewtest</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>  
<span class="go">SkewtestResult(statistic=1.0108048609177787, pvalue=0.3121098361421897)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skewtest</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  
<span class="go">SkewtestResult(statistic=0.44626385374196975, pvalue=0.6554066631275459)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skewtest</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8000</span><span class="p">])</span>  
<span class="go">SkewtestResult(statistic=3.571773510360407, pvalue=0.0003545719905823133)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skewtest</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">101</span><span class="p">])</span>  
<span class="go">SkewtestResult(statistic=3.5717766638478072, pvalue=0.000354567720281634)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.stats.kurtosis">
<code class="sig-prename descclassname">dask.array.stats.</code><code class="sig-name descname">kurtosis</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">fisher=True</em>, <em class="sig-param">bias=True</em>, <em class="sig-param">nan_policy='propagate'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.stats.kurtosis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the kurtosis (Fisher or Pearson) of a dataset.</p>
<p>This docstring was copied from scipy.stats.kurtosis.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Kurtosis is the fourth central moment divided by the square of the
variance. If Fisher’s definition is used, then 3.0 is subtracted from
the result to give 0.0 for a normal distribution.</p>
<p>If bias is False then the kurtosis is calculated using k statistics to
eliminate bias coming from biased moment estimators</p>
<p>Use <cite>kurtosistest</cite> to see if result is close enough to normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array</span></dt><dd><p>Data for which the kurtosis is calculated.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>Axis along which the kurtosis is calculated. Default is 0.
If None, compute over the whole array <cite>a</cite>.</p>
</dd>
<dt><strong>fisher</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, Fisher’s definition is used (normal ==&gt; 0.0). If False,
Pearson’s definition is used (normal ==&gt; 3.0).</p>
</dd>
<dt><strong>bias</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, then the calculations are corrected for statistical bias.</p>
</dd>
<dt><strong>nan_policy</strong><span class="classifier">{‘propagate’, ‘raise’, ‘omit’}, optional</span></dt><dd><p>Defines how to handle when input contains nan. ‘propagate’ returns nan,
‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan
values. Default is ‘propagate’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>kurtosis</strong><span class="classifier">array</span></dt><dd><p>The kurtosis of values along an axis. If all values are equal,
return -3 for Fisher’s definition and 0 for Pearson’s definition.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r44d42581afde-1"><span class="brackets"><a class="fn-backref" href="#id119">1</a></span></dt>
<dd><p>Zwillinger, D. and Kokoska, S. (2000). CRC Standard
Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New
York. 2000.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In Fisher’s definiton, the kurtosis of the normal distribution is zero.
In the following example, the kurtosis is close to zero, because it was
calculated from the dataset, not from the continuous distribution.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">kurtosis</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">kurtosis</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  
<span class="go">-0.06928694200380558</span>
</pre></div>
</div>
<p>The distribution with a higher kurtosis has a heavier tail.
The zero valued kurtosis of the normal distribution in Fisher’s definition
can serve as a reference point.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">kurtosis</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">distnames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;laplace&#39;</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="s1">&#39;uniform&#39;</span><span class="p">]</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">distname</span> <span class="ow">in</span> <span class="n">distnames</span><span class="p">:</span>  
<span class="gp">... </span>    <span class="k">if</span> <span class="n">distname</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">dist</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">distname</span><span class="p">)(</span><span class="n">loc</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">dist</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">distname</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">data</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">kur</span> <span class="o">=</span> <span class="n">kurtosis</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fisher</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">y</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">distname</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">kur</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="gp">... </span>    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
<p>The Laplace distribution has a heavier tail than the normal distribution.
The uniform distribution (which has negative kurtosis) has the thinnest
tail.</p>
</dd></dl>

<dl class="function">
<dt id="dask.array.stats.kurtosistest">
<code class="sig-prename descclassname">dask.array.stats.</code><code class="sig-name descname">kurtosistest</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">nan_policy='propagate'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.stats.kurtosistest" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a dataset has normal kurtosis.</p>
<p>This docstring was copied from scipy.stats.kurtosistest.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This function tests the null hypothesis that the kurtosis
of the population from which the sample was drawn is that
of the normal distribution: <code class="docutils literal notranslate"><span class="pre">kurtosis</span> <span class="pre">=</span> <span class="pre">3(n-1)/(n+1)</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array</span></dt><dd><p>Array of the sample data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>Axis along which to compute test. Default is 0. If None,
compute over the whole array <cite>a</cite>.</p>
</dd>
<dt><strong>nan_policy</strong><span class="classifier">{‘propagate’, ‘raise’, ‘omit’}, optional</span></dt><dd><p>Defines how to handle when input contains nan.
The following options are available (default is ‘propagate’):</p>
<blockquote>
<div><ul class="simple">
<li><p>‘propagate’: returns nan</p></li>
<li><p>‘raise’: throws an error</p></li>
<li><p>‘omit’: performs the calculations ignoring nan values</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>statistic</strong><span class="classifier">float</span></dt><dd><p>The computed z-score for this test.</p>
</dd>
<dt><strong>pvalue</strong><span class="classifier">float</span></dt><dd><p>The two-sided p-value for the hypothesis test.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Valid only for n&gt;20. This function uses the method described in <a class="reference internal" href="#r0535d6059af7-1" id="id120">[1]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0535d6059af7-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id120">1</a>,<a href="#id121">2</a>)</span></dt>
<dd><p>see e.g. F. J. Anscombe, W. J. Glynn, “Distribution of the kurtosis
statistic b2 for normal samples”, Biometrika, vol. 70, pp. 227-234, 1983.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">kurtosistest</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">kurtosistest</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))</span>  
<span class="go">KurtosistestResult(statistic=-1.7058104152122062, pvalue=0.08804338332528348)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">28041990</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">kurtosistest</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  
<span class="go">KurtosistestResult(statistic=1.2317590987707365, pvalue=0.21803908613450895)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.stats.normaltest">
<code class="sig-prename descclassname">dask.array.stats.</code><code class="sig-name descname">normaltest</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">nan_policy='propagate'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.stats.normaltest" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a sample differs from a normal distribution.</p>
<p>This docstring was copied from scipy.stats.normaltest.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>This function tests the null hypothesis that a sample comes
from a normal distribution.  It is based on D’Agostino and
Pearson’s <a class="reference internal" href="#r32e5e6b3c76f-1" id="id122">[1]</a>, <a class="reference internal" href="#r32e5e6b3c76f-2" id="id123">[2]</a> test that combines skew and kurtosis to
produce an omnibus test of normality.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>The array containing the sample to be tested.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>Axis along which to compute test. Default is 0. If None,
compute over the whole array <cite>a</cite>.</p>
</dd>
<dt><strong>nan_policy</strong><span class="classifier">{‘propagate’, ‘raise’, ‘omit’}, optional</span></dt><dd><p>Defines how to handle when input contains nan.
The following options are available (default is ‘propagate’):</p>
<blockquote>
<div><ul class="simple">
<li><p>‘propagate’: returns nan</p></li>
<li><p>‘raise’: throws an error</p></li>
<li><p>‘omit’: performs the calculations ignoring nan values</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>statistic</strong><span class="classifier">float or array</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">s^2</span> <span class="pre">+</span> <span class="pre">k^2</span></code>, where <code class="docutils literal notranslate"><span class="pre">s</span></code> is the z-score returned by <cite>skewtest</cite> and
<code class="docutils literal notranslate"><span class="pre">k</span></code> is the z-score returned by <cite>kurtosistest</cite>.</p>
</dd>
<dt><strong>pvalue</strong><span class="classifier">float or array</span></dt><dd><p>A 2-sided chi squared probability for the hypothesis test.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r32e5e6b3c76f-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id122">1</a>,<a href="#id124">2</a>)</span></dt>
<dd><p>D’Agostino, R. B. (1971), “An omnibus test of normality for
moderate and large sample size”, Biometrika, 58, 341-348</p>
</dd>
<dt class="label" id="r32e5e6b3c76f-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id123">1</a>,<a href="#id125">2</a>)</span></dt>
<dd><p>D’Agostino, R. and Pearson, E. S. (1973), “Tests for departure from
normality”, Biometrika, 60, 613-622</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">pts</span> <span class="o">=</span> <span class="mi">1000</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">28041990</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">pts</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">pts</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">normaltest</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">1e-3</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;p = </span><span class="si">{:g}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>  
<span class="go">p = 3.27207e-11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="p">:</span>  <span class="c1"># null hypothesis: x comes from a normal distribution  </span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The null hypothesis can be rejected&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The null hypothesis cannot be rejected&quot;</span><span class="p">)</span>
<span class="go">The null hypothesis can be rejected</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.stats.f_oneway">
<code class="sig-prename descclassname">dask.array.stats.</code><code class="sig-name descname">f_oneway</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.stats.f_oneway" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform one-way ANOVA.</p>
<p>This docstring was copied from scipy.stats.f_oneway.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>The one-way ANOVA tests the null hypothesis that two or more groups have
the same population mean.  The test is applied to samples from two or
more groups, possibly with differing sizes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample1, sample2, …</strong><span class="classifier">array_like</span></dt><dd><p>The sample measurements for each group.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>statistic</strong><span class="classifier">float</span></dt><dd><p>The computed F-value of the test.</p>
</dd>
<dt><strong>pvalue</strong><span class="classifier">float</span></dt><dd><p>The associated p-value from the F-distribution.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ANOVA test has important assumptions that must be satisfied in order
for the associated p-value to be valid.</p>
<ol class="arabic simple">
<li><p>The samples are independent.</p></li>
<li><p>Each sample is from a normally distributed population.</p></li>
<li><p>The population standard deviations of the groups are all equal.  This
property is known as homoscedasticity.</p></li>
</ol>
<p>If these assumptions are not true for a given set of data, it may still be
possible to use the Kruskal-Wallis H-test (<cite>scipy.stats.kruskal</cite>) although
with some loss of power.</p>
<p>The algorithm is from Heiman[2], pp.394-7.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r47f7c78b184f-1"><span class="brackets"><a class="fn-backref" href="#id126">1</a></span></dt>
<dd><p>R. Lowry, “Concepts and Applications of Inferential Statistics”,
Chapter 14, 2014, <a class="reference external" href="http://vassarstats.net/textbook/">http://vassarstats.net/textbook/</a></p>
</dd>
<dt class="label" id="r47f7c78b184f-2"><span class="brackets"><a class="fn-backref" href="#id127">2</a></span></dt>
<dd><p>G.W. Heiman, “Understanding research methods and statistics: An
integrated introduction for psychology”, Houghton, Mifflin and
Company, 2001.</p>
</dd>
<dt class="label" id="r47f7c78b184f-3"><span class="brackets">3</span><span class="fn-backref">(<a href="#id128">1</a>,<a href="#id129">2</a>)</span></dt>
<dd><p>G.H. McDonald, “Handbook of Biological Statistics”, One-way ANOVA.
<a class="reference external" href="http://www.biostathandbook.com/onewayanova.html">http://www.biostathandbook.com/onewayanova.html</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>  
</pre></div>
</div>
<p><a class="reference internal" href="#r47f7c78b184f-3" id="id129">[3]</a> Here are some data on a shell measurement (the length of the anterior
adductor muscle scar, standardized by dividing by length) in the mussel
Mytilus trossulus from five locations: Tillamook, Oregon; Newport, Oregon;
Petersburg, Alaska; Magadan, Russia; and Tvarminne, Finland, taken from a
much larger data set used in McDonald et al. (1991).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tillamook</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0571</span><span class="p">,</span> <span class="mf">0.0813</span><span class="p">,</span> <span class="mf">0.0831</span><span class="p">,</span> <span class="mf">0.0976</span><span class="p">,</span> <span class="mf">0.0817</span><span class="p">,</span> <span class="mf">0.0859</span><span class="p">,</span> <span class="mf">0.0735</span><span class="p">,</span>  
<span class="gp">... </span>             <span class="mf">0.0659</span><span class="p">,</span> <span class="mf">0.0923</span><span class="p">,</span> <span class="mf">0.0836</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newport</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0873</span><span class="p">,</span> <span class="mf">0.0662</span><span class="p">,</span> <span class="mf">0.0672</span><span class="p">,</span> <span class="mf">0.0819</span><span class="p">,</span> <span class="mf">0.0749</span><span class="p">,</span> <span class="mf">0.0649</span><span class="p">,</span> <span class="mf">0.0835</span><span class="p">,</span>  
<span class="gp">... </span>           <span class="mf">0.0725</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">petersburg</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0974</span><span class="p">,</span> <span class="mf">0.1352</span><span class="p">,</span> <span class="mf">0.0817</span><span class="p">,</span> <span class="mf">0.1016</span><span class="p">,</span> <span class="mf">0.0968</span><span class="p">,</span> <span class="mf">0.1064</span><span class="p">,</span> <span class="mf">0.105</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">magadan</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1033</span><span class="p">,</span> <span class="mf">0.0915</span><span class="p">,</span> <span class="mf">0.0781</span><span class="p">,</span> <span class="mf">0.0685</span><span class="p">,</span> <span class="mf">0.0677</span><span class="p">,</span> <span class="mf">0.0697</span><span class="p">,</span> <span class="mf">0.0764</span><span class="p">,</span>  
<span class="gp">... </span>           <span class="mf">0.0689</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tvarminne</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0703</span><span class="p">,</span> <span class="mf">0.1026</span><span class="p">,</span> <span class="mf">0.0956</span><span class="p">,</span> <span class="mf">0.0973</span><span class="p">,</span> <span class="mf">0.1039</span><span class="p">,</span> <span class="mf">0.1045</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="o">.</span><span class="n">f_oneway</span><span class="p">(</span><span class="n">tillamook</span><span class="p">,</span> <span class="n">newport</span><span class="p">,</span> <span class="n">petersburg</span><span class="p">,</span> <span class="n">magadan</span><span class="p">,</span> <span class="n">tvarminne</span><span class="p">)</span>  
<span class="go">(7.1210194716424473, 0.00028122423145345439)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.stats.moment">
<code class="sig-prename descclassname">dask.array.stats.</code><code class="sig-name descname">moment</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">moment=1</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">nan_policy='propagate'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.stats.moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the nth moment about the mean for a sample.</p>
<p>This docstring was copied from scipy.stats.moment.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>A moment is a specific quantitative measure of the shape of a set of
points. It is often used to calculate coefficients of skewness and kurtosis
due to its close relationship with them.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>moment</strong><span class="classifier">int or array_like of ints, optional</span></dt><dd><p>Order of central moment that is returned. Default is 1.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>Axis along which the central moment is computed. Default is 0.
If None, compute over the whole array <cite>a</cite>.</p>
</dd>
<dt><strong>nan_policy</strong><span class="classifier">{‘propagate’, ‘raise’, ‘omit’}, optional</span></dt><dd><p>Defines how to handle when input contains nan.
The following options are available (default is ‘propagate’):</p>
<blockquote>
<div><ul class="simple">
<li><p>‘propagate’: returns nan</p></li>
<li><p>‘raise’: throws an error</p></li>
<li><p>‘omit’: performs the calculations ignoring nan values</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>n-th central moment</strong><span class="classifier">ndarray or float</span></dt><dd><p>The appropriate moment along the given axis or over all values if axis
is None. The denominator for the moment calculation is the number of
observations, no degrees of freedom correction is done.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.stats.kurtosis" title="dask.array.stats.kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kurtosis</span></code></a>, <a class="reference internal" href="#dask.array.stats.skew" title="dask.array.stats.skew"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skew</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">describe</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The k-th central moment of a data sample is:</p>
<div class="math notranslate nohighlight">
\[m_k = \frac{1}{n} \sum_{i = 1}^n (x_i - \bar{x})^k\]</div>
<p>Where n is the number of samples and x-bar is the mean. This function uses
exponentiation by squares <a class="reference internal" href="#r330c2a4ee428-1" id="id130">[1]</a> for efficiency.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r330c2a4ee428-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id130">1</a>,<a href="#id131">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://eli.thegreenplace.net/2009/03/21/efficient-integer-exponentiation-algorithms">https://eli.thegreenplace.net/2009/03/21/efficient-integer-exponentiation-algorithms</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">moment</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">moment</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">moment</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moment</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">moment</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">2.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.image.imread">
<code class="sig-prename descclassname">dask.array.image.</code><code class="sig-name descname">imread</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">imread=None</em>, <em class="sig-param">preprocess=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.image.imread" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a stack of images into a dask array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: string</strong></dt><dd><p>A globstring like ‘myfile.*.png’</p>
</dd>
<dt><strong>imread: function (optional)</strong></dt><dd><p>Optionally provide custom imread function.
Function should expect a filename and produce a numpy array.
Defaults to <code class="docutils literal notranslate"><span class="pre">skimage.io.imread</span></code>.</p>
</dd>
<dt><strong>preprocess: function (optional)</strong></dt><dd><p>Optionally provide custom function to preprocess the image.
Function should expect a numpy array for a single image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Dask array of all images stacked along the first dimension.  All images</strong></dt><dd></dd>
<dt><strong>will be treated as individual chunks</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask.array.image</span> <span class="kn">import</span> <span class="n">imread</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s1">&#39;2015-*-*.png&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">shape</span>  
<span class="go">(365, 1000, 1000, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.gufunc.apply_gufunc">
<code class="sig-prename descclassname">dask.array.gufunc.</code><code class="sig-name descname">apply_gufunc</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">signature</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.gufunc.apply_gufunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a generalized ufunc or similar python function to arrays.</p>
<p><code class="docutils literal notranslate"><span class="pre">signature</span></code> determines if the function consumes or produces core
dimensions. The remaining dimensions in given input arrays (<code class="docutils literal notranslate"><span class="pre">*args</span></code>)
are considered loop dimensions and are required to broadcast
naturally against each other.</p>
<p>In other terms, this function is like <code class="docutils literal notranslate"><span class="pre">np.vectorize</span></code>, but for
the blocks of dask arrays. If the function itself shall also
be vectorized use <code class="docutils literal notranslate"><span class="pre">vectorize=True</span></code> for convenience.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>Function to call like <code class="docutils literal notranslate"><span class="pre">func(*args,</span> <span class="pre">**kwargs)</span></code> on input arrays
(<code class="docutils literal notranslate"><span class="pre">*args</span></code>) that returns an array or tuple of arrays. If multiple
arguments with non-matching dimensions are supplied, this function is
expected to vectorize (broadcast) over axes of positional arguments in
the style of NumPy universal functions <a class="reference internal" href="#rb8504d1ef58d-1" id="id132">[1]</a> (if this is not the case,
set <code class="docutils literal notranslate"><span class="pre">vectorize=True</span></code>). If this function returns multiple outputs,
<code class="docutils literal notranslate"><span class="pre">output_core_dims</span></code> has to be set as well.</p>
</dd>
<dt><strong>signature: string</strong></dt><dd><p>Specifies what core dimensions are consumed and produced by <code class="docutils literal notranslate"><span class="pre">func</span></code>.
According to the specification of numpy.gufunc signature <a class="reference internal" href="#rb8504d1ef58d-2" id="id133">[2]</a></p>
</dd>
<dt><strong>*args</strong><span class="classifier">numeric</span></dt><dd><p>Input arrays or scalars to the callable function.</p>
</dd>
<dt><strong>axes: List of tuples, optional, keyword only</strong></dt><dd><p>A list of tuples with indices of axes a generalized ufunc should operate on.
For instance, for a signature of <code class="docutils literal notranslate"><span class="pre">&quot;(i,j),(j,k)-&gt;(i,k)&quot;</span></code> appropriate for
matrix multiplication, the base elements are two-dimensional matrices
and these are taken to be stored in the two last axes of each argument. The
corresponding axes keyword would be <code class="docutils literal notranslate"><span class="pre">[(-2,</span> <span class="pre">-1),</span> <span class="pre">(-2,</span> <span class="pre">-1),</span> <span class="pre">(-2,</span> <span class="pre">-1)]</span></code>.
For simplicity, for generalized ufuncs that operate on 1-dimensional arrays
(vectors), a single integer is accepted instead of a single-element tuple,
and for generalized ufuncs for which all outputs are scalars, the output
tuples can be omitted.</p>
</dd>
<dt><strong>axis: int, optional, keyword only</strong></dt><dd><p>A single axis over which a generalized ufunc should operate. This is a short-cut
for ufuncs that operate over a single, shared core dimension, equivalent to passing
in axes with entries of (axis,) for each single-core-dimension argument and <code class="docutils literal notranslate"><span class="pre">()</span></code> for
all others. For instance, for a signature <code class="docutils literal notranslate"><span class="pre">&quot;(i),(i)-&gt;()&quot;</span></code>, it is equivalent to passing
in <code class="docutils literal notranslate"><span class="pre">axes=[(axis,),</span> <span class="pre">(axis,),</span> <span class="pre">()]</span></code>.</p>
</dd>
<dt><strong>keepdims: bool, optional, keyword only</strong></dt><dd><p>If this is set to True, axes which are reduced over will be left in the result as
a dimension with size one, so that the result will broadcast correctly against the
inputs. This option can only be used for generalized ufuncs that operate on inputs
that all have the same number of core dimensions and with outputs that have no core
dimensions , i.e., with signatures like <code class="docutils literal notranslate"><span class="pre">&quot;(i),(i)-&gt;()&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;(m,m)-&gt;()&quot;</span></code>.
If used, the location of the dimensions in the output can be controlled with axes
and axis.</p>
</dd>
<dt><strong>output_dtypes</strong><span class="classifier">Optional, dtype or list of dtypes, keyword only</span></dt><dd><p>Valid numpy dtype specification or list thereof.
If not given, a call of <code class="docutils literal notranslate"><span class="pre">func</span></code> with a small set of data
is performed in order to try to automatically determine the
output dtypes.</p>
</dd>
<dt><strong>output_sizes</strong><span class="classifier">dict, optional, keyword only</span></dt><dd><p>Optional mapping from dimension names to sizes for outputs. Only used if
new core dimensions (not found on inputs) appear on outputs.</p>
</dd>
<dt><strong>vectorize: bool, keyword only</strong></dt><dd><p>If set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">np.vectorize</span></code> is applied to <code class="docutils literal notranslate"><span class="pre">func</span></code> for
convenience. Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
<dt><strong>allow_rechunk: Optional, bool, keyword only</strong></dt><dd><p>Allows rechunking, otherwise chunk sizes need to match and core
dimensions are to consist only of one chunk.
Warning: enabling this can increase memory usage significantly.
Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>Extra keyword arguments to pass to <cite>func</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Single dask.array.Array or tuple of dask.array.Array</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb8504d1ef58d-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id132">1</a>,<a href="#id134">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html">https://docs.scipy.org/doc/numpy/reference/ufuncs.html</a></p>
</dd>
<dt class="label" id="rb8504d1ef58d-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id133">1</a>,<a href="#id135">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html">https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">apply_gufunc</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="s2">&quot;(i)-&gt;(),()&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(10, 20)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">outer_product</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i,j-&gt;ij&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span>   <span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">40</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">40</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">apply_gufunc</span><span class="p">(</span><span class="n">outer_product</span><span class="p">,</span> <span class="s2">&quot;(i),(j)-&gt;(i,j)&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(10, 20, 30, 40)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.gufunc.as_gufunc">
<code class="sig-prename descclassname">dask.array.gufunc.</code><code class="sig-name descname">as_gufunc</code><span class="sig-paren">(</span><em class="sig-param">signature=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.gufunc.as_gufunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for <code class="docutils literal notranslate"><span class="pre">dask.array.gufunc</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>signature</strong><span class="classifier">String</span></dt><dd><p>Specifies what core dimensions are consumed and produced by <code class="docutils literal notranslate"><span class="pre">func</span></code>.
According to the specification of numpy.gufunc signature <a class="reference internal" href="#red860e6aea48-2" id="id136">[2]</a></p>
</dd>
<dt><strong>axes: List of tuples, optional, keyword only</strong></dt><dd><p>A list of tuples with indices of axes a generalized ufunc should operate on.
For instance, for a signature of <code class="docutils literal notranslate"><span class="pre">&quot;(i,j),(j,k)-&gt;(i,k)&quot;</span></code> appropriate for
matrix multiplication, the base elements are two-dimensional matrices
and these are taken to be stored in the two last axes of each argument. The
corresponding axes keyword would be <code class="docutils literal notranslate"><span class="pre">[(-2,</span> <span class="pre">-1),</span> <span class="pre">(-2,</span> <span class="pre">-1),</span> <span class="pre">(-2,</span> <span class="pre">-1)]</span></code>.
For simplicity, for generalized ufuncs that operate on 1-dimensional arrays
(vectors), a single integer is accepted instead of a single-element tuple,
and for generalized ufuncs for which all outputs are scalars, the output
tuples can be omitted.</p>
</dd>
<dt><strong>axis: int, optional, keyword only</strong></dt><dd><p>A single axis over which a generalized ufunc should operate. This is a short-cut
for ufuncs that operate over a single, shared core dimension, equivalent to passing
in axes with entries of (axis,) for each single-core-dimension argument and <code class="docutils literal notranslate"><span class="pre">()</span></code> for
all others. For instance, for a signature <code class="docutils literal notranslate"><span class="pre">&quot;(i),(i)-&gt;()&quot;</span></code>, it is equivalent to passing
in <code class="docutils literal notranslate"><span class="pre">axes=[(axis,),</span> <span class="pre">(axis,),</span> <span class="pre">()]</span></code>.</p>
</dd>
<dt><strong>keepdims: bool, optional, keyword only</strong></dt><dd><p>If this is set to True, axes which are reduced over will be left in the result as
a dimension with size one, so that the result will broadcast correctly against the
inputs. This option can only be used for generalized ufuncs that operate on inputs
that all have the same number of core dimensions and with outputs that have no core
dimensions , i.e., with signatures like <code class="docutils literal notranslate"><span class="pre">&quot;(i),(i)-&gt;()&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;(m,m)-&gt;()&quot;</span></code>.
If used, the location of the dimensions in the output can be controlled with axes
and axis.</p>
</dd>
<dt><strong>output_dtypes</strong><span class="classifier">Optional, dtype or list of dtypes, keyword only</span></dt><dd><p>Valid numpy dtype specification or list thereof.
If not given, a call of <code class="docutils literal notranslate"><span class="pre">func</span></code> with a small set of data
is performed in order to try to automatically determine the
output dtypes.</p>
</dd>
<dt><strong>output_sizes</strong><span class="classifier">dict, optional, keyword only</span></dt><dd><p>Optional mapping from dimension names to sizes for outputs. Only used if
new core dimensions (not found on inputs) appear on outputs.</p>
</dd>
<dt><strong>vectorize: bool, keyword only</strong></dt><dd><p>If set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">np.vectorize</span></code> is applied to <code class="docutils literal notranslate"><span class="pre">func</span></code> for
convenience. Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
<dt><strong>allow_rechunk: Optional, bool, keyword only</strong></dt><dd><p>Allows rechunking, otherwise chunk sizes need to match and core
dimensions are to consist only of one chunk.
Warning: enabling this can increase memory usage significantly.
Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Decorator for `pyfunc` that itself returns a `gufunc`.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="red860e6aea48-1"><span class="brackets"><a class="fn-backref" href="#id137">1</a></span></dt>
<dd><p><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html">https://docs.scipy.org/doc/numpy/reference/ufuncs.html</a></p>
</dd>
<dt class="label" id="red860e6aea48-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id136">1</a>,<a href="#id138">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html">https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@da</span><span class="o">.</span><span class="n">as_gufunc</span><span class="p">(</span><span class="s2">&quot;(i)-&gt;(),()&quot;</span><span class="p">,</span> <span class="n">output_dtypes</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="n">stats</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(10, 20)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span>   <span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">40</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">40</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@da</span><span class="o">.</span><span class="n">as_gufunc</span><span class="p">(</span><span class="s2">&quot;(i),(j)-&gt;(i,j)&quot;</span><span class="p">,</span> <span class="n">output_dtypes</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">outer_product</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i,j-&gt;ij&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">outer_product</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(10, 20, 30, 40)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.gufunc.gufunc">
<code class="sig-prename descclassname">dask.array.gufunc.</code><code class="sig-name descname">gufunc</code><span class="sig-paren">(</span><em class="sig-param">pyfunc</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.gufunc.gufunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Binds <cite>pyfunc</cite> into <code class="docutils literal notranslate"><span class="pre">dask.array.apply_gufunc</span></code> when called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pyfunc</strong><span class="classifier">callable</span></dt><dd><p>Function to call like <code class="docutils literal notranslate"><span class="pre">func(*args,</span> <span class="pre">**kwargs)</span></code> on input arrays
(<code class="docutils literal notranslate"><span class="pre">*args</span></code>) that returns an array or tuple of arrays. If multiple
arguments with non-matching dimensions are supplied, this function is
expected to vectorize (broadcast) over axes of positional arguments in
the style of NumPy universal functions <a class="reference internal" href="#r02163d2dfbb7-1" id="id139">[1]</a> (if this is not the case,
set <code class="docutils literal notranslate"><span class="pre">vectorize=True</span></code>). If this function returns multiple outputs,
<code class="docutils literal notranslate"><span class="pre">output_core_dims</span></code> has to be set as well.</p>
</dd>
<dt><strong>signature</strong><span class="classifier">String, keyword only</span></dt><dd><p>Specifies what core dimensions are consumed and produced by <code class="docutils literal notranslate"><span class="pre">func</span></code>.
According to the specification of numpy.gufunc signature <a class="reference internal" href="#r02163d2dfbb7-2" id="id140">[2]</a></p>
</dd>
<dt><strong>axes: List of tuples, optional, keyword only</strong></dt><dd><p>A list of tuples with indices of axes a generalized ufunc should operate on.
For instance, for a signature of <code class="docutils literal notranslate"><span class="pre">&quot;(i,j),(j,k)-&gt;(i,k)&quot;</span></code> appropriate for
matrix multiplication, the base elements are two-dimensional matrices
and these are taken to be stored in the two last axes of each argument. The
corresponding axes keyword would be <code class="docutils literal notranslate"><span class="pre">[(-2,</span> <span class="pre">-1),</span> <span class="pre">(-2,</span> <span class="pre">-1),</span> <span class="pre">(-2,</span> <span class="pre">-1)]</span></code>.
For simplicity, for generalized ufuncs that operate on 1-dimensional arrays
(vectors), a single integer is accepted instead of a single-element tuple,
and for generalized ufuncs for which all outputs are scalars, the output
tuples can be omitted.</p>
</dd>
<dt><strong>axis: int, optional, keyword only</strong></dt><dd><p>A single axis over which a generalized ufunc should operate. This is a short-cut
for ufuncs that operate over a single, shared core dimension, equivalent to passing
in axes with entries of (axis,) for each single-core-dimension argument and <code class="docutils literal notranslate"><span class="pre">()</span></code> for
all others. For instance, for a signature <code class="docutils literal notranslate"><span class="pre">&quot;(i),(i)-&gt;()&quot;</span></code>, it is equivalent to passing
in <code class="docutils literal notranslate"><span class="pre">axes=[(axis,),</span> <span class="pre">(axis,),</span> <span class="pre">()]</span></code>.</p>
</dd>
<dt><strong>keepdims: bool, optional, keyword only</strong></dt><dd><p>If this is set to True, axes which are reduced over will be left in the result as
a dimension with size one, so that the result will broadcast correctly against the
inputs. This option can only be used for generalized ufuncs that operate on inputs
that all have the same number of core dimensions and with outputs that have no core
dimensions , i.e., with signatures like <code class="docutils literal notranslate"><span class="pre">&quot;(i),(i)-&gt;()&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;(m,m)-&gt;()&quot;</span></code>.
If used, the location of the dimensions in the output can be controlled with axes
and axis.</p>
</dd>
<dt><strong>output_dtypes</strong><span class="classifier">Optional, dtype or list of dtypes, keyword only</span></dt><dd><p>Valid numpy dtype specification or list thereof.
If not given, a call of <code class="docutils literal notranslate"><span class="pre">func</span></code> with a small set of data
is performed in order to try to automatically determine the
output dtypes.</p>
</dd>
<dt><strong>output_sizes</strong><span class="classifier">dict, optional, keyword only</span></dt><dd><p>Optional mapping from dimension names to sizes for outputs. Only used if
new core dimensions (not found on inputs) appear on outputs.</p>
</dd>
<dt><strong>vectorize: bool, keyword only</strong></dt><dd><p>If set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">np.vectorize</span></code> is applied to <code class="docutils literal notranslate"><span class="pre">func</span></code> for
convenience. Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
<dt><strong>allow_rechunk: Optional, bool, keyword only</strong></dt><dd><p>Allows rechunking, otherwise chunk sizes need to match and core
dimensions are to consist only of one chunk.
Warning: enabling this can increase memory usage significantly.
Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Wrapped function</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r02163d2dfbb7-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id139">1</a>,<a href="#id141">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html">https://docs.scipy.org/doc/numpy/reference/ufuncs.html</a></p>
</dd>
<dt class="label" id="r02163d2dfbb7-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id140">1</a>,<a href="#id142">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html">https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gustats</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">gufunc</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="s2">&quot;(i)-&gt;(),()&quot;</span><span class="p">,</span> <span class="n">output_dtypes</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="n">gustats</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(10, 20)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span>   <span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">40</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">40</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">outer_product</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i,j-&gt;ij&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">guouter_product</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">gufunc</span><span class="p">(</span><span class="n">outer_product</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="s2">&quot;(i),(j)-&gt;(i,j)&quot;</span><span class="p">,</span> <span class="n">output_dtypes</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">guouter_product</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(10, 20, 30, 40)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.core.map_blocks">
<code class="sig-prename descclassname">dask.array.core.</code><code class="sig-name descname">map_blocks</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">name=None</em>, <em class="sig-param">token=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">chunks=None</em>, <em class="sig-param">drop_axis=[]</em>, <em class="sig-param">new_axis=None</em>, <em class="sig-param">meta=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.core.map_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a function across all blocks of a dask array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>Function to apply to every block in the array.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dask arrays or other objects</span></dt><dd></dd>
<dt><strong>dtype</strong><span class="classifier">np.dtype, optional</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">dtype</span></code> of the output array. It is recommended to provide this.
If not provided, will be inferred by applying the function to a small
set of fake data.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">tuple, optional</span></dt><dd><p>Chunk shape of resulting blocks if the function does not preserve
shape. If not provided, the resulting array is assumed to have the same
block structure as the first input array.</p>
</dd>
<dt><strong>drop_axis</strong><span class="classifier">number or iterable, optional</span></dt><dd><p>Dimensions lost by the function.</p>
</dd>
<dt><strong>new_axis</strong><span class="classifier">number or iterable, optional</span></dt><dd><p>New dimensions created by the function. Note that these are applied
after <code class="docutils literal notranslate"><span class="pre">drop_axis</span></code> (if present).</p>
</dd>
<dt><strong>token</strong><span class="classifier">string, optional</span></dt><dd><p>The key prefix to use for the output array. If not provided, will be
determined from the function name.</p>
</dd>
<dt><strong>name</strong><span class="classifier">string, optional</span></dt><dd><p>The key name to use for the output array. Note that this fully
specifies the output key name, and must be unique. If not provided,
will be determined by a hash of the arguments.</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Other keyword arguments to pass to function. Values must be constants
(not dask.arrays)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.blockwise" title="dask.array.blockwise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.blockwise</span></code></a></dt><dd><p>Generalized operation with control over block alignment.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([ 0,  2,  4,  6,  8, 10])</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">da.map_blocks</span></code> function can also accept multiple arrays.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([ 0,  2,  6, 12, 20])</span>
</pre></div>
</div>
<p>If the function changes shape of the blocks then you must provide chunks
explicitly.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),))</span>
</pre></div>
</div>
<p>You have a bit of freedom in specifying chunks.  If all of the output chunk
sizes are the same, you can provide just that chunk size as a single tuple.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
</pre></div>
</div>
<p>If the function changes the dimension of the blocks you must specify the
created or destroyed dimensions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="n">new_axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">chunks</span></code> is specified but <code class="docutils literal notranslate"><span class="pre">new_axis</span></code> is not, then it is inferred to
add the necessary number of axes on the left.</p>
<p>Map_blocks aligns blocks by block positions without regard to shape. In the
following example we have two arrays with the same number of blocks but
with different shape and chunk sizes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
</pre></div>
</div>
<p>The relevant attribute to match is numblocks.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">numblocks</span>
<span class="go">(10,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">numblocks</span>
<span class="go">(10,)</span>
</pre></div>
</div>
<p>If these match (up to broadcasting rules) then we can map arbitrary
functions across blocks</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i8&#39;</span><span class="p">)</span>
<span class="go">dask.array&lt;func, shape=(20,), dtype=int64, chunksize=(2,), chunktype=numpy.ndarray&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([ 99,   9, 199,  19, 299,  29, 399,  39, 499,  49, 599,  59, 699,</span>
<span class="go">        69, 799,  79, 899,  89, 999,  99])</span>
</pre></div>
</div>
<p>Your block function get information about where it is in the array by
accepting a special <code class="docutils literal notranslate"><span class="pre">block_info</span></code> keyword argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">block_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
</pre></div>
</div>
<p>This will receive the following information:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_info</span>  
<span class="go">{0: {&#39;shape&#39;: (1000,),</span>
<span class="go">     &#39;num-chunks&#39;: (10,),</span>
<span class="go">     &#39;chunk-location&#39;: (4,),</span>
<span class="go">     &#39;array-location&#39;: [(400, 500)]},</span>
<span class="go"> None: {&#39;shape&#39;: (1000,),</span>
<span class="go">        &#39;num-chunks&#39;: (10,),</span>
<span class="go">        &#39;chunk-location&#39;: (4,),</span>
<span class="go">        &#39;array-location&#39;: [(400, 500)],</span>
<span class="go">        &#39;chunk-shape&#39;: (100,),</span>
<span class="go">        &#39;dtype&#39;: dtype(&#39;float64&#39;)}}</span>
</pre></div>
</div>
<p>For each argument and keyword arguments that are dask arrays (the positions
of which are the first index), you will receive the shape of the full
array, the number of chunks of the full array in each dimension, the chunk
location (for example the fourth chunk over in the first dimension), and
the array location (for example the slice corresponding to <code class="docutils literal notranslate"><span class="pre">40:50</span></code>). The
same information is provided for the output, with the key <code class="docutils literal notranslate"><span class="pre">None</span></code>, plus
the shape and dtype that should be returned.</p>
<p>These features can be combined to synthesize an array from scratch, for
example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">block_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">loc</span> <span class="o">=</span> <span class="n">block_info</span><span class="p">[</span><span class="kc">None</span><span class="p">][</span><span class="s1">&#39;array-location&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
<span class="go">dask.array&lt;func, shape=(8,), dtype=float64, chunksize=(4,), chunktype=numpy.ndarray&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7])</span>
</pre></div>
</div>
<p>You may specify the key name prefix of the resulting task in the graph with
the optional <code class="docutils literal notranslate"><span class="pre">token</span></code> keyword argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;increment&#39;</span><span class="p">)</span>  
<span class="go">dask.array&lt;increment, shape=(100,), dtype=int64, chunksize=(10,), chunktype=numpy.ndarray&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.core.blockwise">
<code class="sig-prename descclassname">dask.array.core.</code><code class="sig-name descname">blockwise</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">out_ind</em>, <em class="sig-param">*args</em>, <em class="sig-param">name=None</em>, <em class="sig-param">token=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">adjust_chunks=None</em>, <em class="sig-param">new_axes=None</em>, <em class="sig-param">align_arrays=True</em>, <em class="sig-param">concatenate=None</em>, <em class="sig-param">meta=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.core.blockwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Tensor operation: Generalized inner and outer products</p>
<p>A broad class of blocked algorithms and patterns can be specified with a
concise multi-index notation.  The <code class="docutils literal notranslate"><span class="pre">blockwise</span></code> function applies an in-memory
function across multiple blocks of multiple inputs in a variety of ways.
Many dask.array operations are special cases of blockwise including
elementwise, broadcasting, reductions, tensordot, and transpose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>Function to apply to individual tuples of blocks</p>
</dd>
<dt><strong>out_ind</strong><span class="classifier">iterable</span></dt><dd><p>Block pattern of the output, something like ‘ijk’ or (1, 2, 3)</p>
</dd>
<dt><strong>*args</strong><span class="classifier">sequence of Array, index pairs</span></dt><dd><p>Sequence like (x, ‘ij’, y, ‘jk’, z, ‘i’)</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>Extra keyword arguments to pass to function</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">np.dtype</span></dt><dd><p>Datatype of resulting array.</p>
</dd>
<dt><strong>concatenate</strong><span class="classifier">bool, keyword only</span></dt><dd><p>If true concatenate arrays along dummy indices, else provide lists</p>
</dd>
<dt><strong>adjust_chunks</strong><span class="classifier">dict</span></dt><dd><p>Dictionary mapping index to function to be applied to chunk sizes</p>
</dd>
<dt><strong>new_axes</strong><span class="classifier">dict, keyword only</span></dt><dd><p>New indexes and their dimension lengths</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>2D embarrassingly parallel operation from two arrays, x, and y.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>  <span class="c1"># z = x + y  </span>
</pre></div>
</div>
<p>Outer product multiplying x by y, two 1-d vectors</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>z = x.T</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">,</span> <span class="s1">&#39;ji&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  
</pre></div>
</div>
<p>The transpose case above is illustrative because it does same transposition
both on each in-memory block by calling <code class="docutils literal notranslate"><span class="pre">np.transpose</span></code> and on the order
of the blocks themselves, by switching the order of the index <code class="docutils literal notranslate"><span class="pre">ij</span> <span class="pre">-&gt;</span> <span class="pre">ji</span></code>.</p>
<p>We can compose these same patterns with more variables and more complex
in-memory functions</p>
<p>z = X + Y.T</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ji&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>Any index, like <code class="docutils literal notranslate"><span class="pre">i</span></code> missing from the output index is interpreted as a
contraction (note that this differs from Einstein convention; repeated
indices do not imply contraction.)  In the case of a contraction the passed
function should expect an iterable of blocks on any array that holds that
index.  To receive arrays concatenated along contracted dimensions instead
pass <code class="docutils literal notranslate"><span class="pre">concatenate=True</span></code>.</p>
<p>Inner product multiplying x by y, two 1-d vectors</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sequence_dot</span><span class="p">(</span><span class="n">x_blocks</span><span class="p">,</span> <span class="n">y_blocks</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_blocks</span><span class="p">,</span> <span class="n">y_blocks</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">sequence_dot</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>Add new single-chunk dimensions with the <code class="docutils literal notranslate"><span class="pre">new_axes=</span></code> keyword, including
the length of the new dimension.  New dimensions will always be in a single
chunk.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;az&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  
</pre></div>
</div>
<p>New dimensions can also be multi-chunk by specifying a tuple of chunk
sizes.  This has limited utility as is (because the chunks are all the
same), but the resulting graph can be modified to achieve more useful
results (see <code class="docutils literal notranslate"><span class="pre">da.map_blocks</span></code>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;az&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)},</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  
</pre></div>
</div>
<p>If the applied function changes the size of each chunk you can specify this
with a <code class="docutils literal notranslate"><span class="pre">adjust_chunks={...}</span></code> dictionary holding a function for each index
that modifies the dimension size in that index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">double</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">adjust_chunks</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">},</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  
</pre></div>
</div>
<p>Include literals by indexing with None</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dask.array.core.normalize_chunks">
<code class="sig-prename descclassname">dask.array.core.</code><code class="sig-name descname">normalize_chunks</code><span class="sig-paren">(</span><em class="sig-param">chunks</em>, <em class="sig-param">shape=None</em>, <em class="sig-param">limit=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">previous_chunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.core.normalize_chunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize chunks to tuple of tuples</p>
<p>This takes in a variety of input types and information and produces a full
tuple-of-tuples result for chunks, suitable to be passed to Array or
rechunk or any other operation that creates a Dask array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chunks: tuple, int, dict, or string</strong></dt><dd><p>The chunks to be normalized.  See examples below for more details</p>
</dd>
<dt><strong>shape: Tuple[int]</strong></dt><dd><p>The shape of the array</p>
</dd>
<dt><strong>limit: int (optional)</strong></dt><dd><p>The maximum block size to target in bytes,
if freedom is given to choose</p>
</dd>
<dt><strong>dtype: np.dtype</strong></dt><dd></dd>
<dt><strong>previous_chunks: Tuple[Tuple[int]] optional</strong></dt><dd><p>Chunks from a previous array that we should use for inspiration when
rechunking auto dimensions.  If not provided but auto-chunking exists
then auto-dimensions will prefer square-like chunk shapes.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Specify uniform chunk sizes</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalize_chunks</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">((2, 2, 1), (2, 2, 2))</span>
</pre></div>
</div>
<p>Also passes through fully explicit tuple-of-tuples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalize_chunks</span><span class="p">(((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">((2, 2, 1), (2, 2, 2))</span>
</pre></div>
</div>
<p>Cleans up lists to tuples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalize_chunks</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="go">((2, 2), (3, 3))</span>
</pre></div>
</div>
<p>Expands integer inputs 10 -&gt; (10, 10)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalize_chunks</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">((10, 10, 10), (5,))</span>
</pre></div>
</div>
<p>Expands dict inputs</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalize_chunks</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">((2, 2, 2), (3, 3))</span>
</pre></div>
</div>
<p>The values -1 and None get mapped to full size</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalize_chunks</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="go">((5, 5), (10,))</span>
</pre></div>
</div>
<p>Use the value “auto” to automatically determine chunk sizes along certain
dimensions.  This uses the <code class="docutils literal notranslate"><span class="pre">limit=</span></code> and <code class="docutils literal notranslate"><span class="pre">dtype=</span></code> keywords to
determine how large to make the chunks.  The term “auto” can be used
anywhere an integer can be used.  See array chunking documentation for more
information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalize_chunks</span><span class="p">((</span><span class="s2">&quot;auto&quot;</span><span class="p">,),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,),</span> <span class="n">limit</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
<span class="go">((5, 5, 5, 5),)</span>
</pre></div>
</div>
<p>You can also use byte sizes (see <code class="docutils literal notranslate"><span class="pre">dask.utils.parse_bytes</span></code>) in place of
“auto” to ask for a particular size</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalize_chunks</span><span class="p">(</span><span class="s2">&quot;1kiB&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2000</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="go">((250, 250, 250, 250, 250, 250, 250, 250),)</span>
</pre></div>
</div>
<p>Respects null dimensions</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalize_chunks</span><span class="p">((),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">((0,), (0,))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="array-methods">
<h2>Array Methods<a class="headerlink" href="#array-methods" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dask.array.Array">
<em class="property">class </em><code class="sig-prename descclassname">dask.array.</code><code class="sig-name descname">Array</code><a class="headerlink" href="#dask.array.Array" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel Dask Array</p>
<p>A parallel nd-array comprised of many numpy arrays arranged in a grid.</p>
<p>This constructor is for advanced uses only.  For normal use see the
<code class="docutils literal notranslate"><span class="pre">da.from_array</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dask</strong><span class="classifier">dict</span></dt><dd><p>Task dependency graph</p>
</dd>
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>Name of array in dask</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple of ints</span></dt><dd><p>Shape of the entire array</p>
</dd>
<dt><strong>chunks: iterable of tuples</strong></dt><dd><p>block sizes along each dimension</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">str or dtype</span></dt><dd><p>Typecode or data-type for the new Dask Array</p>
</dd>
<dt><strong>meta</strong><span class="classifier">empty ndarray</span></dt><dd><p>empty ndarray created with same NumPy backend, ndim and dtype as the
Dask Array being created (overrides dtype)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.from_array" title="dask.array.from_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.from_array</span></code></a></p>
</div>
<dl class="method">
<dt id="dask.array.Array.all">
<code class="sig-name descname">all</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.all" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.all.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns True if all elements evaluate to True.</p>
<p>Refer to <cite>numpy.all</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.all.html#numpy.all" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.all</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.any">
<code class="sig-name descname">any</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.any" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.any.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns True if any of the elements of <cite>a</cite> evaluate to True.</p>
<p>Refer to <cite>numpy.any</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.any.html#numpy.any" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.any</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.argmax">
<code class="sig-name descname">argmax</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.argmax.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return indices of the maximum values along the given axis.</p>
<p>Refer to <cite>numpy.argmax</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.argmax.html#numpy.argmax" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.argmax</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.argmin">
<code class="sig-name descname">argmin</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.argmin.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return indices of the minimum values along the given axis of <cite>a</cite>.</p>
<p>Refer to <cite>numpy.argmin</cite> for detailed documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.argmin.html#numpy.argmin" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.argmin</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.argtopk">
<code class="sig-name descname">argtopk</code><span class="sig-paren">(</span><em class="sig-param">k</em>, <em class="sig-param">axis=-1</em>, <em class="sig-param">split_every=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.argtopk" title="Permalink to this definition">¶</a></dt>
<dd><p>The indices of the top k elements of an array.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">da.argtopk</span></code> for docstring</p>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.astype">
<code class="sig-name descname">astype</code><span class="sig-paren">(</span><em class="sig-param">dtype</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy of the array, cast to a specified type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">str or dtype</span></dt><dd><p>Typecode or data-type to which the array is cast.</p>
</dd>
<dt><strong>casting</strong><span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt><dd><p>Controls what kind of data casting may occur. Defaults to ‘unsafe’
for backwards compatibility.</p>
<ul class="simple">
<li><p>‘no’ means the data types should not be cast at all.</p></li>
<li><p>‘equiv’ means only byte-order changes are allowed.</p></li>
<li><p>‘safe’ means only casts which can preserve values are allowed.</p></li>
<li><dl class="simple">
<dt>‘same_kind’ means only safe casts or casts within a kind,</dt><dd><p>like float64 to float32, are allowed.</p>
</dd>
</dl>
</li>
<li><p>‘unsafe’ means any data conversions may be done.</p></li>
</ul>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional</span></dt><dd><p>By default, astype always returns a newly allocated array. If this
is set to False and the <cite>dtype</cite> requirement is satisfied, the input
array is returned instead of a copy.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.blocks">
<em class="property">property </em><code class="sig-name descname">blocks</code><a class="headerlink" href="#dask.array.Array.blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice an array by blocks</p>
<p>This allows blockwise slicing of a Dask array.  You can perform normal
Numpy-style slicing but now rather than slice elements of the array you
slice along blocks so, for example, <code class="docutils literal notranslate"><span class="pre">x.blocks[0,</span> <span class="pre">::2]</span></code> produces a new
dask array with every other block in the first row of blocks.</p>
<p>You can index blocks in any way that could index a numpy array of shape
equal to the number of blocks in each dimension, (available as
array.numblocks).  The dimension of the output array will be the same
as the dimension of this array, even if integer indices are passed.
This does not support slicing with <code class="docutils literal notranslate"><span class="pre">np.newaxis</span></code> or multiple lists.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A Dask array</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">blocks</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([0, 1, 2, 3, 4, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">blocks</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([0, 1, 4, 5, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">blocks</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([8, 9, 0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.choose">
<code class="sig-name descname">choose</code><span class="sig-paren">(</span><em class="sig-param">choices</em>, <em class="sig-param">out=None</em>, <em class="sig-param">mode='raise'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.choose" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.choose.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Use an index array to construct a new array from a set of choices.</p>
<p>Refer to <cite>numpy.choose</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.choose.html#numpy.choose" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.choose</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.clip">
<code class="sig-name descname">clip</code><span class="sig-paren">(</span><em class="sig-param">min=None</em>, <em class="sig-param">max=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.clip.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return an array whose values are limited to <code class="docutils literal notranslate"><span class="pre">[min,</span> <span class="pre">max]</span></code>.
One of max or min must be given.</p>
<p>Refer to <cite>numpy.clip</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html#numpy.clip" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.clip</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.compute_chunk_sizes">
<code class="sig-name descname">compute_chunk_sizes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.compute_chunk_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the chunk sizes for a Dask array. This is especially useful
when the chunk sizes are unknown (e.g., when indexing one Dask array
with another).</p>
<p class="rubric">Notes</p>
<p>This function modifies the Dask array in-place.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">chunks</span>
<span class="go">((2, 2, 1),)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">chunks</span>
<span class="go">((nan, nan, nan),)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">compute_chunk_sizes</span><span class="p">()</span>  <span class="c1"># in-place computation</span>
<span class="go">dask.array&lt;getitem, shape=(3,), dtype=int64, chunksize=(2,), chunktype=numpy.ndarray&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">chunks</span>
<span class="go">((2, 1, 0),)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy array.  This is a no-op for dask.arrays, which are immutable</p>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.cumprod">
<code class="sig-name descname">cumprod</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.cumprod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the cumulative product of the elements along the given axis.</p>
<p>Refer to <cite>numpy.cumprod</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.cumprod.html#numpy.cumprod" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.cumprod</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.cumsum">
<code class="sig-name descname">cumsum</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.cumsum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the cumulative sum of the elements along the given axis.</p>
<p>Refer to <cite>numpy.cumsum</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.cumsum.html#numpy.cumsum" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.cumsum</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.dot">
<code class="sig-name descname">dot</code><span class="sig-paren">(</span><em class="sig-param">b</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.dot.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Dot product of two arrays.</p>
<p>Refer to <cite>numpy.dot</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html#numpy.dot" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.dot</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="go">array([[2.,  2.],</span>
<span class="go">       [2.,  2.]])</span>
</pre></div>
</div>
<p>This array method can be conveniently chained:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="go">array([[8.,  8.],</span>
<span class="go">       [8.,  8.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.flatten">
<code class="sig-name descname">flatten</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">order</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.ravel.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return a flattened array.</p>
<p>Refer to <cite>numpy.ravel</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html#numpy.ravel" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ravel</span></code></a></dt><dd><p>equivalent function</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.flat</span></code></dt><dd><p>a flat iterator on the array.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.itemsize">
<em class="property">property </em><code class="sig-name descname">itemsize</code><a class="headerlink" href="#dask.array.Array.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Length of one array element in bytes</p>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.map_blocks">
<code class="sig-name descname">map_blocks</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">name=None</em>, <em class="sig-param">token=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">chunks=None</em>, <em class="sig-param">drop_axis=[]</em>, <em class="sig-param">new_axis=None</em>, <em class="sig-param">meta=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.map_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a function across all blocks of a dask array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>Function to apply to every block in the array.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dask arrays or other objects</span></dt><dd></dd>
<dt><strong>dtype</strong><span class="classifier">np.dtype, optional</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">dtype</span></code> of the output array. It is recommended to provide this.
If not provided, will be inferred by applying the function to a small
set of fake data.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">tuple, optional</span></dt><dd><p>Chunk shape of resulting blocks if the function does not preserve
shape. If not provided, the resulting array is assumed to have the same
block structure as the first input array.</p>
</dd>
<dt><strong>drop_axis</strong><span class="classifier">number or iterable, optional</span></dt><dd><p>Dimensions lost by the function.</p>
</dd>
<dt><strong>new_axis</strong><span class="classifier">number or iterable, optional</span></dt><dd><p>New dimensions created by the function. Note that these are applied
after <code class="docutils literal notranslate"><span class="pre">drop_axis</span></code> (if present).</p>
</dd>
<dt><strong>token</strong><span class="classifier">string, optional</span></dt><dd><p>The key prefix to use for the output array. If not provided, will be
determined from the function name.</p>
</dd>
<dt><strong>name</strong><span class="classifier">string, optional</span></dt><dd><p>The key name to use for the output array. Note that this fully
specifies the output key name, and must be unique. If not provided,
will be determined by a hash of the arguments.</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Other keyword arguments to pass to function. Values must be constants
(not dask.arrays)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#dask.array.blockwise" title="dask.array.blockwise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.blockwise</span></code></a></dt><dd><p>Generalized operation with control over block alignment.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([ 0,  2,  4,  6,  8, 10])</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">da.map_blocks</span></code> function can also accept multiple arrays.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([ 0,  2,  6, 12, 20])</span>
</pre></div>
</div>
<p>If the function changes shape of the blocks then you must provide chunks
explicitly.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),))</span>
</pre></div>
</div>
<p>You have a bit of freedom in specifying chunks.  If all of the output chunk
sizes are the same, you can provide just that chunk size as a single tuple.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
</pre></div>
</div>
<p>If the function changes the dimension of the blocks you must specify the
created or destroyed dimensions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="n">new_axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">chunks</span></code> is specified but <code class="docutils literal notranslate"><span class="pre">new_axis</span></code> is not, then it is inferred to
add the necessary number of axes on the left.</p>
<p>Map_blocks aligns blocks by block positions without regard to shape. In the
following example we have two arrays with the same number of blocks but
with different shape and chunk sizes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
</pre></div>
</div>
<p>The relevant attribute to match is numblocks.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">numblocks</span>
<span class="go">(10,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">numblocks</span>
<span class="go">(10,)</span>
</pre></div>
</div>
<p>If these match (up to broadcasting rules) then we can map arbitrary
functions across blocks</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i8&#39;</span><span class="p">)</span>
<span class="go">dask.array&lt;func, shape=(20,), dtype=int64, chunksize=(2,), chunktype=numpy.ndarray&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([ 99,   9, 199,  19, 299,  29, 399,  39, 499,  49, 599,  59, 699,</span>
<span class="go">        69, 799,  79, 899,  89, 999,  99])</span>
</pre></div>
</div>
<p>Your block function get information about where it is in the array by
accepting a special <code class="docutils literal notranslate"><span class="pre">block_info</span></code> keyword argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">block_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
</pre></div>
</div>
<p>This will receive the following information:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_info</span>  
<span class="go">{0: {&#39;shape&#39;: (1000,),</span>
<span class="go">     &#39;num-chunks&#39;: (10,),</span>
<span class="go">     &#39;chunk-location&#39;: (4,),</span>
<span class="go">     &#39;array-location&#39;: [(400, 500)]},</span>
<span class="go"> None: {&#39;shape&#39;: (1000,),</span>
<span class="go">        &#39;num-chunks&#39;: (10,),</span>
<span class="go">        &#39;chunk-location&#39;: (4,),</span>
<span class="go">        &#39;array-location&#39;: [(400, 500)],</span>
<span class="go">        &#39;chunk-shape&#39;: (100,),</span>
<span class="go">        &#39;dtype&#39;: dtype(&#39;float64&#39;)}}</span>
</pre></div>
</div>
<p>For each argument and keyword arguments that are dask arrays (the positions
of which are the first index), you will receive the shape of the full
array, the number of chunks of the full array in each dimension, the chunk
location (for example the fourth chunk over in the first dimension), and
the array location (for example the slice corresponding to <code class="docutils literal notranslate"><span class="pre">40:50</span></code>). The
same information is provided for the output, with the key <code class="docutils literal notranslate"><span class="pre">None</span></code>, plus
the shape and dtype that should be returned.</p>
<p>These features can be combined to synthesize an array from scratch, for
example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">block_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">loc</span> <span class="o">=</span> <span class="n">block_info</span><span class="p">[</span><span class="kc">None</span><span class="p">][</span><span class="s1">&#39;array-location&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
<span class="go">dask.array&lt;func, shape=(8,), dtype=float64, chunksize=(4,), chunktype=numpy.ndarray&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7])</span>
</pre></div>
</div>
<p>You may specify the key name prefix of the resulting task in the graph with
the optional <code class="docutils literal notranslate"><span class="pre">token</span></code> keyword argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;increment&#39;</span><span class="p">)</span>  
<span class="go">dask.array&lt;increment, shape=(100,), dtype=int64, chunksize=(10,), chunktype=numpy.ndarray&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.map_overlap">
<code class="sig-name descname">map_overlap</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">depth</em>, <em class="sig-param">boundary=None</em>, <em class="sig-param">trim=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.map_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a function over blocks of the array with some overlap</p>
<p>We share neighboring zones between blocks of the array, then map a
function, then trim away the neighboring strips.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func: function</strong></dt><dd><p>The function to apply to each extended block</p>
</dd>
<dt><strong>depth: int, tuple, or dict</strong></dt><dd><p>The number of elements that each block should share with its neighbors
If a tuple or dict then this can be different per axis</p>
</dd>
<dt><strong>boundary: str, tuple, dict</strong></dt><dd><p>How to handle the boundaries.
Values include ‘reflect’, ‘periodic’, ‘nearest’, ‘none’,
or any constant value like 0 or np.nan</p>
</dd>
<dt><strong>trim: bool</strong></dt><dd><p>Whether or not to trim <code class="docutils literal notranslate"><span class="pre">depth</span></code> elements from each block after
calling the map function.
Set this to False if your mapping function already does this for you</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>Other keyword arguments valid in <code class="docutils literal notranslate"><span class="pre">map_blocks</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span><span class="n">derivative</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([ 1,  0,  1,  1,  0,  0, -1, -1,  0])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([[16, 17, 18, 19],</span>
<span class="go">       [20, 21, 22, 23],</span>
<span class="go">       [24, 25, 26, 27],</span>
<span class="go">       [28, 29, 30, 31]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">depth</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">boundary</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;none&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>  
<span class="go">array([[12,  13,  14,  15],</span>
<span class="go">       [16,  17,  18,  19],</span>
<span class="go">       [20,  21,  22,  23],</span>
<span class="go">       [24,  25,  26,  27]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">initial=&lt;no value&gt;</em>, <em class="sig-param">where=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.max" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.max.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the maximum along a given axis.</p>
<p>Refer to <cite>numpy.amax</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.amax.html#numpy.amax" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.amax</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.mean.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns the average of the array elements along given axis.</p>
<p>Refer to <cite>numpy.mean</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.mean.html#numpy.mean" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.mean</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">initial=&lt;no value&gt;</em>, <em class="sig-param">where=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.min" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.min.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the minimum along a given axis.</p>
<p>Refer to <cite>numpy.amin</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.amin.html#numpy.amin" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.amin</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.moment">
<code class="sig-name descname">moment</code><span class="sig-paren">(</span><em class="sig-param">order</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">ddof=0</em>, <em class="sig-param">split_every=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the nth centralized moment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>Order of the moment that is returned, must be &gt;= 2.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which the central moment is computed. The default is to
compute the moment of the flattened array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Type to use in computing the moment. For arrays of integer type the
default is float64; for arrays of float types it is the same as the
array type.</p>
</dd>
<dt><strong>keepdims</strong><span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the original array.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, optional</span></dt><dd><p>“Delta Degrees of Freedom”: the divisor used in the calculation is
N - ddof, where N represents the number of elements. By default
ddof is zero.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>moment</strong><span class="classifier">ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5d65cf9270ff-1"><span class="brackets"><a class="fn-backref" href="#id143">1</a></span></dt>
<dd><p>Pebay, Philippe (2008), “Formulas for Robust, One-Pass Parallel
Computation of Covariances and Arbitrary-Order Statistical Moments”,
Technical Report SAND2008-6212, Sandia National Laboratories.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.nbytes">
<em class="property">property </em><code class="sig-name descname">nbytes</code><a class="headerlink" href="#dask.array.Array.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of bytes in array</p>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.nonzero">
<code class="sig-name descname">nonzero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.nonzero.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the indices of the elements that are non-zero.</p>
<p>Refer to <cite>numpy.nonzero</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.nonzero.html#numpy.nonzero" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.nonzero</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.partitions">
<em class="property">property </em><code class="sig-name descname">partitions</code><a class="headerlink" href="#dask.array.Array.partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice an array by partitions. Alias of dask array .blocks attribute.</p>
<p>This alias allows you to write agnostic code that works with both
dask arrays and dask dataframes.</p>
<p>This allows blockwise slicing of a Dask array.  You can perform normal
Numpy-style slicing but now rather than slice elements of the array you
slice along blocks so, for example, <code class="docutils literal notranslate"><span class="pre">x.blocks[0,</span> <span class="pre">::2]</span></code> produces a new
dask array with every other block in the first row of blocks.</p>
<p>You can index blocks in any way that could index a numpy array of shape
equal to the number of blocks in each dimension, (available as
array.numblocks).  The dimension of the output array will be the same
as the dimension of this array, even if integer indices are passed.
This does not support slicing with <code class="docutils literal notranslate"><span class="pre">np.newaxis</span></code> or multiple lists.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A Dask array</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">partitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">partitions</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([0, 1, 2, 3, 4, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">partitions</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([0, 1, 4, 5, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">partitions</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([8, 9, 0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">partitions</span><span class="p">[:]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">blocks</span><span class="p">[:]</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.prod">
<code class="sig-name descname">prod</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">initial=1</em>, <em class="sig-param">where=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.prod.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the product of the array elements over the given axis</p>
<p>Refer to <cite>numpy.prod</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.prod.html#numpy.prod" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.prod</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.ravel">
<code class="sig-name descname">ravel</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">order</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.ravel.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return a flattened array.</p>
<p>Refer to <cite>numpy.ravel</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html#numpy.ravel" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ravel</span></code></a></dt><dd><p>equivalent function</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.flat</span></code></dt><dd><p>a flat iterator on the array.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.rechunk">
<code class="sig-name descname">rechunk</code><span class="sig-paren">(</span><em class="sig-param">chunks='auto'</em>, <em class="sig-param">threshold=None</em>, <em class="sig-param">block_size_limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.rechunk" title="Permalink to this definition">¶</a></dt>
<dd><p>See da.rechunk for docstring</p>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.repeat">
<code class="sig-name descname">repeat</code><span class="sig-paren">(</span><em class="sig-param">repeats</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.repeat.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Repeat elements of an array.</p>
<p>Refer to <cite>numpy.repeat</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.repeat.html#numpy.repeat" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.repeat</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.reshape">
<code class="sig-name descname">reshape</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.reshape.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns an array containing the same data with a new shape.</p>
<p>Refer to <cite>numpy.reshape</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html#numpy.reshape" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.reshape</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Unlike the free function <cite>numpy.reshape</cite>, this method on <cite>ndarray</cite> allows
the elements of the shape parameter to be passed in as separate arguments.
For example, <code class="docutils literal notranslate"><span class="pre">a.reshape(10,</span> <span class="pre">11)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">a.reshape((10,</span> <span class="pre">11))</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.round">
<code class="sig-name descname">round</code><span class="sig-paren">(</span><em class="sig-param">decimals=0</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.round" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.round.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return <cite>a</cite> with each element rounded to the given number of decimals.</p>
<p>Refer to <cite>numpy.around</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.around.html#numpy.around" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.around</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.size">
<em class="property">property </em><code class="sig-name descname">size</code><a class="headerlink" href="#dask.array.Array.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of elements in array</p>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.squeeze">
<code class="sig-name descname">squeeze</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.squeeze.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Remove single-dimensional entries from the shape of <cite>a</cite>.</p>
<p>Refer to <cite>numpy.squeeze</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.squeeze.html#numpy.squeeze" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.squeeze</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">ddof=0</em>, <em class="sig-param">keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.std" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.std.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns the standard deviation of the array elements along given axis.</p>
<p>Refer to <cite>numpy.std</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.std.html#numpy.std" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.std</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.store">
<code class="sig-name descname">store</code><span class="sig-paren">(</span><em class="sig-param">targets</em>, <em class="sig-param">lock=True</em>, <em class="sig-param">regions=None</em>, <em class="sig-param">compute=True</em>, <em class="sig-param">return_stored=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.store" title="Permalink to this definition">¶</a></dt>
<dd><p>Store dask arrays in array-like objects, overwrite data in target</p>
<p>This stores dask arrays into object that supports numpy-style setitem
indexing.  It stores values chunk by chunk so that it does not have to
fill up memory.  For best performance you can align the block size of
the storage target with the block size of your array.</p>
<p>If your data fits in memory then you may prefer calling
<code class="docutils literal notranslate"><span class="pre">np.array(myarray)</span></code> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sources: Array or iterable of Arrays</strong></dt><dd></dd>
<dt><strong>targets: array-like or Delayed or iterable of array-likes and/or Delayeds</strong></dt><dd><p>These should support setitem syntax <code class="docutils literal notranslate"><span class="pre">target[10:20]</span> <span class="pre">=</span> <span class="pre">...</span></code></p>
</dd>
<dt><strong>lock: boolean or threading.Lock, optional</strong></dt><dd><p>Whether or not to lock the data stores while storing.
Pass True (lock each file individually), False (don’t lock) or a
particular <code class="docutils literal notranslate"><span class="pre">threading.Lock</span></code> object to be shared among all writes.</p>
</dd>
<dt><strong>regions: tuple of slices or list of tuples of slices</strong></dt><dd><p>Each <code class="docutils literal notranslate"><span class="pre">region</span></code> tuple in <code class="docutils literal notranslate"><span class="pre">regions</span></code> should be such that
<code class="docutils literal notranslate"><span class="pre">target[region].shape</span> <span class="pre">=</span> <span class="pre">source.shape</span></code>
for the corresponding source and target in sources and targets,
respectively. If this is a tuple, the contents will be assumed to be
slices, so do not provide a tuple of tuples.</p>
</dd>
<dt><strong>compute: boolean, optional</strong></dt><dd><p>If true compute immediately, return <code class="docutils literal notranslate"><span class="pre">dask.delayed.Delayed</span></code> otherwise</p>
</dd>
<dt><strong>return_stored: boolean, optional</strong></dt><dd><p>Optionally return the stored result (default False).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="o">...</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">h5py</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;myfile.hdf5&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">dset</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;/data&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">chunks</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">store</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dset</span><span class="p">)</span>  
</pre></div>
</div>
<p>Alternatively store many arrays at the same time</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">store</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="p">[</span><span class="n">dset1</span><span class="p">,</span> <span class="n">dset2</span><span class="p">,</span> <span class="n">dset3</span><span class="p">])</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">keepdims=False</em>, <em class="sig-param">initial=0</em>, <em class="sig-param">where=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.sum.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the sum of the array elements over the given axis.</p>
<p>Refer to <cite>numpy.sum</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html#numpy.sum" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.sum</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.swapaxes">
<code class="sig-name descname">swapaxes</code><span class="sig-paren">(</span><em class="sig-param">axis1</em>, <em class="sig-param">axis2</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.swapaxes.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</p>
<p>Refer to <cite>numpy.swapaxes</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.swapaxes.html#numpy.swapaxes" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.swapaxes</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.to_dask_dataframe">
<code class="sig-name descname">to_dask_dataframe</code><span class="sig-paren">(</span><em class="sig-param">columns=None</em>, <em class="sig-param">index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.to_dask_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert dask Array to dask Dataframe</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>columns: list or string</strong></dt><dd><p>list of column names if DataFrame, single string if Series</p>
</dd>
<dt><strong>index</strong><span class="classifier">dask.dataframe.Index, optional</span></dt><dd><p>An optional <em>dask</em> Index to use for the output Series or DataFrame.</p>
<p>The default output index depends on whether the array has any unknown
chunks. If there are any unknown chunks, the output has <code class="docutils literal notranslate"><span class="pre">None</span></code>
for all the divisions (one per chunk). If all the chunks are known,
a default index with known divsions is created.</p>
<p>Specifying <code class="docutils literal notranslate"><span class="pre">index</span></code> can be useful if you’re conforming a Dask Array
to an existing dask Series or DataFrame, and you would like the
indices to match.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="dataframe-api.html#dask.dataframe.from_dask_array" title="dask.dataframe.from_dask_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.dataframe.from_dask_array</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.to_delayed">
<code class="sig-name descname">to_delayed</code><span class="sig-paren">(</span><em class="sig-param">optimize_graph=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.to_delayed" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert into an array of <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> objects, one per chunk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>optimize_graph</strong><span class="classifier">bool, optional</span></dt><dd><p>If True [default], the graph is optimized before converting into
<code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> objects.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#dask.array.from_delayed" title="dask.array.from_delayed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.from_delayed</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.to_hdf5">
<code class="sig-name descname">to_hdf5</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">datapath</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.to_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Store array in HDF5 file</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_hdf5</span><span class="p">(</span><span class="s1">&#39;myfile.hdf5&#39;</span><span class="p">,</span> <span class="s1">&#39;/x&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>Optionally provide arguments as though to <code class="docutils literal notranslate"><span class="pre">h5py.File.create_dataset</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_hdf5</span><span class="p">(</span><span class="s1">&#39;myfile.hdf5&#39;</span><span class="p">,</span> <span class="s1">&#39;/x&#39;</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s1">&#39;lzf&#39;</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">da.store</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">h5py.File.create_dataset</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.to_svg">
<code class="sig-name descname">to_svg</code><span class="sig-paren">(</span><em class="sig-param">size=500</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.to_svg" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert chunks from Dask Array into an SVG Image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chunks: tuple</strong></dt><dd></dd>
<dt><strong>size: int</strong></dt><dd><p>Rough size of the image</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>text: An svg string depicting the array as a grid of chunks</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_svg</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.to_tiledb">
<code class="sig-name descname">to_tiledb</code><span class="sig-paren">(</span><em class="sig-param">uri</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.to_tiledb" title="Permalink to this definition">¶</a></dt>
<dd><p>Save array to the TileDB storage manager</p>
<p>See function <code class="docutils literal notranslate"><span class="pre">to_tiledb()</span></code> for argument documentation.</p>
<p>See <a class="reference external" href="https://docs.tiledb.io">https://docs.tiledb.io</a> for details about the format and engine.</p>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.to_zarr">
<code class="sig-name descname">to_zarr</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.to_zarr" title="Permalink to this definition">¶</a></dt>
<dd><p>Save array to the zarr storage format</p>
<p>See <a class="reference external" href="https://zarr.readthedocs.io">https://zarr.readthedocs.io</a> for details about the format.</p>
<p>See function <code class="docutils literal notranslate"><span class="pre">to_zarr()</span></code> for parameters.</p>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.topk">
<code class="sig-name descname">topk</code><span class="sig-paren">(</span><em class="sig-param">k</em>, <em class="sig-param">axis=-1</em>, <em class="sig-param">split_every=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.topk" title="Permalink to this definition">¶</a></dt>
<dd><p>The top k elements of an array.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">da.topk</span></code> for docstring</p>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.trace">
<code class="sig-name descname">trace</code><span class="sig-paren">(</span><em class="sig-param">offset=0</em>, <em class="sig-param">axis1=0</em>, <em class="sig-param">axis2=1</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.trace.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Return the sum along diagonals of the array.</p>
<p>Refer to <cite>numpy.trace</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.trace.html#numpy.trace" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.trace</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.transpose">
<code class="sig-name descname">transpose</code><span class="sig-paren">(</span><em class="sig-param">*axes</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.transpose.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns a view of the array with axes transposed.</p>
<p>For a 1-D array this has no effect, as a transposed vector is simply the
same vector. To convert a 1-D array into a 2D column vector, an additional
dimension must be added. <cite>np.atleast2d(a).T</cite> achieves this, as does
<cite>a[:, np.newaxis]</cite>.
For a 2-D array, this is a standard matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
<code class="docutils literal notranslate"><span class="pre">a.shape</span> <span class="pre">=</span> <span class="pre">(i[0],</span> <span class="pre">i[1],</span> <span class="pre">...</span> <span class="pre">i[n-2],</span> <span class="pre">i[n-1])</span></code>, then
<code class="docutils literal notranslate"><span class="pre">a.transpose().shape</span> <span class="pre">=</span> <span class="pre">(i[n-1],</span> <span class="pre">i[n-2],</span> <span class="pre">...</span> <span class="pre">i[1],</span> <span class="pre">i[0])</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>axes</strong><span class="classifier">None, tuple of ints, or <cite>n</cite> ints</span></dt><dd><ul class="simple">
<li><p>None or no argument: reverses the order of the axes.</p></li>
<li><p>tuple of ints: <cite>i</cite> in the <cite>j</cite>-th place in the tuple means <cite>a</cite>’s
<cite>i</cite>-th axis becomes <cite>a.transpose()</cite>’s <cite>j</cite>-th axis.</p></li>
<li><p><cite>n</cite> ints: same as an n-tuple of the same ints (this form is
intended simply as a “convenience” alternative to the tuple form)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>View of <cite>a</cite>, with axes suitably permuted.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.T</span></code></dt><dd><p>Array property returning the array transposed.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray.reshape</span></code></dt><dd><p>Give a new shape to an array without changing its data.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>  
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>  
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">ddof=0</em>, <em class="sig-param">keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.var" title="Permalink to this definition">¶</a></dt>
<dd><p>This docstring was copied from numpy.ndarray.var.</p>
<p>Some inconsistencies with the Dask version may exist.</p>
<p>Returns the variance of the array elements, along given axis.</p>
<p>Refer to <cite>numpy.var</cite> for full documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.var.html#numpy.var" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.var</span></code></a></dt><dd><p>equivalent function</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.view">
<code class="sig-name descname">view</code><span class="sig-paren">(</span><em class="sig-param">dtype=None</em>, <em class="sig-param">order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#dask.array.Array.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a view of the array as a new data type</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype:</strong></dt><dd><p>The dtype by which to view the array.
The default, None, results in the view having the same data-type
as the original array.</p>
</dd>
<dt><strong>order: string</strong></dt><dd><p>‘C’ or ‘F’ (Fortran) ordering</p>
</dd>
<dt><strong>This reinterprets the bytes of the array under a new dtype.  If that</strong></dt><dd></dd>
<dt><strong>dtype does not have the same size as the original array then the shape</strong></dt><dd></dd>
<dt><strong>will change.</strong></dt><dd></dd>
<dt><strong>Beware that both numpy and dask.array can behave oddly when taking</strong></dt><dd></dd>
<dt><strong>shape-changing views of arrays under Fortran ordering.  Under some</strong></dt><dd></dd>
<dt><strong>versions of NumPy this function will fail when taking shape-changing</strong></dt><dd></dd>
<dt><strong>views of Fortran ordered arrays if the first dimension has chunks of</strong></dt><dd></dd>
<dt><strong>size one.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dask.array.Array.vindex">
<em class="property">property </em><code class="sig-name descname">vindex</code><a class="headerlink" href="#dask.array.Array.vindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorized indexing with broadcasting.</p>
<p>This is equivalent to numpy’s advanced indexing, using arrays that are
broadcast against each other. This allows for pointwise indexing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">from_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">vindex</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">array([1, 5, 9])</span>
</pre></div>
</div>
<p>Mixed basic/advanced indexing with slices/arrays is also supported. The
order of dimensions in the result follows those proposed for
<a class="reference external" href="https://github.com/numpy/numpy/pull/6256">ndarray.vindex</a>:
the subspace spanned by arrays is followed by all slices.</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">vindex</span></code> provides more general functionality than standard
indexing, but it also has fewer optimizations and can be significantly
slower.</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="array-best-practices.html" class="btn btn-neutral float-right" title="Best Practices" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="array.html" class="btn btn-neutral float-left" title="Array" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014-2018, Anaconda, Inc. and contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>