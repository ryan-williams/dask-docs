








<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Futures &mdash; Dask 2.13.0+4.gf26bb993.dirty documentation</title>
  

  
  
  
  

  
  <link rel="stylesheet" href="_static/css/style.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  <link rel="stylesheet" href="_static/style.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/explore.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/nbsphinx.css" type="text/css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="_static/js/custom.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Best Practices" href="best-practices.html" />
    <link rel="prev" title="Best Practices" href="delayed-best-practices.html" />
    <link rel="shortcut icon" href="_static/images/favicon.ico"/>
  
</head>

<body class="wy-body-for-nav">

  
    <nav id="explore-links">
        <a href="https://docs.dask.org/">
        <img class="caption" src="_static/images/dask-horizontal-white.svg"/>
        </a>

        <ul>
        <li>
            <a>Get Started</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/install.html"> Install </a></li>
            <li><a href="https://examples.dask.org"> Examples </a></li>
            <li><a href="https://github.com/dask/dask-tutorial"> Tutorial </a></li>
            <li><a href="https://docs.dask.org/en/latest/why.html"> Why Dask? </a></li>
            <li><a href="https://stories.dask.org/en/latest"> Use Cases </a></li>
            <li><a href="https://www.youtube.com/watch?v=RA_2qdipVng&list=PLRtz5iA93T4PQvWuoMnIyEIz1fXiJ5Pri"> Talks </a></li>
            <li><a href="https://mybinder.org/v2/gh/dask/dask-examples/master?urlpath=lab"> Try Online </a></li>
            <li><a href="https://dask.org/slides"> Slides </a></li>
            </ul>
        </li>

        <li>
            <a href="">Algorithms</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/array.html">Arrays</a></li>
            <li><a href="https://docs.dask.org/en/latest/dataframe.html">Dataframes</a></li>
            <li><a href="https://docs.dask.org/en/latest/bag.html">Bags</a></li>
            <li><a href="https://docs.dask.org/en/latest/delayed.html">Delayed (custom)</a></li>
            <li><a href="https://docs.dask.org/en/latest/futures.html">Futures (real-time)</a></li>
            <li><a href="http://ml.dask.org">Machine Learning</a></li>
            <li><a href="https://xarray.pydata.org/en/latest/">XArray</a></li>
            </ul>
        </li>

        <li>
            <a href="https://docs.dask.org/en/latest/setup.html">Setup</a>
            <ul>
            <li><a href="https://docs.dask.org/en/latest/setup/single-machine.html"> Local </a></li>
            <li><a href="https://docs.dask.org/en/latest/setup/cloud.html"> Cloud </a></li>
            <li><a href="https://docs.dask.org/en/latest/setup/hpc.html"> HPC </a></li>
            <li><a href="https://kubernetes.dask.org/en/latest/"> Kubernetes </a></li>
            <li><a href="https://yarn.dask.org/en/latest/"> Hadoop / Yarn </a></li>
            </ul>
        </li>

        <li>
            <a>Community</a>
            <ul>
            <li><a href="http://docs.dask.org/en/latest/support.html">Ask for Help</a></li>
            <li><a href="https://github.com/dask">Github</a></li>
            <li><a href="https://stackoverflow.com/questions/tagged/dask">Stack Overflow</a></li>
            <li><a href="https://twitter.com/dask_dev">Twitter</a></li>
            <li><a href="https://blog.dask.org/"> Developer Blog </a></li>
            </ul>
        </li>
        </ul>

    </nav>
  
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Dask
          

          
          </a>

          
            
            
              <div class="version">
                2.13.0+4.gf26bb993.dirty
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Install Dask</a></li>
<li class="toctree-l1"><a class="reference internal" href="setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference external" href="https://stories.dask.org">Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="support.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="why.html">Why Dask?</a></li>
<li class="toctree-l1"><a class="reference internal" href="institutional-faq.html">Institutional FAQ</a></li>
</ul>
<p class="caption"><span class="caption-text">User Interface</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="user-interfaces.html">User Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="array.html">Array</a></li>
<li class="toctree-l1"><a class="reference internal" href="bag.html">Bag</a></li>
<li class="toctree-l1"><a class="reference internal" href="dataframe.html">DataFrame</a></li>
<li class="toctree-l1"><a class="reference internal" href="delayed.html">Delayed</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Futures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#start-dask-client">Start Dask Client</a></li>
<li class="toctree-l2"><a class="reference internal" href="#submit-tasks">Submit Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#move-data">Move Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references-cancellation-and-exceptions">References, Cancellation, and Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#waiting-on-futures">Waiting on Futures</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fire-and-forget">Fire and Forget</a></li>
<li class="toctree-l2"><a class="reference internal" href="#submit-tasks-from-tasks">Submit Tasks from Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coordination-primitives">Coordination Primitives</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#queues">Queues</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-variables">Global Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#locks">Locks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#publish-subscribe">Publish-Subscribe</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#actors">Actors</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-counter">Example: Counter</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-parameter-server">Example: Parameter Server</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynchronous-operation">Asynchronous Operation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#api">API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://ml.dask.org">Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="best-practices.html">Best Practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
</ul>
<p class="caption"><span class="caption-text">Scheduling</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="scheduling.html">Scheduling</a></li>
<li class="toctree-l1"><a class="reference external" href="https://distributed.dask.org/">Distributed Scheduling</a></li>
</ul>
<p class="caption"><span class="caption-text">Diagnostics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="understanding-performance.html">Understanding Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphviz.html">Visualize task graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics-local.html">Diagnostics (local)</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics-distributed.html">Diagnostics (distributed)</a></li>
<li class="toctree-l1"><a class="reference internal" href="debugging.html">Debugging</a></li>
</ul>
<p class="caption"><span class="caption-text">Help &amp; reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="develop.html">Development Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="educational-resources.html">Educational Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="presentations.html">Presentations On Dask</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheatsheet.html">Dask Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="spark.html">Comparison to Spark</a></li>
<li class="toctree-l1"><a class="reference internal" href="caching.html">Opportunistic Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphs.html">Task Graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="remote-data-services.html">Remote Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpu.html">GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="cite.html">Citations</a></li>
<li class="toctree-l1"><a class="reference internal" href="funding.html">Funding</a></li>
<li class="toctree-l1"><a class="reference internal" href="logos.html">Images and Logos</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Dask</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Futures</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/futures.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="futures">
<h1>Futures<a class="headerlink" href="#futures" title="Permalink to this headline">¶</a></h1>
<p>Dask supports a real-time task framework that extends Python’s
<a class="reference external" href="https://docs.python.org/3/library/concurrent.futures.html">concurrent.futures</a>
interface.  This interface is good for arbitrary task scheduling like
<a class="reference internal" href="delayed.html"><span class="doc">dask.delayed</span></a>, but is immediate rather than lazy, which
provides some more flexibility in situations where the computations may evolve
over time.</p>
<p>These features depend on the second generation task scheduler found in
<a class="reference external" href="https://distributed.dask.org/en/latest">dask.distributed</a> (which,
despite its name, runs very well on a single machine).</p>
<iframe width="560"
        height="315"
        src="https://www.youtube.com/embed/07EiCpdhtDE"
        style="margin: 0 auto 20px auto; display: block;"
        frameborder="0"
        allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
        allowfullscreen></iframe><div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>Visit <a class="reference external" href="https://examples.dask.org/futures.html">https://examples.dask.org/futures.html</a> to see and run examples
using futures with Dask.</p>
</div>
<div class="section" id="start-dask-client">
<h2>Start Dask Client<a class="headerlink" href="#start-dask-client" title="Permalink to this headline">¶</a></h2>
<p>You must start a <code class="docutils literal notranslate"><span class="pre">Client</span></code> to use the futures interface.  This tracks state
among the various worker processes or threads:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>

<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>  <span class="c1"># start local workers as processes</span>
<span class="c1"># or</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># start local workers as threads</span>
</pre></div>
</div>
<p>If you have <a class="reference external" href="https://bokeh.pydata.org">Bokeh</a> installed, then this starts up a
diagnostic dashboard at <a class="reference external" href="http://localhost:8787">http://localhost:8787</a> .</p>
</div>
<div class="section" id="submit-tasks">
<h2>Submit Tasks<a class="headerlink" href="#submit-tasks" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.submit" title="distributed.Client.submit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.submit</span></code></a>(func, *args[, key, workers, …])</p></td>
<td><p>Submit a function application to the scheduler</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.map" title="distributed.Client.map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.map</span></code></a>(func, *iterables[, key, workers, …])</p></td>
<td><p>Map a function on a sequence of arguments</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Future.result" title="distributed.Future.result"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.result</span></code></a>([timeout])</p></td>
<td><p>Wait until computation completes, gather result to local process.</p></td>
</tr>
</tbody>
</table>
<p>You can submit individual tasks using the <code class="docutils literal notranslate"><span class="pre">submit</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">inc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c1"># calls inc(10) in background thread or process</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>  <span class="c1"># calls inc(20) in background thread or process</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">submit</span></code> function returns a <code class="docutils literal notranslate"><span class="pre">Future</span></code>, which refers to a remote result.  This result may
not yet be completed:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">&lt;Future: status: pending, key: inc-b8aaf26b99466a7a1980efa1ade6701d&gt;</span>
</pre></div>
</div>
<p>Eventually it will complete.  The result stays in the remote
thread/process/worker until you ask for it back explicitly:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">&lt;Future: status: finished, type: int, key: inc-b8aaf26b99466a7a1980efa1ade6701d&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>  <span class="c1"># blocks until task completes and data arrives</span>
<span class="go">11</span>
</pre></div>
</div>
<p>You can pass futures as inputs to submit.  Dask automatically handles dependency
tracking; once all input futures have completed, they will be moved onto a
single worker (if necessary), and then the computation that depends on them
will be started.  You do not need to wait for inputs to finish before
submitting a new task; Dask will handle this automatically:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># calls add on the results of a and b</span>
</pre></div>
</div>
<p>Similar to Python’s <code class="docutils literal notranslate"><span class="pre">map</span></code>, you can use <code class="docutils literal notranslate"><span class="pre">Client.map</span></code> to call the same
function and many inputs:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">futures</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
</pre></div>
</div>
<p>However, note that each task comes with about 1ms of overhead.  If you want to
map a function over a large number of inputs, then you might consider
<a class="reference internal" href="bag.html"><span class="doc">dask.bag</span></a> or <a class="reference internal" href="dataframe.html"><span class="doc">dask.dataframe</span></a> instead.</p>
</div>
<div class="section" id="move-data">
<h2>Move Data<a class="headerlink" href="#move-data" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Future.result" title="distributed.Future.result"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.result</span></code></a>([timeout])</p></td>
<td><p>Wait until computation completes, gather result to local process.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.gather" title="distributed.Client.gather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.gather</span></code></a>(futures[, errors, direct, …])</p></td>
<td><p>Gather futures from distributed memory</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.scatter" title="distributed.Client.scatter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.scatter</span></code></a>(data[, workers, broadcast, …])</p></td>
<td><p>Scatter data into distributed memory</p></td>
</tr>
</tbody>
</table>
<p>Given any future, you can call the <code class="docutils literal notranslate"><span class="pre">.result</span></code> method to gather the result.
This will block until the future is done computing and then transfer the result
back to your local process if necessary:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">32</span>
</pre></div>
</div>
<p>You can gather many results concurrently using the <code class="docutils literal notranslate"><span class="pre">Client.gather</span></code> method.
This can be more efficient than calling <code class="docutils literal notranslate"><span class="pre">.result()</span></code> on each future
sequentially:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># results = [future.result() for future in futures]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">futures</span><span class="p">)</span>  <span class="c1"># this can be faster</span>
</pre></div>
</div>
<p>If you have important local data that you want to include in your computation,
you can either include it as a normal input to a submit or map call:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;training-data.csv&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">my_function</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>Or you can <code class="docutils literal notranslate"><span class="pre">scatter</span></code> it explicitly.  Scattering moves your data to a worker
and returns a future pointing to that data:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">remote_df</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">remote_df</span>
<span class="go">&lt;Future: status: finished, type: DataFrame, key: bbd0ca93589c56ea14af49cba470006e&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">my_function</span><span class="p">,</span> <span class="n">remote_df</span><span class="p">)</span>
</pre></div>
</div>
<p>Both of these accomplish the same result, but using scatter can sometimes be
faster.  This is especially true if you use processes or distributed workers
(where data transfer is necessary) and you want to use <code class="docutils literal notranslate"><span class="pre">df</span></code> in many
computations.  Scattering the data beforehand avoids excessive data movement.</p>
<p>Calling scatter on a list scatters all elements individually.  Dask will spread
these elements evenly throughout workers in a round-robin fashion:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[&lt;Future: status: finished, type: int, key: c0a8a20f903a4915b94db8de3ea63195&gt;,</span>
<span class="go"> &lt;Future: status: finished, type: int, key: 58e78e1b34eb49a68c65b54815d1b158&gt;,</span>
<span class="go"> &lt;Future: status: finished, type: int, key: d3395e15f605bc35ab1bac6341a285e2&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="references-cancellation-and-exceptions">
<h2>References, Cancellation, and Exceptions<a class="headerlink" href="#references-cancellation-and-exceptions" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Future.cancel" title="distributed.Future.cancel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.cancel</span></code></a>(**kwargs)</p></td>
<td><p>Cancel request to run this future</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Future.exception" title="distributed.Future.exception"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.exception</span></code></a>([timeout])</p></td>
<td><p>Return the exception of a failed task</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Future.traceback" title="distributed.Future.traceback"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.traceback</span></code></a>([timeout])</p></td>
<td><p>Return the traceback of a failed task</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.cancel" title="distributed.Client.cancel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.cancel</span></code></a>(futures[, asynchronous, force])</p></td>
<td><p>Cancel running futures</p></td>
</tr>
</tbody>
</table>
<p>Dask will only compute and hold onto results for which there are active
futures.  In this way, your local variables define what is active in Dask.  When
a future is garbage collected by your local Python session, Dask will feel free
to delete that data or stop ongoing computations that were trying to produce
it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">future</span>  <span class="c1"># deletes remote data once future is garbage collected</span>
</pre></div>
</div>
<p>You can also explicitly cancel a task using the <code class="docutils literal notranslate"><span class="pre">Future.cancel</span></code> or
<code class="docutils literal notranslate"><span class="pre">Client.cancel</span></code> methods:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">future</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>  <span class="c1"># deletes data even if other futures point to it</span>
</pre></div>
</div>
<p>If a future fails, then Dask will raise the remote exceptions and tracebacks if
you try to get the result:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">div</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># 1 / 0 raises a ZeroDivisionError</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="o">&lt;</span><span class="n">Future</span><span class="p">:</span> <span class="n">status</span><span class="p">:</span> <span class="n">error</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">div</span><span class="o">-</span><span class="mi">3601743182196</span><span class="n">fb56339e584a2bf1039</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
      <span class="mi">1</span> <span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="o">----&gt;</span> <span class="mi">2</span>     <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>

<span class="ne">ZeroDivisionError</span><span class="p">:</span> <span class="n">division</span> <span class="n">by</span> <span class="n">zero</span>
</pre></div>
</div>
<p>All futures that depend on an erred future also err with the same exception:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">&lt;Future: status: error, key: inc-15e2e4450a0227fa38ede4d6b1a952db&gt;</span>
</pre></div>
</div>
<p>You can collect the exception or traceback explicitly with the
<code class="docutils literal notranslate"><span class="pre">Future.exception</span></code> or <code class="docutils literal notranslate"><span class="pre">Future.traceback</span></code> methods.</p>
</div>
<div class="section" id="waiting-on-futures">
<h2>Waiting on Futures<a class="headerlink" href="#waiting-on-futures" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.as_completed" title="distributed.as_completed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_completed</span></code></a>([futures, loop, with_results, …])</p></td>
<td><p>Return futures in the order in which they complete</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.wait" title="distributed.wait"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait</span></code></a>(fs[, timeout, return_when])</p></td>
<td><p>Wait until all/any futures are finished</p></td>
</tr>
</tbody>
</table>
<p>You can wait on a future or collection of futures using the <code class="docutils literal notranslate"><span class="pre">wait</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">wait</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">wait</span><span class="p">(</span><span class="n">futures</span><span class="p">)</span>
</pre></div>
</div>
<p>This blocks until all futures are finished or have erred.</p>
<p>You can also iterate over the futures as they complete using the
<code class="docutils literal notranslate"><span class="pre">as_completed</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">as_completed</span>

<span class="n">futures</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">x_values</span><span class="p">)</span>

<span class="n">best</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">):</span>
   <span class="n">y</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
   <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">best</span><span class="p">:</span>
       <span class="n">best</span> <span class="o">=</span> <span class="n">y</span>
</pre></div>
</div>
<p>For greater efficiency, you can also ask <code class="docutils literal notranslate"><span class="pre">as_completed</span></code> to gather the results
in the background:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">future</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">,</span> <span class="n">with_results</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># y = future.result()  # don&#39;t need this</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>Or collect all futures in batches that had arrived since the last iteration:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">,</span> <span class="n">with_results</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">batches</span><span class="p">():</span>
   <span class="k">for</span> <span class="n">future</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">:</span>
       <span class="o">...</span>
</pre></div>
</div>
<p>Additionally, for iterative algorithms, you can add more futures into the
<code class="docutils literal notranslate"><span class="pre">as_completed</span></code> iterator <em>during</em> iteration:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="o">=</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">)</span>

<span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">condition</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="n">new_future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_future</span><span class="p">)</span>  <span class="c1"># add back into the loop</span>
</pre></div>
</div>
</div>
<div class="section" id="fire-and-forget">
<h2>Fire and Forget<a class="headerlink" href="#fire-and-forget" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.fire_and_forget" title="distributed.fire_and_forget"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fire_and_forget</span></code></a>(obj)</p></td>
<td><p>Run tasks at least once, even if we release the futures</p></td>
</tr>
</tbody>
</table>
<p>Sometimes we don’t care about gathering the result of a task, and only care
about side effects that it might have like writing a result to a file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out_filename</span><span class="p">)</span>
</pre></div>
</div>
<p>As noted above, Dask will stop work that doesn’t have any active futures.  It
thinks that because no one has a pointer to this data that no one cares.  You
can tell Dask to compute a task anyway, even if there are no active futures,
using the <code class="docutils literal notranslate"><span class="pre">fire_and_forget</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">fire_and_forget</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fire_and_forget</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>This is particularly useful when a future may go out of scope, for example, as
part of a function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">out_filename</span> <span class="o">=</span> <span class="s1">&#39;out-&#39;</span> <span class="o">+</span> <span class="n">filename</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out_filename</span><span class="p">)</span>
    <span class="n">fire_and_forget</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">return</span>  <span class="c1"># here we lose the reference to c, but that&#39;s now ok</span>

<span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
    <span class="n">process</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="submit-tasks-from-tasks">
<h2>Submit Tasks from Tasks<a class="headerlink" href="#submit-tasks-from-tasks" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.get_client" title="distributed.get_client"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_client</span></code></a>([address, timeout, resolve_address])</p></td>
<td><p>Get a client while within a task.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.rejoin" title="distributed.rejoin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rejoin</span></code></a>()</p></td>
<td><p>Have this thread rejoin the ThreadPoolExecutor</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.secede" title="distributed.secede"><code class="xref py py-obj docutils literal notranslate"><span class="pre">secede</span></code></a>()</p></td>
<td><p>Have this task secede from the worker’s thread pool</p></td>
</tr>
</tbody>
</table>
<p><em>This is an advanced feature and is rarely necessary in the common case.</em></p>
<p>Tasks can launch other tasks by getting their own client.  This enables complex
and highly dynamic workloads:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">get_client</span>

<span class="k">def</span> <span class="nf">my_function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="c1"># Get locally created client</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">get_client</span><span class="p">()</span>

    <span class="c1"># Do normal client operations, asking cluster for computation</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">gather</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>It also allows you to set up long running tasks that watch other resources like
sockets or physical sensors:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">monitor</span><span class="p">(</span><span class="n">device</span><span class="p">):</span>
   <span class="n">client</span> <span class="o">=</span> <span class="n">get_client</span><span class="p">()</span>
   <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
       <span class="n">data</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">read_data</span><span class="p">()</span>
       <span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
       <span class="n">fire_and_forget</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>

<span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">devices</span><span class="p">:</span>
    <span class="n">fire_and_forget</span><span class="p">(</span><span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">monitor</span><span class="p">))</span>
</pre></div>
</div>
<p>However, each running task takes up a single thread, and so if you launch many
tasks that launch other tasks, then it is possible to deadlock the system if you
are not careful.  You can call the <code class="docutils literal notranslate"><span class="pre">secede</span></code> function from within a task to
have it remove itself from the dedicated thread pool into an administrative
thread that does not take up a slot within the Dask worker:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">get_client</span><span class="p">,</span> <span class="n">secede</span>

<span class="k">def</span> <span class="nf">monitor</span><span class="p">(</span><span class="n">device</span><span class="p">):</span>
   <span class="n">client</span> <span class="o">=</span> <span class="n">get_client</span><span class="p">()</span>
   <span class="n">secede</span><span class="p">()</span>  <span class="c1"># remove this task from the thread pool</span>
   <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
       <span class="n">data</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">read_data</span><span class="p">()</span>
       <span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
       <span class="n">fire_and_forget</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
</pre></div>
</div>
<p>If you intend to do more work in the same thread after waiting on client work,
you may want to explicitly block until the thread is able to <em>rejoin</em> the
thread pool.  This allows some control over the number of threads that are
created and stops too many threads from being active at once, over-saturating
your hardware:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>  <span class="c1"># assume that this runs as a task</span>
   <span class="n">client</span> <span class="o">=</span> <span class="n">get_client</span><span class="p">()</span>

   <span class="n">secede</span><span class="p">()</span>  <span class="c1"># secede while we wait for results to come back</span>
   <span class="n">futures</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
   <span class="n">results</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">futures</span><span class="p">)</span>

   <span class="n">rejoin</span><span class="p">()</span>  <span class="c1"># block until a slot is open in the thread pool</span>
   <span class="n">result</span> <span class="o">=</span> <span class="n">analyze</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>Alternatively, you can just use the normal <code class="docutils literal notranslate"><span class="pre">compute</span></code> function <em>within</em> a
task.  This will automatically call <code class="docutils literal notranslate"><span class="pre">secede</span></code> and <code class="docutils literal notranslate"><span class="pre">rejoin</span></code> appropriately:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>  <span class="c1"># note that this is a dask collection</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

    <span class="c1"># This calls secede</span>
    <span class="c1"># Then runs the computation on the cluster (including this worker)</span>
    <span class="c1"># Then blocks on rejoin, and finally delivers the answer</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="coordination-primitives">
<h2>Coordination Primitives<a class="headerlink" href="#coordination-primitives" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Queue" title="distributed.Queue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Queue</span></code></a>([name, client, maxsize])</p></td>
<td><p>Distributed Queue</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Variable" title="distributed.Variable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Variable</span></code></a>([name, client, maxsize])</p></td>
<td><p>Distributed Global Variable</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Lock" title="distributed.Lock"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lock</span></code></a>([name, client])</p></td>
<td><p>Distributed Centralized Lock</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Pub" title="distributed.Pub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pub</span></code></a>(name[, worker, client])</p></td>
<td><p>Publish data with Publish-Subscribe pattern</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Sub" title="distributed.Sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sub</span></code></a>(name[, worker, client])</p></td>
<td><p>Subscribe to a Publish/Subscribe topic</p></td>
</tr>
</tbody>
</table>
<p>Sometimes situations arise where tasks, workers, or clients need to coordinate
with each other in ways beyond normal task scheduling with futures.  In these
cases Dask provides additional primitives to help in complex situations.</p>
<p>Dask provides distributed versions of coordination primitives like locks,
queues, global variables, and pub-sub systems that, where appropriate, match
their in-memory counterparts.  These can be used to control access to external
resources, track progress of ongoing computations, or share data in
side-channels between many workers, clients, and tasks sensibly.</p>
<iframe width="560"
        height="315"
        src="https://www.youtube.com/embed/Q-Y3BR1u7c0"
        style="margin: 0 auto 20px auto; display: block;"
        frameborder="0"
        allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
        allowfullscreen></iframe><p>These features are rarely necessary for common use of Dask.  We recommend that
beginning users stick with using the simpler futures found above (like
<code class="docutils literal notranslate"><span class="pre">Client.submit</span></code> and <code class="docutils literal notranslate"><span class="pre">Client.gather</span></code>) rather than embracing needlessly
complex techniques.</p>
<div class="section" id="queues">
<h3>Queues<a class="headerlink" href="#queues" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Queue" title="distributed.Queue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Queue</span></code></a>([name, client, maxsize])</p></td>
<td><p>Distributed Queue</p></td>
</tr>
</tbody>
</table>
<p>Dask queues follow the API for the standard Python Queue, but now move futures
or small messages between clients.  Queues serialize sensibly and reconnect
themselves on remote clients if necessary:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">load_and_submit</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">get_client</span><span class="p">()</span>
    <span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>

<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>

<span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

<span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
    <span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">load_and_submit</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="n">fire_and_forget</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>

<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">future</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
</pre></div>
</div>
<p>Queues can also send small pieces of information, anything that is msgpack
encodable (ints, strings, bools, lists, dicts, etc.).  This can be useful to
send back small scores or administrative messages:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
       <span class="o">...</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">error_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

<span class="n">error_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
</pre></div>
</div>
<p>Queues are mediated by the central scheduler, and so they are not ideal for
sending large amounts of data (everything you send will be routed through a
central point).  They are well suited to move around small bits of metadata, or
futures.  These futures may point to much larger pieces of data safely:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="o">...</span> <span class="c1"># my large numpy array</span>

<span class="go"># Don&#39;t do this!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="go"># Do this instead</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>

<span class="go"># Or use futures for metadata</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">({</span><span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;OK&#39;</span><span class="p">,</span> <span class="s1">&#39;stage=&#39;</span><span class="p">:</span> <span class="mi">1234</span><span class="p">})</span>
</pre></div>
</div>
<p>If you’re looking to move large amounts of data between workers, then you might
also want to consider the Pub/Sub system described a few sections below.</p>
</div>
<div class="section" id="global-variables">
<h3>Global Variables<a class="headerlink" href="#global-variables" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Variable" title="distributed.Variable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Variable</span></code></a>([name, client, maxsize])</p></td>
<td><p>Distributed Global Variable</p></td>
</tr>
</tbody>
</table>
<p>Variables are like Queues in that they communicate futures and small data
between clients.  However, variables hold only a single value.  You can get or
set that value at any time:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;stopping-criterion&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This is often used to signal stopping criteria or current parameters
between clients.</p>
<p>If you want to share large pieces of information, then scatter the data first:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="locks">
<h3>Locks<a class="headerlink" href="#locks" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Lock" title="distributed.Lock"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lock</span></code></a>([name, client])</p></td>
<td><p>Distributed Centralized Lock</p></td>
</tr>
</tbody>
</table>
<p>You can also hold onto cluster-wide locks using the <code class="docutils literal notranslate"><span class="pre">Lock</span></code> object.
Dask Locks have the same API as normal <code class="docutils literal notranslate"><span class="pre">threading.Lock</span></code> objects, except that
they work across the cluster:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Lock</span>
<span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

<span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
    <span class="c1"># access protected resource</span>
</pre></div>
</div>
<p>You can manage several locks at the same time.  Lock can either be given a
consistent name or you can pass the lock object around itself.</p>
<p>Using a consistent name is convenient when you want to lock some known named resource:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Lock</span>

<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">Lock</span><span class="p">(</span><span class="s1">&#39;the-production-database&#39;</span><span class="p">):</span>
        <span class="c1"># read data from filename using some sensitive source</span>
        <span class="k">return</span> <span class="o">...</span>

<span class="n">futures</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">filenames</span><span class="p">)</span>
</pre></div>
</div>
<p>Passing around a lock works as well and is easier when you want to create short-term
locks for a particular situation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Lock</span>
<span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
        <span class="c1"># read data from filename using some sensitive source</span>
        <span class="k">return</span> <span class="o">...</span>

<span class="n">futures</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">)</span>
</pre></div>
</div>
<p>This can be useful if you want to control concurrent access to some external
resource like a database or un-thread-safe library.</p>
</div>
<div class="section" id="publish-subscribe">
<h3>Publish-Subscribe<a class="headerlink" href="#publish-subscribe" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Pub" title="distributed.Pub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pub</span></code></a>(name[, worker, client])</p></td>
<td><p>Publish data with Publish-Subscribe pattern</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Sub" title="distributed.Sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sub</span></code></a>(name[, worker, client])</p></td>
<td><p>Subscribe to a Publish/Subscribe topic</p></td>
</tr>
</tbody>
</table>
<p>Dask implements the <a class="reference external" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Publish Subscribe pattern</a>,
providing an additional channel of communication between ongoing tasks.</p>
<dl class="class">
<dt id="distributed.Pub">
<em class="property">class </em><code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">Pub</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">worker=None</em>, <em class="sig-param">client=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Pub" title="Permalink to this definition">¶</a></dt>
<dd><p>Publish data with Publish-Subscribe pattern</p>
<p>This allows clients and workers to directly communicate data between each
other with a typical Publish-Subscribe pattern.  This involves two
components,</p>
<p>Pub objects, into which we put data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pub</span> <span class="o">=</span> <span class="n">Pub</span><span class="p">(</span><span class="s1">&#39;my-topic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pub</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
</pre></div>
</div>
<p>And Sub objects, from which we collect data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span> <span class="o">=</span> <span class="n">Sub</span><span class="p">(</span><span class="s1">&#39;my-topic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="go">123</span>
</pre></div>
</div>
<p>Many Pub and Sub objects can exist for the same topic.  All data sent from
any Pub will be sent to all Sub objects on that topic that are currently
connected.  Pub’s and Sub’s find each other using the scheduler, but they
communicate directly with each other without coordination from the
scheduler.</p>
<p>Pubs and Subs use the central scheduler to find each other, but not to
mediate the communication.  This means that there is very little additional
latency or overhead, and they are appropriate for very frequent data
transfers.  For context, most data transfer first checks with the scheduler to find which
workers should participate, and then does direct worker-to-worker
transfers.  This checking in with the scheduler provides some stability
guarantees, but also adds in a few extra network hops.  PubSub doesn’t do
this, and so is faster, but also can easily drop messages if Pubs or Subs
disappear without notice.</p>
<p>When using a Pub or Sub from a Client all communications will be routed
through the scheduler.  This can cause some performance degradation.  Pubs
and Subs only operate at top-speed when they are both on workers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name: object (msgpack serializable)</strong></dt><dd><p>The name of the group of Pubs and Subs on which to participate.</p>
</dd>
<dt><strong>worker: Worker (optional)</strong></dt><dd><p>The worker to be used for publishing data. Defaults to the value of
<code class="docutils literal notranslate"><span class="pre">`get_worker()`</span></code>. If given, <code class="docutils literal notranslate"><span class="pre">client</span></code> must be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>client: Client (optional)</strong></dt><dd><p>Client used for communication with the scheduler. Defaults to
the value of <code class="docutils literal notranslate"><span class="pre">get_client()</span></code>. If given, <code class="docutils literal notranslate"><span class="pre">worker</span></code> must be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Sub" title="distributed.Sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sub</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pub</span> <span class="o">=</span> <span class="n">Pub</span><span class="p">(</span><span class="s1">&#39;my-topic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span> <span class="o">=</span> <span class="n">Sub</span><span class="p">(</span><span class="s1">&#39;my-topic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pub</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
<p>You can also use sub within a for loop:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">sub</span><span class="p">:</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<p>or an async for loop</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">sub</span><span class="p">:</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly the <code class="docutils literal notranslate"><span class="pre">.get</span></code> method will return an awaitable if used by an async
client or within the IOLoop thread of a worker</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">await</span> <span class="n">sub</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>  
</pre></div>
</div>
<p>You can see the set of connected worker subscribers by looking at the
<code class="docutils literal notranslate"><span class="pre">.subscribers</span></code> attribute:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pub</span><span class="o">.</span><span class="n">subscribers</span>
<span class="go">{&#39;tcp://...&#39;: {},</span>
<span class="go"> &#39;tcp://...&#39;: {}}</span>
</pre></div>
</div>
<dl class="method">
<dt id="distributed.Pub.put">
<code class="sig-name descname">put</code><span class="sig-paren">(</span><em class="sig-param">msg</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Pub.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Publish a message to all subscribers of this topic</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="actors">
<h2>Actors<a class="headerlink" href="#actors" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is an advanced feature and is rarely necessary in the common case.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is an experimental feature and is subject to change without notice.</p>
</div>
<p>Actors allow workers to manage rapidly changing state without coordinating with
the central scheduler.  This has the advantage of reducing latency
(worker-to-worker roundtrip latency is around 1ms), reducing pressure on the
centralized scheduler (workers can coordinate actors entirely among each other),
and also enabling workflows that require stateful or in-place memory
manipulation.</p>
<p>However, these benefits come at a cost.  The scheduler is unaware of actors and
so they don’t benefit from diagnostics, load balancing, or resilience.  Once an
actor is running on a worker it is forever tied to that worker.  If that worker
becomes overburdened or dies, then there is no opportunity to recover the
workload.</p>
<p><em>Because Actors avoid the central scheduler they can be high-performing, but not resilient.</em></p>
<div class="section" id="example-counter">
<h3>Example: Counter<a class="headerlink" href="#example-counter" title="Permalink to this headline">¶</a></h3>
<p>An actor is a class containing both state and methods that is submitted to a
worker:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Counter</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>

<span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">Counter</span><span class="p">,</span> <span class="n">actor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">counter</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span>
<span class="o">&lt;</span><span class="n">Actor</span><span class="p">:</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="o">-</span><span class="n">afa1cdfb6b4761e616fa2cfab42398c8</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Method calls on this object produce <code class="docutils literal notranslate"><span class="pre">ActorFutures</span></code>, which are similar to
normal Futures, but interact only with the worker holding the Actor:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">future</span> <span class="o">=</span> <span class="n">counter</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">future</span>
<span class="go">&lt;ActorFuture&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Attribute access is synchronous and blocking:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">counter</span><span class="o">.</span><span class="n">n</span>
<span class="go">1</span>
</pre></div>
</div>
</div>
<div class="section" id="example-parameter-server">
<h3>Example: Parameter Server<a class="headerlink" href="#example-parameter-server" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ParameterServer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<span class="n">ps_future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">ParameterServer</span><span class="p">,</span> <span class="n">actor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ps</span> <span class="o">=</span> <span class="n">ps_future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="n">ps</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;parameters&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">ps</span><span class="p">):</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;parameters&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">batches</span><span class="p">:</span>
</pre></div>
</div>
</div>
<div class="section" id="asynchronous-operation">
<h3>Asynchronous Operation<a class="headerlink" href="#asynchronous-operation" title="Permalink to this headline">¶</a></h3>
<p>All operations that require talking to the remote worker are awaitable:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">Counter</span><span class="p">,</span> <span class="n">actor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="k">await</span> <span class="n">future</span>  <span class="c1"># gather actor object locally</span>

    <span class="n">counter</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>  <span class="c1"># send off a request asynchronously</span>
    <span class="k">await</span> <span class="n">counter</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>  <span class="c1"># or wait until it was received</span>

    <span class="n">n</span> <span class="o">=</span> <span class="k">await</span> <span class="n">counter</span><span class="o">.</span><span class="n">n</span>  <span class="c1"># attribute access also must be awaited</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<p><strong>Client</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client" title="distributed.Client"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client</span></code></a>([address, loop, timeout, …])</p></td>
<td><p>Connect to and submit computation to a Dask cluster</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.cancel" title="distributed.Client.cancel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.cancel</span></code></a>(futures[, asynchronous, force])</p></td>
<td><p>Cancel running futures</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.compute" title="distributed.Client.compute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.compute</span></code></a>(collections[, sync, …])</p></td>
<td><p>Compute dask collections on cluster</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.gather" title="distributed.Client.gather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.gather</span></code></a>(futures[, errors, direct, …])</p></td>
<td><p>Gather futures from distributed memory</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.get" title="distributed.Client.get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.get</span></code></a>(dsk, keys[, restrictions, …])</p></td>
<td><p>Compute dask graph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.get_dataset" title="distributed.Client.get_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.get_dataset</span></code></a>(name, **kwargs)</p></td>
<td><p>Get named dataset from the scheduler</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.get_executor" title="distributed.Client.get_executor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.get_executor</span></code></a>(**kwargs)</p></td>
<td><p>Return a concurrent.futures Executor for submitting tasks on this Client</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.has_what" title="distributed.Client.has_what"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.has_what</span></code></a>([workers])</p></td>
<td><p>Which keys are held by which workers</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.list_datasets" title="distributed.Client.list_datasets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.list_datasets</span></code></a>(**kwargs)</p></td>
<td><p>List named datasets available on the scheduler</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.map" title="distributed.Client.map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.map</span></code></a>(func, *iterables[, key, workers, …])</p></td>
<td><p>Map a function on a sequence of arguments</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.ncores" title="distributed.Client.ncores"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.ncores</span></code></a>([workers])</p></td>
<td><p>The number of threads/cores available on each worker node</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.persist" title="distributed.Client.persist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.persist</span></code></a>(collections[, …])</p></td>
<td><p>Persist dask collections on cluster</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.profile" title="distributed.Client.profile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.profile</span></code></a>([key, start, stop, workers, …])</p></td>
<td><p>Collect statistical profiling information about recent work</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.publish_dataset" title="distributed.Client.publish_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.publish_dataset</span></code></a>(*args, **kwargs)</p></td>
<td><p>Publish named datasets to scheduler</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.rebalance" title="distributed.Client.rebalance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.rebalance</span></code></a>([futures, workers])</p></td>
<td><p>Rebalance data within network</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.replicate" title="distributed.Client.replicate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.replicate</span></code></a>(futures[, n, workers, …])</p></td>
<td><p>Set replication of futures within network</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.restart" title="distributed.Client.restart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.restart</span></code></a>(**kwargs)</p></td>
<td><p>Restart the distributed network</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.run" title="distributed.Client.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.run</span></code></a>(function, *args, **kwargs)</p></td>
<td><p>Run a function on all workers outside of task scheduling system</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.run_on_scheduler" title="distributed.Client.run_on_scheduler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.run_on_scheduler</span></code></a>(function, *args, …)</p></td>
<td><p>Run a function on the scheduler process</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.scatter" title="distributed.Client.scatter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.scatter</span></code></a>(data[, workers, broadcast, …])</p></td>
<td><p>Scatter data into distributed memory</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.shutdown" title="distributed.Client.shutdown"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.shutdown</span></code></a>()</p></td>
<td><p>Shut down the connected scheduler and workers</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.scheduler_info" title="distributed.Client.scheduler_info"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.scheduler_info</span></code></a>(**kwargs)</p></td>
<td><p>Basic information about the workers in the cluster</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.shutdown" title="distributed.Client.shutdown"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.shutdown</span></code></a>()</p></td>
<td><p>Shut down the connected scheduler and workers</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.start_ipython_workers" title="distributed.Client.start_ipython_workers"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.start_ipython_workers</span></code></a>([workers, …])</p></td>
<td><p>Start IPython kernels on workers</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.start_ipython_scheduler" title="distributed.Client.start_ipython_scheduler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.start_ipython_scheduler</span></code></a>([magic_name, …])</p></td>
<td><p>Start IPython kernel on the scheduler</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.submit" title="distributed.Client.submit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.submit</span></code></a>(func, *args[, key, workers, …])</p></td>
<td><p>Submit a function application to the scheduler</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.unpublish_dataset" title="distributed.Client.unpublish_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.unpublish_dataset</span></code></a>(name, **kwargs)</p></td>
<td><p>Remove named datasets from scheduler</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Client.upload_file" title="distributed.Client.upload_file"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.upload_file</span></code></a>(filename, **kwargs)</p></td>
<td><p>Upload local package to workers</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Client.who_has" title="distributed.Client.who_has"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.who_has</span></code></a>([futures])</p></td>
<td><p>The workers storing each future’s data</p></td>
</tr>
</tbody>
</table>
<p><strong>Future</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Future" title="distributed.Future"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future</span></code></a>(key[, client, inform, state])</p></td>
<td><p>A remotely running computation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Future.add_done_callback" title="distributed.Future.add_done_callback"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.add_done_callback</span></code></a>(fn)</p></td>
<td><p>Call callback on future when callback has finished</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Future.cancel" title="distributed.Future.cancel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.cancel</span></code></a>(**kwargs)</p></td>
<td><p>Cancel request to run this future</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Future.cancelled" title="distributed.Future.cancelled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.cancelled</span></code></a>()</p></td>
<td><p>Returns True if the future has been cancelled</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Future.done" title="distributed.Future.done"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.done</span></code></a>()</p></td>
<td><p>Is the computation complete?</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Future.exception" title="distributed.Future.exception"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.exception</span></code></a>([timeout])</p></td>
<td><p>Return the exception of a failed task</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.Future.result" title="distributed.Future.result"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.result</span></code></a>([timeout])</p></td>
<td><p>Wait until computation completes, gather result to local process.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.Future.traceback" title="distributed.Future.traceback"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.traceback</span></code></a>([timeout])</p></td>
<td><p>Return the traceback of a failed task</p></td>
</tr>
</tbody>
</table>
<p><strong>Functions</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.as_completed" title="distributed.as_completed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_completed</span></code></a>([futures, loop, with_results, …])</p></td>
<td><p>Return futures in the order in which they complete</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.fire_and_forget" title="distributed.fire_and_forget"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fire_and_forget</span></code></a>(obj)</p></td>
<td><p>Run tasks at least once, even if we release the futures</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.get_client" title="distributed.get_client"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_client</span></code></a>([address, timeout, resolve_address])</p></td>
<td><p>Get a client while within a task.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.secede" title="distributed.secede"><code class="xref py py-obj docutils literal notranslate"><span class="pre">secede</span></code></a>()</p></td>
<td><p>Have this task secede from the worker’s thread pool</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#distributed.rejoin" title="distributed.rejoin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rejoin</span></code></a>()</p></td>
<td><p>Have this thread rejoin the ThreadPoolExecutor</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#distributed.wait" title="distributed.wait"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait</span></code></a>(fs[, timeout, return_when])</p></td>
<td><p>Wait until all/any futures are finished</p></td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="distributed.as_completed">
<code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">as_completed</code><span class="sig-paren">(</span><em class="sig-param">futures=None</em>, <em class="sig-param">loop=None</em>, <em class="sig-param">with_results=False</em>, <em class="sig-param">raise_errors=True</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.as_completed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return futures in the order in which they complete</p>
<p>This returns an iterator that yields the input future objects in the order
in which they complete.  Calling <code class="docutils literal notranslate"><span class="pre">next</span></code> on the iterator will block until
the next future completes, irrespective of order.</p>
<p>Additionally, you can also add more futures to this object during
computation with the <code class="docutils literal notranslate"><span class="pre">.add</span></code> method</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>futures: Collection of futures</strong></dt><dd><p>A list of Future objects to be iterated over in the order in which they
complete</p>
</dd>
<dt><strong>with_results: bool (False)</strong></dt><dd><p>Whether to wait and include results of futures as well;
in this case <cite>as_completed</cite> yields a tuple of (future, result)</p>
</dd>
<dt><strong>raise_errors: bool (True)</strong></dt><dd><p>Whether we should raise when the result of a future raises an exception;
only affects behavior when <cite>with_results=True</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]):</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>  
<span class="go">3</span>
<span class="go">2</span>
<span class="go">4</span>
</pre></div>
</div>
<p>Add more futures during computation</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">ac</span> <span class="o">=</span> <span class="n">as_completed</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">ac</span><span class="p">:</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>  
<span class="gp">... </span>    <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>  
<span class="gp">... </span>        <span class="n">ac</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">double</span><span class="p">,</span> <span class="n">future</span><span class="p">))</span>  
<span class="go">4</span>
<span class="go">2</span>
<span class="go">8</span>
<span class="go">3</span>
<span class="go">6</span>
<span class="go">12</span>
<span class="go">24</span>
</pre></div>
</div>
<p>Optionally wait until the result has been gathered as well</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ac</span> <span class="o">=</span> <span class="n">as_completed</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">with_results</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">future</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">ac</span><span class="p">:</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  
<span class="go">2</span>
<span class="go">4</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="distributed.fire_and_forget">
<code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">fire_and_forget</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.fire_and_forget" title="Permalink to this definition">¶</a></dt>
<dd><p>Run tasks at least once, even if we release the futures</p>
<p>Under normal operation Dask will not run any tasks for which there is not
an active future (this avoids unnecessary work in many situations).
However sometimes you want to just fire off a task, not track its future,
and expect it to finish eventually.  You can use this function on a future
or collection of futures to ask Dask to complete the task even if no active
client is tracking it.</p>
<p>The results will not be kept in memory after the task completes (unless
there is an active future) so this is only useful for tasks that depend on
side effects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj: Future, list, dict, dask collection</strong></dt><dd><p>The futures that you want to run at least once</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fire_and_forget</span><span class="p">(</span><span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>  
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="distributed.get_client">
<code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">get_client</code><span class="sig-paren">(</span><em class="sig-param">address=None</em>, <em class="sig-param">timeout=3</em>, <em class="sig-param">resolve_address=True</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.get_client" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a client while within a task.</p>
<p>This client connects to the same scheduler to which the worker is connected</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>address</strong><span class="classifier">str, optional</span></dt><dd><p>The address of the scheduler to connect to. Defaults to the scheduler
the worker is connected to.</p>
</dd>
<dt><strong>timeout</strong><span class="classifier">int, default 3</span></dt><dd><p>Timeout (in seconds) for getting the Client</p>
</dd>
<dt><strong>resolve_address</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to resolve <cite>address</cite> to its canonical form.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Client</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_worker</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">worker_client</span></code>, <a class="reference internal" href="#distributed.secede" title="distributed.secede"><code class="xref py py-obj docutils literal notranslate"><span class="pre">secede</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">client</span> <span class="o">=</span> <span class="n">get_client</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">futures</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>  <span class="c1"># spawn many tasks</span>
<span class="gp">... </span>    <span class="n">results</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">futures</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>  
<span class="go">55</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="distributed.secede">
<code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">secede</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distributed.secede" title="Permalink to this definition">¶</a></dt>
<dd><p>Have this task secede from the worker’s thread pool</p>
<p>This opens up a new scheduling slot and a new thread for a new task. This
enables the client to schedule tasks on this node, which is
especially useful while waiting for other jobs to finish (e.g., with
<code class="docutils literal notranslate"><span class="pre">client.gather</span></code>).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.get_client" title="distributed.get_client"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_client</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">get_worker</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mytask</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># do some work</span>
<span class="gp">... </span>    <span class="n">client</span> <span class="o">=</span> <span class="n">get_client</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">futures</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1"># do some remote work</span>
<span class="gp">... </span>    <span class="n">secede</span><span class="p">()</span>  <span class="c1"># while that work happens, remove ourself from the pool</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">client</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">futures</span><span class="p">)</span>  <span class="c1"># return gathered results</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="distributed.rejoin">
<code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">rejoin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distributed.rejoin" title="Permalink to this definition">¶</a></dt>
<dd><p>Have this thread rejoin the ThreadPoolExecutor</p>
<p>This will block until a new slot opens up in the executor.  The next thread
to finish a task will leave the pool to allow this one to join.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.secede" title="distributed.secede"><code class="xref py py-obj docutils literal notranslate"><span class="pre">secede</span></code></a></dt><dd><p>leave the thread pool</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="distributed.wait">
<code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">wait</code><span class="sig-paren">(</span><em class="sig-param">fs</em>, <em class="sig-param">timeout=None</em>, <em class="sig-param">return_when='ALL_COMPLETED'</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until all/any futures are finished</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fs: list of futures</strong></dt><dd></dd>
<dt><strong>timeout: number, optional</strong></dt><dd><p>Time in seconds after which to raise a <code class="docutils literal notranslate"><span class="pre">dask.distributed.TimeoutError</span></code></p>
</dd>
<dt><strong>return_when: str, optional</strong></dt><dd><p>One of <cite>ALL_COMPLETED</cite> or <cite>FIRST_COMPLETED</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Named tuple of completed, not completed</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="distributed.Client">
<em class="property">class </em><code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">Client</code><span class="sig-paren">(</span><em class="sig-param">address=None, loop=None, timeout='__no_default__', set_as_default=True, scheduler_file=None, security=None, asynchronous=False, name=None, heartbeat_interval=None, serializers=None, deserializers=None, extensions=[&lt;class 'distributed.pubsub.PubSubClientExtension'&gt;], direct_to_workers=None, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect to and submit computation to a Dask cluster</p>
<p>The Client connects users to a Dask cluster.  It provides an asynchronous
user interface around functions and futures.  This class resembles
executors in <code class="docutils literal notranslate"><span class="pre">concurrent.futures</span></code> but also allows <code class="docutils literal notranslate"><span class="pre">Future</span></code> objects
within <code class="docutils literal notranslate"><span class="pre">submit/map</span></code> calls.  When a Client is instantiated it takes over
all <code class="docutils literal notranslate"><span class="pre">dask.compute</span></code> and <code class="docutils literal notranslate"><span class="pre">dask.persist</span></code> calls by default.</p>
<p>It is also common to create a Client without specifying the scheduler
address , like <code class="docutils literal notranslate"><span class="pre">Client()</span></code>.  In this case the Client creates a
<code class="xref py py-class docutils literal notranslate"><span class="pre">LocalCluster</span></code> in the background and connects to that.  Any extra
keywords are passed from Client to LocalCluster in this case.  See the
LocalCluster documentation for more information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>address: string, or Cluster</strong></dt><dd><p>This can be the address of a <code class="docutils literal notranslate"><span class="pre">Scheduler</span></code> server like a string
<code class="docutils literal notranslate"><span class="pre">'127.0.0.1:8786'</span></code> or a cluster object like <code class="docutils literal notranslate"><span class="pre">LocalCluster()</span></code></p>
</dd>
<dt><strong>timeout: int</strong></dt><dd><p>Timeout duration for initial connection to the scheduler</p>
</dd>
<dt><strong>set_as_default: bool (True)</strong></dt><dd><p>Claim this scheduler as the global dask scheduler</p>
</dd>
<dt><strong>scheduler_file: string (optional)</strong></dt><dd><p>Path to a file with scheduler information if available</p>
</dd>
<dt><strong>security: Security or bool, optional</strong></dt><dd><p>Optional security information. If creating a local cluster can also
pass in <code class="docutils literal notranslate"><span class="pre">True</span></code>, in which case temporary self-signed credentials will
be created automatically.</p>
</dd>
<dt><strong>asynchronous: bool (False by default)</strong></dt><dd><p>Set to True if using this client within async/await functions or within
Tornado gen.coroutines.  Otherwise this should remain False for normal
use.</p>
</dd>
<dt><strong>name: string (optional)</strong></dt><dd><p>Gives the client a name that will be included in logs generated on
the scheduler for matters relating to this client</p>
</dd>
<dt><strong>direct_to_workers: bool (optional)</strong></dt><dd><p>Whether or not to connect directly to the workers, or to ask
the scheduler to serve as intermediary.</p>
</dd>
<dt><strong>heartbeat_interval: int</strong></dt><dd><p>Time in milliseconds between heartbeats to scheduler</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>If you do not pass a scheduler address, Client will create a
<code class="docutils literal notranslate"><span class="pre">LocalCluster</span></code> object, passing any extra keyword arguments.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">distributed.scheduler.Scheduler</span></code></dt><dd><p>Internal scheduler</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">distributed.LocalCluster</span></code></p>
</div>
<p class="rubric">Examples</p>
<p>Provide cluster’s scheduler node address on initialization:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="s1">&#39;127.0.0.1:8786&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">submit</span></code> method to send individual computations to the cluster</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>  
</pre></div>
</div>
<p>Continue using submit or map on results to build up larger computations</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
</pre></div>
</div>
<p>Gather results with the <code class="docutils literal notranslate"><span class="pre">gather</span></code> method.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  
<span class="go">33</span>
</pre></div>
</div>
<p>You can also call Client with no arguments in order to create your own
local cluster.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>  <span class="c1"># makes your own local &quot;cluster&quot; </span>
</pre></div>
</div>
<p>Extra keywords will be passed directly to LocalCluster</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
</pre></div>
</div>
<dl class="method">
<dt id="distributed.Client.asynchronous">
<em class="property">property </em><code class="sig-name descname">asynchronous</code><a class="headerlink" href="#distributed.Client.asynchronous" title="Permalink to this definition">¶</a></dt>
<dd><p>Are we running in the event loop?</p>
<p>This is true if the user signaled that we might be when creating the
client as in the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">asynchronous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>However, we override this expectation if we can definitively tell that
we are running from a thread that is not the event loop.  This is
common when calling get_client() from within a worker task.  Even
though the client was originally created in asynchronous mode we may
find ourselves in contexts when it is better to operate synchronously.</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.call_stack">
<code class="sig-name descname">call_stack</code><span class="sig-paren">(</span><em class="sig-param">futures=None</em>, <em class="sig-param">keys=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.call_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>The actively running call stack of all relevant keys</p>
<p>You can specify data of interest either by providing futures or
collections in the <code class="docutils literal notranslate"><span class="pre">futures=</span></code> keyword or a list of explicit keys in
the <code class="docutils literal notranslate"><span class="pre">keys=</span></code> keyword.  If neither are provided then all call stacks
will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>futures: list (optional)</strong></dt><dd><p>List of futures, defaults to all data</p>
</dd>
<dt><strong>keys: list (optional)</strong></dt><dd><p>List of key names, defaults to all data</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">call_stack</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>  <span class="c1"># call on collections</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">call_stack</span><span class="p">()</span>  <span class="c1"># Or call with no arguments for all activity  </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.cancel">
<code class="sig-name descname">cancel</code><span class="sig-paren">(</span><em class="sig-param">futures</em>, <em class="sig-param">asynchronous=None</em>, <em class="sig-param">force=False</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel running futures</p>
<p>This stops future tasks from being scheduled if they have not yet run
and deletes them if they have already run.  After calling, this result
and all dependent results will no longer be accessible</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>futures: list of Futures</strong></dt><dd></dd>
<dt><strong>force: boolean (False)</strong></dt><dd><p>Cancel this future even if other clients desire it</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><em class="sig-param">timeout='__no_default__'</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this client</p>
<p>Clients will also close automatically when your Python session ends</p>
<p>If you started a client without arguments like <code class="docutils literal notranslate"><span class="pre">Client()</span></code> then this
will also close the local cluster that was started at the same time.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.restart" title="distributed.Client.restart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.restart</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.compute">
<code class="sig-name descname">compute</code><span class="sig-paren">(</span><em class="sig-param">collections</em>, <em class="sig-param">sync=False</em>, <em class="sig-param">optimize_graph=True</em>, <em class="sig-param">workers=None</em>, <em class="sig-param">allow_other_workers=False</em>, <em class="sig-param">resources=None</em>, <em class="sig-param">retries=0</em>, <em class="sig-param">priority=0</em>, <em class="sig-param">fifo_timeout='60s'</em>, <em class="sig-param">actors=None</em>, <em class="sig-param">traverse=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute dask collections on cluster</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>collections: iterable of dask objects or single dask object</strong></dt><dd><p>Collections like dask.array or dataframe or dask.value objects</p>
</dd>
<dt><strong>sync: bool (optional)</strong></dt><dd><p>Returns Futures if False (default) or concrete values if True</p>
</dd>
<dt><strong>optimize_graph: bool</strong></dt><dd><p>Whether or not to optimize the underlying graphs</p>
</dd>
<dt><strong>workers: str, list, dict</strong></dt><dd><p>Which workers can run which parts of the computation
If a string a list then the output collections will run on the listed
workers, but other sub-computations can run anywhere
If a dict then keys should be (tuples of) collections and values
should be addresses or lists.</p>
</dd>
<dt><strong>allow_other_workers: bool, list</strong></dt><dd><p>If True then all restrictions in workers= are considered loose
If a list then only the keys for the listed collections are loose</p>
</dd>
<dt><strong>retries: int (default to 0)</strong></dt><dd><p>Number of allowed automatic retries if computing a result fails</p>
</dd>
<dt><strong>priority: Number</strong></dt><dd><p>Optional prioritization of task.  Zero is default.
Higher priorities take precedence</p>
</dd>
<dt><strong>fifo_timeout: timedelta str (defaults to ’60s’)</strong></dt><dd><p>Allowed amount of time between calls to consider the same priority</p>
</dd>
<dt><strong>traverse: bool (defaults to True)</strong></dt><dd><p>By default dask traverses builtin python collections looking for
dask objects passed to <code class="docutils literal notranslate"><span class="pre">compute</span></code>. For large collections this can
be expensive. If none of the arguments contain any dask objects,
set <code class="docutils literal notranslate"><span class="pre">traverse=False</span></code> to avoid doing this traversal.</p>
</dd>
<dt><strong>resources: dict (defaults to {})</strong></dt><dd><p>Defines the <cite>resources</cite> these tasks require on the worker. Can
specify global resources (<code class="docutils literal notranslate"><span class="pre">{'GPU':</span> <span class="pre">2}</span></code>), or per-task resources
(<code class="docutils literal notranslate"><span class="pre">{'x':</span> <span class="pre">{'GPU':</span> <span class="pre">1},</span> <span class="pre">'y':</span> <span class="pre">{'SSD':</span> <span class="pre">4}}</span></code>), but not both.
See <span class="xref std std-doc">worker resources</span> for details on defining
resources.</p>
</dd>
<dt><strong>actors: bool or dict (default None)</strong></dt><dd><p>Whether these tasks should exist on the worker as stateful actors.
Specified on a global (True/False) or per-task (<code class="docutils literal notranslate"><span class="pre">{'x':</span> <span class="pre">True,</span>
<span class="pre">'y':</span> <span class="pre">False}</span></code>) basis. See <span class="xref std std-doc">actors</span> for additional details.</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>Options to pass to the graph optimize calls</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>List of Futures if input is a sequence, or a single future otherwise</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Client.get" title="distributed.Client.get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.get</span></code></a></dt><dd><p>Normal synchronous dask.get function</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask</span> <span class="kn">import</span> <span class="n">delayed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">delayed</span><span class="p">(</span><span class="n">add</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">delayed</span><span class="p">(</span><span class="n">add</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">compute</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span>  
<span class="go">&lt;Future: status: finished, key: add-8f6e709446674bad78ea8aeecfee188e&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>  
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yy</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>  
<span class="go">6</span>
</pre></div>
</div>
<p>Also support single arguments</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.current">
<em class="property">classmethod </em><code class="sig-name descname">current</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.current" title="Permalink to this definition">¶</a></dt>
<dd><p>Return global client if one exists, otherwise raise ValueError</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.gather">
<code class="sig-name descname">gather</code><span class="sig-paren">(</span><em class="sig-param">futures</em>, <em class="sig-param">errors='raise'</em>, <em class="sig-param">direct=None</em>, <em class="sig-param">asynchronous=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.gather" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather futures from distributed memory</p>
<p>Accepts a future, nested container of futures, iterator, or queue.
The return type will match the input type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>futures: Collection of futures</strong></dt><dd><p>This can be a possibly nested collection of Future objects.
Collections can be lists, sets, or dictionaries</p>
</dd>
<dt><strong>errors: string</strong></dt><dd><p>Either ‘raise’ or ‘skip’ if we should raise if a future has erred
or skip its inclusion in the output collection</p>
</dd>
<dt><strong>direct: boolean</strong></dt><dd><p>Whether or not to connect directly to the workers, or to ask
the scheduler to serve as intermediary.  This can also be set when
creating the Client.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results: a collection of the same type as the input, but now with</strong></dt><dd></dd>
<dt><strong>gathered results rather than futures</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Client.scatter" title="distributed.Client.scatter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.scatter</span></code></a></dt><dd><p>Send data out to cluster</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="s1">&#39;127.0.0.1:8787&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">gather</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="p">])</span>  <span class="c1"># support lists and dicts </span>
<span class="go">[3, [3], 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">dsk</em>, <em class="sig-param">keys</em>, <em class="sig-param">restrictions=None</em>, <em class="sig-param">loose_restrictions=None</em>, <em class="sig-param">resources=None</em>, <em class="sig-param">sync=True</em>, <em class="sig-param">asynchronous=None</em>, <em class="sig-param">direct=None</em>, <em class="sig-param">retries=None</em>, <em class="sig-param">priority=0</em>, <em class="sig-param">fifo_timeout='60s'</em>, <em class="sig-param">actors=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute dask graph</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dsk: dict</strong></dt><dd></dd>
<dt><strong>keys: object, or nested lists of objects</strong></dt><dd></dd>
<dt><strong>restrictions: dict (optional)</strong></dt><dd><p>A mapping of {key: {set of worker hostnames}} that restricts where
jobs can take place</p>
</dd>
<dt><strong>retries: int (default to 0)</strong></dt><dd><p>Number of allowed automatic retries if computing a result fails</p>
</dd>
<dt><strong>priority: Number</strong></dt><dd><p>Optional prioritization of task.  Zero is default.
Higher priorities take precedence</p>
</dd>
<dt><strong>sync: bool (optional)</strong></dt><dd><p>Returns Futures if False or concrete values if True (default).</p>
</dd>
<dt><strong>direct: bool</strong></dt><dd><p>Whether or not to connect directly to the workers, or to ask
the scheduler to serve as intermediary.  This can also be set when
creating the Client.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Client.compute" title="distributed.Client.compute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.compute</span></code></a></dt><dd><p>Compute asynchronous collections</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="s1">&#39;127.0.0.1:8787&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)},</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>  
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.get_dataset">
<code class="sig-name descname">get_dataset</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.get_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Get named dataset from the scheduler</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.publish_dataset" title="distributed.Client.publish_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.publish_dataset</span></code></a>, <a class="reference internal" href="#distributed.Client.list_datasets" title="distributed.Client.list_datasets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.list_datasets</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.get_executor">
<code class="sig-name descname">get_executor</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.get_executor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a concurrent.futures Executor for submitting tasks on this Client</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>**kwargs:</strong></dt><dd><p>Any submit()- or map()- compatible arguments, such as
<cite>workers</cite> or <cite>resources</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>An Executor object that’s fully compatible with the concurrent.futures</strong></dt><dd></dd>
<dt><strong>API.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.get_metadata">
<code class="sig-name descname">get_metadata</code><span class="sig-paren">(</span><em class="sig-param">keys</em>, <em class="sig-param">default='__no_default__'</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.get_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Get arbitrary metadata from scheduler</p>
<p>See set_metadata for the full docstring with examples</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>keys: key or list</strong></dt><dd><p>Key to access.  If a list then gets within a nested collection</p>
</dd>
<dt><strong>default: optional</strong></dt><dd><p>If the key does not exist then return this value instead.
If not provided then this raises a KeyError if the key is not
present</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.set_metadata" title="distributed.Client.set_metadata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.set_metadata</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.get_restrictions">
<em class="property">classmethod </em><code class="sig-name descname">get_restrictions</code><span class="sig-paren">(</span><em class="sig-param">collections</em>, <em class="sig-param">workers</em>, <em class="sig-param">allow_other_workers</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.get_restrictions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get restrictions from inputs to compute/persist</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.get_scheduler_logs">
<code class="sig-name descname">get_scheduler_logs</code><span class="sig-paren">(</span><em class="sig-param">n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.get_scheduler_logs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get logs from scheduler</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of logs to retrive.  Maxes out at 10000 by default,
confiruable in config.yaml::log-length</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Logs in reversed order (newest first)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.get_task_stream">
<code class="sig-name descname">get_task_stream</code><span class="sig-paren">(</span><em class="sig-param">start=None</em>, <em class="sig-param">stop=None</em>, <em class="sig-param">count=None</em>, <em class="sig-param">plot=False</em>, <em class="sig-param">filename='task-stream.html'</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.get_task_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Get task stream data from scheduler</p>
<p>This collects the data present in the diagnostic “Task Stream” plot on
the dashboard.  It includes the start, stop, transfer, and
deserialization time of every task for a particular duration.</p>
<p>Note that the task stream diagnostic does not run by default.  You may
wish to call this function once before you start work to ensure that
things start recording, and then again after you have completed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start: Number or string</strong></dt><dd><p>When you want to start recording
If a number it should be the result of calling time()
If a string then it should be a time difference before now,
like ’60s’ or ‘500 ms’</p>
</dd>
<dt><strong>stop: Number or string</strong></dt><dd><p>When you want to stop recording</p>
</dd>
<dt><strong>count: int</strong></dt><dd><p>The number of desired records, ignored if both start and stop are
specified</p>
</dd>
<dt><strong>plot: boolean, str</strong></dt><dd><p>If true then also return a Bokeh figure
If plot == ‘save’ then save the figure to a file</p>
</dd>
<dt><strong>filename: str (optional)</strong></dt><dd><p>The filename to save to if you set <code class="docutils literal notranslate"><span class="pre">plot='save'</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>L: List[Dict]</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Client.get_task_stream" title="distributed.Client.get_task_stream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_task_stream</span></code></a></dt><dd><p>a context manager version of this method</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">get_task_stream</span><span class="p">()</span>  <span class="c1"># prime plugin if not already connected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>  <span class="c1"># do some work</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">get_task_stream</span><span class="p">()</span>
<span class="go">[{&#39;task&#39;: ...,</span>
<span class="go">  &#39;type&#39;: ...,</span>
<span class="go">  &#39;thread&#39;: ...,</span>
<span class="go">  ...}]</span>
</pre></div>
</div>
<p>Pass the <code class="docutils literal notranslate"><span class="pre">plot=True</span></code> or <code class="docutils literal notranslate"><span class="pre">plot='save'</span></code> keywords to get back a Bokeh
figure</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">figure</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_task_stream</span><span class="p">(</span><span class="n">plot</span><span class="o">=</span><span class="s1">&#39;save&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;myfile.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively consider the context manager</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">get_task_stream</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">get_task_stream</span><span class="p">()</span> <span class="k">as</span> <span class="n">ts</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">x</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span><span class="o">.</span><span class="n">data</span>
<span class="go">[...]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.get_versions">
<code class="sig-name descname">get_versions</code><span class="sig-paren">(</span><em class="sig-param">check=False</em>, <em class="sig-param">packages=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.get_versions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return version info for the scheduler, all workers and myself</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>check</strong><span class="classifier">boolean, default False</span></dt><dd><p>raise ValueError if all required &amp; optional packages
do not match</p>
</dd>
<dt><strong>packages</strong><span class="classifier">List[str]</span></dt><dd><p>Extra package names to check</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">get_versions</span><span class="p">()</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">get_versions</span><span class="p">(</span><span class="n">packages</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sklearn&#39;</span><span class="p">,</span> <span class="s1">&#39;geopandas&#39;</span><span class="p">])</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.get_worker_logs">
<code class="sig-name descname">get_worker_logs</code><span class="sig-paren">(</span><em class="sig-param">n=None</em>, <em class="sig-param">workers=None</em>, <em class="sig-param">nanny=False</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.get_worker_logs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get logs from workers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of logs to retrive.  Maxes out at 10000 by default,
confiruable in config.yaml::log-length</p>
</dd>
<dt><strong>workers</strong><span class="classifier">iterable</span></dt><dd><p>List of worker addresses to retrieve.  Gets all workers by default.</p>
</dd>
<dt><strong>nanny</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether to get the logs from the workers (False) or the nannies (True). If
specified, the addresses in <cite>workers</cite> should still be the worker addresses,
not the nanny addresses.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Dictionary mapping worker address to logs.</strong></dt><dd></dd>
<dt><strong>Logs are returned in reversed order (newest first)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.has_what">
<code class="sig-name descname">has_what</code><span class="sig-paren">(</span><em class="sig-param">workers=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.has_what" title="Permalink to this definition">¶</a></dt>
<dd><p>Which keys are held by which workers</p>
<p>This returns the keys of the data that are held in each worker’s
memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>workers: list (optional)</strong></dt><dd><p>A list of worker addresses, defaults to all</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.who_has" title="distributed.Client.who_has"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.who_has</span></code></a>, <a class="reference internal" href="#distributed.Client.nthreads" title="distributed.Client.nthreads"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.nthreads</span></code></a>, <a class="reference internal" href="#distributed.Client.processing" title="distributed.Client.processing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.processing</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">wait</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">has_what</span><span class="p">()</span>  
<span class="go">{&#39;192.168.1.141:46784&#39;: [&#39;inc-1c8dd6be1c21646c71f76c16d09304ea&#39;,</span>
<span class="go">                         &#39;inc-fd65c238a7ea60f6a01bf4c8a5fcf44b&#39;,</span>
<span class="go">                         &#39;inc-1e297fc27658d7b67b3a758f16bcf47a&#39;]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.list_datasets">
<code class="sig-name descname">list_datasets</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.list_datasets" title="Permalink to this definition">¶</a></dt>
<dd><p>List named datasets available on the scheduler</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.publish_dataset" title="distributed.Client.publish_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.publish_dataset</span></code></a>, <a class="reference internal" href="#distributed.Client.get_dataset" title="distributed.Client.get_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.get_dataset</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.map">
<code class="sig-name descname">map</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*iterables</em>, <em class="sig-param">key=None</em>, <em class="sig-param">workers=None</em>, <em class="sig-param">retries=None</em>, <em class="sig-param">resources=None</em>, <em class="sig-param">priority=0</em>, <em class="sig-param">allow_other_workers=False</em>, <em class="sig-param">fifo_timeout='100 ms'</em>, <em class="sig-param">actor=False</em>, <em class="sig-param">actors=False</em>, <em class="sig-param">pure=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a function on a sequence of arguments</p>
<p>Arguments can be normal objects or Futures</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func: callable</strong></dt><dd></dd>
<dt><strong>iterables: Iterables</strong></dt><dd><p>List-like objects to map over.  They should have the same length.</p>
</dd>
<dt><strong>key: str, list</strong></dt><dd><p>Prefix for task names if string.  Explicit names if list.</p>
</dd>
<dt><strong>pure: bool (defaults to True)</strong></dt><dd><p>Whether or not the function is pure.  Set <code class="docutils literal notranslate"><span class="pre">pure=False</span></code> for
impure functions like <code class="docutils literal notranslate"><span class="pre">np.random.random</span></code>.</p>
</dd>
<dt><strong>workers: set, iterable of sets</strong></dt><dd><p>A set of worker hostnames on which computations may be performed.
Leave empty to default to all workers (common case)</p>
</dd>
<dt><strong>allow_other_workers: bool (defaults to False)</strong></dt><dd><p>Used with <cite>workers</cite>. Indicates whether or not the computations
may be performed on workers that are not in the <cite>workers</cite> set(s).</p>
</dd>
<dt><strong>retries: int (default to 0)</strong></dt><dd><p>Number of allowed automatic retries if a task fails</p>
</dd>
<dt><strong>priority: Number</strong></dt><dd><p>Optional prioritization of task.  Zero is default.
Higher priorities take precedence</p>
</dd>
<dt><strong>fifo_timeout: str timedelta (default ‘100ms’)</strong></dt><dd><p>Allowed amount of time between calls to consider the same priority</p>
</dd>
<dt><strong>resources: dict (defaults to {})</strong></dt><dd><p>Defines the <cite>resources</cite> each instance of this mapped task requires
on the worker; e.g. <code class="docutils literal notranslate"><span class="pre">{'GPU':</span> <span class="pre">2}</span></code>. See
<span class="xref std std-doc">worker resources</span> for details on defining
resources.</p>
</dd>
<dt><strong>actor: bool (default False)</strong></dt><dd><p>Whether these tasks should exist on the worker as stateful actors.
See <span class="xref std std-doc">actors</span> for additional details.</p>
</dd>
<dt><strong>actors: bool (default False)</strong></dt><dd><p>Alias for <cite>actor</cite></p>
</dd>
<dt><strong>**kwargs: dict</strong></dt><dd><p>Extra keywords to send to the function.
Large values will be included explicitly in the task graph.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>List, iterator, or Queue of futures, depending on the type of the</strong></dt><dd></dd>
<dt><strong>inputs.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Client.submit" title="distributed.Client.submit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.submit</span></code></a></dt><dd><p>Submit a single function</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sequence</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.nbytes">
<code class="sig-name descname">nbytes</code><span class="sig-paren">(</span><em class="sig-param">keys=None</em>, <em class="sig-param">summary=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>The bytes taken up by each key on the cluster</p>
<p>This is as measured by <code class="docutils literal notranslate"><span class="pre">sys.getsizeof</span></code> which may not accurately
reflect the true cost.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>keys: list (optional)</strong></dt><dd><p>A list of keys, defaults to all keys</p>
</dd>
<dt><strong>summary: boolean, (optional)</strong></dt><dd><p>Summarize keys into key types</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.who_has" title="distributed.Client.who_has"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.who_has</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">nbytes</span><span class="p">(</span><span class="n">summary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
<span class="go">{&#39;inc-1c8dd6be1c21646c71f76c16d09304ea&#39;: 28,</span>
<span class="go"> &#39;inc-1e297fc27658d7b67b3a758f16bcf47a&#39;: 28,</span>
<span class="go"> &#39;inc-fd65c238a7ea60f6a01bf4c8a5fcf44b&#39;: 28}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">nbytes</span><span class="p">(</span><span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">{&#39;inc&#39;: 84}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.ncores">
<code class="sig-name descname">ncores</code><span class="sig-paren">(</span><em class="sig-param">workers=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.ncores" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of threads/cores available on each worker node</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>workers: list (optional)</strong></dt><dd><p>A list of workers that we care about specifically.
Leave empty to receive information about all workers.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.who_has" title="distributed.Client.who_has"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.who_has</span></code></a>, <a class="reference internal" href="#distributed.Client.has_what" title="distributed.Client.has_what"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.has_what</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">threads</span><span class="p">()</span>  
<span class="go">{&#39;192.168.1.141:46784&#39;: 8,</span>
<span class="go"> &#39;192.167.1.142:47548&#39;: 8,</span>
<span class="go"> &#39;192.167.1.143:47329&#39;: 8,</span>
<span class="go"> &#39;192.167.1.144:37297&#39;: 8}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.normalize_collection">
<code class="sig-name descname">normalize_collection</code><span class="sig-paren">(</span><em class="sig-param">collection</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.normalize_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace collection’s tasks by already existing futures if they exist</p>
<p>This normalizes the tasks within a collections task graph against the
known futures within the scheduler.  It returns a copy of the
collection with a task graph that includes the overlapping futures.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Client.persist" title="distributed.Client.persist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.persist</span></code></a></dt><dd><p>trigger computation of collection’s tasks</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">())</span>  <span class="c1"># x is a dask collection with 100 tasks  </span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">set</span><span class="p">(</span><span class="n">client</span><span class="o">.</span><span class="n">futures</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">())</span>  <span class="c1"># some overlap exists  </span>
<span class="go">10</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">normalize_collection</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">())</span>  <span class="c1"># smaller computational graph  </span>
<span class="go">20</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.nthreads">
<code class="sig-name descname">nthreads</code><span class="sig-paren">(</span><em class="sig-param">workers=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.nthreads" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of threads/cores available on each worker node</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>workers: list (optional)</strong></dt><dd><p>A list of workers that we care about specifically.
Leave empty to receive information about all workers.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.who_has" title="distributed.Client.who_has"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.who_has</span></code></a>, <a class="reference internal" href="#distributed.Client.has_what" title="distributed.Client.has_what"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.has_what</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">threads</span><span class="p">()</span>  
<span class="go">{&#39;192.168.1.141:46784&#39;: 8,</span>
<span class="go"> &#39;192.167.1.142:47548&#39;: 8,</span>
<span class="go"> &#39;192.167.1.143:47329&#39;: 8,</span>
<span class="go"> &#39;192.167.1.144:37297&#39;: 8}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.persist">
<code class="sig-name descname">persist</code><span class="sig-paren">(</span><em class="sig-param">collections</em>, <em class="sig-param">optimize_graph=True</em>, <em class="sig-param">workers=None</em>, <em class="sig-param">allow_other_workers=None</em>, <em class="sig-param">resources=None</em>, <em class="sig-param">retries=None</em>, <em class="sig-param">priority=0</em>, <em class="sig-param">fifo_timeout='60s'</em>, <em class="sig-param">actors=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.persist" title="Permalink to this definition">¶</a></dt>
<dd><p>Persist dask collections on cluster</p>
<p>Starts computation of the collection on the cluster in the background.
Provides a new dask collection that is semantically identical to the
previous one, but now based off of futures currently in execution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>collections: sequence or single dask object</strong></dt><dd><p>Collections like dask.array or dataframe or dask.value objects</p>
</dd>
<dt><strong>optimize_graph: bool</strong></dt><dd><p>Whether or not to optimize the underlying graphs</p>
</dd>
<dt><strong>workers: str, list, dict</strong></dt><dd><p>Which workers can run which parts of the computation
If a string a list then the output collections will run on the listed
workers, but other sub-computations can run anywhere
If a dict then keys should be (tuples of) collections and values
should be addresses or lists.</p>
</dd>
<dt><strong>allow_other_workers: bool, list</strong></dt><dd><p>If True then all restrictions in workers= are considered loose
If a list then only the keys for the listed collections are loose</p>
</dd>
<dt><strong>retries: int (default to 0)</strong></dt><dd><p>Number of allowed automatic retries if computing a result fails</p>
</dd>
<dt><strong>priority: Number</strong></dt><dd><p>Optional prioritization of task.  Zero is default.
Higher priorities take precedence</p>
</dd>
<dt><strong>fifo_timeout: timedelta str (defaults to ’60s’)</strong></dt><dd><p>Allowed amount of time between calls to consider the same priority</p>
</dd>
<dt><strong>resources: dict (defaults to {})</strong></dt><dd><p>Defines the <cite>resources</cite> these tasks require on the worker. Can
specify global resources (<code class="docutils literal notranslate"><span class="pre">{'GPU':</span> <span class="pre">2}</span></code>), or per-task resources
(<code class="docutils literal notranslate"><span class="pre">{'x':</span> <span class="pre">{'GPU':</span> <span class="pre">1},</span> <span class="pre">'y':</span> <span class="pre">{'SSD':</span> <span class="pre">4}}</span></code>), but not both.
See <span class="xref std std-doc">worker resources</span> for details on defining
resources.</p>
</dd>
<dt><strong>actors: bool or dict (default None)</strong></dt><dd><p>Whether these tasks should exist on the worker as stateful actors.
Specified on a global (True/False) or per-task (<code class="docutils literal notranslate"><span class="pre">{'x':</span> <span class="pre">True,</span>
<span class="pre">'y':</span> <span class="pre">False}</span></code>) basis. See <span class="xref std std-doc">actors</span> for additional details.</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>Options to pass to the graph optimize calls</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>List of collections, or single collection, depending on type of input.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.compute" title="distributed.Client.compute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.compute</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">persist</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">persist</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.processing">
<code class="sig-name descname">processing</code><span class="sig-paren">(</span><em class="sig-param">workers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.processing" title="Permalink to this definition">¶</a></dt>
<dd><p>The tasks currently running on each worker</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>workers: list (optional)</strong></dt><dd><p>A list of worker addresses, defaults to all</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.who_has" title="distributed.Client.who_has"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.who_has</span></code></a>, <a class="reference internal" href="#distributed.Client.has_what" title="distributed.Client.has_what"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.has_what</span></code></a>, <a class="reference internal" href="#distributed.Client.nthreads" title="distributed.Client.nthreads"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.nthreads</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">processing</span><span class="p">()</span>  
<span class="go">{&#39;192.168.1.141:46784&#39;: [&#39;inc-1c8dd6be1c21646c71f76c16d09304ea&#39;,</span>
<span class="go">                         &#39;inc-fd65c238a7ea60f6a01bf4c8a5fcf44b&#39;,</span>
<span class="go">                         &#39;inc-1e297fc27658d7b67b3a758f16bcf47a&#39;]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.profile">
<code class="sig-name descname">profile</code><span class="sig-paren">(</span><em class="sig-param">key=None</em>, <em class="sig-param">start=None</em>, <em class="sig-param">stop=None</em>, <em class="sig-param">workers=None</em>, <em class="sig-param">merge_workers=True</em>, <em class="sig-param">plot=False</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">server=False</em>, <em class="sig-param">scheduler=False</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect statistical profiling information about recent work</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>key: str</strong></dt><dd><p>Key prefix to select, this is typically a function name like ‘inc’
Leave as None to collect all data</p>
</dd>
<dt><strong>start: time</strong></dt><dd></dd>
<dt><strong>stop: time</strong></dt><dd></dd>
<dt><strong>workers: list</strong></dt><dd><p>List of workers to restrict profile information</p>
</dd>
<dt><strong>server</strong><span class="classifier">bool</span></dt><dd><p>If true, return the profile of the worker’s administrative thread
rather than the worker threads.
This is useful when profiling Dask itself, rather than user code.</p>
</dd>
<dt><strong>scheduler: bool</strong></dt><dd><p>If true, return the profile information from the scheduler’s
administrative thread rather than the workers.
This is useful when profiling Dask’s scheduling itself.</p>
</dd>
<dt><strong>plot: boolean or string</strong></dt><dd><p>Whether or not to return a plot object</p>
</dd>
<dt><strong>filename: str</strong></dt><dd><p>Filename to save the plot</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">profile</span><span class="p">()</span>  <span class="c1"># call on collections</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;dask-profile.html&#39;</span><span class="p">)</span>  <span class="c1"># save to html file</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.publish_dataset">
<code class="sig-name descname">publish_dataset</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.publish_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Publish named datasets to scheduler</p>
<p>This stores a named reference to a dask collection or list of futures
on the scheduler.  These references are available to other Clients
which can download the collection or futures with <code class="docutils literal notranslate"><span class="pre">get_dataset</span></code>.</p>
<p>Datasets are not immediately computed.  You may wish to call
<code class="docutils literal notranslate"><span class="pre">Client.persist</span></code> prior to publishing a dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">list of objects to publish as name</span></dt><dd></dd>
<dt><strong>name</strong><span class="classifier">optional name of the dataset to publish</span></dt><dd></dd>
<dt><strong>kwargs: dict</strong></dt><dd><p>named collections to publish on the scheduler</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.list_datasets" title="distributed.Client.list_datasets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.list_datasets</span></code></a>, <a class="reference internal" href="#distributed.Client.get_dataset" title="distributed.Client.get_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.get_dataset</span></code></a>, <a class="reference internal" href="#distributed.Client.unpublish_dataset" title="distributed.Client.unpublish_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.unpublish_dataset</span></code></a>, <a class="reference internal" href="#distributed.Client.persist" title="distributed.Client.persist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.persist</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Publishing client:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;s3://...&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">persist</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">publish_dataset</span><span class="p">(</span><span class="n">my_dataset</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>  
</pre></div>
</div>
<p>Alternative invocation
&gt;&gt;&gt; c.publish_dataset(df, name=’my_dataset’)</p>
<p>Receiving client:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">list_datasets</span><span class="p">()</span>  
<span class="go">[&#39;my_dataset&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get_dataset</span><span class="p">(</span><span class="s1">&#39;my_dataset&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.rebalance">
<code class="sig-name descname">rebalance</code><span class="sig-paren">(</span><em class="sig-param">futures=None</em>, <em class="sig-param">workers=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.rebalance" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebalance data within network</p>
<p>Move data between workers to roughly balance memory burden.  This
either affects a subset of the keys/workers or the entire network,
depending on keyword arguments.</p>
<p>This operation is generally not well tested against normal operation of
the scheduler.  It it not recommended to use it while waiting on
computations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>futures: list, optional</strong></dt><dd><p>A list of futures to balance, defaults all data</p>
</dd>
<dt><strong>workers: list, optional</strong></dt><dd><p>A list of workers on which to balance, defaults to all workers</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.register_worker_callbacks">
<code class="sig-name descname">register_worker_callbacks</code><span class="sig-paren">(</span><em class="sig-param">setup=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.register_worker_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a setup callback function for all current and future workers.</p>
<p>This registers a new setup function for workers in this cluster. The
function will run immediately on all currently connected workers. It
will also be run upon connection by any workers that are added in the
future. Multiple setup functions can be registered - these will be
called in the order they were added.</p>
<p>If the function takes an input argument named <code class="docutils literal notranslate"><span class="pre">dask_worker</span></code> then
that variable will be populated with the worker itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>setup</strong><span class="classifier">callable(dask_worker: Worker) -&gt; None</span></dt><dd><p>Function to register and run on all workers</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.register_worker_plugin">
<code class="sig-name descname">register_worker_plugin</code><span class="sig-paren">(</span><em class="sig-param">plugin=None</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.register_worker_plugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a lifecycle worker plugin for all current and future workers.</p>
<p>This registers a new object to handle setup, task state transitions and
teardown for workers in this cluster. The plugin will instantiate itself
on all currently connected workers. It will also be run on any worker
that connects in the future.</p>
<p>The plugin may include methods <code class="docutils literal notranslate"><span class="pre">setup</span></code>, <code class="docutils literal notranslate"><span class="pre">teardown</span></code>, and
<code class="docutils literal notranslate"><span class="pre">transition</span></code>.  See the <code class="docutils literal notranslate"><span class="pre">dask.distributed.WorkerPlugin</span></code> class or the
examples below for the interface and docstrings.  It must be
serializable with the pickle or cloudpickle modules.</p>
<p>If the plugin has a <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute, or if the <code class="docutils literal notranslate"><span class="pre">name=</span></code> keyword is
used then that will control idempotency.  A a plugin with that name has
already registered then any future plugins will not run.</p>
<p>For alternatives to plugins, you may also wish to look into preload
scripts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>plugin: WorkerPlugin</strong></dt><dd><p>The plugin object to pass to the workers</p>
</dd>
<dt><strong>name: str, optional</strong></dt><dd><p>A name for the plugin.
Registering a plugin with the same name will have no effect.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">distributed.WorkerPlugin</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyPlugin</span><span class="p">(</span><span class="n">WorkerPlugin</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>  <span class="c1"># the constructor is up to you</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">:</span> <span class="n">dask</span><span class="o">.</span><span class="n">distributed</span><span class="o">.</span><span class="n">Worker</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">teardown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">:</span> <span class="n">dask</span><span class="o">.</span><span class="n">distributed</span><span class="o">.</span><span class="n">Worker</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">transition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">finish</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plugin</span> <span class="o">=</span> <span class="n">MyPlugin</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">register_worker_plugin</span><span class="p">(</span><span class="n">plugin</span><span class="p">)</span>
</pre></div>
</div>
<p>You can get access to the plugin with the <code class="docutils literal notranslate"><span class="pre">get_worker</span></code> function</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">register_worker_plugin</span><span class="p">(</span><span class="n">other_plugin</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;my-plugin&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">worker</span> <span class="o">=</span> <span class="n">get_worker</span><span class="p">()</span>
<span class="gp">... </span>   <span class="n">plugin</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">plugins</span><span class="p">[</span><span class="s1">&#39;my-plugin&#39;</span><span class="p">]</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">plugin</span><span class="o">.</span><span class="n">my_state</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.replicate">
<code class="sig-name descname">replicate</code><span class="sig-paren">(</span><em class="sig-param">futures</em>, <em class="sig-param">n=None</em>, <em class="sig-param">workers=None</em>, <em class="sig-param">branching_factor=2</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.replicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set replication of futures within network</p>
<p>Copy data onto many workers.  This helps to broadcast frequently
accessed data and it helps to improve resilience.</p>
<p>This performs a tree copy of the data throughout the network
individually on each piece of data.  This operation blocks until
complete.  It does not guarantee replication of data to future workers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>futures: list of futures</strong></dt><dd><p>Futures we wish to replicate</p>
</dd>
<dt><strong>n: int, optional</strong></dt><dd><p>Number of processes on the cluster on which to replicate the data.
Defaults to all.</p>
</dd>
<dt><strong>workers: list of worker addresses</strong></dt><dd><p>Workers on which we want to restrict the replication.
Defaults to all.</p>
</dd>
<dt><strong>branching_factor: int, optional</strong></dt><dd><p>The number of workers that can copy data in each generation</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.rebalance" title="distributed.Client.rebalance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.rebalance</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">replicate</span><span class="p">([</span><span class="n">x</span><span class="p">])</span>  <span class="c1"># send to all workers  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">replicate</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># send to three workers  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">replicate</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">workers</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;alice&#39;</span><span class="p">,</span> <span class="s1">&#39;bob&#39;</span><span class="p">])</span>  <span class="c1"># send to specific  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">replicate</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;alice&#39;</span><span class="p">,</span> <span class="s1">&#39;bob&#39;</span><span class="p">])</span>  <span class="c1"># send to one of specific workers  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">replicate</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># reduce replications </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.restart">
<code class="sig-name descname">restart</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>Restart the distributed network</p>
<p>This kills all active work, deletes all data on the network, and
restarts the worker processes.</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.retire_workers">
<code class="sig-name descname">retire_workers</code><span class="sig-paren">(</span><em class="sig-param">workers=None</em>, <em class="sig-param">close_workers=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.retire_workers" title="Permalink to this definition">¶</a></dt>
<dd><p>Retire certain workers on the scheduler</p>
<p>See dask.distributed.Scheduler.retire_workers for the full docstring.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.distributed.Scheduler.retire_workers</span></code></p>
</div>
<p class="rubric">Examples</p>
<p>You can get information about active workers using the following:
&gt;&gt;&gt; workers = client.scheduler_info()[‘workers’]</p>
<p>From that list you may want to select some workers to close
&gt;&gt;&gt; client.retire_workers(workers=[‘<a class="reference external" href="tcp://address:port">tcp://address:port</a>’, …])</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.retry">
<code class="sig-name descname">retry</code><span class="sig-paren">(</span><em class="sig-param">futures</em>, <em class="sig-param">asynchronous=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.retry" title="Permalink to this definition">¶</a></dt>
<dd><p>Retry failed futures</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>futures: list of Futures</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a function on all workers outside of task scheduling system</p>
<p>This calls a function on all currently known workers immediately,
blocks until those results come back, and returns the results
asynchronously as a dictionary keyed by worker address.  This method
if generally used for side effects, such and collecting diagnostic
information or installing libraries.</p>
<p>If your function takes an input argument named <code class="docutils literal notranslate"><span class="pre">dask_worker</span></code> then
that variable will be populated with the worker itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function: callable</strong></dt><dd></dd>
<dt><strong>*args: arguments for remote function</strong></dt><dd></dd>
<dt><strong>**kwargs: keyword arguments for remote function</strong></dt><dd></dd>
<dt><strong>workers: list</strong></dt><dd><p>Workers on which to run the function. Defaults to all known workers.</p>
</dd>
<dt><strong>wait: boolean (optional)</strong></dt><dd><p>If the function is asynchronous whether or not to wait until that
function finishes.</p>
</dd>
<dt><strong>nanny</strong><span class="classifier">bool, defualt False</span></dt><dd><p>Whether to run <code class="docutils literal notranslate"><span class="pre">function</span></code> on the nanny. By default, the function
is run on the worker process.  If specified, the addresses in
<code class="docutils literal notranslate"><span class="pre">workers</span></code> should still be the worker addresses, not the nanny addresses.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">)</span>  
<span class="go">{&#39;192.168.0.100:9000&#39;: 1234,</span>
<span class="go"> &#39;192.168.0.101:9000&#39;: 4321,</span>
<span class="go"> &#39;192.168.0.102:9000&#39;: 5555}</span>
</pre></div>
</div>
<p>Restrict computation to particular workers with the <code class="docutils literal notranslate"><span class="pre">workers=</span></code>
keyword argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;192.168.0.100:9000&#39;</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="s1">&#39;192.168.0.101:9000&#39;</span><span class="p">])</span>  
<span class="go">{&#39;192.168.0.100:9000&#39;: 1234,</span>
<span class="go"> &#39;192.168.0.101:9000&#39;: 4321}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="n">dask_worker</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">dask_worker</span><span class="o">.</span><span class="n">status</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">get_hostname</span><span class="p">)</span>  
<span class="go">{&#39;192.168.0.100:9000&#39;: &#39;running&#39;,</span>
<span class="go"> &#39;192.168.0.101:9000&#39;: &#39;running}</span>
</pre></div>
</div>
<p>Run asynchronous functions in the background:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">def</span> <span class="nf">print_state</span><span class="p">(</span><span class="n">dask_worker</span><span class="p">):</span>  
<span class="gp">... </span>   <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>       <span class="nb">print</span><span class="p">(</span><span class="n">dask_worker</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
<span class="gp">... </span>       <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">print_state</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.run_coroutine">
<code class="sig-name descname">run_coroutine</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.run_coroutine" title="Permalink to this definition">¶</a></dt>
<dd><p>Spawn a coroutine on all workers.</p>
<p>This spaws a coroutine on all currently known workers and then waits
for the coroutine on each worker.  The coroutines’ results are returned
as a dictionary keyed by worker address.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function: a coroutine function</strong></dt><dd><dl class="simple">
<dt>(typically a function wrapped in gen.coroutine or</dt><dd><p>a Python 3.5+ async function)</p>
</dd>
</dl>
</dd>
<dt><strong>*args: arguments for remote function</strong></dt><dd></dd>
<dt><strong>**kwargs: keyword arguments for remote function</strong></dt><dd></dd>
<dt><strong>wait: boolean (default True)</strong></dt><dd><p>Whether to wait for coroutines to end.</p>
</dd>
<dt><strong>workers: list</strong></dt><dd><p>Workers on which to run the function. Defaults to all known workers.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.run_on_scheduler">
<code class="sig-name descname">run_on_scheduler</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.run_on_scheduler" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a function on the scheduler process</p>
<p>This is typically used for live debugging.  The function should take a
keyword argument <code class="docutils literal notranslate"><span class="pre">dask_scheduler=</span></code>, which will be given the scheduler
object itself.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Client.run" title="distributed.Client.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.run</span></code></a></dt><dd><p>Run a function on all workers</p>
</dd>
<dt><a class="reference internal" href="#distributed.Client.start_ipython_scheduler" title="distributed.Client.start_ipython_scheduler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.start_ipython_scheduler</span></code></a></dt><dd><p>Start an IPython session on scheduler</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">get_number_of_tasks</span><span class="p">(</span><span class="n">dask_scheduler</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">dask_scheduler</span><span class="o">.</span><span class="n">tasks</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">run_on_scheduler</span><span class="p">(</span><span class="n">get_number_of_tasks</span><span class="p">)</span>  
<span class="go">100</span>
</pre></div>
</div>
<p>Run asynchronous functions in the background:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">def</span> <span class="nf">print_state</span><span class="p">(</span><span class="n">dask_scheduler</span><span class="p">):</span>  
<span class="gp">... </span>   <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>       <span class="nb">print</span><span class="p">(</span><span class="n">dask_scheduler</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
<span class="gp">... </span>       <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">print_state</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.scatter">
<code class="sig-name descname">scatter</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">workers=None</em>, <em class="sig-param">broadcast=False</em>, <em class="sig-param">direct=None</em>, <em class="sig-param">hash=True</em>, <em class="sig-param">timeout='__no_default__'</em>, <em class="sig-param">asynchronous=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.scatter" title="Permalink to this definition">¶</a></dt>
<dd><p>Scatter data into distributed memory</p>
<p>This moves data from the local client process into the workers of the
distributed scheduler.  Note that it is often better to submit jobs to
your workers to have them load the data rather than loading data
locally and then scattering it out to them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data: list, dict, or object</strong></dt><dd><p>Data to scatter out to workers.  Output type matches input type.</p>
</dd>
<dt><strong>workers: list of tuples (optional)</strong></dt><dd><p>Optionally constrain locations of data.
Specify workers as hostname/port pairs, e.g. <code class="docutils literal notranslate"><span class="pre">('127.0.0.1',</span> <span class="pre">8787)</span></code>.</p>
</dd>
<dt><strong>broadcast: bool (defaults to False)</strong></dt><dd><p>Whether to send each data element to all workers.
By default we round-robin based on number of cores.</p>
</dd>
<dt><strong>direct: bool (defaults to automatically check)</strong></dt><dd><p>Whether or not to connect directly to the workers, or to ask
the scheduler to serve as intermediary.  This can also be set when
creating the Client.</p>
</dd>
<dt><strong>hash: bool (optional)</strong></dt><dd><p>Whether or not to hash data to determine key.
If False then this uses a random key</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>List, dict, iterator, or queue of futures matching the type of input.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Client.gather" title="distributed.Client.gather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.gather</span></code></a></dt><dd><p>Gather data back to local process</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="s1">&#39;127.0.0.1:8787&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> 
<span class="go">&lt;Future: status: finished, key: c0a8a20f903a4915b94db8de3ea63195&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="go">[&lt;Future: status: finished, key: c0a8a20f903a4915b94db8de3ea63195&gt;,</span>
<span class="go"> &lt;Future: status: finished, key: 58e78e1b34eb49a68c65b54815d1b158&gt;,</span>
<span class="go"> &lt;Future: status: finished, key: d3395e15f605bc35ab1bac6341a285e2&gt;]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">scatter</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>  
<span class="go">{&#39;x&#39;: &lt;Future: status: finished, key: x&gt;,</span>
<span class="go"> &#39;y&#39;: &lt;Future: status: finished, key: y&gt;,</span>
<span class="go"> &#39;z&#39;: &lt;Future: status: finished, key: z&gt;}</span>
</pre></div>
</div>
<p>Constrain location of data to subset of workers</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">workers</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;hostname&#39;</span><span class="p">,</span> <span class="mi">8788</span><span class="p">)])</span>   
</pre></div>
</div>
<p>Broadcast data to all workers</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">future</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">element</span><span class="p">],</span> <span class="n">broadcast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
</pre></div>
</div>
<p>Send scattered data to parallelized function using client futures
interface</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.scheduler_info">
<code class="sig-name descname">scheduler_info</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.scheduler_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic information about the workers in the cluster</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">scheduler_info</span><span class="p">()</span>  
<span class="go">{&#39;id&#39;: &#39;2de2b6da-69ee-11e6-ab6a-e82aea155996&#39;,</span>
<span class="go"> &#39;services&#39;: {},</span>
<span class="go"> &#39;type&#39;: &#39;Scheduler&#39;,</span>
<span class="go"> &#39;workers&#39;: {&#39;127.0.0.1:40575&#39;: {&#39;active&#39;: 0,</span>
<span class="go">                                 &#39;last-seen&#39;: 1472038237.4845693,</span>
<span class="go">                                 &#39;name&#39;: &#39;127.0.0.1:40575&#39;,</span>
<span class="go">                                 &#39;services&#39;: {},</span>
<span class="go">                                 &#39;stored&#39;: 0,</span>
<span class="go">                                 &#39;time-delay&#39;: 0.0061032772064208984}}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.set_metadata">
<code class="sig-name descname">set_metadata</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.set_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Set arbitrary metadata in the scheduler</p>
<p>This allows you to store small amounts of data on the central scheduler
process for administrative purposes.  Data should be msgpack
serializable (ints, strings, lists, dicts)</p>
<p>If the key corresponds to a task then that key will be cleaned up when
the task is forgotten by the scheduler.</p>
<p>If the key is a list then it will be assumed that you want to index
into a nested dictionary structure using those keys.  For example if
you call the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">set_metadata</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="mi">123</span><span class="p">)</span>
</pre></div>
</div>
<p>Then this is the same as setting</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scheduler</span><span class="o">.</span><span class="n">task_metadata</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">][</span><span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">123</span>
</pre></div>
</div>
<p>The lower level dictionaries will be created on demand.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.get_metadata" title="distributed.Client.get_metadata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_metadata</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">set_metadata</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="mi">123</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>  
<span class="go">123</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">set_metadata</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="mi">123</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>  
<span class="go">{&#39;y&#39;: 123}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">set_metadata</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="mi">456</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>  
<span class="go">{&#39;y&#39;: 123, &#39;w&#39;: {&#39;z&#39;: 456}}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">])</span>  
<span class="go">{&#39;z&#39;: 456}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.shutdown">
<code class="sig-name descname">shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Shut down the connected scheduler and workers</p>
<p>Note, this may disrupt other clients that may be using the same
scheduler and workers.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Client.close" title="distributed.Client.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.close</span></code></a></dt><dd><p>close only this client</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.start">
<code class="sig-name descname">start</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start scheduler running in separate thread</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.start_ipython_scheduler">
<code class="sig-name descname">start_ipython_scheduler</code><span class="sig-paren">(</span><em class="sig-param">magic_name='scheduler_if_ipython'</em>, <em class="sig-param">qtconsole=False</em>, <em class="sig-param">qtconsole_args=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.start_ipython_scheduler" title="Permalink to this definition">¶</a></dt>
<dd><p>Start IPython kernel on the scheduler</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>magic_name: str or None (optional)</strong></dt><dd><p>If defined, register IPython magic with this name for
executing code on the scheduler.
If not defined, register %scheduler magic if IPython is running.</p>
</dd>
<dt><strong>qtconsole: bool (optional)</strong></dt><dd><p>If True, launch a Jupyter QtConsole connected to the worker(s).</p>
</dd>
<dt><strong>qtconsole_args: list(str) (optional)</strong></dt><dd><p>Additional arguments to pass to the qtconsole on startup.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>connection_info: dict</strong></dt><dd><p>connection_info dict containing info necessary
to connect Jupyter clients to the scheduler.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Client.start_ipython_workers" title="distributed.Client.start_ipython_workers"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.start_ipython_workers</span></code></a></dt><dd><p>Start IPython on the workers</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">start_ipython_scheduler</span><span class="p">()</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="o">%</span><span class="n">scheduler</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">processing</span>  
<span class="go">{&#39;127.0.0.1:3595&#39;: {&#39;inc-1&#39;, &#39;inc-2&#39;},</span>
<span class="go"> &#39;127.0.0.1:53589&#39;: {&#39;inc-2&#39;, &#39;add-5&#39;}}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">start_ipython_scheduler</span><span class="p">(</span><span class="n">qtconsole</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.start_ipython_workers">
<code class="sig-name descname">start_ipython_workers</code><span class="sig-paren">(</span><em class="sig-param">workers=None</em>, <em class="sig-param">magic_names=False</em>, <em class="sig-param">qtconsole=False</em>, <em class="sig-param">qtconsole_args=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.start_ipython_workers" title="Permalink to this definition">¶</a></dt>
<dd><p>Start IPython kernels on workers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>workers: list (optional)</strong></dt><dd><p>A list of worker addresses, defaults to all</p>
</dd>
<dt><strong>magic_names: str or list(str) (optional)</strong></dt><dd><p>If defined, register IPython magics with these names for
executing code on the workers.  If string has asterix then expand
asterix into 0, 1, …, n for n workers</p>
</dd>
<dt><strong>qtconsole: bool (optional)</strong></dt><dd><p>If True, launch a Jupyter QtConsole connected to the worker(s).</p>
</dd>
<dt><strong>qtconsole_args: list(str) (optional)</strong></dt><dd><p>Additional arguments to pass to the qtconsole on startup.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>iter_connection_info: list</strong></dt><dd><p>List of connection_info dicts containing info necessary
to connect Jupyter clients to the workers.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Client.start_ipython_scheduler" title="distributed.Client.start_ipython_scheduler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.start_ipython_scheduler</span></code></a></dt><dd><p>start ipython on the scheduler</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">info</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">start_ipython_workers</span><span class="p">()</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="o">%</span><span class="n">remote</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;192.168.1.101:5752&#39;</span><span class="p">]</span> <span class="n">worker</span><span class="o">.</span><span class="n">data</span>  
<span class="go">{&#39;x&#39;: 1, &#39;y&#39;: 100}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">start_ipython_workers</span><span class="p">(</span><span class="s1">&#39;192.168.1.101:5752&#39;</span><span class="p">,</span> <span class="n">magic_names</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="o">%</span><span class="n">w</span> <span class="n">worker</span><span class="o">.</span><span class="n">data</span>  
<span class="go">{&#39;x&#39;: 1, &#39;y&#39;: 100}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">start_ipython_workers</span><span class="p">(</span><span class="s1">&#39;192.168.1.101:5752&#39;</span><span class="p">,</span> <span class="n">qtconsole</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
</pre></div>
</div>
<p>Add asterix * in magic names to add one magic per worker</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">start_ipython_workers</span><span class="p">(</span><span class="n">magic_names</span><span class="o">=</span><span class="s1">&#39;w_*&#39;</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="o">%</span><span class="n">w_0</span> <span class="n">worker</span><span class="o">.</span><span class="n">data</span>  
<span class="go">{&#39;x&#39;: 1, &#39;y&#39;: 100}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">%</span><span class="n">w_1</span> <span class="n">worker</span><span class="o">.</span><span class="n">data</span>  
<span class="go">{&#39;z&#39;: 5}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.submit">
<code class="sig-name descname">submit</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">key=None</em>, <em class="sig-param">workers=None</em>, <em class="sig-param">resources=None</em>, <em class="sig-param">retries=None</em>, <em class="sig-param">priority=0</em>, <em class="sig-param">fifo_timeout='100 ms'</em>, <em class="sig-param">allow_other_workers=False</em>, <em class="sig-param">actor=False</em>, <em class="sig-param">actors=False</em>, <em class="sig-param">pure=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.submit" title="Permalink to this definition">¶</a></dt>
<dd><p>Submit a function application to the scheduler</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func: callable</strong></dt><dd></dd>
<dt><strong>*args:</strong></dt><dd></dd>
<dt><strong>**kwargs:</strong></dt><dd></dd>
<dt><strong>pure: bool (defaults to True)</strong></dt><dd><p>Whether or not the function is pure.  Set <code class="docutils literal notranslate"><span class="pre">pure=False</span></code> for
impure functions like <code class="docutils literal notranslate"><span class="pre">np.random.random</span></code>.</p>
</dd>
<dt><strong>workers: set, iterable of sets</strong></dt><dd><p>A set of worker hostnames on which computations may be performed.
Leave empty to default to all workers (common case)</p>
</dd>
<dt><strong>key: str</strong></dt><dd><p>Unique identifier for the task.  Defaults to function-name and hash</p>
</dd>
<dt><strong>allow_other_workers: bool (defaults to False)</strong></dt><dd><p>Used with <cite>workers</cite>. Indicates whether or not the computations
may be performed on workers that are not in the <cite>workers</cite> set(s).</p>
</dd>
<dt><strong>retries: int (default to 0)</strong></dt><dd><p>Number of allowed automatic retries if the task fails</p>
</dd>
<dt><strong>priority: Number</strong></dt><dd><p>Optional prioritization of task.  Zero is default.
Higher priorities take precedence</p>
</dd>
<dt><strong>fifo_timeout: str timedelta (default ‘100ms’)</strong></dt><dd><p>Allowed amount of time between calls to consider the same priority</p>
</dd>
<dt><strong>resources: dict (defaults to {})</strong></dt><dd><p>Defines the <cite>resources</cite> this job requires on the worker; e.g.
<code class="docutils literal notranslate"><span class="pre">{'GPU':</span> <span class="pre">2}</span></code>. See <span class="xref std std-doc">worker resources</span> for details
on defining resources.</p>
</dd>
<dt><strong>actor: bool (default False)</strong></dt><dd><p>Whether this task should exist on the worker as a stateful actor.
See <span class="xref std std-doc">actors</span> for additional details.</p>
</dd>
<dt><strong>actors: bool (default False)</strong></dt><dd><p>Alias for <cite>actor</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Future</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Client.map" title="distributed.Client.map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.map</span></code></a></dt><dd><p>Submit on many arguments at once</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.unpublish_dataset">
<code class="sig-name descname">unpublish_dataset</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.unpublish_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove named datasets from scheduler</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.publish_dataset" title="distributed.Client.publish_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.publish_dataset</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">list_datasets</span><span class="p">()</span>  
<span class="go">[&#39;my_dataset&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">unpublish_datasets</span><span class="p">(</span><span class="s1">&#39;my_dataset&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">list_datasets</span><span class="p">()</span>  
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.upload_file">
<code class="sig-name descname">upload_file</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.upload_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Upload local package to workers</p>
<p>This sends a local file up to all worker nodes.  This file is placed
into a temporary directory on Python’s system path so any .py,  .egg
or .zip  files will be importable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: string</strong></dt><dd><p>Filename of .py, .egg or .zip file to send to workers</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">upload_file</span><span class="p">(</span><span class="s1">&#39;mylibrary.egg&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mylibrary</span> <span class="kn">import</span> <span class="n">myfunc</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">myfunc</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.wait_for_workers">
<code class="sig-name descname">wait_for_workers</code><span class="sig-paren">(</span><em class="sig-param">n_workers=0</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.wait_for_workers" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocking call to wait for n workers before continuing</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.who_has">
<code class="sig-name descname">who_has</code><span class="sig-paren">(</span><em class="sig-param">futures=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.who_has" title="Permalink to this definition">¶</a></dt>
<dd><p>The workers storing each future’s data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>futures: list (optional)</strong></dt><dd><p>A list of futures, defaults to all data</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.has_what" title="distributed.Client.has_what"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.has_what</span></code></a>, <a class="reference internal" href="#distributed.Client.nthreads" title="distributed.Client.nthreads"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.nthreads</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">wait</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">who_has</span><span class="p">()</span>  
<span class="go">{&#39;inc-1c8dd6be1c21646c71f76c16d09304ea&#39;: [&#39;192.168.1.141:46784&#39;],</span>
<span class="go"> &#39;inc-1e297fc27658d7b67b3a758f16bcf47a&#39;: [&#39;192.168.1.141:46784&#39;],</span>
<span class="go"> &#39;inc-fd65c238a7ea60f6a01bf4c8a5fcf44b&#39;: [&#39;192.168.1.141:46784&#39;]}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">who_has</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>  
<span class="go">{&#39;inc-1c8dd6be1c21646c71f76c16d09304ea&#39;: [&#39;192.168.1.141:46784&#39;],</span>
<span class="go"> &#39;inc-1e297fc27658d7b67b3a758f16bcf47a&#39;: [&#39;192.168.1.141:46784&#39;]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Client.write_scheduler_file">
<code class="sig-name descname">write_scheduler_file</code><span class="sig-paren">(</span><em class="sig-param">scheduler_file</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Client.write_scheduler_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the scheduler information to a json file.</p>
<p>This facilitates easy sharing of scheduler information using a file
system. The scheduler file can be used to instantiate a second Client
using the same scheduler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scheduler_file: str</strong></dt><dd><p>Path to a write the scheduler file.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">write_scheduler_file</span><span class="p">(</span><span class="s1">&#39;scheduler.json&#39;</span><span class="p">)</span>  
<span class="go"># connect to previous client&#39;s scheduler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client2</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">scheduler_file</span><span class="o">=</span><span class="s1">&#39;scheduler.json&#39;</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="distributed.Future">
<em class="property">class </em><code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">Future</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">client=None</em>, <em class="sig-param">inform=True</em>, <em class="sig-param">state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Future" title="Permalink to this definition">¶</a></dt>
<dd><p>A remotely running computation</p>
<p>A Future is a local proxy to a result running on a remote worker.  A user
manages future objects in the local Python process to determine what
happens in the larger cluster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>key: str, or tuple</strong></dt><dd><p>Key of remote data to which this future refers</p>
</dd>
<dt><strong>client: Client</strong></dt><dd><p>Client that should own this future.  Defaults to _get_global_client()</p>
</dd>
<dt><strong>inform: bool</strong></dt><dd><p>Do we inform the scheduler that we need an update on this future</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Client" title="distributed.Client"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client</span></code></a></dt><dd><p>Creates futures</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Futures typically emerge from Client computations</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
</pre></div>
</div>
<p>We can track the progress and results of a future</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_future</span>  
<span class="go">&lt;Future: status: finished, key: add-8f6e709446674bad78ea8aeecfee188e&gt;</span>
</pre></div>
</div>
<p>We can get the result or the exception and traceback from the future</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>  
</pre></div>
</div>
<dl class="method">
<dt id="distributed.Future.add_done_callback">
<code class="sig-name descname">add_done_callback</code><span class="sig-paren">(</span><em class="sig-param">fn</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Future.add_done_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Call callback on future when callback has finished</p>
<p>The callback <code class="docutils literal notranslate"><span class="pre">fn</span></code> should take the future as its only argument.  This
will be called regardless of if the future completes successfully,
errs, or is cancelled</p>
<p>The callback is executed in a separate thread.</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Future.cancel">
<code class="sig-name descname">cancel</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Future.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel request to run this future</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.cancel" title="distributed.Client.cancel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.cancel</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Future.cancelled">
<code class="sig-name descname">cancelled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Future.cancelled" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the future has been cancelled</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Future.done">
<code class="sig-name descname">done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Future.done" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the computation complete?</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Future.exception">
<code class="sig-name descname">exception</code><span class="sig-paren">(</span><em class="sig-param">timeout=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Future.exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exception of a failed task</p>
<p>If <em>timeout</em> seconds are elapsed before returning, a
<code class="docutils literal notranslate"><span class="pre">dask.distributed.TimeoutError</span></code> is raised.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Future.traceback" title="distributed.Future.traceback"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.traceback</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Future.result">
<code class="sig-name descname">result</code><span class="sig-paren">(</span><em class="sig-param">timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Future.result" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until computation completes, gather result to local process.</p>
<p>If <em>timeout</em> seconds are elapsed before returning, a
<code class="docutils literal notranslate"><span class="pre">dask.distributed.TimeoutError</span></code> is raised.</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Future.retry">
<code class="sig-name descname">retry</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Future.retry" title="Permalink to this definition">¶</a></dt>
<dd><p>Retry this future if it has failed</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Client.retry" title="distributed.Client.retry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Client.retry</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Future.traceback">
<code class="sig-name descname">traceback</code><span class="sig-paren">(</span><em class="sig-param">timeout=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Future.traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the traceback of a failed task</p>
<p>This returns a traceback object.  You can inspect this object using the
<code class="docutils literal notranslate"><span class="pre">traceback</span></code> module.  Alternatively if you call <code class="docutils literal notranslate"><span class="pre">future.result()</span></code>
this traceback will accompany the raised exception.</p>
<p>If <em>timeout</em> seconds are elapsed before returning, a
<code class="docutils literal notranslate"><span class="pre">dask.distributed.TimeoutError</span></code> is raised.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Future.exception" title="distributed.Future.exception"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Future.exception</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">traceback</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">tb</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">traceback</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">traceback</span><span class="o">.</span><span class="n">format_tb</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>  
<span class="go">[...]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="distributed.Queue">
<em class="property">class </em><code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">Queue</code><span class="sig-paren">(</span><em class="sig-param">name=None</em>, <em class="sig-param">client=None</em>, <em class="sig-param">maxsize=0</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Distributed Queue</p>
<p>This allows multiple clients to share futures or small bits of data between
each other with a multi-producer/multi-consumer queue.  All metadata is
sequentialized through the scheduler.</p>
<p>Elements of the Queue must be either Futures or msgpack-encodable data
(ints, strings, lists, dicts).  All data is sent through the scheduler so
it is wise not to send large objects.  To share large objects scatter the
data and share the future instead.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This object is experimental and has known issues in Python 2</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name: string (optional)</strong></dt><dd><p>Name used by other clients and the scheduler to identify the queue. If
not given, a random name will be generated.</p>
</dd>
<dt><strong>client: Client (optional)</strong></dt><dd><p>Client used for communication with the scheduler. Defaults to the
value of <code class="docutils literal notranslate"><span class="pre">_get_global_client()</span></code>.</p>
</dd>
<dt><strong>maxsize: int (optional)</strong></dt><dd><p>Number of items allowed in the queue. If 0 (the default), the queue
size is unbounded.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Variable" title="distributed.Variable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Variable</span></code></a></dt><dd><p>shared variable between clients</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span><span class="p">,</span> <span class="n">Queue</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>  
</pre></div>
</div>
<dl class="method">
<dt id="distributed.Queue.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">timeout=None</em>, <em class="sig-param">batch=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Queue.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data from the queue</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>timeout: Number (optional)</strong></dt><dd><p>Time in seconds to wait before timing out</p>
</dd>
<dt><strong>batch: boolean, int (optional)</strong></dt><dd><p>If True then return all elements currently waiting in the queue.
If an integer than return that many elements from the queue
If False (default) then return one item at a time</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distributed.Queue.put">
<code class="sig-name descname">put</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">timeout=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Queue.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Put data into the queue</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Queue.qsize">
<code class="sig-name descname">qsize</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Queue.qsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Current number of elements in the queue</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="distributed.Variable">
<em class="property">class </em><code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">Variable</code><span class="sig-paren">(</span><em class="sig-param">name=None</em>, <em class="sig-param">client=None</em>, <em class="sig-param">maxsize=0</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Distributed Global Variable</p>
<p>This allows multiple clients to share futures and data between each other
with a single mutable variable.  All metadata is sequentialized through the
scheduler.  Race conditions can occur.</p>
<p>Values must be either Futures or msgpack-encodable data (ints, lists,
strings, etc..)  All data will be kept and sent through the scheduler, so
it is wise not to send too much.  If you want to share a large amount of
data then <code class="docutils literal notranslate"><span class="pre">scatter</span></code> it and share the future instead.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This object is experimental and has known issues in Python 2</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name: string (optional)</strong></dt><dd><p>Name used by other clients and the scheduler to identify the variable.
If not given, a random name will be generated.</p>
</dd>
<dt><strong>client: Client (optional)</strong></dt><dd><p>Client used for communication with the scheduler. Defaults to the
value of <code class="docutils literal notranslate"><span class="pre">_get_global_client()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Queue" title="distributed.Queue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Queue</span></code></a></dt><dd><p>shared multi-producer/multi-consumer queue between clients</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span><span class="p">,</span> <span class="n">Variable</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>  <span class="c1"># docttest: +SKIP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>  <span class="c1"># docttest: +SKIP</span>
<span class="go">123</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">future</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>  
</pre></div>
</div>
<dl class="method">
<dt id="distributed.Variable.delete">
<code class="sig-name descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Variable.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete this variable</p>
<p>Caution, this affects all clients currently pointing to this variable.</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Variable.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">timeout=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Variable.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of this variable</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Variable.set">
<code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Variable.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of this variable</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value: Future or object</strong></dt><dd><p>Must be either a Future or a msgpack-encodable value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="distributed.Lock">
<em class="property">class </em><code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">Lock</code><span class="sig-paren">(</span><em class="sig-param">name=None</em>, <em class="sig-param">client=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Distributed Centralized Lock</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name: string (optional)</strong></dt><dd><p>Name of the lock to acquire.  Choosing the same name allows two
disconnected processes to coordinate a lock.  If not given, a random
name will be generated.</p>
</dd>
<dt><strong>client: Client (optional)</strong></dt><dd><p>Client to use for communication with the scheduler.  If not given, the
default global client will be used.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># do things with protected resource</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>  
</pre></div>
</div>
<dl class="method">
<dt id="distributed.Lock.acquire">
<code class="sig-name descname">acquire</code><span class="sig-paren">(</span><em class="sig-param">blocking=True</em>, <em class="sig-param">timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Lock.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the lock</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>blocking</strong><span class="classifier">bool, optional</span></dt><dd><p>If false, don’t wait on the lock in the scheduler at all.</p>
</dd>
<dt><strong>timeout</strong><span class="classifier">number, optional</span></dt><dd><p>Seconds to wait on the lock in the scheduler.  This does not
include local coroutine time, network transfer time, etc..
It is forbidden to specify a timeout when blocking is false.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>True or False whether or not it sucessfully acquired the lock</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="distributed.Lock.release">
<code class="sig-name descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Lock.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the lock if already acquired</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">Pub</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">worker=None</em>, <em class="sig-param">client=None</em><span class="sig-paren">)</span></dt>
<dd><p>Publish data with Publish-Subscribe pattern</p>
<p>This allows clients and workers to directly communicate data between each
other with a typical Publish-Subscribe pattern.  This involves two
components,</p>
<p>Pub objects, into which we put data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pub</span> <span class="o">=</span> <span class="n">Pub</span><span class="p">(</span><span class="s1">&#39;my-topic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pub</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
</pre></div>
</div>
<p>And Sub objects, from which we collect data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span> <span class="o">=</span> <span class="n">Sub</span><span class="p">(</span><span class="s1">&#39;my-topic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="go">123</span>
</pre></div>
</div>
<p>Many Pub and Sub objects can exist for the same topic.  All data sent from
any Pub will be sent to all Sub objects on that topic that are currently
connected.  Pub’s and Sub’s find each other using the scheduler, but they
communicate directly with each other without coordination from the
scheduler.</p>
<p>Pubs and Subs use the central scheduler to find each other, but not to
mediate the communication.  This means that there is very little additional
latency or overhead, and they are appropriate for very frequent data
transfers.  For context, most data transfer first checks with the scheduler to find which
workers should participate, and then does direct worker-to-worker
transfers.  This checking in with the scheduler provides some stability
guarantees, but also adds in a few extra network hops.  PubSub doesn’t do
this, and so is faster, but also can easily drop messages if Pubs or Subs
disappear without notice.</p>
<p>When using a Pub or Sub from a Client all communications will be routed
through the scheduler.  This can cause some performance degradation.  Pubs
and Subs only operate at top-speed when they are both on workers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name: object (msgpack serializable)</strong></dt><dd><p>The name of the group of Pubs and Subs on which to participate.</p>
</dd>
<dt><strong>worker: Worker (optional)</strong></dt><dd><p>The worker to be used for publishing data. Defaults to the value of
<code class="docutils literal notranslate"><span class="pre">`get_worker()`</span></code>. If given, <code class="docutils literal notranslate"><span class="pre">client</span></code> must be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>client: Client (optional)</strong></dt><dd><p>Client used for communication with the scheduler. Defaults to
the value of <code class="docutils literal notranslate"><span class="pre">get_client()</span></code>. If given, <code class="docutils literal notranslate"><span class="pre">worker</span></code> must be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#distributed.Sub" title="distributed.Sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sub</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pub</span> <span class="o">=</span> <span class="n">Pub</span><span class="p">(</span><span class="s1">&#39;my-topic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span> <span class="o">=</span> <span class="n">Sub</span><span class="p">(</span><span class="s1">&#39;my-topic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pub</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
<p>You can also use sub within a for loop:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">sub</span><span class="p">:</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<p>or an async for loop</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">sub</span><span class="p">:</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly the <code class="docutils literal notranslate"><span class="pre">.get</span></code> method will return an awaitable if used by an async
client or within the IOLoop thread of a worker</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">await</span> <span class="n">sub</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>  
</pre></div>
</div>
<p>You can see the set of connected worker subscribers by looking at the
<code class="docutils literal notranslate"><span class="pre">.subscribers</span></code> attribute:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pub</span><span class="o">.</span><span class="n">subscribers</span>
<span class="go">{&#39;tcp://...&#39;: {},</span>
<span class="go"> &#39;tcp://...&#39;: {}}</span>
</pre></div>
</div>
<dl class="method">
<dt>
<code class="sig-name descname">put</code><span class="sig-paren">(</span><em class="sig-param">msg</em><span class="sig-paren">)</span></dt>
<dd><p>Publish a message to all subscribers of this topic</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="distributed.Sub">
<em class="property">class </em><code class="sig-prename descclassname">distributed.</code><code class="sig-name descname">Sub</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">worker=None</em>, <em class="sig-param">client=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subscribe to a Publish/Subscribe topic</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#distributed.Pub" title="distributed.Pub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pub</span></code></a></dt><dd><p>for full docstring</p>
</dd>
</dl>
</div>
<dl class="method">
<dt id="distributed.Sub.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Sub.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a single message</p>
</dd></dl>

<dl class="method">
<dt id="distributed.Sub.next">
<code class="sig-name descname">next</code><span class="sig-paren">(</span><em class="sig-param">timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#distributed.Sub.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a single message</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="best-practices.html" class="btn btn-neutral float-right" title="Best Practices" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="delayed-best-practices.html" class="btn btn-neutral float-left" title="Best Practices" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014-2018, Anaconda, Inc. and contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>